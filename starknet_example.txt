
--------------------------------------------------------------------------------
/listings/advanced-concepts/commit_reveal/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "commit_reveal"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/commit_reveal/src/commit_reveal.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait ICommitmentRevealTrait<T> {
 3 |     fn commit(ref self: T, commitment: felt252);
 4 |     fn reveal(self: @T, secret: felt252) -> bool;
 5 | }
 6 | 
 7 | // [!region contract]
 8 | #[starknet::contract]
 9 | pub mod CommitmentRevealTraits {
10 |     use starknet::storage::{StoragePointerWriteAccess, StoragePointerReadAccess};
11 |     use core::hash::HashStateTrait;
12 |     use core::pedersen::PedersenTrait;
13 | 
14 |     #[storage]
15 |     struct Storage {
16 |         commitment: felt252,
17 |     }
18 | 
19 |     #[abi(embed_v0)]
20 |     impl CommitmentRevealTrait of super::ICommitmentRevealTrait<ContractState> {
21 |         fn commit(ref self: ContractState, commitment: felt252) {
22 |             self.commitment.write(commitment);
23 |         }
24 | 
25 |         fn reveal(self: @ContractState, secret: felt252) -> bool {
26 |             let hash = PedersenTrait::new(secret).finalize();
27 |             self.commitment.read() == hash
28 |         }
29 |     }
30 | }
31 | // [!endregion contract]
32 | 
33 | #[cfg(test)]
34 | mod tests {
35 |     use starknet::SyscallResultTrait;
36 |     use super::{
37 |         CommitmentRevealTraits, ICommitmentRevealTraitDispatcher,
38 |         ICommitmentRevealTraitDispatcherTrait
39 |     };
40 | 
41 |     use core::hash::HashStateTrait;
42 |     use core::pedersen::PedersenTrait;
43 |     use starknet::syscalls::deploy_syscall;
44 | 
45 |     fn deploy() -> ICommitmentRevealTraitDispatcher {
46 |         let (contract_address, _) = deploy_syscall(
47 |             CommitmentRevealTraits::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
48 |         )
49 |             .unwrap_syscall();
50 |         ICommitmentRevealTraitDispatcher { contract_address }
51 |     }
52 | 
53 |     #[test]
54 |     fn commit_and_reveal() {
55 |         let mut contract = deploy();
56 | 
57 |         // [!region offchain]
58 |         // Off-chain, compute the commitment hash for secret
59 |         let secret = 'My secret';
60 |         let offchain_commitment = PedersenTrait::new(secret).finalize();
61 | 
62 |         // Commit on-chain
63 |         contract.commit(offchain_commitment);
64 | 
65 |         // Reveal on-chain and assert the result
66 |         let reveal_result = contract.reveal(secret);
67 |         // [!endregion offchain]
68 |         assert_eq!(reveal_result, true);
69 |     }
70 | }
71 | 
72 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/commit_reveal/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod commit_reveal;
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/ecdsa_verification/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/ecdsa_verification/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "ecdsa_verification"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/ecdsa_verification/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "ecdsa_verification"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/ecdsa_verification/src/ecdsa_verification.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | use core::starknet::eth_address::EthAddress;
  3 | use starknet::secp256_trait::{Signature};
  4 | 
  5 | // How to Sign and Verify
  6 | // # Signing
  7 | // 1. Create message to sign
  8 | // 2. Hash the message
  9 | // 3. Sign the hash (off chain, keep your private key secret)
 10 | #[starknet::interface]
 11 | trait IVerifySignature<TContractState> {
 12 |     fn get_signature(self: @TContractState, r: u256, s: u256, v: u32,) -> Signature;
 13 |     fn verify_eth_signature(
 14 |         self: @TContractState, eth_address: EthAddress, msg_hash: u256, r: u256, s: u256, v: u32,
 15 |     );
 16 |     fn recover_public_key(
 17 |         self: @TContractState, eth_address: EthAddress, msg_hash: u256, r: u256, s: u256, v: u32
 18 |     );
 19 | }
 20 | 
 21 | #[starknet::contract]
 22 | mod verifySignature {
 23 |     use super::IVerifySignature;
 24 |     use core::starknet::eth_address::EthAddress;
 25 |     use starknet::secp256k1::Secp256k1Point;
 26 |     use starknet::secp256_trait::{Signature, signature_from_vrs, recover_public_key,};
 27 |     use starknet::eth_signature::{verify_eth_signature, public_key_point_to_eth_address};
 28 | 
 29 |     #[storage]
 30 |     struct Storage {
 31 |         msg_hash: u256,
 32 |         signature: Signature,
 33 |         eth_address: EthAddress,
 34 |     }
 35 | 
 36 |     #[abi(embed_v0)]
 37 |     impl VerifySignature of IVerifySignature<ContractState> {
 38 |         /// This function returns the signature struct for the given parameters.
 39 |         ///
 40 |         /// # Arguments
 41 |         ///
 42 |         /// * `r` - The R component of the signature.
 43 |         /// * `s` - The S component of the signature.
 44 |         /// * `v` - The V component of the signature.
 45 |         ///
 46 |         /// # Returns
 47 |         ///
 48 |         /// * `Signature` - The signature struct.
 49 |         fn get_signature(self: @ContractState, r: u256, s: u256, v: u32,) -> Signature {
 50 |             // Create a Signature object from the given v, r, and s values.
 51 |             let signature: Signature = signature_from_vrs(v, r, s);
 52 |             signature
 53 |         }
 54 | 
 55 |         /// Verifies an Ethereum signature.
 56 |         ///
 57 |         /// # Arguments
 58 |         ///
 59 |         /// * `eth_address` - The Ethereum address to verify the signature against.
 60 |         /// * `msg_hash` - The hash of the message that was signed.
 61 |         /// * `r` - The R component of the signature.
 62 |         /// * `s` - The S component of the signature.
 63 |         /// * `v` - The V component of the signature.
 64 |         fn verify_eth_signature(
 65 |             self: @ContractState, eth_address: EthAddress, msg_hash: u256, r: u256, s: u256, v: u32
 66 |         ) {
 67 |             let signature = self.get_signature(r, s, v);
 68 |             verify_eth_signature(:msg_hash, :signature, :eth_address);
 69 |         }
 70 | 
 71 |         /// Recovers the public key from an Ethereum signature and verifies that it matches the
 72 |         /// given Ethereum address.
 73 |         ///
 74 |         /// # Arguments
 75 |         ///
 76 |         /// * `eth_address` - The Ethereum address to verify the signature against.
 77 |         /// * `msg_hash` - The hash of the message that was signed.
 78 |         /// * `r` - The R component of the signature.
 79 |         /// * `s` - The S component of the signature.
 80 |         /// * `v` - The V component of the signature.
 81 |         fn recover_public_key(
 82 |             self: @ContractState, eth_address: EthAddress, msg_hash: u256, r: u256, s: u256, v: u32
 83 |         ) {
 84 |             let signature = self.get_signature(r, s, v);
 85 |             let public_key_point = recover_public_key::<Secp256k1Point>(msg_hash, signature)
 86 |                 .unwrap();
 87 |             let calculated_eth_address = public_key_point_to_eth_address(:public_key_point);
 88 |             assert(calculated_eth_address == eth_address, 'Invalid Address');
 89 |         }
 90 |     }
 91 | }
 92 | // [!endregion contract]
 93 | 
 94 | #[cfg(test)]
 95 | mod tests {
 96 |     use starknet::secp256_trait::{Signature, signature_from_vrs, recover_public_key,};
 97 |     use starknet::EthAddress;
 98 |     use starknet::secp256k1::{Secp256k1Point};
 99 |     use starknet::eth_signature::{verify_eth_signature, public_key_point_to_eth_address};
100 | 
101 |     fn get_message_and_signature() -> (u256, Signature, EthAddress) {
102 |         let msg_hash = 0x546ec3fa4f7d3308931816fafd47fa297afe9ac9a09651f77acc13c05a84734f;
103 |         let r = 0xc0f30bcef72974dedaf165cf7848a83b0b9eb6a65167a14643df96698d753efb;
104 |         let s = 0x7f189e3cb5eb992d8cd26e287a13e900326b87f58da2b7fb48fbd3977e3cab1c;
105 |         let v = 27;
106 | 
107 |         let eth_address = 0x5F04693482cfC121FF244cB3c3733aF712F9df02_u256.into();
108 |         let signature: Signature = signature_from_vrs(v, r, s);
109 | 
110 |         (msg_hash, signature, eth_address)
111 |     }
112 | 
113 |     #[test]
114 |     fn test_verify_eth_signature() {
115 |         let (msg_hash, signature, eth_address) = get_message_and_signature();
116 |         verify_eth_signature(msg_hash, signature, eth_address);
117 |     }
118 | 
119 |     #[test]
120 |     fn test_secp256k1_recover_public_key() {
121 |         let (msg_hash, signature, eth_address) = get_message_and_signature();
122 |         let public_key_point = recover_public_key::<Secp256k1Point>(msg_hash, signature).unwrap();
123 |         let calculated_eth_address = public_key_point_to_eth_address(public_key_point);
124 |         assert_eq!(calculated_eth_address, eth_address);
125 |     }
126 | }
127 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/ecdsa_verification/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod ecdsa_verification;
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_solidity_compatible/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_solidity_compatible/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "hash_solidity_compatible"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_solidity_compatible/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "hash_solidity_compatible"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_solidity_compatible/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait ISolidityHashExample<TContractState> {
 3 |     fn hash_data(ref self: TContractState, input_data: Span<u256>) -> u256;
 4 | }
 5 | 
 6 | #[starknet::contract]
 7 | pub mod SolidityHashExample {
 8 |     use core::keccak::keccak_u256s_be_inputs;
 9 |     use core::integer;
10 | 
11 |     #[storage]
12 |     struct Storage {}
13 | 
14 |     #[abi(embed_v0)]
15 |     impl SolidityHashExample of super::ISolidityHashExample<ContractState> {
16 |         fn hash_data(ref self: ContractState, input_data: Span<u256>) -> u256 {
17 |             let hashed = keccak_u256s_be_inputs(input_data);
18 | 
19 |             // Split the hashed value into two 128-bit segments
20 |             let low: u128 = hashed.low;
21 |             let high: u128 = hashed.high;
22 | 
23 |             // Reverse each 128-bit segment
24 |             let reversed_low = integer::u128_byte_reverse(low);
25 |             let reversed_high = integer::u128_byte_reverse(high);
26 | 
27 |             // Reverse merge the reversed segments back into a u256 value
28 |             let compatible_hash = u256 { low: reversed_high, high: reversed_low };
29 | 
30 |             compatible_hash
31 |         }
32 |     }
33 | }
34 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_solidity_compatible/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_solidity_compatible/src/tests.cairo:
--------------------------------------------------------------------------------
 1 | mod tests {
 2 |     use hash_solidity_compatible::contract::{SolidityHashExample, ISolidityHashExample};
 3 |     use starknet::{contract_address_const, testing::set_contract_address};
 4 | 
 5 |     fn setup() -> SolidityHashExample::ContractState {
 6 |         let mut state = SolidityHashExample::contract_state_for_testing();
 7 |         let contract_address = contract_address_const::<0x1>();
 8 |         set_contract_address(contract_address);
 9 |         state
10 |     }
11 | 
12 |     #[test]
13 |     fn get_same_hash_solidity() {
14 |         let mut state = setup();
15 |         let mut array: Array<u256> = array![];
16 |         array.append(1);
17 | 
18 |         let hash_expected: u256 =
19 |             0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6;
20 |         let hash_received: u256 = state.hash_data(array.span());
21 | 
22 |         assert_eq!(hash_received, hash_expected);
23 |     }
24 | }
25 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_trait/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "hash_trait"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_trait/src/hash_trait.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::interface]
  2 | pub trait IHashTrait<T> {
  3 |     fn save_user_with_poseidon(
  4 |         ref self: T, id: felt252, username: felt252, password: felt252
  5 |     ) -> felt252;
  6 |     fn save_user_with_pedersen(
  7 |         ref self: T, id: felt252, username: felt252, password: felt252
  8 |     ) -> felt252;
  9 | }
 10 | 
 11 | // [!region hash]
 12 | #[starknet::contract]
 13 | pub mod HashTraits {
 14 |     use starknet::storage::StoragePointerWriteAccess;
 15 |     use core::hash::{HashStateTrait, HashStateExTrait};
 16 |     use core::{pedersen::PedersenTrait, poseidon::PoseidonTrait};
 17 | 
 18 |     #[storage]
 19 |     struct Storage {
 20 |         user_hash_poseidon: felt252,
 21 |         user_hash_pedersen: felt252,
 22 |     }
 23 | 
 24 |     #[derive(Drop, Hash)]
 25 |     struct LoginDetails {
 26 |         username: felt252,
 27 |         password: felt252,
 28 |     }
 29 | 
 30 |     #[derive(Drop, Hash)]
 31 |     struct UserDetails {
 32 |         id: felt252,
 33 |         login: LoginDetails,
 34 |     }
 35 | 
 36 |     #[abi(embed_v0)]
 37 |     impl HashTrait of super::IHashTrait<ContractState> {
 38 |         fn save_user_with_poseidon(
 39 |             ref self: ContractState, id: felt252, username: felt252, password: felt252
 40 |         ) -> felt252 {
 41 |             let login = LoginDetails { username, password };
 42 |             let user = UserDetails { id, login };
 43 | 
 44 |             let poseidon_hash = PoseidonTrait::new().update_with(user).finalize();
 45 | 
 46 |             self.user_hash_poseidon.write(poseidon_hash);
 47 |             poseidon_hash
 48 |         }
 49 | 
 50 |         fn save_user_with_pedersen(
 51 |             ref self: ContractState, id: felt252, username: felt252, password: felt252
 52 |         ) -> felt252 {
 53 |             let login = LoginDetails { username, password };
 54 |             let user = UserDetails { id, login };
 55 | 
 56 |             let pedersen_hash = PedersenTrait::new(0).update_with(user).finalize();
 57 | 
 58 |             self.user_hash_pedersen.write(pedersen_hash);
 59 |             pedersen_hash
 60 |         }
 61 |     }
 62 | }
 63 | // [!endregion hash]
 64 | 
 65 | #[cfg(test)]
 66 | mod tests {
 67 |     use starknet::SyscallResultTrait;
 68 |     use super::{HashTraits, IHashTraitDispatcher, IHashTraitDispatcherTrait};
 69 |     use starknet::syscalls::deploy_syscall;
 70 | 
 71 |     fn deploy() -> IHashTraitDispatcher {
 72 |         let mut calldata = array![];
 73 |         let (address, _) = deploy_syscall(
 74 |             HashTraits::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
 75 |         )
 76 |             .unwrap_syscall();
 77 |         IHashTraitDispatcher { contract_address: address }
 78 |     }
 79 | 
 80 | 
 81 |     #[test]
 82 |     fn test_pedersen_hash() {
 83 |         let mut contract = deploy();
 84 | 
 85 |         let id = 0x1;
 86 |         let username = 'A.stark';
 87 |         let password = 'password.stark';
 88 |         let test_hash = contract.save_user_with_pedersen(id, username, password);
 89 | 
 90 |         assert_eq!(test_hash, 0x6da4b4d0489989f5483d179643dafb3405b0e3b883a6c8efe5beb824ba9055a);
 91 |     }
 92 | 
 93 |     #[test]
 94 |     fn test_poseidon_hash() {
 95 |         let mut contract = deploy();
 96 | 
 97 |         let id = 0x1;
 98 |         let username = 'A.stark';
 99 |         let password = 'password.stark';
100 | 
101 |         let test_hash = contract.save_user_with_poseidon(id, username, password);
102 | 
103 |         assert_eq!(test_hash, 0x4d165e1d398ae4864854518d3c58c3d7a21ed9c1f8f3618fbb0031d208aab7b);
104 |     }
105 | }
106 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/hash_trait/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod hash_trait;
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/library_calls/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/library_calls/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "library_calls"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/library_calls/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod library_call;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/library_calls/src/library_call.cairo:
--------------------------------------------------------------------------------
 1 | // [!region library_dispatcher]
 2 | #[starknet::interface]
 3 | pub trait IMathUtils<T> {
 4 |     fn add(ref self: T, x: u32, y: u32) -> u32;
 5 |     fn set_class_hash(ref self: T, class_hash: starknet::ClassHash);
 6 | }
 7 | 
 8 | // contract A
 9 | #[starknet::contract]
10 | pub mod MathUtils {
11 |     #[storage]
12 |     struct Storage {}
13 | 
14 |     #[abi(embed_v0)]
15 |     impl ImathUtilsImpl of super::IMathUtils<ContractState> {
16 |         fn add(ref self: ContractState, x: u32, y: u32) -> u32 {
17 |             x + y
18 |         }
19 | 
20 |         fn set_class_hash(ref self: ContractState, class_hash: starknet::ClassHash) {}
21 |     }
22 | }
23 | 
24 | 
25 | // contract B to make library call to the class of contract A
26 | #[starknet::contract]
27 | pub mod MathUtilsLibraryCall {
28 |     use super::{IMathUtilsDispatcherTrait, IMathUtilsLibraryDispatcher};
29 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
30 | 
31 |     #[storage]
32 |     struct Storage {
33 |         value: u32,
34 |         lib_class_hash: starknet::ClassHash,
35 |     }
36 | 
37 |     #[abi(embed_v0)]
38 |     impl MathUtils of super::IMathUtils<ContractState> {
39 |         fn add(ref self: ContractState, x: u32, y: u32) -> u32 {
40 |             IMathUtilsLibraryDispatcher { class_hash: self.lib_class_hash.read() }.add(x, y)
41 |         }
42 | 
43 |         #[abi(embed_v0)]
44 |         fn set_class_hash(ref self: ContractState, class_hash: starknet::ClassHash) {
45 |             self.lib_class_hash.write(class_hash);
46 |         }
47 |     }
48 | }
49 | // [!endregion library_dispatcher]
50 | 
51 | 
52 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/library_calls/src/tests.cairo:
--------------------------------------------------------------------------------
 1 | mod tests {
 2 |     use starknet::syscalls::deploy_syscall;
 3 |     use starknet::SyscallResultTrait;
 4 |     use library_calls::library_call::{
 5 |         MathUtils, MathUtilsLibraryCall, IMathUtilsDispatcher, IMathUtilsDispatcherTrait
 6 |     };
 7 | 
 8 |     #[test]
 9 |     fn test_library_dispatcher() {
10 |         let math_utils_class_hash: starknet::ClassHash = MathUtils::TEST_CLASS_HASH
11 |             .try_into()
12 |             .unwrap();
13 |         let mut calldata: Array<felt252> = array![];
14 |         let (address, _) = deploy_syscall(
15 |             MathUtilsLibraryCall::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
16 |         )
17 |             .unwrap_syscall();
18 |         let mut contract = IMathUtilsDispatcher { contract_address: address };
19 | 
20 |         contract.set_class_hash(math_utils_class_hash);
21 |         let mut result = contract.add(30, 5);
22 |         assert_eq!(result, 35, "Wrong result");
23 |     }
24 | }
25 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/simple_account/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/simple_account/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "ecdsa_verification"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/simple_account/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "simple_account"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | openzeppelin.workspace = true
 9 | 
10 | [scripts]
11 | test.workspace = true
12 | 
13 | [[target.starknet-contract]]
14 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/simple_account/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod simple_account;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/simple_account/src/simple_account.cairo:
--------------------------------------------------------------------------------
 1 | use starknet::account::Call;
 2 | 
 3 | #[starknet::interface]
 4 | trait ISRC6<TContractState> {
 5 |     fn execute_calls(self: @TContractState, calls: Array<Call>) -> Array<Span<felt252>>;
 6 |     fn validate_calls(self: @TContractState, calls: Array<Call>) -> felt252;
 7 |     fn is_valid_signature(
 8 |         self: @TContractState, hash: felt252, signature: Array<felt252>
 9 |     ) -> felt252;
10 | }
11 | 
12 | #[starknet::contract]
13 | mod simpleAccount {
14 |     use super::ISRC6;
15 |     use starknet::account::Call;
16 |     use core::num::traits::Zero;
17 |     use core::ecdsa::check_ecdsa_signature;
18 |     use starknet::storage::{StoragePointerWriteAccess, StoragePointerReadAccess};
19 | 
20 |     // Implement SRC5 with openzeppelin
21 |     use openzeppelin::account::interface;
22 |     use openzeppelin::introspection::src5::SRC5Component;
23 |     component!(path: SRC5Component, storage: src5, event: SRC5Event);
24 | 
25 |     #[abi(embed_v0)]
26 |     impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
27 |     impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;
28 | 
29 |     #[storage]
30 |     struct Storage {
31 |         #[substorage(v0)]
32 |         src5: SRC5Component::Storage,
33 |         public_key: felt252
34 |     }
35 | 
36 |     #[constructor]
37 |     fn constructor(ref self: ContractState, public_key: felt252) {
38 |         self.src5.register_interface(interface::ISRC6_ID);
39 |         self.public_key.write(public_key);
40 |     }
41 | 
42 |     #[event]
43 |     #[derive(Drop, starknet::Event)]
44 |     enum Event {
45 |         #[flat]
46 |         SRC5Event: SRC5Component::Event
47 |     }
48 | 
49 |     #[abi(embed_v0)]
50 |     impl SRC6 of ISRC6<ContractState> {
51 |         fn execute_calls(self: @ContractState, calls: Array<Call>) -> Array<Span<felt252>> {
52 |             assert(starknet::get_caller_address().is_zero(), 'Not Starknet Protocol');
53 |             let Call { to, selector, calldata } = calls.at(0);
54 |             let res = starknet::syscalls::call_contract_syscall(*to, *selector, *calldata).unwrap();
55 |             array![res]
56 |         }
57 | 
58 |         fn validate_calls(self: @ContractState, calls: Array<Call>) -> felt252 {
59 |             assert(starknet::get_caller_address().is_zero(), 'Not Starknet Protocol');
60 |             let tx_info = starknet::get_tx_info().unbox();
61 |             let tx_hash = tx_info.transaction_hash;
62 |             let signature = tx_info.signature;
63 |             if self._is_valid_signature(tx_hash, signature) {
64 |                 starknet::VALIDATED
65 |             } else {
66 |                 0
67 |             }
68 |         }
69 | 
70 |         fn is_valid_signature(
71 |             self: @ContractState, hash: felt252, signature: Array<felt252>
72 |         ) -> felt252 {
73 |             if self._is_valid_signature(hash, signature.span()) {
74 |                 starknet::VALIDATED
75 |             } else {
76 |                 0
77 |             }
78 |         }
79 |     }
80 | 
81 |     #[generate_trait]
82 |     impl SignatureVerificationImpl of SignatureVerification {
83 |         fn _is_valid_signature(
84 |             self: @ContractState, hash: felt252, signature: Span<felt252>
85 |         ) -> bool {
86 |             check_ecdsa_signature(
87 |                 hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)
88 |             )
89 |         }
90 |     }
91 | }
92 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/simple_account/src/tests.cairo:
--------------------------------------------------------------------------------
1 | #[cfg(test)]
2 | mod tests { // TODO
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/store_using_packing/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/store_using_packing/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "store_using_packing"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/store_using_packing/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "store_using_packing"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/store_using_packing/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Serde, Drop)]
 2 | pub struct Time {
 3 |     pub hour: u8,
 4 |     pub minute: u8
 5 | }
 6 | 
 7 | #[starknet::interface]
 8 | pub trait ITime<TContractState> {
 9 |     fn set(ref self: TContractState, value: Time);
10 |     fn get(self: @TContractState) -> Time;
11 | }
12 | 
13 | #[starknet::contract]
14 | pub mod TimeContract {
15 |     use starknet::storage::{StoragePointerWriteAccess, StoragePointerReadAccess};
16 |     use super::Time;
17 |     use starknet::storage_access::StorePacking;
18 | 
19 |     #[storage]
20 |     struct Storage {
21 |         time: Time
22 |     }
23 | 
24 |     impl TimePackable of StorePacking<Time, felt252> {
25 |         fn pack(value: Time) -> felt252 {
26 |             let msb: felt252 = 256 * value.hour.into();
27 |             let lsb: felt252 = value.minute.into();
28 |             msb + lsb
29 |         }
30 |         fn unpack(value: felt252) -> Time {
31 |             let value: u16 = value.try_into().unwrap();
32 |             let (q, r) = DivRem::div_rem(value, 256_u16.try_into().unwrap());
33 |             let hour: u8 = Into::<u16, felt252>::into(q).try_into().unwrap();
34 |             let minute: u8 = Into::<u16, felt252>::into(r).try_into().unwrap();
35 |             Time { hour, minute }
36 |         }
37 |     }
38 | 
39 |     #[abi(embed_v0)]
40 |     impl TimeContract of super::ITime<ContractState> {
41 |         fn set(ref self: ContractState, value: Time) {
42 |             // This will call the pack method of the TimePackable trait
43 |             // and store the resulting felt252
44 |             self.time.write(value);
45 |         }
46 |         fn get(self: @ContractState) -> Time {
47 |             // This will read the felt252 value from storage
48 |             // and return the result of the unpack method of the TimePackable trait
49 |             return self.time.read();
50 |         }
51 |     }
52 | }
53 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/store_using_packing/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/store_using_packing/src/tests.cairo:
--------------------------------------------------------------------------------
 1 | mod tests {
 2 |     use starknet::SyscallResultTrait;
 3 |     use store_using_packing::contract::{TimeContract, Time, ITimeDispatcher, ITimeDispatcherTrait};
 4 | 
 5 |     use starknet::syscalls::deploy_syscall;
 6 | 
 7 |     #[test]
 8 |     fn test_packing() {
 9 |         // Set up.
10 |         let mut calldata: Array<felt252> = array![];
11 |         let (address0, _) = deploy_syscall(
12 |             TimeContract::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
13 |         )
14 |             .unwrap_syscall();
15 |         let mut contract = ITimeDispatcher { contract_address: address0 };
16 | 
17 |         // Store a Time struct.
18 |         let time = Time { hour: 1, minute: 2 };
19 |         contract.set(time);
20 | 
21 |         // Read the stored struct.
22 |         let read_time: Time = contract.get();
23 |         assert_eq!(read_time.hour, time.hour);
24 |         assert_eq!(read_time.minute, time.minute);
25 |     }
26 | }
27 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/struct_as_mapping_key/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/listings/advanced-concepts/struct_as_mapping_key/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "struct_as_mapping_key"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/struct_as_mapping_key/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "struct_as_mapping_key"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/struct_as_mapping_key/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop, Serde, Hash)]
 2 | pub struct Pet {
 3 |     pub name: felt252,
 4 |     pub age: u8,
 5 |     pub owner: felt252,
 6 | }
 7 | 
 8 | #[starknet::interface]
 9 | pub trait IPetRegistry<TContractState> {
10 |     fn register_pet(ref self: TContractState, key: Pet, timestamp: u64);
11 |     fn get_registration_date(self: @TContractState, key: Pet) -> u64;
12 | }
13 | 
14 | #[starknet::contract]
15 | pub mod PetRegistry {
16 |     use super::Pet;
17 |     use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
18 | 
19 |     #[storage]
20 |     struct Storage {
21 |         registration_time: Map::<Pet, u64>,
22 |     }
23 | 
24 |     #[abi(embed_v0)]
25 |     impl PetRegistry of super::IPetRegistry<ContractState> {
26 |         fn register_pet(ref self: ContractState, key: Pet, timestamp: u64) {
27 |             self.registration_time.write(key, timestamp);
28 |         }
29 | 
30 |         fn get_registration_date(self: @ContractState, key: Pet) -> u64 {
31 |             self.registration_time.read(key)
32 |         }
33 |     }
34 | }
35 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/struct_as_mapping_key/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 
3 | #[cfg(test)]
4 | mod test;
5 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/struct_as_mapping_key/src/test.cairo:
--------------------------------------------------------------------------------
 1 | mod tests {
 2 |     use starknet::SyscallResultTrait;
 3 |     use struct_as_mapping_key::contract::{PetRegistry, Pet};
 4 |     use starknet::syscalls::deploy_syscall;
 5 | 
 6 |     #[starknet::interface]
 7 |     trait IPetRegistry<TContractState> {
 8 |         fn register_pet(ref self: TContractState, key: Pet, timestamp: u64);
 9 |         fn get_registration_date(self: @TContractState, key: Pet) -> u64;
10 |     }
11 | 
12 |     #[test]
13 |     fn test_e2e() {
14 |         // Set up.
15 |         let mut calldata: Array<felt252> = array![];
16 |         let (address0, _) = deploy_syscall(
17 |             PetRegistry::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
18 |         )
19 |             .unwrap_syscall();
20 |         let mut contract = IPetRegistryDispatcher { contract_address: address0 };
21 | 
22 |         let pet = Pet { name: 'Cute Labrador', age: 5, owner: 'Louis' };
23 | 
24 |         // Store a pet.
25 |         contract.register_pet(pet, 1234);
26 | 
27 |         // Read the array.
28 |         let registration_date = contract.get_registration_date(pet);
29 |         assert_eq!(registration_date, 1234);
30 |     }
31 | }
32 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/write_to_any_slot/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/write_to_any_slot/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "write_to_any_slot"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/write_to_any_slot/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "write_to_any_slot"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/write_to_any_slot/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IWriteToAnySlots<TContractState> {
 3 |     fn write_slot(ref self: TContractState, value: u32);
 4 |     fn read_slot(self: @TContractState) -> u32;
 5 | }
 6 | 
 7 | #[starknet::contract]
 8 | pub mod WriteToAnySlot {
 9 |     use starknet::syscalls::{storage_read_syscall, storage_write_syscall};
10 |     use starknet::SyscallResultTrait;
11 |     use core::poseidon::poseidon_hash_span;
12 |     use starknet::StorageAddress;
13 | 
14 |     #[storage]
15 |     struct Storage {}
16 | 
17 |     const SLOT_NAME: felt252 = 'test_slot';
18 | 
19 |     #[abi(embed_v0)]
20 |     impl WriteToAnySlot of super::IWriteToAnySlots<ContractState> {
21 |         fn write_slot(ref self: ContractState, value: u32) {
22 |             storage_write_syscall(0, get_address_from_name(SLOT_NAME), value.into())
23 |                 .unwrap_syscall();
24 |         }
25 | 
26 |         fn read_slot(self: @ContractState) -> u32 {
27 |             storage_read_syscall(0, get_address_from_name(SLOT_NAME))
28 |                 .unwrap_syscall()
29 |                 .try_into()
30 |                 .unwrap()
31 |         }
32 |     }
33 |     pub fn get_address_from_name(variable_name: felt252) -> StorageAddress {
34 |         let mut data: Array<felt252> = array![];
35 |         data.append(variable_name);
36 |         let hashed_name: felt252 = poseidon_hash_span(data.span());
37 |         let MASK_250: u256 = 0x03ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
38 |         // By taking the 250 least significant bits of the hash output, we get a valid 250bits
39 |         // storage address.
40 |         let result: felt252 = (hashed_name.into() & MASK_250).try_into().unwrap();
41 |         let result: StorageAddress = result.try_into().unwrap();
42 |         result
43 |     }
44 | }
45 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/write_to_any_slot/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/advanced-concepts/write_to_any_slot/src/tests.cairo:
--------------------------------------------------------------------------------
 1 | use write_to_any_slot::contract::WriteToAnySlot;
 2 | 
 3 | #[starknet::interface]
 4 | trait IWriteToAnySlot<TContractState> {
 5 |     fn write_slot(ref self: TContractState, value: u32);
 6 |     fn read_slot(self: @TContractState) -> u32;
 7 | }
 8 | 
 9 | mod tests {
10 |     use super::WriteToAnySlot;
11 |     use super::{IWriteToAnySlotDispatcher, IWriteToAnySlotDispatcherTrait};
12 |     use starknet::syscalls::deploy_syscall;
13 | 
14 |     #[test]
15 |     fn test_read_write() {
16 |         // Set up.
17 |         let mut calldata: Array<felt252> = array![];
18 |         let (address0, _) = deploy_syscall(
19 |             WriteToAnySlot::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
20 |         )
21 |             .unwrap();
22 |         let mut contract = IWriteToAnySlotDispatcher { contract_address: address0 };
23 | 
24 |         // Write to slot.
25 |         let value: u32 = 42;
26 |         contract.write_slot(value);
27 | 
28 |         // Read from slot.
29 |         let read_value = contract.read_slot();
30 |         assert_eq!(read_value, value);
31 |     }
32 | }
33 | 
34 | 


--------------------------------------------------------------------------------
/listings/applications/advanced_factory/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | .snfoundry_cache/
3 | 


--------------------------------------------------------------------------------
/listings/applications/advanced_factory/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "advanced_factory"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | components.workspace = true
 9 | crowdfunding = { path = "../crowdfunding" }
10 | 
11 | [dev-dependencies]
12 | assert_macros.workspace = true
13 | snforge_std.workspace = true
14 | 
15 | [scripts]
16 | test.workspace = true
17 | 
18 | [[target.starknet-contract]]
19 | build-external-contracts = ["crowdfunding::campaign::Campaign"]
20 | 


--------------------------------------------------------------------------------
/listings/applications/advanced_factory/src/contract.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | pub use starknet::{ContractAddress, ClassHash};
  3 | 
  4 | #[starknet::interface]
  5 | pub trait ICampaignFactory<TContractState> {
  6 |     fn create_campaign(
  7 |         ref self: TContractState,
  8 |         title: ByteArray,
  9 |         description: ByteArray,
 10 |         goal: u256,
 11 |         start_time: u64,
 12 |         end_time: u64,
 13 |         token_address: ContractAddress
 14 |     ) -> ContractAddress;
 15 |     fn get_campaign_class_hash(self: @TContractState) -> ClassHash;
 16 |     fn update_campaign_class_hash(ref self: TContractState, new_class_hash: ClassHash);
 17 |     fn upgrade_campaign(
 18 |         ref self: TContractState, campaign_address: ContractAddress, new_end_time: Option<u64>
 19 |     );
 20 | }
 21 | 
 22 | #[starknet::contract]
 23 | pub mod CampaignFactory {
 24 |     use core::num::traits::Zero;
 25 |     use starknet::{
 26 |         ContractAddress, ClassHash, SyscallResultTrait, syscalls::deploy_syscall, get_caller_address
 27 |     };
 28 |     use crowdfunding::campaign::{ICampaignDispatcher, ICampaignDispatcherTrait};
 29 |     use components::ownable::ownable_component;
 30 |     use starknet::storage::{
 31 |         Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
 32 |         StoragePointerWriteAccess
 33 |     };
 34 | 
 35 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
 36 | 
 37 |     #[abi(embed_v0)]
 38 |     impl OwnableImpl = ownable_component::Ownable<ContractState>;
 39 |     impl OwnableInternalImpl = ownable_component::OwnableInternalImpl<ContractState>;
 40 | 
 41 |     #[storage]
 42 |     struct Storage {
 43 |         #[substorage(v0)]
 44 |         ownable: ownable_component::Storage,
 45 |         /// Store all of the created campaign instances' addresses and their class hashes
 46 |         campaigns: Map<(ContractAddress, ContractAddress), ClassHash>,
 47 |         /// Store the class hash of the contract to deploy
 48 |         campaign_class_hash: ClassHash,
 49 |     }
 50 | 
 51 |     #[event]
 52 |     #[derive(Drop, starknet::Event)]
 53 |     pub enum Event {
 54 |         #[flat]
 55 |         OwnableEvent: ownable_component::Event,
 56 |         CampaignClassHashUpgraded: CampaignClassHashUpgraded,
 57 |         CampaignCreated: CampaignCreated,
 58 |         ClassHashUpdated: ClassHashUpdated,
 59 |     }
 60 | 
 61 |     #[derive(Drop, starknet::Event)]
 62 |     pub struct ClassHashUpdated {
 63 |         pub new_class_hash: ClassHash,
 64 |     }
 65 | 
 66 |     #[derive(Drop, starknet::Event)]
 67 |     pub struct CampaignClassHashUpgraded {
 68 |         pub campaign: ContractAddress,
 69 |     }
 70 | 
 71 |     #[derive(Drop, starknet::Event)]
 72 |     pub struct CampaignCreated {
 73 |         pub creator: ContractAddress,
 74 |         pub contract_address: ContractAddress
 75 |     }
 76 | 
 77 |     pub mod Errors {
 78 |         pub const CLASS_HASH_ZERO: felt252 = 'Class hash cannot be zero';
 79 |         pub const ZERO_ADDRESS: felt252 = 'Zero address';
 80 |         pub const SAME_IMPLEMENTATION: felt252 = 'Implementation is unchanged';
 81 |         pub const CAMPAIGN_NOT_FOUND: felt252 = 'Campaign not found';
 82 |     }
 83 | 
 84 |     #[constructor]
 85 |     fn constructor(ref self: ContractState, class_hash: ClassHash) {
 86 |         assert(class_hash.is_non_zero(), Errors::CLASS_HASH_ZERO);
 87 |         self.campaign_class_hash.write(class_hash);
 88 |         self.ownable._init(get_caller_address());
 89 |     }
 90 | 
 91 | 
 92 |     #[abi(embed_v0)]
 93 |     impl CampaignFactory of super::ICampaignFactory<ContractState> {
 94 |         fn create_campaign(
 95 |             ref self: ContractState,
 96 |             title: ByteArray,
 97 |             description: ByteArray,
 98 |             goal: u256,
 99 |             start_time: u64,
100 |             end_time: u64,
101 |             token_address: ContractAddress,
102 |         ) -> ContractAddress {
103 |             let creator = get_caller_address();
104 | 
105 |             // Create constructor arguments
106 |             let mut constructor_calldata: Array::<felt252> = array![];
107 |             ((creator, title, description, goal), start_time, end_time, token_address)
108 |                 .serialize(ref constructor_calldata);
109 | 
110 |             // Contract deployment
111 |             let (contract_address, _) = deploy_syscall(
112 |                 self.campaign_class_hash.read(), 0, constructor_calldata.span(), false
113 |             )
114 |                 .unwrap_syscall();
115 | 
116 |             // track new campaign instance
117 |             self.campaigns.write((creator, contract_address), self.campaign_class_hash.read());
118 | 
119 |             self.emit(Event::CampaignCreated(CampaignCreated { creator, contract_address }));
120 | 
121 |             contract_address
122 |         }
123 | 
124 |         fn get_campaign_class_hash(self: @ContractState) -> ClassHash {
125 |             self.campaign_class_hash.read()
126 |         }
127 | 
128 |         fn update_campaign_class_hash(ref self: ContractState, new_class_hash: ClassHash) {
129 |             self.ownable._assert_only_owner();
130 |             assert(new_class_hash.is_non_zero(), Errors::CLASS_HASH_ZERO);
131 | 
132 |             self.campaign_class_hash.write(new_class_hash);
133 | 
134 |             self.emit(Event::ClassHashUpdated(ClassHashUpdated { new_class_hash }));
135 |         }
136 | 
137 |         fn upgrade_campaign(
138 |             ref self: ContractState, campaign_address: ContractAddress, new_end_time: Option<u64>
139 |         ) {
140 |             assert(campaign_address.is_non_zero(), Errors::ZERO_ADDRESS);
141 | 
142 |             let creator = get_caller_address();
143 |             let old_class_hash = self.campaigns.read((creator, campaign_address));
144 |             assert(old_class_hash.is_non_zero(), Errors::CAMPAIGN_NOT_FOUND);
145 |             assert(old_class_hash != self.campaign_class_hash.read(), Errors::SAME_IMPLEMENTATION);
146 | 
147 |             let campaign = ICampaignDispatcher { contract_address: campaign_address };
148 |             campaign.upgrade(self.campaign_class_hash.read(), new_end_time);
149 |         }
150 |     }
151 | }
152 | // [!endregion contract]
153 | 
154 | 
155 | 


--------------------------------------------------------------------------------
/listings/applications/advanced_factory/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | mod mock_upgrade;
3 | 
4 | #[cfg(test)]
5 | mod tests;
6 | 


--------------------------------------------------------------------------------
/listings/applications/advanced_factory/src/mock_upgrade.cairo:
--------------------------------------------------------------------------------
1 | #[starknet::contract]
2 | pub mod MockContract {
3 |     #[storage]
4 |     struct Storage {}
5 |     #[event]
6 |     #[derive(Drop, starknet::Event)]
7 |     enum Event {}
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/applications/advanced_factory/src/tests.cairo:
--------------------------------------------------------------------------------
  1 | use advanced_factory::contract::{
  2 |     CampaignFactory, ICampaignFactoryDispatcher, ICampaignFactoryDispatcherTrait
  3 | };
  4 | use crowdfunding::campaign::Campaign;
  5 | use starknet::{ClassHash, get_block_timestamp, contract_address_const};
  6 | use snforge_std::{
  7 |     declare, start_cheat_caller_address, stop_cheat_caller_address, spy_events, DeclareResultTrait,
  8 |     ContractClassTrait, get_class_hash, EventSpyAssertionsTrait
  9 | };
 10 | 
 11 | // Define a goal contract to deploy
 12 | use crowdfunding::campaign::{ICampaignDispatcher, ICampaignDispatcherTrait};
 13 | use components::ownable::{IOwnableDispatcher, IOwnableDispatcherTrait};
 14 | 
 15 | /// Deploy a campaign factory contract with the provided campaign class hash
 16 | fn deploy_factory_with(campaign_class_hash: ClassHash) -> ICampaignFactoryDispatcher {
 17 |     let mut constructor_calldata: @Array::<felt252> = @array![campaign_class_hash.into()];
 18 | 
 19 |     let contract = declare("CampaignFactory").unwrap().contract_class();
 20 |     let contract_address = contract.precalculate_address(constructor_calldata);
 21 |     let factory_owner = contract_address_const::<'factory_owner'>();
 22 |     start_cheat_caller_address(contract_address, factory_owner);
 23 | 
 24 |     contract.deploy(constructor_calldata).unwrap();
 25 | 
 26 |     stop_cheat_caller_address(contract_address);
 27 | 
 28 |     ICampaignFactoryDispatcher { contract_address }
 29 | }
 30 | 
 31 | /// Deploy a campaign factory contract with default campaign class hash
 32 | fn deploy_factory() -> ICampaignFactoryDispatcher {
 33 |     let campaign = declare("Campaign").unwrap().contract_class();
 34 |     deploy_factory_with(*campaign.class_hash)
 35 | }
 36 | 
 37 | #[test]
 38 | fn test_deploy_factory() {
 39 |     let campaign = declare("Campaign").unwrap().contract_class();
 40 |     let factory = deploy_factory_with(*campaign.class_hash);
 41 | 
 42 |     assert_eq!(factory.get_campaign_class_hash(), *campaign.class_hash);
 43 | 
 44 |     let factory_owner = contract_address_const::<'factory_owner'>();
 45 |     let factory_ownable = IOwnableDispatcher { contract_address: factory.contract_address };
 46 |     assert_eq!(factory_ownable.owner(), factory_owner);
 47 | }
 48 | 
 49 | #[test]
 50 | fn test_create_campaign() {
 51 |     let factory = deploy_factory();
 52 | 
 53 |     let mut spy = spy_events();
 54 | 
 55 |     let campaign_creator = contract_address_const::<'campaign_creator'>();
 56 |     start_cheat_caller_address(factory.contract_address, campaign_creator);
 57 | 
 58 |     let title: ByteArray = "New campaign";
 59 |     let description: ByteArray = "Some description";
 60 |     let goal: u256 = 10000;
 61 |     let start_time = get_block_timestamp();
 62 |     let end_time = start_time + 60;
 63 |     let token = contract_address_const::<'token'>();
 64 | 
 65 |     let campaign_address = factory
 66 |         .create_campaign(title.clone(), description.clone(), goal, start_time, end_time, token);
 67 |     let campaign = ICampaignDispatcher { contract_address: campaign_address };
 68 | 
 69 |     let details = campaign.get_details();
 70 |     assert_eq!(details.title, title);
 71 |     assert_eq!(details.description, description);
 72 |     assert_eq!(details.goal, goal);
 73 |     assert_eq!(details.start_time, start_time);
 74 |     assert_eq!(details.end_time, end_time);
 75 |     assert_eq!(details.claimed, false);
 76 |     assert_eq!(details.canceled, false);
 77 |     assert_eq!(details.token, token);
 78 |     assert_eq!(details.total_pledges, 0);
 79 |     assert_eq!(details.creator, campaign_creator);
 80 | 
 81 |     let campaign_ownable = IOwnableDispatcher { contract_address: campaign_address };
 82 |     assert_eq!(campaign_ownable.owner(), factory.contract_address);
 83 | 
 84 |     spy
 85 |         .assert_emitted(
 86 |             @array![
 87 |                 (
 88 |                     factory.contract_address,
 89 |                     CampaignFactory::Event::CampaignCreated(
 90 |                         CampaignFactory::CampaignCreated {
 91 |                             creator: campaign_creator, contract_address: campaign_address
 92 |                         }
 93 |                     )
 94 |                 )
 95 |             ]
 96 |         );
 97 | }
 98 | 
 99 | #[test]
100 | fn test_upgrade_campaign_class_hash() {
101 |     let factory = deploy_factory();
102 |     let old_class_hash = factory.get_campaign_class_hash();
103 |     let new_class_hash = *declare("MockContract").unwrap().contract_class().class_hash;
104 | 
105 |     let token = contract_address_const::<'token'>();
106 | 
107 |     // deploy a pending campaign with the old class hash
108 |     let start_time_pending = get_block_timestamp() + 20;
109 |     let end_time_pending = start_time_pending + 60;
110 |     let pending_campaign_creator = contract_address_const::<'pending_campaign_creator'>();
111 |     start_cheat_caller_address(factory.contract_address, pending_campaign_creator);
112 |     let pending_campaign = factory
113 |         .create_campaign(
114 |             "title 1", "description 1", 10000, start_time_pending, end_time_pending, token
115 |         );
116 | 
117 |     assert_eq!(old_class_hash, get_class_hash(pending_campaign));
118 | 
119 |     // deploy an active campaign with the old class hash
120 |     let start_time_active = get_block_timestamp();
121 |     let end_time_active = start_time_active + 60;
122 |     let active_campaign_creator = contract_address_const::<'active_campaign_creator'>();
123 |     start_cheat_caller_address(factory.contract_address, active_campaign_creator);
124 |     let active_campaign = factory
125 |         .create_campaign(
126 |             "title 2", "description 2", 20000, start_time_active, end_time_active, token
127 |         );
128 | 
129 |     assert_eq!(old_class_hash, get_class_hash(active_campaign));
130 | 
131 |     // update the factory's campaign class hash value
132 |     let mut spy = spy_events();
133 | 
134 |     let factory_owner = contract_address_const::<'factory_owner'>();
135 |     start_cheat_caller_address(factory.contract_address, factory_owner);
136 |     factory.update_campaign_class_hash(new_class_hash);
137 | 
138 |     assert_eq!(factory.get_campaign_class_hash(), new_class_hash);
139 |     assert_eq!(old_class_hash, get_class_hash(pending_campaign));
140 |     assert_eq!(old_class_hash, get_class_hash(active_campaign));
141 | 
142 |     spy
143 |         .assert_emitted(
144 |             @array![
145 |                 (
146 |                     factory.contract_address,
147 |                     CampaignFactory::Event::ClassHashUpdated(
148 |                         CampaignFactory::ClassHashUpdated { new_class_hash }
149 |                     )
150 |                 )
151 |             ]
152 |         );
153 | 
154 |     // upgrade pending campaign
155 |     start_cheat_caller_address(factory.contract_address, pending_campaign_creator);
156 |     factory.upgrade_campaign(pending_campaign, Option::None);
157 | 
158 |     assert_eq!(get_class_hash(pending_campaign), new_class_hash);
159 |     assert_eq!(get_class_hash(active_campaign), old_class_hash);
160 | 
161 |     spy
162 |         .assert_emitted(
163 |             @array![
164 |                 (
165 |                     pending_campaign,
166 |                     Campaign::Event::Upgraded(Campaign::Upgraded { implementation: new_class_hash })
167 |                 )
168 |             ]
169 |         );
170 | 
171 |     // upgrade active campaign
172 |     start_cheat_caller_address(factory.contract_address, active_campaign_creator);
173 |     factory.upgrade_campaign(active_campaign, Option::None);
174 | 
175 |     assert_eq!(get_class_hash(pending_campaign), new_class_hash);
176 |     assert_eq!(get_class_hash(active_campaign), new_class_hash);
177 | 
178 |     spy
179 |         .assert_emitted(
180 |             @array![
181 |                 (
182 |                     active_campaign,
183 |                     Campaign::Event::Upgraded(Campaign::Upgraded { implementation: new_class_hash })
184 |                 )
185 |             ]
186 |         );
187 | }
188 | 


--------------------------------------------------------------------------------
/listings/applications/coin_flip/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | .snfoundry_cache/
3 | 


--------------------------------------------------------------------------------
/listings/applications/coin_flip/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "coin_flip"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | openzeppelin.workspace = true
 9 | pragma_lib.workspace = true
10 | 
11 | [dev-dependencies]
12 | assert_macros.workspace = true
13 | snforge_std.workspace = true
14 | 
15 | [scripts]
16 | test.workspace = true
17 | 
18 | [[target.starknet-contract]]
19 | build-external-contracts = ["openzeppelin_presets::erc20::ERC20Upgradeable"]
20 | 


--------------------------------------------------------------------------------
/listings/applications/coin_flip/src/contract.cairo:
--------------------------------------------------------------------------------
  1 | use starknet::ContractAddress;
  2 | 
  3 | #[starknet::interface]
  4 | pub trait ICoinFlip<TContractState> {
  5 |     fn flip(ref self: TContractState);
  6 | }
  7 | 
  8 | // declares just the pragma_lib::abi::IRandomness.receive_random_words function
  9 | #[starknet::interface]
 10 | pub trait IPragmaVRF<TContractState> {
 11 |     fn receive_random_words(
 12 |         ref self: TContractState,
 13 |         requestor_address: ContractAddress,
 14 |         request_id: u64,
 15 |         random_words: Span<felt252>,
 16 |         calldata: Array<felt252>
 17 |     );
 18 | }
 19 | 
 20 | #[starknet::contract]
 21 | pub mod CoinFlip {
 22 |     use core::num::traits::zero::Zero;
 23 |     use starknet::{ContractAddress, get_caller_address, get_contract_address,};
 24 |     use starknet::storage::{
 25 |         Map, StoragePointerReadAccess, StoragePathEntry, StoragePointerWriteAccess
 26 |     };
 27 |     use pragma_lib::abi::{IRandomnessDispatcher, IRandomnessDispatcherTrait};
 28 |     use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 29 | 
 30 |     #[storage]
 31 |     struct Storage {
 32 |         eth_dispatcher: IERC20Dispatcher,
 33 |         flips: Map<u64, ContractAddress>,
 34 |         nonce: u64,
 35 |         randomness_contract_address: ContractAddress,
 36 |     }
 37 | 
 38 |     #[event]
 39 |     #[derive(Drop, starknet::Event)]
 40 |     pub enum Event {
 41 |         Flipped: Flipped,
 42 |         Landed: Landed,
 43 |     }
 44 | 
 45 |     #[derive(Drop, starknet::Event)]
 46 |     pub struct Flipped {
 47 |         pub flip_id: u64,
 48 |         pub flipper: ContractAddress,
 49 |     }
 50 | 
 51 |     #[derive(Drop, starknet::Event)]
 52 |     pub struct Landed {
 53 |         pub flip_id: u64,
 54 |         pub flipper: ContractAddress,
 55 |         pub side: Side
 56 |     }
 57 | 
 58 |     #[derive(Drop, Debug, PartialEq, Serde)]
 59 |     pub enum Side {
 60 |         Heads,
 61 |         Tails,
 62 |     }
 63 | 
 64 |     pub mod Errors {
 65 |         pub const CALLER_NOT_RANDOMNESS: felt252 = 'Caller not randomness contract';
 66 |         pub const INVALID_ADDRESS: felt252 = 'Invalid address';
 67 |         pub const INVALID_FLIP_ID: felt252 = 'No flip with the given ID';
 68 |         pub const REQUESTOR_NOT_SELF: felt252 = 'Requestor is not self';
 69 |         pub const TRANSFER_FAILED: felt252 = 'Transfer failed';
 70 |     }
 71 | 
 72 |     pub const PUBLISH_DELAY: u64 = 1; // return the random value asap
 73 |     pub const NUM_OF_WORDS: u64 = 1; // one random value is sufficient
 74 |     pub const CALLBACK_FEE_LIMIT: u128 = 100_000_000_000_000; // 0.0001 ETH
 75 |     pub const MAX_CALLBACK_FEE_DEPOSIT: u256 =
 76 |         500_000_000_000_000; // CALLBACK_FEE_LIMIT * 5; needs to cover the Premium fee
 77 | 
 78 |     #[constructor]
 79 |     fn constructor(
 80 |         ref self: ContractState,
 81 |         randomness_contract_address: ContractAddress,
 82 |         eth_address: ContractAddress
 83 |     ) {
 84 |         assert(randomness_contract_address.is_non_zero(), Errors::INVALID_ADDRESS);
 85 |         assert(eth_address.is_non_zero(), Errors::INVALID_ADDRESS);
 86 |         self.randomness_contract_address.write(randomness_contract_address);
 87 |         self.eth_dispatcher.write(IERC20Dispatcher { contract_address: eth_address });
 88 |     }
 89 | 
 90 |     #[abi(embed_v0)]
 91 |     impl CoinFlip of super::ICoinFlip<ContractState> {
 92 |         /// The contract needs to be funded with some ETH in order for this function
 93 |         /// to be callable. For simplicity, anyone can fund the contract.
 94 |         fn flip(ref self: ContractState) {
 95 |             let flip_id = self._request_my_randomness();
 96 |             let flipper = get_caller_address();
 97 |             self.flips.entry(flip_id).write(flipper);
 98 |             self.emit(Event::Flipped(Flipped { flip_id, flipper }));
 99 |         }
100 |     }
101 | 
102 |     #[abi(embed_v0)]
103 |     impl PragmaVRF of super::IPragmaVRF<ContractState> {
104 |         fn receive_random_words(
105 |             ref self: ContractState,
106 |             requestor_address: ContractAddress,
107 |             request_id: u64,
108 |             random_words: Span<felt252>,
109 |             calldata: Array<felt252>
110 |         ) {
111 |             let caller = get_caller_address();
112 |             assert(
113 |                 caller == self.randomness_contract_address.read(), Errors::CALLER_NOT_RANDOMNESS
114 |             );
115 | 
116 |             let this = get_contract_address();
117 |             assert(requestor_address == this, Errors::REQUESTOR_NOT_SELF);
118 | 
119 |             self._process_coin_flip(request_id, random_words.at(0));
120 |         }
121 |     }
122 | 
123 |     #[generate_trait]
124 |     impl Private of PrivateTrait {
125 |         fn _request_my_randomness(ref self: ContractState) -> u64 {
126 |             let randomness_contract_address = self.randomness_contract_address.read();
127 |             let randomness_dispatcher = IRandomnessDispatcher {
128 |                 contract_address: randomness_contract_address
129 |             };
130 | 
131 |             let this = get_contract_address();
132 | 
133 |             // Approve the randomness contract to transfer the callback deposit/fee
134 |             let eth_dispatcher = self.eth_dispatcher.read();
135 |             eth_dispatcher.approve(randomness_contract_address, MAX_CALLBACK_FEE_DEPOSIT);
136 | 
137 |             let nonce = self.nonce.read();
138 | 
139 |             // Request the randomness to be used to construct the winning combination
140 |             let request_id = randomness_dispatcher
141 |                 .request_random(
142 |                     nonce, this, CALLBACK_FEE_LIMIT, PUBLISH_DELAY, NUM_OF_WORDS, array![]
143 |                 );
144 | 
145 |             self.nonce.write(nonce + 1);
146 | 
147 |             request_id
148 |         }
149 | 
150 |         fn _process_coin_flip(ref self: ContractState, flip_id: u64, random_value: @felt252) {
151 |             let flipper = self.flips.entry(flip_id).read();
152 |             assert(flipper.is_non_zero(), Errors::INVALID_FLIP_ID);
153 | 
154 |             let random_value: u256 = (*random_value).into();
155 |             let side = if random_value % 2 == 0 {
156 |                 Side::Heads
157 |             } else {
158 |                 Side::Tails
159 |             };
160 | 
161 |             self.emit(Event::Landed(Landed { flip_id, flipper, side }));
162 |         }
163 |     }
164 | }
165 | 


--------------------------------------------------------------------------------
/listings/applications/coin_flip/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | mod mock_randomness;
3 | 
4 | #[cfg(test)]
5 | mod tests;
6 | 


--------------------------------------------------------------------------------
/listings/applications/coin_flip/src/mock_randomness.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::contract]
  2 | pub mod MockRandomness {
  3 |     use pragma_lib::abi::IRandomness;
  4 |     use pragma_lib::types::RequestStatus;
  5 |     use starknet::{ContractAddress, ClassHash, get_caller_address, get_contract_address};
  6 |     use starknet::storage::{
  7 |         Map, StoragePointerReadAccess, StoragePathEntry, StoragePointerWriteAccess
  8 |     };
  9 |     use core::num::traits::zero::Zero;
 10 |     use coin_flip::contract::{IPragmaVRFDispatcher, IPragmaVRFDispatcherTrait};
 11 |     use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 12 | 
 13 |     #[storage]
 14 |     struct Storage {
 15 |         eth_dispatcher: IERC20Dispatcher,
 16 |         next_request_id: u64,
 17 |         total_fees: Map<(ContractAddress, u64), u256>,
 18 |     }
 19 | 
 20 |     #[event]
 21 |     #[derive(Drop, starknet::Event)]
 22 |     enum Event {}
 23 | 
 24 |     pub mod Errors {
 25 |         pub const INVALID_ADDRESS: felt252 = 'Invalid address';
 26 |         pub const TRANSFER_FAILED: felt252 = 'Transfer failed';
 27 |     }
 28 | 
 29 |     #[constructor]
 30 |     fn constructor(ref self: ContractState, eth_address: ContractAddress) {
 31 |         assert(eth_address.is_non_zero(), Errors::INVALID_ADDRESS);
 32 |         self.eth_dispatcher.write(IERC20Dispatcher { contract_address: eth_address });
 33 |     }
 34 | 
 35 |     #[abi(embed_v0)]
 36 |     impl MockRandomness of IRandomness<ContractState> {
 37 |         fn request_random(
 38 |             ref self: ContractState,
 39 |             seed: u64,
 40 |             callback_address: ContractAddress,
 41 |             callback_fee_limit: u128,
 42 |             publish_delay: u64,
 43 |             num_words: u64,
 44 |             calldata: Array<felt252>
 45 |         ) -> u64 {
 46 |             let caller = get_caller_address();
 47 |             let this = get_contract_address();
 48 | 
 49 |             let total_fee: u256 = callback_fee_limit.into() * 5;
 50 |             let eth_dispatcher = self.eth_dispatcher.read();
 51 |             let success = eth_dispatcher.transfer_from(caller, this, total_fee);
 52 |             assert(success, Errors::TRANSFER_FAILED);
 53 | 
 54 |             let request_id = self.next_request_id.read();
 55 |             self.next_request_id.write(request_id + 1);
 56 | 
 57 |             self.total_fees.entry((caller, request_id)).write(total_fee);
 58 | 
 59 |             request_id
 60 |         }
 61 | 
 62 |         fn submit_random(
 63 |             ref self: ContractState,
 64 |             request_id: u64,
 65 |             requestor_address: ContractAddress,
 66 |             seed: u64,
 67 |             minimum_block_number: u64,
 68 |             callback_address: ContractAddress,
 69 |             callback_fee_limit: u128,
 70 |             callback_fee: u128,
 71 |             random_words: Span<felt252>,
 72 |             proof: Span<felt252>,
 73 |             calldata: Array<felt252>
 74 |         ) {
 75 |             let requestor = IPragmaVRFDispatcher { contract_address: callback_address };
 76 |             requestor.receive_random_words(requestor_address, request_id, random_words, calldata);
 77 |             let eth_dispatcher = self.eth_dispatcher.read();
 78 |             let success = eth_dispatcher
 79 |                 .transfer(requestor_address, (callback_fee_limit - callback_fee).into());
 80 |             assert(success, Errors::TRANSFER_FAILED);
 81 |         }
 82 | 
 83 |         fn get_total_fees(
 84 |             self: @ContractState, caller_address: ContractAddress, request_id: u64
 85 |         ) -> u256 {
 86 |             self.total_fees.entry((caller_address, request_id)).read()
 87 |         }
 88 | 
 89 | 
 90 |         fn compute_premium_fee(self: @ContractState, caller_address: ContractAddress) -> u128 {
 91 |             panic!("unimplemented 'compute_premium_fee'")
 92 |         }
 93 |         fn update_status(
 94 |             ref self: ContractState,
 95 |             requestor_address: ContractAddress,
 96 |             request_id: u64,
 97 |             new_status: RequestStatus
 98 |         ) {
 99 |             panic!("unimplemented")
100 |         }
101 | 
102 |         fn cancel_random_request(
103 |             ref self: ContractState,
104 |             request_id: u64,
105 |             requestor_address: ContractAddress,
106 |             seed: u64,
107 |             minimum_block_number: u64,
108 |             callback_address: ContractAddress,
109 |             callback_fee_limit: u128,
110 |             num_words: u64
111 |         ) {
112 |             panic!("unimplemented")
113 |         }
114 | 
115 |         fn get_pending_requests(
116 |             self: @ContractState, requestor_address: ContractAddress, offset: u64, max_len: u64
117 |         ) -> Span<felt252> {
118 |             panic!("unimplemented")
119 |         }
120 | 
121 |         fn get_request_status(
122 |             self: @ContractState, requestor_address: ContractAddress, request_id: u64
123 |         ) -> RequestStatus {
124 |             panic!("unimplemented")
125 |         }
126 |         fn requestor_current_index(
127 |             self: @ContractState, requestor_address: ContractAddress
128 |         ) -> u64 {
129 |             panic!("unimplemented")
130 |         }
131 |         fn get_public_key(self: @ContractState, requestor_address: ContractAddress) -> felt252 {
132 |             panic!("unimplemented")
133 |         }
134 |         fn get_payment_token(self: @ContractState) -> ContractAddress {
135 |             panic!("unimplemented")
136 |         }
137 |         fn set_payment_token(ref self: ContractState, token_contract: ContractAddress) {
138 |             panic!("unimplemented")
139 |         }
140 |         fn upgrade(ref self: ContractState, impl_hash: ClassHash) {
141 |             panic!("unimplemented")
142 |         }
143 |         fn refund_operation(
144 |             ref self: ContractState, caller_address: ContractAddress, request_id: u64
145 |         ) {
146 |             panic!("unimplemented")
147 |         }
148 |         fn get_out_of_gas_requests(
149 |             self: @ContractState, requestor_address: ContractAddress,
150 |         ) -> Span<u64> {
151 |             panic!("unimplemented")
152 |         }
153 |         fn withdraw_funds(ref self: ContractState, receiver_address: ContractAddress) {
154 |             panic!("unimplemented")
155 |         }
156 |         fn get_contract_balance(self: @ContractState) -> u256 {
157 |             panic!("unimplemented")
158 |         }
159 |         fn get_admin_address(self: @ContractState,) -> ContractAddress {
160 |             panic!("unimplemented")
161 |         }
162 |         fn set_admin_address(ref self: ContractState, new_admin_address: ContractAddress) {
163 |             panic!("unimplemented")
164 |         }
165 |     }
166 | }
167 | 


--------------------------------------------------------------------------------
/listings/applications/coin_flip/src/tests.cairo:
--------------------------------------------------------------------------------
  1 | use coin_flip::contract::{
  2 |     CoinFlip, CoinFlip::{Side, CALLBACK_FEE_LIMIT}, ICoinFlipDispatcher, ICoinFlipDispatcherTrait,
  3 | };
  4 | use starknet::{ContractAddress, contract_address_const};
  5 | use snforge_std::{
  6 |     declare, start_cheat_caller_address, stop_cheat_caller_address, spy_events,
  7 |     EventSpyAssertionsTrait, DeclareResultTrait, ContractClassTrait
  8 | };
  9 | use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 10 | use pragma_lib::abi::{IRandomnessDispatcher, IRandomnessDispatcherTrait};
 11 | 
 12 | fn deploy() -> (ICoinFlipDispatcher, IRandomnessDispatcher, IERC20Dispatcher, ContractAddress) {
 13 |     // deploy mock ETH token
 14 |     let eth_contract = declare("ERC20Upgradeable").unwrap().contract_class();
 15 |     let eth_name: ByteArray = "Ethereum";
 16 |     let eth_symbol: ByteArray = "ETH";
 17 |     let eth_supply: u256 = CALLBACK_FEE_LIMIT.into() * 100;
 18 |     let mut eth_ctor_calldata = array![];
 19 |     let deployer = contract_address_const::<'deployer'>();
 20 |     ((eth_name, eth_symbol, eth_supply, deployer), deployer).serialize(ref eth_ctor_calldata);
 21 |     let eth_address = eth_contract.precalculate_address(@eth_ctor_calldata);
 22 |     start_cheat_caller_address(eth_address, deployer);
 23 |     eth_contract.deploy(@eth_ctor_calldata).unwrap();
 24 |     stop_cheat_caller_address(eth_address);
 25 | 
 26 |     // deploy MockRandomness
 27 |     let mock_randomness = declare("MockRandomness").unwrap().contract_class();
 28 |     let mut randomness_calldata: Array<felt252> = array![];
 29 |     (eth_address).serialize(ref randomness_calldata);
 30 |     let (randomness_address, _) = mock_randomness.deploy(@randomness_calldata).unwrap();
 31 | 
 32 |     // deploy the actual CoinFlip contract
 33 |     let coin_flip_contract = declare("CoinFlip").unwrap().contract_class();
 34 |     let mut coin_flip_ctor_calldata: Array<felt252> = array![];
 35 |     (randomness_address, eth_address).serialize(ref coin_flip_ctor_calldata);
 36 |     let (coin_flip_address, _) = coin_flip_contract.deploy(@coin_flip_ctor_calldata).unwrap();
 37 | 
 38 |     let eth_dispatcher = IERC20Dispatcher { contract_address: eth_address };
 39 |     let randomness_dispatcher = IRandomnessDispatcher { contract_address: randomness_address };
 40 |     let coin_flip_dispatcher = ICoinFlipDispatcher { contract_address: coin_flip_address };
 41 | 
 42 |     (coin_flip_dispatcher, randomness_dispatcher, eth_dispatcher, deployer)
 43 | }
 44 | 
 45 | #[test]
 46 | fn test_all_relevant_random_words() {
 47 |     let (coin_flip, randomness, eth, deployer) = deploy();
 48 | 
 49 |     // fund the CoinFlip contract
 50 |     start_cheat_caller_address(eth.contract_address, deployer);
 51 |     eth.transfer(coin_flip.contract_address, CALLBACK_FEE_LIMIT.into() * 100);
 52 |     stop_cheat_caller_address(eth.contract_address);
 53 | 
 54 |     let random_words: Array<(felt252, Side, u64)> = array![
 55 |         (0, Side::Heads, 0),
 56 |         (2, Side::Heads, 1),
 57 |         (4, Side::Heads, 2),
 58 |         (1000, Side::Heads, 3),
 59 |         (12345654320, Side::Heads, 4),
 60 |         (1, Side::Tails, 5),
 61 |         (3, Side::Tails, 6),
 62 |         (5, Side::Tails, 7),
 63 |         (1001, Side::Tails, 8),
 64 |         (12345654321, Side::Tails, 9),
 65 |     ];
 66 |     for (
 67 |         random_word, expected_side, expected_request_id
 68 |     ) in random_words {
 69 |         _flip_request(
 70 |             coin_flip,
 71 |             randomness,
 72 |             eth,
 73 |             deployer,
 74 |             expected_request_id,
 75 |             CALLBACK_FEE_LIMIT / 5 * 3,
 76 |             random_word,
 77 |             expected_side
 78 |         );
 79 |     }
 80 | }
 81 | 
 82 | #[test]
 83 | fn test_multiple_flips() {
 84 |     let (coin_flip, randomness, eth, deployer) = deploy();
 85 | 
 86 |     // fund the CoinFlip contract
 87 |     start_cheat_caller_address(eth.contract_address, deployer);
 88 |     eth.transfer(coin_flip.contract_address, CALLBACK_FEE_LIMIT.into() * 50);
 89 |     stop_cheat_caller_address(eth.contract_address);
 90 | 
 91 |     _flip_request(
 92 |         coin_flip, randomness, eth, deployer, 0, CALLBACK_FEE_LIMIT / 5 * 3, 123456789, Side::Tails
 93 |     );
 94 |     _flip_request(
 95 |         coin_flip,
 96 |         randomness,
 97 |         eth,
 98 |         deployer,
 99 |         1,
100 |         CALLBACK_FEE_LIMIT / 4 * 3,
101 |         12345654321,
102 |         Side::Tails
103 |     );
104 |     _flip_request(coin_flip, randomness, eth, deployer, 2, CALLBACK_FEE_LIMIT, 3, Side::Tails);
105 | }
106 | 
107 | fn _flip_request(
108 |     coin_flip: ICoinFlipDispatcher,
109 |     randomness: IRandomnessDispatcher,
110 |     eth: IERC20Dispatcher,
111 |     deployer: ContractAddress,
112 |     expected_request_id: u64,
113 |     expected_callback_fee: u128,
114 |     random_word: felt252,
115 |     expected_side: Side
116 | ) {
117 |     let original_balance = eth.balance_of(coin_flip.contract_address);
118 | 
119 |     let mut spy = spy_events();
120 | 
121 |     start_cheat_caller_address(coin_flip.contract_address, deployer);
122 |     coin_flip.flip();
123 |     stop_cheat_caller_address(coin_flip.contract_address);
124 | 
125 |     spy
126 |         .assert_emitted(
127 |             @array![
128 |                 (
129 |                     coin_flip.contract_address,
130 |                     CoinFlip::Event::Flipped(
131 |                         CoinFlip::Flipped { flip_id: expected_request_id, flipper: deployer }
132 |                     )
133 |                 )
134 |             ]
135 |         );
136 | 
137 |     let post_flip_balance = eth.balance_of(coin_flip.contract_address);
138 |     assert_eq!(
139 |         post_flip_balance,
140 |         original_balance
141 |             - randomness.get_total_fees(coin_flip.contract_address, expected_request_id)
142 |     );
143 | 
144 |     randomness
145 |         .submit_random(
146 |             expected_request_id,
147 |             coin_flip.contract_address,
148 |             0,
149 |             0,
150 |             coin_flip.contract_address,
151 |             CALLBACK_FEE_LIMIT,
152 |             expected_callback_fee,
153 |             array![random_word].span(),
154 |             array![].span(),
155 |             array![]
156 |         );
157 | 
158 |     spy
159 |         .assert_emitted(
160 |             @array![
161 |                 (
162 |                     coin_flip.contract_address,
163 |                     CoinFlip::Event::Landed(
164 |                         CoinFlip::Landed {
165 |                             flip_id: expected_request_id, flipper: deployer, side: expected_side
166 |                         }
167 |                     )
168 |                 )
169 |             ]
170 |         );
171 | 
172 |     assert_eq!(
173 |         eth.balance_of(coin_flip.contract_address),
174 |         post_flip_balance + (CALLBACK_FEE_LIMIT - expected_callback_fee).into()
175 |     );
176 | }
177 | 
178 | #[test]
179 | fn test_two_consecutive_flips() {
180 |     let (coin_flip, randomness, eth, deployer) = deploy();
181 | 
182 |     // fund the CoinFlip contract
183 |     start_cheat_caller_address(eth.contract_address, deployer);
184 |     eth.transfer(coin_flip.contract_address, CALLBACK_FEE_LIMIT.into() * 50);
185 |     stop_cheat_caller_address(eth.contract_address);
186 | 
187 |     let mut spy = spy_events();
188 | 
189 |     let original_balance = eth.balance_of(coin_flip.contract_address);
190 | 
191 |     let other_flipper = contract_address_const::<'other_flipper'>();
192 | 
193 |     start_cheat_caller_address(coin_flip.contract_address, deployer);
194 |     coin_flip.flip();
195 |     start_cheat_caller_address(coin_flip.contract_address, other_flipper);
196 |     coin_flip.flip();
197 |     stop_cheat_caller_address(coin_flip.contract_address);
198 | 
199 |     spy
200 |         .assert_emitted(
201 |             @array![
202 |                 (
203 |                     coin_flip.contract_address,
204 |                     CoinFlip::Event::Flipped(CoinFlip::Flipped { flip_id: 0, flipper: deployer })
205 |                 ),
206 |                 (
207 |                     coin_flip.contract_address,
208 |                     CoinFlip::Event::Flipped(
209 |                         CoinFlip::Flipped { flip_id: 1, flipper: other_flipper }
210 |                     )
211 |                 )
212 |             ]
213 |         );
214 | 
215 |     let post_flip_balance = eth.balance_of(coin_flip.contract_address);
216 |     let first_flip_fee = randomness.get_total_fees(coin_flip.contract_address, 0);
217 |     let second_flip_fee = randomness.get_total_fees(coin_flip.contract_address, 1);
218 |     assert_eq!(post_flip_balance, original_balance - first_flip_fee - second_flip_fee);
219 | 
220 |     let expected_callback_fee = CALLBACK_FEE_LIMIT / 5 * 3;
221 |     let random_word_deployer = 5633;
222 |     let expected_side_deployer = Side::Tails;
223 |     let random_word_other_flipper = 8000;
224 |     let expected_side_other_flipper = Side::Heads;
225 | 
226 |     randomness
227 |         .submit_random(
228 |             0,
229 |             coin_flip.contract_address,
230 |             0,
231 |             0,
232 |             coin_flip.contract_address,
233 |             CALLBACK_FEE_LIMIT,
234 |             expected_callback_fee,
235 |             array![random_word_deployer].span(),
236 |             array![].span(),
237 |             array![]
238 |         );
239 |     randomness
240 |         .submit_random(
241 |             1,
242 |             coin_flip.contract_address,
243 |             0,
244 |             0,
245 |             coin_flip.contract_address,
246 |             CALLBACK_FEE_LIMIT,
247 |             expected_callback_fee,
248 |             array![random_word_other_flipper].span(),
249 |             array![].span(),
250 |             array![]
251 |         );
252 | 
253 |     spy
254 |         .assert_emitted(
255 |             @array![
256 |                 (
257 |                     coin_flip.contract_address,
258 |                     CoinFlip::Event::Landed(
259 |                         CoinFlip::Landed {
260 |                             flip_id: 0, flipper: deployer, side: expected_side_deployer
261 |                         }
262 |                     )
263 |                 ),
264 |                 (
265 |                     coin_flip.contract_address,
266 |                     CoinFlip::Event::Landed(
267 |                         CoinFlip::Landed {
268 |                             flip_id: 1, flipper: other_flipper, side: expected_side_other_flipper
269 |                         }
270 |                     )
271 |                 )
272 |             ]
273 |         );
274 | 
275 |     assert_eq!(
276 |         eth.balance_of(coin_flip.contract_address),
277 |         post_flip_balance + (CALLBACK_FEE_LIMIT - expected_callback_fee).into() * 2
278 |     );
279 | }
280 | 
281 | #[test]
282 | #[should_panic(expected: 'ERC20: insufficient balance')]
283 | fn test_flip_without_enough_for_fees() {
284 |     let (coin_flip, _, _, deployer) = deploy();
285 |     start_cheat_caller_address(coin_flip.contract_address, deployer);
286 |     coin_flip.flip();
287 | }
288 | 


--------------------------------------------------------------------------------
/listings/applications/components/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/components/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "components"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [lib]
 7 | 
 8 | [dependencies]
 9 | starknet.workspace = true
10 | 
11 | [dev-dependencies]
12 | cairo_test.workspace = true
13 | 
14 | [scripts]
15 | test.workspace = true
16 | 
17 | [[target.starknet-contract]]
18 | 


--------------------------------------------------------------------------------
/listings/applications/components/src/countable.cairo:
--------------------------------------------------------------------------------
 1 | // [!region component]
 2 | #[starknet::interface]
 3 | pub trait ICountable<TContractState> {
 4 |     fn get(self: @TContractState) -> u32;
 5 |     fn increment(ref self: TContractState);
 6 | }
 7 | 
 8 | #[starknet::component]
 9 | pub mod countable_component {
10 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
11 | 
12 |     #[storage]
13 |     pub struct Storage {
14 |         countable_value: u32,
15 |     }
16 | 
17 |     #[embeddable_as(Countable)]
18 |     impl CountableImpl<
19 |         TContractState, +HasComponent<TContractState>
20 |     > of super::ICountable<ComponentState<TContractState>> {
21 |         fn get(self: @ComponentState<TContractState>) -> u32 {
22 |             self.countable_value.read()
23 |         }
24 | 
25 |         fn increment(ref self: ComponentState<TContractState>) {
26 |             self.countable_value.write(self.countable_value.read() + 1);
27 |         }
28 |     }
29 | }
30 | // [!endregion component]
31 | 
32 | #[starknet::contract]
33 | mod CountableContract {
34 |     use super::countable_component;
35 | 
36 |     component!(path: countable_component, storage: countable, event: CountableEvent);
37 | 
38 |     #[storage]
39 |     struct Storage {
40 |         #[substorage(v0)]
41 |         countable: countable_component::Storage,
42 |     }
43 | 
44 |     #[event]
45 |     #[derive(Drop, starknet::Event)]
46 |     enum Event {
47 |         CountableEvent: countable_component::Event
48 |     }
49 | 
50 |     #[abi(embed_v0)]
51 |     impl CountableImpl = countable_component::Countable<ContractState>;
52 | }
53 | 
54 | 
55 | #[cfg(test)]
56 | mod test {
57 |     use super::CountableContract;
58 |     use super::{ICountableDispatcher, ICountableDispatcherTrait};
59 |     use starknet::syscalls::deploy_syscall;
60 |     use starknet::SyscallResultTrait;
61 | 
62 |     fn deploy_countable() -> ICountableDispatcher {
63 |         let (address, _) = deploy_syscall(
64 |             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
65 |         )
66 |             .unwrap_syscall();
67 |         ICountableDispatcher { contract_address: address }
68 |     }
69 | 
70 |     #[test]
71 |     fn test_constructor() {
72 |         let counter = deploy_countable();
73 |         assert_eq!(counter.get(), 0);
74 |     }
75 | 
76 |     #[test]
77 |     fn test_increment() {
78 |         let counter = deploy_countable();
79 |         counter.increment();
80 |         assert_eq!(counter.get(), 1);
81 |     }
82 | 
83 |     #[test]
84 |     fn test_multiple_increments() {
85 |         let counter = deploy_countable();
86 |         counter.increment();
87 |         counter.increment();
88 |         counter.increment();
89 |         assert_eq!(counter.get(), 3);
90 |     }
91 | }
92 | 


--------------------------------------------------------------------------------
/listings/applications/components/src/lib.cairo:
--------------------------------------------------------------------------------
1 | // Components
2 | pub mod switchable;
3 | pub mod countable;
4 | pub mod ownable;
5 | 
6 | // Not components but using them for specific examples
7 | mod others;
8 | 


--------------------------------------------------------------------------------
/listings/applications/components/src/others.cairo:
--------------------------------------------------------------------------------
1 | mod switch_collision;
2 | 


--------------------------------------------------------------------------------
/listings/applications/components/src/others/switch_collision.cairo:
--------------------------------------------------------------------------------
 1 | // [!region interface]
 2 | #[starknet::interface]
 3 | pub trait ISwitchCollision<TContractState> {
 4 |     fn set(ref self: TContractState, value: bool);
 5 |     fn get(ref self: TContractState) -> bool;
 6 | }
 7 | // [!endregion interface]
 8 | 
 9 | #[starknet::contract]
10 | pub mod SwitchCollisionContract {
11 |     use components::switchable::switchable_component;
12 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
13 | 
14 |     component!(path: switchable_component, storage: switch, event: SwitchableEvent);
15 | 
16 |     #[abi(embed_v0)]
17 |     impl SwitchableImpl = switchable_component::Switchable<ContractState>;
18 |     impl SwitchableInternalImpl = switchable_component::SwitchableInternalImpl<ContractState>;
19 | 
20 |     // [!region storage]
21 |     #[storage]
22 |     struct Storage {
23 |         switchable_value: bool,
24 |         #[substorage(v0)]
25 |         switch: switchable_component::Storage,
26 |     }
27 |     // [!endregion storage]
28 | 
29 |     #[constructor]
30 |     fn constructor(ref self: ContractState) {
31 |         self.switch._off();
32 |     }
33 | 
34 |     #[event]
35 |     #[derive(Drop, starknet::Event)]
36 |     enum Event {
37 |         SwitchableEvent: switchable_component::Event,
38 |     }
39 | 
40 |     #[abi(embed_v0)]
41 |     impl SwitchCollisionContract of super::ISwitchCollision<ContractState> {
42 |         fn set(ref self: ContractState, value: bool) {
43 |             self.switchable_value.write(value);
44 |         }
45 | 
46 |         fn get(ref self: ContractState) -> bool {
47 |             self.switchable_value.read()
48 |         }
49 |     }
50 | }
51 | 
52 | #[cfg(test)]
53 | mod switch_collision_tests {
54 |     use components::switchable::{ISwitchableDispatcher, ISwitchableDispatcherTrait};
55 |     use super::{
56 |         SwitchCollisionContract, ISwitchCollisionDispatcher, ISwitchCollisionDispatcherTrait
57 |     };
58 |     use starknet::SyscallResultTrait;
59 |     use starknet::syscalls::deploy_syscall;
60 | 
61 |     fn deploy() -> (ISwitchCollisionDispatcher, ISwitchableDispatcher) {
62 |         let (contract_address, _) = deploy_syscall(
63 |             SwitchCollisionContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
64 |         )
65 |             .unwrap_syscall();
66 | 
67 |         (
68 |             ISwitchCollisionDispatcher { contract_address },
69 |             ISwitchableDispatcher { contract_address },
70 |         )
71 |     }
72 | 
73 |     #[test]
74 |     // [!region collision]
75 |     fn test_collision() {
76 |         let (mut contract, mut contract_iswitch) = deploy();
77 | 
78 |         assert_eq!(contract.get(), false);
79 |         assert_eq!(contract_iswitch.is_on(), false);
80 | 
81 |         contract_iswitch.switch();
82 |         assert_eq!(contract_iswitch.is_on(), true);
83 |         assert_eq!(contract.get(), true);
84 | 
85 |         // `collision` between component storage 'value' and contract storage 'value'
86 |         assert_eq!(contract.get(), contract_iswitch.is_on());
87 | 
88 |         contract.set(false);
89 |         assert_eq!(contract.get(), contract_iswitch.is_on());
90 |     }
91 |     // [!endregion collision]
92 | }
93 | 


--------------------------------------------------------------------------------
/listings/applications/components/src/ownable.cairo:
--------------------------------------------------------------------------------
  1 | // [!region component]
  2 | use starknet::ContractAddress;
  3 | 
  4 | #[starknet::interface]
  5 | pub trait IOwnable<TContractState> {
  6 |     fn owner(self: @TContractState) -> ContractAddress;
  7 |     fn transfer_ownership(ref self: TContractState, new: ContractAddress);
  8 |     fn renounce_ownership(ref self: TContractState);
  9 | }
 10 | 
 11 | pub mod Errors {
 12 |     pub const UNAUTHORIZED: felt252 = 'Not owner';
 13 |     pub const ZERO_ADDRESS_OWNER: felt252 = 'Owner cannot be zero';
 14 |     pub const ZERO_ADDRESS_CALLER: felt252 = 'Caller cannot be zero';
 15 | }
 16 | 
 17 | #[starknet::component]
 18 | pub mod ownable_component {
 19 |     use super::Errors;
 20 |     use starknet::{ContractAddress, get_caller_address};
 21 |     use core::num::traits::Zero;
 22 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 23 | 
 24 |     #[storage]
 25 |     pub struct Storage {
 26 |         ownable_owner: ContractAddress,
 27 |     }
 28 | 
 29 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
 30 |     pub struct OwnershipTransferredEvent {
 31 |         pub previous: ContractAddress,
 32 |         pub new: ContractAddress
 33 |     }
 34 | 
 35 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
 36 |     pub struct OwnershipRenouncedEvent {
 37 |         pub previous: ContractAddress
 38 |     }
 39 | 
 40 |     #[event]
 41 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
 42 |     pub enum Event {
 43 |         OwnershipTransferredEvent: OwnershipTransferredEvent,
 44 |         OwnershipRenouncedEvent: OwnershipRenouncedEvent
 45 |     }
 46 | 
 47 |     #[embeddable_as(Ownable)]
 48 |     pub impl OwnableImpl<
 49 |         TContractState, +HasComponent<TContractState>
 50 |     > of super::IOwnable<ComponentState<TContractState>> {
 51 |         fn owner(self: @ComponentState<TContractState>) -> ContractAddress {
 52 |             self.ownable_owner.read()
 53 |         }
 54 | 
 55 |         fn transfer_ownership(ref self: ComponentState<TContractState>, new: ContractAddress) {
 56 |             self._assert_only_owner();
 57 |             self._transfer_ownership(new);
 58 |         }
 59 | 
 60 |         fn renounce_ownership(ref self: ComponentState<TContractState>) {
 61 |             self._assert_only_owner();
 62 |             self._renounce_ownership();
 63 |         }
 64 |     }
 65 | 
 66 |     #[generate_trait]
 67 |     pub impl OwnableInternalImpl<
 68 |         TContractState, +HasComponent<TContractState>
 69 |     > of OwnableInternalTrait<TContractState> {
 70 |         fn _assert_only_owner(self: @ComponentState<TContractState>) {
 71 |             let caller = get_caller_address();
 72 |             assert(caller.is_non_zero(), Errors::ZERO_ADDRESS_CALLER);
 73 |             assert(caller == self.ownable_owner.read(), Errors::UNAUTHORIZED);
 74 |         }
 75 | 
 76 |         fn _init(ref self: ComponentState<TContractState>, owner: ContractAddress) {
 77 |             assert(owner.is_non_zero(), Errors::ZERO_ADDRESS_OWNER);
 78 |             self.ownable_owner.write(owner);
 79 |         }
 80 | 
 81 |         fn _transfer_ownership(ref self: ComponentState<TContractState>, new: ContractAddress) {
 82 |             assert(new.is_non_zero(), Errors::ZERO_ADDRESS_OWNER);
 83 |             let previous = self.ownable_owner.read();
 84 |             self.ownable_owner.write(new);
 85 |             self
 86 |                 .emit(
 87 |                     Event::OwnershipTransferredEvent(OwnershipTransferredEvent { previous, new })
 88 |                 );
 89 |         }
 90 | 
 91 |         fn _renounce_ownership(ref self: ComponentState<TContractState>) {
 92 |             let previous = self.ownable_owner.read();
 93 |             self.ownable_owner.write(Zero::zero());
 94 |             self.emit(Event::OwnershipRenouncedEvent(OwnershipRenouncedEvent { previous }));
 95 |         }
 96 |     }
 97 | }
 98 | // [!endregion component]
 99 | 
100 | // [!region contract]
101 | #[starknet::contract]
102 | pub mod OwnedContract {
103 |     use super::{ownable_component, ownable_component::OwnableInternalTrait};
104 | 
105 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
106 | 
107 |     #[abi(embed_v0)]
108 |     impl OwnableImpl = ownable_component::Ownable<ContractState>;
109 | 
110 |     #[storage]
111 |     struct Storage {
112 |         #[substorage(v0)]
113 |         ownable: ownable_component::Storage,
114 |     }
115 | 
116 |     #[constructor]
117 |     fn constructor(ref self: ContractState) {
118 |         self.ownable._init(starknet::get_caller_address());
119 |     }
120 | 
121 |     #[event]
122 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
123 |     pub enum Event {
124 |         OwnableEvent: ownable_component::Event,
125 |     }
126 | }
127 | // [!endregion contract]
128 | 
129 | #[cfg(test)]
130 | mod test {
131 |     use super::OwnedContract;
132 |     use super::ownable_component::{OwnershipRenouncedEvent, OwnershipTransferredEvent};
133 |     use super::{IOwnableDispatcher, IOwnableDispatcherTrait};
134 |     use starknet::ContractAddress;
135 |     use starknet::{syscalls::deploy_syscall, SyscallResultTrait, contract_address_const};
136 |     use starknet::testing::{set_contract_address};
137 |     use core::num::traits::Zero;
138 | 
139 |     fn deploy() -> (IOwnableDispatcher, ContractAddress) {
140 |         let (contract_address, _) = deploy_syscall(
141 |             OwnedContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
142 |         )
143 |             .unwrap_syscall();
144 | 
145 |         (IOwnableDispatcher { contract_address }, contract_address)
146 |     }
147 | 
148 |     #[test]
149 |     fn test_initial_state() {
150 |         let owner = contract_address_const::<'owner'>();
151 |         set_contract_address(owner);
152 |         let (ownable, _) = deploy();
153 | 
154 |         assert_eq!(ownable.owner(), owner);
155 |     }
156 | 
157 |     #[test]
158 |     fn test_transfer_ownership() {
159 |         let contract_address = contract_address_const::<'owner'>();
160 |         set_contract_address(contract_address);
161 |         let (ownable, address) = deploy();
162 |         let new_owner = contract_address_const::<'new_owner'>();
163 | 
164 |         ownable.transfer_ownership(new_owner);
165 |         assert_eq!(ownable.owner(), new_owner);
166 |         assert_eq!(
167 |             starknet::testing::pop_log(address),
168 |             Option::Some(
169 |                 OwnedContract::Event::OwnableEvent(
170 |                     OwnershipTransferredEvent { previous: contract_address, new: new_owner }.into()
171 |                 )
172 |             )
173 |         );
174 |     }
175 | 
176 |     #[test]
177 |     #[should_panic]
178 |     fn test_transfer_ownership_not_owner() {
179 |         set_contract_address(contract_address_const::<'initial'>());
180 |         let (ownable, _) = deploy();
181 | 
182 |         set_contract_address(contract_address_const::<'not_owner'>());
183 |         ownable.transfer_ownership(contract_address_const::<'new_owner'>());
184 |     }
185 | 
186 |     #[test]
187 |     #[should_panic]
188 |     fn test_transfer_ownership_zero_error() {
189 |         set_contract_address(contract_address_const::<'initial'>());
190 |         let (ownable, _) = deploy();
191 | 
192 |         ownable.transfer_ownership(Zero::zero());
193 |     }
194 | 
195 |     #[test]
196 |     fn test_renounce_ownership() {
197 |         let contract_address = contract_address_const::<'owner'>();
198 |         set_contract_address(contract_address);
199 |         let (ownable, address) = deploy();
200 | 
201 |         ownable.renounce_ownership();
202 |         assert_eq!(ownable.owner(), Zero::zero());
203 |         assert_eq!(
204 |             starknet::testing::pop_log(address),
205 |             Option::Some(
206 |                 OwnedContract::Event::OwnableEvent(
207 |                     OwnershipRenouncedEvent { previous: contract_address }.into()
208 |                 )
209 |             )
210 |         );
211 |     }
212 | 
213 |     #[test]
214 |     #[should_panic]
215 |     fn test_renounce_ownership_not_owner() {
216 |         set_contract_address(contract_address_const::<'owner'>());
217 |         let (ownable, _) = deploy();
218 | 
219 |         set_contract_address(contract_address_const::<'not_owner'>());
220 |         ownable.renounce_ownership();
221 |     }
222 | 
223 |     #[test]
224 |     #[should_panic]
225 |     fn test_renounce_ownership_previous_owner() {
226 |         set_contract_address(contract_address_const::<'owner'>());
227 |         let (ownable, _) = deploy();
228 | 
229 |         ownable.renounce_ownership();
230 |         ownable.transfer_ownership(contract_address_const::<'new_owner'>());
231 |     }
232 | }
233 | 


--------------------------------------------------------------------------------
/listings/applications/components/src/switchable.cairo:
--------------------------------------------------------------------------------
  1 | // [!region component]
  2 | #[starknet::interface]
  3 | // [!region interface]
  4 | pub trait ISwitchable<TContractState> {
  5 |     fn is_on(self: @TContractState) -> bool;
  6 |     fn switch(ref self: TContractState);
  7 | }
  8 | // [!endregion interface]
  9 | 
 10 | #[starknet::component]
 11 | pub mod switchable_component {
 12 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 13 | 
 14 |     #[storage]
 15 |     pub struct Storage {
 16 |         switchable_value: bool,
 17 |     }
 18 | 
 19 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
 20 |     pub struct SwitchEvent {}
 21 | 
 22 |     #[event]
 23 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
 24 |     pub enum Event {
 25 |         SwitchEvent: SwitchEvent,
 26 |     }
 27 | 
 28 |     #[embeddable_as(Switchable)]
 29 |     impl SwitchableImpl<
 30 |         TContractState, +HasComponent<TContractState>
 31 |     > of super::ISwitchable<ComponentState<TContractState>> {
 32 |         fn is_on(self: @ComponentState<TContractState>) -> bool {
 33 |             self.switchable_value.read()
 34 |         }
 35 | 
 36 |         fn switch(ref self: ComponentState<TContractState>) {
 37 |             self.switchable_value.write(!self.switchable_value.read());
 38 |             self.emit(Event::SwitchEvent(SwitchEvent {}));
 39 |         }
 40 |     }
 41 | 
 42 |     #[generate_trait]
 43 |     pub impl SwitchableInternalImpl<
 44 |         TContractState, +HasComponent<TContractState>
 45 |     > of SwitchableInternalTrait<TContractState> {
 46 |         fn _off(ref self: ComponentState<TContractState>) {
 47 |             self.switchable_value.write(false);
 48 |         }
 49 |     }
 50 | }
 51 | // [!endregion component]
 52 | 
 53 | // [!region contract]
 54 | #[starknet::contract]
 55 | pub mod SwitchContract {
 56 |     use super::switchable_component;
 57 | 
 58 |     component!(path: switchable_component, storage: switch, event: SwitchableEvent);
 59 | 
 60 |     #[abi(embed_v0)]
 61 |     impl SwitchableImpl = switchable_component::Switchable<ContractState>;
 62 | 
 63 |     #[storage]
 64 |     struct Storage {
 65 |         #[substorage(v0)]
 66 |         switch: switchable_component::Storage,
 67 |     }
 68 | 
 69 |     #[event]
 70 |     #[derive(Drop, Debug, PartialEq, starknet::Event)]
 71 |     pub enum Event {
 72 |         SwitchableEvent: switchable_component::Event,
 73 |     }
 74 | 
 75 |     // You can optionally use the internal implementation of the component as well
 76 |     impl SwitchableInternalImpl = switchable_component::SwitchableInternalImpl<ContractState>;
 77 | 
 78 |     #[constructor]
 79 |     fn constructor(ref self: ContractState) {
 80 |         // Internal function call
 81 |         self.switch._off();
 82 |     }
 83 | }
 84 | // [!endregion contract]
 85 | 
 86 | // [!region tests]
 87 | #[cfg(test)]
 88 | mod test {
 89 |     use super::SwitchContract; // Used as a mock contract
 90 |     use super::switchable_component::SwitchEvent;
 91 |     use super::{ISwitchableDispatcher, ISwitchableDispatcherTrait};
 92 |     use starknet::{syscalls::deploy_syscall, ContractAddress};
 93 |     use starknet::SyscallResultTrait;
 94 | 
 95 |     fn deploy() -> (ISwitchableDispatcher, ContractAddress) {
 96 |         let (address, _) = deploy_syscall(
 97 |             SwitchContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
 98 |         )
 99 |             .unwrap_syscall();
100 |         (ISwitchableDispatcher { contract_address: address }, address)
101 |     }
102 | 
103 |     #[test]
104 |     fn test_constructor() {
105 |         let (switchable, _) = deploy();
106 |         assert_eq!(switchable.is_on(), false);
107 |     }
108 | 
109 |     #[test]
110 |     fn test_switch() {
111 |         let (switchable, contract_address) = deploy();
112 |         switchable.switch();
113 |         assert_eq!(switchable.is_on(), true);
114 |         assert_eq!(
115 |             starknet::testing::pop_log(contract_address),
116 |             Option::Some(SwitchContract::Event::SwitchableEvent(SwitchEvent {}.into()))
117 |         );
118 |     }
119 | 
120 |     #[test]
121 |     fn test_multiple_switches() {
122 |         let (switchable, _) = deploy();
123 |         switchable.switch();
124 |         assert_eq!(switchable.is_on(), true);
125 |         switchable.switch();
126 |         assert_eq!(switchable.is_on(), false);
127 |         switchable.switch();
128 |         assert_eq!(switchable.is_on(), true);
129 |     }
130 | }
131 | // [!endregion tests]
132 | 
133 | 
134 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "components_dependencies"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | components = { path = "../components" }
 9 | 
10 | [dev-dependencies]
11 | cairo_test.workspace = true
12 | 
13 | [scripts]
14 | test.workspace = true
15 | 
16 | [[target.starknet-contract]]
17 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/src/contract_countable.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | #[starknet::contract]
  3 | mod CountableContract {
  4 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
  5 |     use components_dependencies::countable_dep_switch::countable_component;
  6 |     use components::switchable::ISwitchable;
  7 | 
  8 |     component!(path: countable_component, storage: counter, event: CountableEvent);
  9 | 
 10 |     #[abi(embed_v0)]
 11 |     impl CountableImpl = countable_component::Countable<ContractState>;
 12 | 
 13 |     #[storage]
 14 |     struct Storage {
 15 |         #[substorage(v0)]
 16 |         counter: countable_component::Storage,
 17 |         switch: bool
 18 |     }
 19 | 
 20 |     // Implementation of the dependency:
 21 |     #[abi(embed_v0)]
 22 |     impl Switchable of ISwitchable<ContractState> {
 23 |         fn switch(ref self: ContractState) {
 24 |             self.switch.write(!self.switch.read());
 25 |         }
 26 | 
 27 |         fn is_on(self: @ContractState) -> bool {
 28 |             self.switch.read()
 29 |         }
 30 |     }
 31 | 
 32 |     #[constructor]
 33 |     fn constructor(ref self: ContractState) {
 34 |         self.switch.write(false);
 35 |     }
 36 | 
 37 |     #[event]
 38 |     #[derive(Drop, starknet::Event)]
 39 |     enum Event {
 40 |         CountableEvent: countable_component::Event,
 41 |     }
 42 | }
 43 | // [!endregion contract]
 44 | 
 45 | #[cfg(test)]
 46 | mod tests {
 47 |     use super::CountableContract;
 48 |     use components::countable::{ICountableDispatcher, ICountableDispatcherTrait};
 49 |     use components::switchable::{ISwitchableDispatcher, ISwitchableDispatcherTrait};
 50 | 
 51 |     use starknet::SyscallResultTrait;
 52 |     use starknet::syscalls::deploy_syscall;
 53 | 
 54 |     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {
 55 |         let (contract_address, _) = deploy_syscall(
 56 |             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
 57 |         )
 58 |             .unwrap_syscall();
 59 | 
 60 |         (ICountableDispatcher { contract_address }, ISwitchableDispatcher { contract_address },)
 61 |     }
 62 | 
 63 |     #[test]
 64 |     fn test_init() {
 65 |         let (mut counter, mut switch) = deploy();
 66 | 
 67 |         assert_eq!(counter.get(), 0);
 68 |         assert_eq!(switch.is_on(), false);
 69 |     }
 70 | 
 71 |     #[test]
 72 |     fn test_increment_switch_off() {
 73 |         let (mut counter, mut switch) = deploy();
 74 | 
 75 |         counter.increment();
 76 |         assert_eq!(counter.get(), 0);
 77 |         assert_eq!(switch.is_on(), false);
 78 |     }
 79 | 
 80 |     #[test]
 81 |     fn test_increment_switch_on() {
 82 |         let (mut counter, mut switch) = deploy();
 83 | 
 84 |         switch.switch();
 85 |         assert_eq!(switch.is_on(), true);
 86 | 
 87 |         counter.increment();
 88 |         assert_eq!(counter.get(), 1);
 89 |     }
 90 | 
 91 |     #[test]
 92 |     fn test_increment_multiple_switches() {
 93 |         let (mut counter, mut switch) = deploy();
 94 | 
 95 |         switch.switch();
 96 | 
 97 |         counter.increment();
 98 |         counter.increment();
 99 |         counter.increment();
100 |         assert_eq!(counter.get(), 3);
101 | 
102 |         switch.switch();
103 |         counter.increment();
104 |         counter.increment();
105 |         counter.increment();
106 | 
107 |         switch.switch();
108 | 
109 |         counter.increment();
110 |         counter.increment();
111 |         counter.increment();
112 |         assert_eq!(counter.get(), 6);
113 |     }
114 | }
115 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/src/contract_countable_switchable.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | #[starknet::contract]
  3 | mod CountableContract {
  4 |     use components_dependencies::countable_dep_switch::countable_component;
  5 |     use components::switchable::switchable_component;
  6 | 
  7 |     component!(path: countable_component, storage: counter, event: CountableEvent);
  8 |     component!(path: switchable_component, storage: switch, event: SwitchableEvent);
  9 | 
 10 |     #[abi(embed_v0)]
 11 |     impl CountableImpl = countable_component::Countable<ContractState>;
 12 |     #[abi(embed_v0)]
 13 |     impl SwitchableImpl = switchable_component::Switchable<ContractState>;
 14 |     impl SwitchableInternalImpl = switchable_component::SwitchableInternalImpl<ContractState>;
 15 | 
 16 |     #[storage]
 17 |     struct Storage {
 18 |         #[substorage(v0)]
 19 |         counter: countable_component::Storage,
 20 |         #[substorage(v0)]
 21 |         switch: switchable_component::Storage
 22 |     }
 23 | 
 24 |     #[constructor]
 25 |     fn constructor(ref self: ContractState) {
 26 |         self.switch._off();
 27 |     }
 28 | 
 29 |     #[event]
 30 |     #[derive(Drop, starknet::Event)]
 31 |     enum Event {
 32 |         CountableEvent: countable_component::Event,
 33 |         SwitchableEvent: switchable_component::Event,
 34 |     }
 35 | }
 36 | // [!endregion contract]
 37 | 
 38 | #[cfg(test)]
 39 | mod tests {
 40 |     use super::CountableContract;
 41 |     use components::countable::{ICountableDispatcher, ICountableDispatcherTrait};
 42 |     use components::switchable::{ISwitchableDispatcher, ISwitchableDispatcherTrait};
 43 | 
 44 |     use starknet::SyscallResultTrait;
 45 |     use starknet::syscalls::deploy_syscall;
 46 | 
 47 |     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {
 48 |         let (contract_address, _) = deploy_syscall(
 49 |             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
 50 |         )
 51 |             .unwrap_syscall();
 52 | 
 53 |         (ICountableDispatcher { contract_address }, ISwitchableDispatcher { contract_address },)
 54 |     }
 55 | 
 56 |     #[test]
 57 |     fn test_init() {
 58 |         let (mut counter, mut switch) = deploy();
 59 | 
 60 |         assert_eq!(counter.get(), 0);
 61 |         assert_eq!(switch.is_on(), false);
 62 |     }
 63 | 
 64 |     #[test]
 65 |     fn test_increment_switch_off() {
 66 |         let (mut counter, mut switch) = deploy();
 67 | 
 68 |         counter.increment();
 69 |         assert_eq!(counter.get(), 0);
 70 |         assert_eq!(switch.is_on(), false);
 71 |     }
 72 | 
 73 |     #[test]
 74 |     fn test_increment_switch_on() {
 75 |         let (mut counter, mut switch) = deploy();
 76 | 
 77 |         switch.switch();
 78 |         assert_eq!(switch.is_on(), true);
 79 | 
 80 |         counter.increment();
 81 |         assert_eq!(counter.get(), 1);
 82 |     }
 83 | 
 84 |     #[test]
 85 |     fn test_increment_multiple_switches() {
 86 |         let (mut counter, mut switch) = deploy();
 87 | 
 88 |         switch.switch();
 89 | 
 90 |         counter.increment();
 91 |         counter.increment();
 92 |         counter.increment();
 93 |         assert_eq!(counter.get(), 3);
 94 | 
 95 |         switch.switch();
 96 |         counter.increment();
 97 |         counter.increment();
 98 |         counter.increment();
 99 | 
100 |         switch.switch();
101 | 
102 |         counter.increment();
103 |         counter.increment();
104 |         counter.increment();
105 |         assert_eq!(counter.get(), 6);
106 |     }
107 | }
108 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/src/contract_countable_switchable_internal.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | #[starknet::contract]
  3 | pub mod CountableContract {
  4 |     use components_dependencies::countable_internal_dep_switch::countable_component;
  5 |     use components::switchable::switchable_component;
  6 | 
  7 |     component!(path: countable_component, storage: counter, event: CountableEvent);
  8 |     component!(path: switchable_component, storage: switch, event: SwitchableEvent);
  9 | 
 10 |     #[abi(embed_v0)]
 11 |     impl CountableImpl = countable_component::Countable<ContractState>;
 12 |     #[abi(embed_v0)]
 13 |     impl SwitchableImpl = switchable_component::Switchable<ContractState>;
 14 |     impl SwitchableInternalImpl = switchable_component::SwitchableInternalImpl<ContractState>;
 15 | 
 16 |     #[storage]
 17 |     struct Storage {
 18 |         #[substorage(v0)]
 19 |         counter: countable_component::Storage,
 20 |         #[substorage(v0)]
 21 |         switch: switchable_component::Storage
 22 |     }
 23 | 
 24 |     #[constructor]
 25 |     fn constructor(ref self: ContractState) {
 26 |         self.switch._off();
 27 |     }
 28 | 
 29 |     #[event]
 30 |     #[derive(Drop, starknet::Event)]
 31 |     enum Event {
 32 |         CountableEvent: countable_component::Event,
 33 |         SwitchableEvent: switchable_component::Event,
 34 |     }
 35 | }
 36 | // [!endregion contract]
 37 | 
 38 | #[cfg(test)]
 39 | mod tests {
 40 |     use super::CountableContract;
 41 |     use components::countable::{ICountableDispatcher, ICountableDispatcherTrait};
 42 |     use components::switchable::{ISwitchableDispatcher, ISwitchableDispatcherTrait};
 43 | 
 44 |     use starknet::SyscallResultTrait;
 45 |     use starknet::syscalls::deploy_syscall;
 46 | 
 47 |     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {
 48 |         let (contract_address, _) = deploy_syscall(
 49 |             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
 50 |         )
 51 |             .unwrap_syscall();
 52 | 
 53 |         (ICountableDispatcher { contract_address }, ISwitchableDispatcher { contract_address },)
 54 |     }
 55 | 
 56 |     #[test]
 57 |     fn test_init() {
 58 |         let (mut counter, mut switch) = deploy();
 59 | 
 60 |         assert_eq!(counter.get(), 0);
 61 |         assert_eq!(switch.is_on(), false);
 62 |     }
 63 | 
 64 |     #[test]
 65 |     fn test_increment_switch_off() {
 66 |         let (mut counter, mut switch) = deploy();
 67 | 
 68 |         counter.increment();
 69 |         assert_eq!(counter.get(), 0);
 70 |         assert_eq!(switch.is_on(), false);
 71 |     }
 72 | 
 73 |     #[test]
 74 |     fn test_increment_switch_on() {
 75 |         let (mut counter, mut switch) = deploy();
 76 | 
 77 |         switch.switch();
 78 |         assert_eq!(switch.is_on(), true);
 79 | 
 80 |         counter.increment();
 81 |         assert_eq!(counter.get(), 1);
 82 | 
 83 |         // The counter turned the switch off.
 84 |         assert_eq!(switch.is_on(), false);
 85 |     }
 86 | 
 87 |     #[test]
 88 |     fn test_increment_multiple_switches() {
 89 |         let (mut counter, mut switch) = deploy();
 90 | 
 91 |         switch.switch();
 92 | 
 93 |         counter.increment();
 94 |         counter.increment(); // off
 95 |         counter.increment(); // off
 96 |         assert_eq!(counter.get(), 1);
 97 | 
 98 |         switch.switch();
 99 |         counter.increment();
100 |         switch.switch();
101 |         counter.increment();
102 |         counter.increment();
103 |         assert_eq!(counter.get(), 3);
104 |     }
105 | }
106 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/src/countable_dep_switch.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::component]
 3 | pub mod countable_component {
 4 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 5 |     use components::countable::ICountable;
 6 |     use components::switchable::ISwitchable;
 7 | 
 8 |     #[storage]
 9 |     pub struct Storage {
10 |         countable_value: u32,
11 |     }
12 | 
13 |     // [!region impl]
14 |     #[embeddable_as(Countable)]
15 |     impl CountableImpl<
16 |         TContractState, +HasComponent<TContractState>, +ISwitchable<TContractState>
17 |     > of ICountable<ComponentState<TContractState>> {
18 |         fn get(self: @ComponentState<TContractState>) -> u32 {
19 |             self.countable_value.read()
20 |         }
21 | 
22 |         fn increment(ref self: ComponentState<TContractState>) {
23 |             if (self.get_contract().is_on()) {
24 |                 self.countable_value.write(self.countable_value.read() + 1);
25 |             }
26 |         }
27 |     }
28 |     // [!endregion impl]
29 | }
30 | 
31 | // [!endregion contract]
32 | 
33 | #[starknet::contract]
34 | mod MockContract {
35 |     use super::countable_component;
36 |     use components::switchable::ISwitchable;
37 | 
38 |     component!(path: countable_component, storage: counter, event: CountableEvent);
39 | 
40 |     #[storage]
41 |     struct Storage {
42 |         #[substorage(v0)]
43 |         counter: countable_component::Storage,
44 |         switch: bool,
45 |     }
46 | 
47 |     #[event]
48 |     #[derive(Drop, starknet::Event)]
49 |     enum Event {
50 |         CountableEvent: countable_component::Event,
51 |     }
52 | 
53 |     #[abi(embed_v0)]
54 |     impl CountableImpl = countable_component::Countable<ContractState>;
55 |     #[abi(embed_v0)]
56 |     impl Switchable of ISwitchable<ContractState> {
57 |         fn switch(ref self: ContractState) {}
58 | 
59 |         fn is_on(self: @ContractState) -> bool {
60 |             true
61 |         }
62 |     }
63 | }
64 | 
65 | 
66 | #[cfg(test)]
67 | mod test {
68 |     use super::MockContract;
69 |     use components::countable::{ICountableDispatcher, ICountableDispatcherTrait};
70 |     use starknet::syscalls::deploy_syscall;
71 |     use starknet::SyscallResultTrait;
72 | 
73 |     fn deploy_countable() -> ICountableDispatcher {
74 |         let (contract_address, _) = deploy_syscall(
75 |             MockContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
76 |         )
77 |             .unwrap_syscall();
78 |         ICountableDispatcher { contract_address: contract_address }
79 |     }
80 | 
81 |     #[test]
82 |     fn test_get() {
83 |         let countable = deploy_countable();
84 |         assert_eq!(countable.get(), 0);
85 |     }
86 | 
87 |     #[test]
88 |     fn test_increment() {
89 |         let countable = deploy_countable();
90 |         countable.increment();
91 |         assert_eq!(countable.get(), 1);
92 |     }
93 | }
94 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/src/countable_internal_dep_switch.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::component]
 3 | pub mod countable_component {
 4 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 5 |     use components::countable::ICountable;
 6 |     use components::switchable::ISwitchable;
 7 | 
 8 |     // Explicitly depends on a component and not a trait
 9 |     use components::switchable::switchable_component;
10 |     use switchable_component::{SwitchableInternalImpl, SwitchableInternalTrait};
11 | 
12 |     #[storage]
13 |     pub struct Storage {
14 |         countable_value: u32,
15 |     }
16 | 
17 |     #[generate_trait]
18 |     impl GetSwitchable<
19 |         TContractState,
20 |         +HasComponent<TContractState>,
21 |         +switchable_component::HasComponent<TContractState>,
22 |         +Drop<TContractState>
23 |     > of GetSwitchableTrait<TContractState> {
24 |         fn get_switchable(
25 |             self: @ComponentState<TContractState>
26 |         ) -> @switchable_component::ComponentState<TContractState> {
27 |             let contract = self.get_contract();
28 |             switchable_component::HasComponent::<TContractState>::get_component(contract)
29 |         }
30 | 
31 |         fn get_switchable_mut(
32 |             ref self: ComponentState<TContractState>
33 |         ) -> switchable_component::ComponentState<TContractState> {
34 |             let mut contract = self.get_contract_mut();
35 |             switchable_component::HasComponent::<TContractState>::get_component_mut(ref contract)
36 |         }
37 |     }
38 | 
39 |     #[embeddable_as(Countable)]
40 |     impl CountableImpl<
41 |         TContractState,
42 |         +HasComponent<TContractState>,
43 |         +ISwitchable<TContractState>,
44 |         +switchable_component::HasComponent<TContractState>,
45 |         +Drop<TContractState>
46 |     > of ICountable<ComponentState<TContractState>> {
47 |         fn get(self: @ComponentState<TContractState>) -> u32 {
48 |             self.countable_value.read()
49 |         }
50 | 
51 |         fn increment(ref self: ComponentState<TContractState>) {
52 |             if (self.get_contract().is_on()) {
53 |                 self.countable_value.write(self.countable_value.read() + 1);
54 | 
55 |                 // use the switchable component internal function
56 |                 let mut switch = self.get_switchable_mut();
57 |                 switch._off();
58 |             }
59 |         }
60 |     }
61 | }
62 | // [!endregion contract]
63 | 
64 | 
65 | 


--------------------------------------------------------------------------------
/listings/applications/components_dependencies/src/lib.cairo:
--------------------------------------------------------------------------------
1 | // components
2 | mod countable_dep_switch;
3 | mod countable_internal_dep_switch;
4 | 
5 | // contracts
6 | mod contract_countable;
7 | mod contract_countable_switchable;
8 | mod contract_countable_switchable_internal;
9 | 


--------------------------------------------------------------------------------
/listings/applications/constant_product_amm/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/constant_product_amm/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "constant_product_amm"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | openzeppelin.workspace = true
 9 | 
10 | [dev-dependencies]
11 | cairo_test.workspace = true
12 | 
13 | [scripts]
14 | test.workspace = true
15 | 
16 | [[target.starknet-contract]]
17 | 


--------------------------------------------------------------------------------
/listings/applications/constant_product_amm/src/contracts.cairo:
--------------------------------------------------------------------------------
  1 | // [!region ConstantProductAmmContract]
  2 | use starknet::ContractAddress;
  3 | 
  4 | #[starknet::interface]
  5 | pub trait IConstantProductAmm<TContractState> {
  6 |     fn swap(ref self: TContractState, token_in: ContractAddress, amount_in: u256) -> u256;
  7 |     fn add_liquidity(ref self: TContractState, amount0: u256, amount1: u256) -> u256;
  8 |     fn remove_liquidity(ref self: TContractState, shares: u256) -> (u256, u256);
  9 | }
 10 | 
 11 | #[starknet::contract]
 12 | pub mod ConstantProductAmm {
 13 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 14 |     use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 15 |     use starknet::{ContractAddress, get_caller_address, get_contract_address};
 16 |     use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
 17 |     use core::num::traits::Sqrt;
 18 | 
 19 |     #[storage]
 20 |     struct Storage {
 21 |         token0: IERC20Dispatcher,
 22 |         token1: IERC20Dispatcher,
 23 |         reserve0: u256,
 24 |         reserve1: u256,
 25 |         total_supply: u256,
 26 |         balance_of: Map::<ContractAddress, u256>,
 27 |         // Fee 0 - 1000 (0% - 100%, 1 decimal places)
 28 |         // E.g. 3 = 0.3%
 29 |         fee: u16,
 30 |     }
 31 | 
 32 |     #[constructor]
 33 |     fn constructor(
 34 |         ref self: ContractState, token0: ContractAddress, token1: ContractAddress, fee: u16
 35 |     ) {
 36 |         // assert(fee <= 1000, 'fee > 1000');
 37 |         self.token0.write(IERC20Dispatcher { contract_address: token0 });
 38 |         self.token1.write(IERC20Dispatcher { contract_address: token1 });
 39 |         self.fee.write(fee);
 40 |     }
 41 | 
 42 |     #[generate_trait]
 43 |     impl PrivateFunctions of PrivateFunctionsTrait {
 44 |         fn _mint(ref self: ContractState, to: ContractAddress, amount: u256) {
 45 |             self.balance_of.write(to, self.balance_of.read(to) + amount);
 46 |             self.total_supply.write(self.total_supply.read() + amount);
 47 |         }
 48 | 
 49 |         fn _burn(ref self: ContractState, from: ContractAddress, amount: u256) {
 50 |             self.balance_of.write(from, self.balance_of.read(from) - amount);
 51 |             self.total_supply.write(self.total_supply.read() - amount);
 52 |         }
 53 | 
 54 |         fn _update(ref self: ContractState, reserve0: u256, reserve1: u256) {
 55 |             self.reserve0.write(reserve0);
 56 |             self.reserve1.write(reserve1);
 57 |         }
 58 | 
 59 |         #[inline(always)]
 60 |         fn select_token(self: @ContractState, token: ContractAddress) -> bool {
 61 |             assert(
 62 |                 token == self.token0.read().contract_address
 63 |                     || token == self.token1.read().contract_address,
 64 |                 'invalid token'
 65 |             );
 66 |             token == self.token0.read().contract_address
 67 |         }
 68 | 
 69 |         #[inline(always)]
 70 |         fn min(x: u256, y: u256) -> u256 {
 71 |             if (x <= y) {
 72 |                 x
 73 |             } else {
 74 |                 y
 75 |             }
 76 |         }
 77 |     }
 78 | 
 79 |     #[abi(embed_v0)]
 80 |     impl ConstantProductAmm of super::IConstantProductAmm<ContractState> {
 81 |         fn swap(ref self: ContractState, token_in: ContractAddress, amount_in: u256) -> u256 {
 82 |             assert(amount_in > 0, 'amount in = 0');
 83 |             let is_token0: bool = self.select_token(token_in);
 84 | 
 85 |             let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (
 86 |                 self.token0.read(), self.token1.read()
 87 |             );
 88 |             let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), self.reserve1.read());
 89 |             let (
 90 |                 token_in, token_out, reserve_in, reserve_out
 91 |             ): (IERC20Dispatcher, IERC20Dispatcher, u256, u256) =
 92 |                 if (is_token0) {
 93 |                 (token0, token1, reserve0, reserve1)
 94 |             } else {
 95 |                 (token1, token0, reserve1, reserve0)
 96 |             };
 97 | 
 98 |             let caller = get_caller_address();
 99 |             let this = get_contract_address();
100 |             token_in.transfer_from(caller, this, amount_in);
101 | 
102 |             // How much dy for dx?
103 |             // xy = k
104 |             // (x + dx)(y - dy) = k
105 |             // y - dy = k / (x + dx)
106 |             // y - k / (x + dx) = dy
107 |             // y - xy / (x + dx) = dy
108 |             // (yx + ydx - xy) / (x + dx) = dy
109 |             // ydx / (x + dx) = dy
110 | 
111 |             let amount_in_with_fee = (amount_in * (1000 - self.fee.read().into()) / 1000);
112 |             let amount_out = (reserve_out * amount_in_with_fee) / (reserve_in + amount_in_with_fee);
113 | 
114 |             token_out.transfer(caller, amount_out);
115 | 
116 |             self._update(self.token0.read().balance_of(this), self.token1.read().balance_of(this));
117 |             amount_out
118 |         }
119 | 
120 |         fn add_liquidity(ref self: ContractState, amount0: u256, amount1: u256) -> u256 {
121 |             let caller = get_caller_address();
122 |             let this = get_contract_address();
123 |             let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (
124 |                 self.token0.read(), self.token1.read()
125 |             );
126 | 
127 |             token0.transfer_from(caller, this, amount0);
128 |             token1.transfer_from(caller, this, amount1);
129 | 
130 |             // How much dx, dy to add?
131 |             //
132 |             // xy = k
133 |             // (x + dx)(y + dy) = k'
134 |             //
135 |             // No price change, before and after adding liquidity
136 |             // x / y = (x + dx) / (y + dy)
137 |             //
138 |             // x(y + dy) = y(x + dx)
139 |             // x * dy = y * dx
140 |             //
141 |             // x / y = dx / dy
142 |             // dy = y / x * dx
143 | 
144 |             let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), self.reserve1.read());
145 |             if (reserve0 > 0 || reserve1 > 0) {
146 |                 assert(reserve0 * amount1 == reserve1 * amount0, 'x / y != dx / dy');
147 |             }
148 | 
149 |             // How many shares to mint?
150 |             //
151 |             // f(x, y) = value of liquidity
152 |             // We will define f(x, y) = sqrt(xy)
153 |             //
154 |             // L0 = f(x, y)
155 |             // L1 = f(x + dx, y + dy)
156 |             // T = total shares
157 |             // s = shares to mint
158 |             //
159 |             // Total shares should increase proportional to increase in liquidity
160 |             // L1 / L0 = (T + s) / T
161 |             //
162 |             // L1 * T = L0 * (T + s)
163 |             //
164 |             // (L1 - L0) * T / L0 = s
165 | 
166 |             // Claim
167 |             // (L1 - L0) / L0 = dx / x = dy / y
168 |             //
169 |             // Proof
170 |             // --- Equation 1 ---
171 |             // (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / sqrt(xy)
172 |             //
173 |             // dx / dy = x / y so replace dy = dx * y / x
174 |             //
175 |             // --- Equation 2 ---
176 |             // Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / sqrt(xy)
177 |             //
178 |             // Multiply by sqrt(x) / sqrt(x)
179 |             // Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / sqrt(x^2y)
180 |             //            = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2))) / (sqrt(y)sqrt(x^2))
181 |             // sqrt(y) on top and bottom cancels out
182 |             //
183 |             // --- Equation 3 ---
184 |             // Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / sqrt(x^2)
185 |             // = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)
186 |             // = ((x + dx) - x) / x
187 |             // = dx / x
188 |             // Since dx / dy = x / y,
189 |             // dx / x = dy / y
190 |             //
191 |             // Finally
192 |             // (L1 - L0) / L0 = dx / x = dy / y
193 | 
194 |             let total_supply = self.total_supply.read();
195 |             let shares = if (total_supply == 0) {
196 |                 (amount0 * amount1).sqrt().into()
197 |             } else {
198 |                 PrivateFunctions::min(
199 |                     amount0 * total_supply / reserve0, amount1 * total_supply / reserve1
200 |                 )
201 |             };
202 |             assert(shares > 0, 'shares = 0');
203 |             self._mint(caller, shares);
204 | 
205 |             self._update(self.token0.read().balance_of(this), self.token1.read().balance_of(this));
206 |             shares
207 |         }
208 | 
209 |         fn remove_liquidity(ref self: ContractState, shares: u256) -> (u256, u256) {
210 |             let caller = get_caller_address();
211 |             let this = get_contract_address();
212 |             let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (
213 |                 self.token0.read(), self.token1.read()
214 |             );
215 | 
216 |             // Claim
217 |             // dx, dy = amount of liquidity to remove
218 |             // dx = s / T * x
219 |             // dy = s / T * y
220 |             //
221 |             // Proof
222 |             // Let's find dx, dy such that
223 |             // v / L = s / T
224 |             //
225 |             // where
226 |             // v = f(dx, dy) = sqrt(dxdy)
227 |             // L = total liquidity = sqrt(xy)
228 |             // s = shares
229 |             // T = total supply
230 |             //
231 |             // --- Equation 1 ---
232 |             // v = s / T * L
233 |             // sqrt(dxdy) = s / T * sqrt(xy)
234 |             //
235 |             // Amount of liquidity to remove must not change price so
236 |             // dx / dy = x / y
237 |             //
238 |             // replace dy = dx * y / x
239 |             // sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)
240 |             //
241 |             // Divide both sides of Equation 1 with sqrt(y / x)
242 |             // dx = s / T * sqrt(xy) / sqrt(y / x)
243 |             // = s / T * sqrt(x^2) = s / T * x
244 |             //
245 |             // Likewise
246 |             // dy = s / T * y
247 | 
248 |             // bal0 >= reserve0
249 |             // bal1 >= reserve1
250 |             let (bal0, bal1): (u256, u256) = (token0.balance_of(this), token1.balance_of(this));
251 | 
252 |             let total_supply = self.total_supply.read();
253 |             let (amount0, amount1): (u256, u256) = (
254 |                 (shares * bal0) / total_supply, (shares * bal1) / total_supply
255 |             );
256 |             assert(amount0 > 0 && amount1 > 0, 'amount0 or amount1 = 0');
257 | 
258 |             self._burn(caller, shares);
259 |             self._update(bal0 - amount0, bal1 - amount1);
260 | 
261 |             token0.transfer(caller, amount0);
262 |             token1.transfer(caller, amount1);
263 |             (amount0, amount1)
264 |         }
265 |     }
266 | }
267 | // [!endregion ConstantProductAmmContract]
268 | 
269 | 
270 | 


--------------------------------------------------------------------------------
/listings/applications/constant_product_amm/src/lib.cairo:
--------------------------------------------------------------------------------
1 | pub mod contracts;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/applications/constant_product_amm/src/tests.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::contract]
  2 | pub mod ERC20Token {
  3 |     use openzeppelin::token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
  4 |     use starknet::ContractAddress;
  5 | 
  6 |     component!(path: ERC20Component, storage: erc20, event: ERC20Event);
  7 | 
  8 |     // ERC20 Mixin
  9 |     #[abi(embed_v0)]
 10 |     impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
 11 |     impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;
 12 | 
 13 |     #[storage]
 14 |     struct Storage {
 15 |         #[substorage(v0)]
 16 |         erc20: ERC20Component::Storage
 17 |     }
 18 | 
 19 |     #[event]
 20 |     #[derive(Drop, starknet::Event)]
 21 |     enum Event {
 22 |         #[flat]
 23 |         ERC20Event: ERC20Component::Event
 24 |     }
 25 | 
 26 |     #[constructor]
 27 |     fn constructor(
 28 |         ref self: ContractState,
 29 |         initial_supply: u256,
 30 |         recipient: ContractAddress,
 31 |         name: ByteArray,
 32 |         symbol: ByteArray
 33 |     ) {
 34 |         self.erc20.initializer(name, symbol);
 35 |         self.erc20.mint(recipient, initial_supply);
 36 |     }
 37 | }
 38 | // Wait for OZ #953 fix
 39 | // mod tests {
 40 | //     use super::ERC20Token;
 41 | //     use openzeppelin::token::erc20::{interface::IERC20Dispatcher,
 42 | //     interface::IERC20DispatcherTrait};
 43 | //     use openzeppelin::tests::utils;
 44 | //     use openzeppelin::utils::serde::SerializedAppend;
 45 | 
 46 | //     use constant_product_amm::contracts::{
 47 | //         ConstantProductAmm, IConstantProductAmmDispatcher, IConstantProductAmmDispatcherTrait
 48 | //     };
 49 | //     use starknet::{
 50 | //         ContractAddress, get_caller_address, get_contract_address, contract_address_const
 51 | //     };
 52 | //     use starknet::testing::set_contract_address;
 53 | 
 54 | //     const BANK: felt252 = 0x123;
 55 | //     const INITIAL_SUPPLY: u256 = 10_000;
 56 | 
 57 | //     #[derive(Drop, Copy)]
 58 | //     struct Deployment {
 59 | //         contract: IConstantProductAmmDispatcher,
 60 | //         token0: IERC20Dispatcher,
 61 | //         token1: IERC20Dispatcher
 62 | //     }
 63 | 
 64 | //     fn deploy_erc20(
 65 | //         name: felt252, symbol: felt252, recipient: ContractAddress, initial_supply: u256
 66 | //     ) -> (ContractAddress, IERC20Dispatcher) {
 67 | //         let mut calldata = array![];
 68 | //         calldata.append(18.into());
 69 | //         calldata.append_serde(initial_supply);
 70 | //         calldata.append_serde(recipient);
 71 | //         calldata.append_serde(name);
 72 | //         calldata.append_serde(symbol);
 73 | 
 74 | //         let address = utils::deploy(ERC20Token::TEST_CLASS_HASH, calldata);
 75 | //         (address, IERC20Dispatcher { contract_address: address })
 76 | //     }
 77 | 
 78 | //     fn setup() -> Deployment {
 79 | //         let recipient: ContractAddress = BANK.try_into().unwrap();
 80 | //         let (token0_address, token0) = deploy_erc20('Token0', 'T0', recipient, INITIAL_SUPPLY);
 81 | //         let (token1_address, token1) = deploy_erc20('Token1', 'T1', recipient, INITIAL_SUPPLY);
 82 | 
 83 | //         // 0.3% fee
 84 | //         let fee: u16 = 3;
 85 | 
 86 | //         let mut calldata: Array::<felt252> = array![];
 87 | //         calldata.append(token0_address.into());
 88 | //         calldata.append(token1_address.into());
 89 | //         calldata.append(fee.into());
 90 | 
 91 | //         let (contract_address, _) = starknet::syscalls::deploy_syscall(
 92 | //             ConstantProductAmm::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
 93 | //         )
 94 | //             .unwrap();
 95 | //         // Or with OpenZeppelin helper:
 96 | //         // let contract_address = utils::deploy(ConstantProductAmm::TEST_CLASS_HASH, calldata);
 97 | //         Deployment { contract: IConstantProductAmmDispatcher { contract_address }, token0, token1
 98 | //         }
 99 | //     }
100 | 
101 | //     fn add_liquidity(deploy: Deployment, amount: u256) -> u256 {
102 | //         assert(amount <= INITIAL_SUPPLY, 'amount > INITIAL_SUPPLY');
103 | 
104 | //         let provider: ContractAddress = BANK.try_into().unwrap();
105 | //         set_contract_address(provider);
106 | 
107 | //         deploy.token0.approve(deploy.contract.contract_address, amount);
108 | //         deploy.token1.approve(deploy.contract.contract_address, amount);
109 | 
110 | //         deploy.contract.add_liquidity(amount, amount)
111 | //     }
112 | 
113 | //     #[test]
114 | //     #[available_gas(20000000)]
115 | //     fn should_deploy() {
116 | //         let deploy = setup();
117 | //         let bank: ContractAddress = BANK.try_into().unwrap();
118 | 
119 | //         assert(deploy.token0.balance_of(bank) == INITIAL_SUPPLY, 'Wrong balance token0');
120 | //         assert(deploy.token1.balance_of(bank) == INITIAL_SUPPLY, 'Wrong balance token1');
121 | //     }
122 | 
123 | //     #[test]
124 | //     #[available_gas(20000000)]
125 | //     fn should_add_liquidity() {
126 | //         let deploy = setup();
127 | //         let shares = add_liquidity(deploy, INITIAL_SUPPLY / 2);
128 | 
129 | //         let provider: ContractAddress = BANK.try_into().unwrap();
130 | //         assert(deploy.token0.balance_of(provider) == INITIAL_SUPPLY / 2, 'Wrong balance token0');
131 | //         assert(deploy.token1.balance_of(provider) == INITIAL_SUPPLY / 2, 'Wrong balance token1');
132 | //         assert(shares > 0, 'Wrong shares');
133 | //     }
134 | 
135 | //     #[test]
136 | //     #[available_gas(20000000)]
137 | //     fn should_remove_liquidity() {
138 | //         let deploy = setup();
139 | //         let shares = add_liquidity(deploy, INITIAL_SUPPLY / 2);
140 | //         let provider: ContractAddress = BANK.try_into().unwrap();
141 | 
142 | //         deploy.contract.remove_liquidity(shares);
143 | 
144 | //         assert(deploy.token0.balance_of(provider) == INITIAL_SUPPLY, 'Wrong balance token0');
145 | //         assert(deploy.token1.balance_of(provider) == INITIAL_SUPPLY, 'Wrong balance token1');
146 | //     }
147 | 
148 | //     #[test]
149 | //     #[available_gas(20000000)]
150 | //     fn should_swap() {
151 | //         let deploy = setup();
152 | //         let _shares = add_liquidity(deploy, INITIAL_SUPPLY / 2);
153 | 
154 | //         let provider: ContractAddress = BANK.try_into().unwrap();
155 | //         let user = contract_address_const::<0x1>();
156 | 
157 | //         // Provider send some token0 to user
158 | //         set_contract_address(provider);
159 | //         let amount = deploy.token0.balance_of(provider) / 2;
160 | //         deploy.token0.transfer(user, amount);
161 | 
162 | //         // user swap for token1 using AMM liquidity
163 | //         set_contract_address(user);
164 | //         deploy.token0.approve(deploy.contract.contract_address, amount);
165 | //         deploy.contract.swap(deploy.token0.contract_address, amount);
166 | //         let amount_token1_received = deploy.token1.balance_of(user);
167 | //         assert(amount_token1_received > 0, 'Swap: wrong balance token1');
168 | 
169 | //         // User can swap back token1 to token0
170 | //         // As each swap has a 0.3% fee, user will receive less token0
171 | //         deploy.token1.approve(deploy.contract.contract_address, amount_token1_received);
172 | //         deploy.contract.swap(deploy.token1.contract_address, amount_token1_received);
173 | //         let amount_token0_received = deploy.token0.balance_of(user);
174 | //         assert(amount_token0_received < amount, 'Swap: wrong balance token0');
175 | //     }
176 | // }
177 | 
178 | 
179 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | .snfoundry_cache/
3 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "crowdfunding"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [lib]
 7 | 
 8 | [dependencies]
 9 | starknet.workspace = true
10 | openzeppelin.workspace = true
11 | components.workspace = true
12 | 
13 | [dev-dependencies]
14 | assert_macros.workspace = true
15 | snforge_std.workspace = true
16 | 
17 | [scripts]
18 | test.workspace = true
19 | 
20 | [[target.starknet-contract]]
21 | build-external-contracts = ["openzeppelin_presets::erc20::ERC20Upgradeable"]
22 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/src/campaign.cairo:
--------------------------------------------------------------------------------
  1 | pub mod pledgeable;
  2 | 
  3 | // [!region contract]
  4 | use starknet::{ClassHash, ContractAddress};
  5 | 
  6 | #[derive(Drop, Serde)]
  7 | pub struct Details {
  8 |     pub canceled: bool,
  9 |     pub claimed: bool,
 10 |     pub creator: ContractAddress,
 11 |     pub description: ByteArray,
 12 |     pub end_time: u64,
 13 |     pub goal: u256,
 14 |     pub start_time: u64,
 15 |     pub title: ByteArray,
 16 |     pub token: ContractAddress,
 17 |     pub total_pledges: u256,
 18 | }
 19 | 
 20 | #[starknet::interface]
 21 | pub trait ICampaign<TContractState> {
 22 |     fn claim(ref self: TContractState);
 23 |     fn cancel(ref self: TContractState, reason: ByteArray);
 24 |     fn pledge(ref self: TContractState, amount: u256);
 25 |     fn get_pledge(self: @TContractState, pledger: ContractAddress) -> u256;
 26 |     fn get_pledgers(self: @TContractState) -> Array<ContractAddress>;
 27 |     fn get_details(self: @TContractState) -> Details;
 28 |     fn refund(ref self: TContractState, pledger: ContractAddress, reason: ByteArray);
 29 |     fn upgrade(ref self: TContractState, impl_hash: ClassHash, new_end_time: Option<u64>);
 30 |     fn unpledge(ref self: TContractState, reason: ByteArray);
 31 | }
 32 | 
 33 | #[starknet::contract]
 34 | pub mod Campaign {
 35 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 36 |     use components::ownable::ownable_component::OwnableInternalTrait;
 37 |     use core::num::traits::Zero;
 38 |     use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 39 |     use starknet::{
 40 |         ClassHash, ContractAddress, SyscallResultTrait, get_block_timestamp, get_caller_address,
 41 |         get_contract_address
 42 |     };
 43 |     use components::ownable::ownable_component;
 44 |     use super::pledgeable::pledgeable_component;
 45 |     use super::Details;
 46 | 
 47 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
 48 |     component!(path: pledgeable_component, storage: pledges, event: PledgeableEvent);
 49 | 
 50 |     #[abi(embed_v0)]
 51 |     pub impl OwnableImpl = ownable_component::Ownable<ContractState>;
 52 |     impl OwnableInternalImpl = ownable_component::OwnableInternalImpl<ContractState>;
 53 |     #[abi(embed_v0)]
 54 |     impl PledgeableImpl = pledgeable_component::Pledgeable<ContractState>;
 55 | 
 56 |     #[storage]
 57 |     struct Storage {
 58 |         canceled: bool,
 59 |         claimed: bool,
 60 |         creator: ContractAddress,
 61 |         description: ByteArray,
 62 |         end_time: u64,
 63 |         goal: u256,
 64 |         #[substorage(v0)]
 65 |         ownable: ownable_component::Storage,
 66 |         #[substorage(v0)]
 67 |         pledges: pledgeable_component::Storage,
 68 |         start_time: u64,
 69 |         title: ByteArray,
 70 |         token: IERC20Dispatcher,
 71 |     }
 72 | 
 73 |     #[event]
 74 |     #[derive(Drop, starknet::Event)]
 75 |     pub enum Event {
 76 |         Claimed: Claimed,
 77 |         Canceled: Canceled,
 78 |         #[flat]
 79 |         OwnableEvent: ownable_component::Event,
 80 |         PledgeableEvent: pledgeable_component::Event,
 81 |         PledgeMade: PledgeMade,
 82 |         Refunded: Refunded,
 83 |         RefundedAll: RefundedAll,
 84 |         Unpledged: Unpledged,
 85 |         Upgraded: Upgraded,
 86 |     }
 87 | 
 88 |     #[derive(Drop, starknet::Event)]
 89 |     pub struct Canceled {
 90 |         pub reason: ByteArray,
 91 |     }
 92 | 
 93 |     #[derive(Drop, starknet::Event)]
 94 |     pub struct Claimed {
 95 |         pub amount: u256,
 96 |     }
 97 | 
 98 |     #[derive(Drop, starknet::Event)]
 99 |     pub struct PledgeMade {
100 |         #[key]
101 |         pub pledger: ContractAddress,
102 |         pub amount: u256,
103 |     }
104 | 
105 |     #[derive(Drop, starknet::Event)]
106 |     pub struct Refunded {
107 |         #[key]
108 |         pub pledger: ContractAddress,
109 |         pub amount: u256,
110 |         pub reason: ByteArray,
111 |     }
112 | 
113 |     #[derive(Drop, starknet::Event)]
114 |     pub struct RefundedAll {
115 |         pub reason: ByteArray,
116 |     }
117 | 
118 |     #[derive(Drop, starknet::Event)]
119 |     pub struct Unpledged {
120 |         #[key]
121 |         pub pledger: ContractAddress,
122 |         pub amount: u256,
123 |         pub reason: ByteArray,
124 |     }
125 | 
126 |     #[derive(Drop, starknet::Event)]
127 |     pub struct Upgraded {
128 |         pub implementation: ClassHash
129 |     }
130 | 
131 |     pub mod Errors {
132 |         pub const CANCELED: felt252 = 'Campaign canceled';
133 |         pub const CLAIMED: felt252 = 'Campaign already claimed';
134 |         pub const CLASS_HASH_ZERO: felt252 = 'Class hash zero';
135 |         pub const CREATOR_ZERO: felt252 = 'Creator address zero';
136 |         pub const ENDED: felt252 = 'Campaign already ended';
137 |         pub const END_BEFORE_NOW: felt252 = 'End time < now';
138 |         pub const END_BEFORE_START: felt252 = 'End time < start time';
139 |         pub const END_BIGGER_THAN_MAX: felt252 = 'End time > max duration';
140 |         pub const NOTHING_TO_REFUND: felt252 = 'Nothing to refund';
141 |         pub const NOTHING_TO_UNPLEDGE: felt252 = 'Nothing to unpledge';
142 |         pub const NOT_CREATOR: felt252 = 'Not creator';
143 |         pub const NOT_STARTED: felt252 = 'Campaign not started';
144 |         pub const PLEDGES_LOCKED: felt252 = 'Goal reached, pledges locked';
145 |         pub const START_TIME_IN_PAST: felt252 = 'Start time < now';
146 |         pub const STILL_ACTIVE: felt252 = 'Campaign not ended';
147 |         pub const GOAL_NOT_REACHED: felt252 = 'Goal not reached';
148 |         pub const TITLE_EMPTY: felt252 = 'Title empty';
149 |         pub const TRANSFER_FAILED: felt252 = 'Transfer failed';
150 |         pub const ZERO_ADDRESS_CALLER: felt252 = 'Caller address zero';
151 |         pub const ZERO_ADDRESS_PLEDGER: felt252 = 'Pledger address zero';
152 |         pub const ZERO_ADDRESS_TOKEN: felt252 = 'Token address zero';
153 |         pub const ZERO_DONATION: felt252 = 'Donation must be > 0';
154 |         pub const ZERO_GOAL: felt252 = 'Goal must be > 0';
155 |         pub const ZERO_PLEDGES: felt252 = 'No pledges to claim';
156 |     }
157 | 
158 |     const NINETY_DAYS: u64 = 90 * 24 * 60 * 60;
159 | 
160 |     #[constructor]
161 |     fn constructor(
162 |         ref self: ContractState,
163 |         creator: ContractAddress,
164 |         title: ByteArray,
165 |         description: ByteArray,
166 |         goal: u256,
167 |         start_time: u64,
168 |         end_time: u64,
169 |         token_address: ContractAddress,
170 |     ) {
171 |         assert(creator.is_non_zero(), Errors::CREATOR_ZERO);
172 |         assert(title.len() > 0, Errors::TITLE_EMPTY);
173 |         assert(goal > 0, Errors::ZERO_GOAL);
174 |         assert(start_time >= get_block_timestamp(), Errors::START_TIME_IN_PAST);
175 |         assert(end_time >= start_time, Errors::END_BEFORE_START);
176 |         assert(end_time <= get_block_timestamp() + NINETY_DAYS, Errors::END_BIGGER_THAN_MAX);
177 |         assert(token_address.is_non_zero(), Errors::ZERO_ADDRESS_TOKEN);
178 | 
179 |         self.creator.write(creator);
180 |         self.title.write(title);
181 |         self.goal.write(goal);
182 |         self.description.write(description);
183 |         self.start_time.write(start_time);
184 |         self.end_time.write(end_time);
185 |         self.token.write(IERC20Dispatcher { contract_address: token_address });
186 |         self.ownable._init(get_caller_address());
187 |     }
188 | 
189 |     #[abi(embed_v0)]
190 |     impl Campaign of super::ICampaign<ContractState> {
191 |         fn cancel(ref self: ContractState, reason: ByteArray) {
192 |             self._assert_only_creator();
193 |             assert(!self.canceled.read(), Errors::CANCELED);
194 |             assert(!self.claimed.read(), Errors::CLAIMED);
195 | 
196 |             self.canceled.write(true);
197 | 
198 |             self._refund_all(reason.clone());
199 | 
200 |             self.emit(Event::Canceled(Canceled { reason }));
201 |         }
202 | 
203 |         /// Sends the funds to the campaign creator.
204 |         /// It leaves the pledge data intact as a testament to campaign success
205 |         fn claim(ref self: ContractState) {
206 |             self._assert_only_creator();
207 |             assert(self._is_started(), Errors::NOT_STARTED);
208 |             assert(self._is_ended(), Errors::STILL_ACTIVE);
209 |             assert(!self.claimed.read(), Errors::CLAIMED);
210 |             assert(self._is_goal_reached(), Errors::GOAL_NOT_REACHED);
211 |             // no need to check if canceled; if it was, then the goal wouldn't have been reached
212 | 
213 |             let this = get_contract_address();
214 |             let token = self.token.read();
215 |             let amount = token.balance_of(this);
216 |             assert(amount > 0, Errors::ZERO_PLEDGES);
217 | 
218 |             self.claimed.write(true);
219 | 
220 |             let owner = get_caller_address();
221 |             let success = token.transfer(owner, amount);
222 |             assert(success, Errors::TRANSFER_FAILED);
223 | 
224 |             self.emit(Event::Claimed(Claimed { amount }));
225 |         }
226 | 
227 |         fn get_details(self: @ContractState) -> Details {
228 |             Details {
229 |                 canceled: self.canceled.read(),
230 |                 claimed: self.claimed.read(),
231 |                 creator: self.creator.read(),
232 |                 description: self.description.read(),
233 |                 end_time: self.end_time.read(),
234 |                 goal: self.goal.read(),
235 |                 start_time: self.start_time.read(),
236 |                 title: self.title.read(),
237 |                 token: self.token.read().contract_address,
238 |                 total_pledges: self.pledges.get_total(),
239 |             }
240 |         }
241 | 
242 |         fn get_pledge(self: @ContractState, pledger: ContractAddress) -> u256 {
243 |             self.pledges.get(pledger)
244 |         }
245 | 
246 |         fn get_pledgers(self: @ContractState) -> Array<ContractAddress> {
247 |             self.pledges.array()
248 |         }
249 | 
250 |         fn pledge(ref self: ContractState, amount: u256) {
251 |             assert(self._is_started(), Errors::NOT_STARTED);
252 |             assert(!self._is_ended(), Errors::ENDED);
253 |             assert(!self.canceled.read(), Errors::CANCELED);
254 |             assert(amount > 0, Errors::ZERO_DONATION);
255 | 
256 |             let pledger = get_caller_address();
257 |             let this = get_contract_address();
258 |             let success = self.token.read().transfer_from(pledger, this, amount);
259 |             assert(success, Errors::TRANSFER_FAILED);
260 | 
261 |             self.pledges.add(pledger, amount);
262 | 
263 |             self.emit(Event::PledgeMade(PledgeMade { pledger, amount }));
264 |         }
265 | 
266 |         fn refund(ref self: ContractState, pledger: ContractAddress, reason: ByteArray) {
267 |             self._assert_only_creator();
268 |             assert(self._is_started(), Errors::NOT_STARTED);
269 |             assert(!self.claimed.read(), Errors::CLAIMED);
270 |             assert(!self.canceled.read(), Errors::CANCELED);
271 |             assert(pledger.is_non_zero(), Errors::ZERO_ADDRESS_PLEDGER);
272 |             assert(self.pledges.get(pledger) != 0, Errors::NOTHING_TO_REFUND);
273 | 
274 |             let amount = self._refund(pledger);
275 | 
276 |             self.emit(Event::Refunded(Refunded { pledger, amount, reason }))
277 |         }
278 | 
279 |         fn unpledge(ref self: ContractState, reason: ByteArray) {
280 |             assert(self._is_started(), Errors::NOT_STARTED);
281 |             assert(!self._is_goal_reached(), Errors::PLEDGES_LOCKED);
282 |             assert(self.pledges.get(get_caller_address()) != 0, Errors::NOTHING_TO_UNPLEDGE);
283 | 
284 |             let pledger = get_caller_address();
285 |             let amount = self._refund(pledger);
286 | 
287 |             self.emit(Event::Unpledged(Unpledged { pledger, amount, reason }));
288 |         }
289 | 
290 |         fn upgrade(ref self: ContractState, impl_hash: ClassHash, new_end_time: Option<u64>) {
291 |             self.ownable._assert_only_owner();
292 |             assert(impl_hash.is_non_zero(), Errors::CLASS_HASH_ZERO);
293 | 
294 |             // only active campaigns have pledges to refund and an end time to update
295 |             if self._is_started() {
296 |                 if let Option::Some(end_time) = new_end_time {
297 |                     assert(end_time >= get_block_timestamp(), Errors::END_BEFORE_NOW);
298 |                     assert(
299 |                         end_time <= get_block_timestamp() + NINETY_DAYS, Errors::END_BIGGER_THAN_MAX
300 |                     );
301 |                     self.end_time.write(end_time);
302 |                 };
303 |                 self._refund_all("contract upgraded");
304 |             }
305 | 
306 |             starknet::syscalls::replace_class_syscall(impl_hash).unwrap_syscall();
307 | 
308 |             self.emit(Event::Upgraded(Upgraded { implementation: impl_hash }));
309 |         }
310 |     }
311 | 
312 |     #[generate_trait]
313 |     impl CampaignInternalImpl of CampaignInternalTrait {
314 |         fn _assert_only_creator(self: @ContractState) {
315 |             let caller = get_caller_address();
316 |             assert(caller.is_non_zero(), Errors::ZERO_ADDRESS_CALLER);
317 |             assert(caller == self.creator.read(), Errors::NOT_CREATOR);
318 |         }
319 | 
320 |         fn _is_ended(self: @ContractState) -> bool {
321 |             get_block_timestamp() >= self.end_time.read()
322 |         }
323 | 
324 |         fn _is_goal_reached(self: @ContractState) -> bool {
325 |             self.pledges.get_total() >= self.goal.read()
326 |         }
327 | 
328 |         fn _is_started(self: @ContractState) -> bool {
329 |             get_block_timestamp() >= self.start_time.read()
330 |         }
331 | 
332 |         #[inline(always)]
333 |         fn _refund(ref self: ContractState, pledger: ContractAddress) -> u256 {
334 |             let amount = self.pledges.remove(pledger);
335 | 
336 |             let success = self.token.read().transfer(pledger, amount);
337 |             assert(success, Errors::TRANSFER_FAILED);
338 | 
339 |             amount
340 |         }
341 | 
342 |         fn _refund_all(ref self: ContractState, reason: ByteArray) {
343 |             let mut pledges = self.pledges.array();
344 |             while let Option::Some(pledger) = pledges.pop_front() {
345 |                 self._refund(pledger);
346 |             };
347 |             self.emit(Event::RefundedAll(RefundedAll { reason }));
348 |         }
349 |     }
350 | }
351 | // [!endregion contract]
352 | 
353 | 
354 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/src/campaign/pledgeable.cairo:
--------------------------------------------------------------------------------
  1 | // [!region component]
  2 | use starknet::ContractAddress;
  3 | 
  4 | #[starknet::interface]
  5 | pub trait IPledgeable<TContractState> {
  6 |     fn add(ref self: TContractState, pledger: ContractAddress, amount: u256);
  7 |     fn get(self: @TContractState, pledger: ContractAddress) -> u256;
  8 |     fn get_pledger_count(self: @TContractState) -> u32;
  9 |     fn array(self: @TContractState) -> Array<ContractAddress>;
 10 |     fn get_total(self: @TContractState) -> u256;
 11 |     fn remove(ref self: TContractState, pledger: ContractAddress) -> u256;
 12 | }
 13 | 
 14 | #[starknet::component]
 15 | pub mod pledgeable_component {
 16 |     use core::array::ArrayTrait;
 17 |     use core::num::traits::Zero;
 18 |     use starknet::ContractAddress;
 19 |     use starknet::storage::{
 20 |         Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
 21 |         StoragePointerWriteAccess
 22 |     };
 23 | 
 24 |     #[storage]
 25 |     pub struct Storage {
 26 |         index_to_pledger: Map<u32, ContractAddress>,
 27 |         pledger_to_amount: Map<ContractAddress, u256>,
 28 |         pledger_count: u32,
 29 |         total_amount: u256,
 30 |     }
 31 | 
 32 |     #[event]
 33 |     #[derive(Drop, starknet::Event)]
 34 |     pub enum Event {}
 35 | 
 36 |     mod Errors {
 37 |         pub const INCONSISTENT_STATE: felt252 = 'Non-indexed pledger found';
 38 |     }
 39 | 
 40 |     #[embeddable_as(Pledgeable)]
 41 |     pub impl PledgeableImpl<
 42 |         TContractState, +HasComponent<TContractState>
 43 |     > of super::IPledgeable<ComponentState<TContractState>> {
 44 |         fn add(ref self: ComponentState<TContractState>, pledger: ContractAddress, amount: u256) {
 45 |             let old_amount: u256 = self.pledger_to_amount.read(pledger);
 46 | 
 47 |             if old_amount == 0 {
 48 |                 let index = self.pledger_count.read();
 49 |                 self.index_to_pledger.write(index, pledger);
 50 |                 self.pledger_count.write(index + 1);
 51 |             }
 52 | 
 53 |             self.pledger_to_amount.write(pledger, old_amount + amount);
 54 |             self.total_amount.write(self.total_amount.read() + amount);
 55 |         }
 56 | 
 57 |         fn get(self: @ComponentState<TContractState>, pledger: ContractAddress) -> u256 {
 58 |             self.pledger_to_amount.read(pledger)
 59 |         }
 60 | 
 61 |         fn get_pledger_count(self: @ComponentState<TContractState>) -> u32 {
 62 |             self.pledger_count.read()
 63 |         }
 64 | 
 65 |         fn array(self: @ComponentState<TContractState>) -> Array<ContractAddress> {
 66 |             let mut result = array![];
 67 | 
 68 |             let mut index = self.pledger_count.read();
 69 |             while index != 0 {
 70 |                 index -= 1;
 71 |                 let pledger = self.index_to_pledger.read(index);
 72 |                 result.append(pledger);
 73 |             };
 74 | 
 75 |             result
 76 |         }
 77 | 
 78 |         fn get_total(self: @ComponentState<TContractState>) -> u256 {
 79 |             self.total_amount.read()
 80 |         }
 81 | 
 82 |         fn remove(ref self: ComponentState<TContractState>, pledger: ContractAddress) -> u256 {
 83 |             let amount: u256 = self.pledger_to_amount.read(pledger);
 84 | 
 85 |             // check if the pledge even exists
 86 |             if amount == 0 {
 87 |                 return 0;
 88 |             }
 89 | 
 90 |             let last_index = self.pledger_count.read() - 1;
 91 | 
 92 |             // if there are other pledgers, we need to update our indices
 93 |             if last_index != 0 {
 94 |                 let mut pledger_index = last_index;
 95 |                 loop {
 96 |                     if self.index_to_pledger.read(pledger_index) == pledger {
 97 |                         break;
 98 |                     }
 99 |                     // if pledger_to_amount contains a pledger, then so does index_to_pledger
100 |                     // thus this will never underflow
101 |                     pledger_index -= 1;
102 |                 };
103 | 
104 |                 self.index_to_pledger.write(pledger_index, self.index_to_pledger.read(last_index));
105 |             }
106 | 
107 |             // last_index == new pledger count
108 |             self.pledger_count.write(last_index);
109 |             self.pledger_to_amount.write(pledger, 0);
110 |             self.index_to_pledger.write(last_index, Zero::zero());
111 | 
112 |             self.total_amount.write(self.total_amount.read() - amount);
113 | 
114 |             amount
115 |         }
116 |     }
117 | }
118 | // [!endregion component]
119 | 
120 | #[cfg(test)]
121 | mod tests {
122 |     #[starknet::contract]
123 |     mod MockContract {
124 |         use super::super::pledgeable_component;
125 | 
126 |         component!(path: pledgeable_component, storage: pledges, event: PledgeableEvent);
127 | 
128 |         #[storage]
129 |         struct Storage {
130 |             #[substorage(v0)]
131 |             pledges: pledgeable_component::Storage,
132 |         }
133 | 
134 |         #[event]
135 |         #[derive(Drop, starknet::Event)]
136 |         enum Event {
137 |             PledgeableEvent: pledgeable_component::Event
138 |         }
139 | 
140 |         #[abi(embed_v0)]
141 |         impl Pledgeable = pledgeable_component::Pledgeable<ContractState>;
142 |     }
143 | 
144 |     use super::pledgeable_component;
145 |     use super::pledgeable_component::PledgeableImpl;
146 |     use starknet::{ContractAddress, contract_address_const};
147 |     use core::num::traits::Zero;
148 | 
149 |     type TestingState = pledgeable_component::ComponentState<MockContract::ContractState>;
150 | 
151 |     // You can derive even `Default` on this type alias
152 |     impl TestingStateDefault of Default<TestingState> {
153 |         fn default() -> TestingState {
154 |             pledgeable_component::component_state_for_testing()
155 |         }
156 |     }
157 | 
158 |     #[test]
159 |     fn test_add() {
160 |         let mut pledgeable: TestingState = Default::default();
161 |         let pledger_1 = contract_address_const::<'pledger_1'>();
162 |         let pledger_2 = contract_address_const::<'pledger_2'>();
163 | 
164 |         assert_eq!(pledgeable.get_pledger_count(), 0);
165 |         assert_eq!(pledgeable.get_total(), 0);
166 |         assert_eq!(pledgeable.get(pledger_1), 0);
167 |         assert_eq!(pledgeable.get(pledger_2), 0);
168 | 
169 |         // 1st pledge
170 |         pledgeable.add(pledger_1, 1000);
171 | 
172 |         assert_eq!(pledgeable.get_pledger_count(), 1);
173 |         assert_eq!(pledgeable.get_total(), 1000);
174 |         assert_eq!(pledgeable.get(pledger_1), 1000);
175 |         assert_eq!(pledgeable.get(pledger_2), 0);
176 | 
177 |         // 2nd pledge should be added onto 1st
178 |         pledgeable.add(pledger_1, 1000);
179 | 
180 |         assert_eq!(pledgeable.get_pledger_count(), 1);
181 |         assert_eq!(pledgeable.get_total(), 2000);
182 |         assert_eq!(pledgeable.get(pledger_1), 2000);
183 |         assert_eq!(pledgeable.get(pledger_2), 0);
184 | 
185 |         // different pledger stored separately
186 |         pledgeable.add(pledger_2, 500);
187 | 
188 |         assert_eq!(pledgeable.get_pledger_count(), 2);
189 |         assert_eq!(pledgeable.get_total(), 2500);
190 |         assert_eq!(pledgeable.get(pledger_1), 2000);
191 |         assert_eq!(pledgeable.get(pledger_2), 500);
192 |     }
193 | 
194 |     #[test]
195 |     fn test_add_1000_pledgers() {
196 |         let mut pledgeable: TestingState = Default::default();
197 | 
198 |         // set up 1000 pledgers
199 |         let expected_pledger_count: u32 = 1000;
200 |         let mut expected_total: u256 = 0; // actual value set up in the while loop
201 |         let mut pledgers: Array::<(ContractAddress, u256)> = array![];
202 | 
203 |         let mut i: felt252 = expected_pledger_count.into();
204 |         while i != 0 {
205 |             let pledger: ContractAddress = i.try_into().unwrap();
206 |             let amount: u256 = i.into() * 100;
207 |             pledgeable.add(pledger, amount);
208 |             pledgers.append((pledger, amount));
209 |             expected_total += amount;
210 |             i -= 1;
211 |         };
212 | 
213 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
214 |         assert_eq!(pledgeable.get_total(), expected_total);
215 | 
216 |         while let Option::Some((pledger, expected_amount)) = pledgers.pop_front() {
217 |             assert_eq!(pledgeable.get(pledger), expected_amount);
218 |         }
219 |     }
220 | 
221 |     #[test]
222 |     fn test_add_update_first_of_1000_pledgers() {
223 |         let mut pledgeable: TestingState = Default::default();
224 | 
225 |         let expected_pledger_count: u32 = 1000;
226 |         let mut expected_total: u256 = 0;
227 | 
228 |         // set up 1000 pledgers
229 |         let mut i: felt252 = expected_pledger_count.into();
230 |         let first_pledger: ContractAddress = i.try_into().unwrap();
231 |         let first_amount: u256 = i.into() * 100;
232 |         pledgeable.add(first_pledger, first_amount);
233 |         expected_total += first_amount;
234 | 
235 |         i -= 1;
236 |         while i != 0 {
237 |             let pledger: ContractAddress = i.try_into().unwrap();
238 |             let amount: u256 = i.into() * 100;
239 |             pledgeable.add(pledger, amount);
240 |             expected_total += amount;
241 |             i -= 1;
242 |         };
243 | 
244 |         // first pledger makes another pledge
245 |         pledgeable.add(first_pledger, 2000);
246 |         expected_total += 2000;
247 |         let expected_amount = first_amount + 2000;
248 | 
249 |         let amount = pledgeable.get(first_pledger);
250 |         assert_eq!(amount, expected_amount);
251 |         assert_eq!(pledgeable.get_total(), expected_total);
252 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
253 |     }
254 | 
255 |     #[test]
256 |     fn test_add_update_middle_of_1000_pledgers() {
257 |         let mut pledgeable: TestingState = Default::default();
258 | 
259 |         let expected_pledger_count: u32 = 1000;
260 |         let mut expected_total: u256 = 0;
261 | 
262 |         // set up 1000 pledgers
263 |         let mut middle_pledger: ContractAddress = Zero::zero();
264 |         let mut middle_amount = 0;
265 | 
266 |         let mut i: felt252 = 1000;
267 |         while i != 0 {
268 |             let pledger: ContractAddress = i.try_into().unwrap();
269 |             let amount: u256 = i.into() * 100;
270 |             pledgeable.add(pledger, amount);
271 |             expected_total += amount;
272 | 
273 |             if i == 500 {
274 |                 middle_pledger = pledger;
275 |                 middle_amount = amount;
276 |             }
277 | 
278 |             i -= 1;
279 |         };
280 | 
281 |         // middle pledger makes another pledge
282 |         pledgeable.add(middle_pledger, 2000);
283 |         expected_total += 2000;
284 |         let expected_amount = middle_amount + 2000;
285 | 
286 |         let amount = pledgeable.get(middle_pledger);
287 |         assert_eq!(amount, expected_amount);
288 |         assert_eq!(pledgeable.get_total(), expected_total);
289 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
290 |     }
291 | 
292 |     #[test]
293 |     fn test_add_update_last_of_1000_pledgers() {
294 |         let mut pledgeable: TestingState = Default::default();
295 | 
296 |         let expected_pledger_count: u32 = 1000;
297 |         let mut expected_total: u256 = 0;
298 | 
299 |         // set up 1000 pledgers
300 |         let mut i: felt252 = 1000;
301 |         // remember last pledger, add it after while loop
302 |         let last_pledger: ContractAddress = i.try_into().unwrap();
303 |         let last_amount = 100000;
304 | 
305 |         i -= 1; // leave place for the last pledger
306 |         while i != 0 {
307 |             let pledger: ContractAddress = i.try_into().unwrap();
308 |             let amount: u256 = i.into() * 100;
309 |             pledgeable.add(pledger, amount);
310 |             expected_total += amount;
311 |             i -= 1;
312 |         };
313 |         // add last pledger
314 |         pledgeable.add(last_pledger, last_amount);
315 |         expected_total += last_amount;
316 | 
317 |         // last pledger makes another pledge
318 |         pledgeable.add(last_pledger, 2000);
319 |         expected_total += 2000;
320 |         let expected_amount = last_amount + 2000;
321 | 
322 |         let amount = pledgeable.get(last_pledger);
323 |         assert_eq!(amount, expected_amount);
324 |         assert_eq!(pledgeable.get_total(), expected_total);
325 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
326 |     }
327 | 
328 |     #[test]
329 |     fn test_remove() {
330 |         let mut pledgeable: TestingState = Default::default();
331 |         let pledger_1 = contract_address_const::<'pledger_1'>();
332 |         let pledger_2 = contract_address_const::<'pledger_2'>();
333 |         let pledger_3 = contract_address_const::<'pledger_3'>();
334 | 
335 |         pledgeable.add(pledger_1, 2000);
336 |         pledgeable.add(pledger_2, 3000);
337 |         // pledger_3 not added
338 | 
339 |         assert_eq!(pledgeable.get_pledger_count(), 2);
340 |         assert_eq!(pledgeable.get_total(), 5000);
341 |         assert_eq!(pledgeable.get(pledger_1), 2000);
342 |         assert_eq!(pledgeable.get(pledger_2), 3000);
343 |         assert_eq!(pledgeable.get(pledger_3), 0);
344 | 
345 |         let amount = pledgeable.remove(pledger_1);
346 | 
347 |         assert_eq!(amount, 2000);
348 |         assert_eq!(pledgeable.get_pledger_count(), 1);
349 |         assert_eq!(pledgeable.get_total(), 3000);
350 |         assert_eq!(pledgeable.get(pledger_1), 0);
351 |         assert_eq!(pledgeable.get(pledger_2), 3000);
352 |         assert_eq!(pledgeable.get(pledger_3), 0);
353 | 
354 |         let amount = pledgeable.remove(pledger_2);
355 | 
356 |         assert_eq!(amount, 3000);
357 |         assert_eq!(pledgeable.get_pledger_count(), 0);
358 |         assert_eq!(pledgeable.get_total(), 0);
359 |         assert_eq!(pledgeable.get(pledger_1), 0);
360 |         assert_eq!(pledgeable.get(pledger_2), 0);
361 |         assert_eq!(pledgeable.get(pledger_3), 0);
362 | 
363 |         // pledger_3 not added, so this should do nothing and return 0
364 |         let amount = pledgeable.remove(pledger_3);
365 | 
366 |         assert_eq!(amount, 0);
367 |         assert_eq!(pledgeable.get_pledger_count(), 0);
368 |         assert_eq!(pledgeable.get_total(), 0);
369 |         assert_eq!(pledgeable.get(pledger_1), 0);
370 |         assert_eq!(pledgeable.get(pledger_2), 0);
371 |         assert_eq!(pledgeable.get(pledger_3), 0);
372 |     }
373 | 
374 |     #[test]
375 |     fn test_remove_first_of_1000_pledgers() {
376 |         let mut pledgeable: TestingState = Default::default();
377 | 
378 |         // set up 1000 pledgers
379 |         let expected_pledger_count: u32 = 1000;
380 |         let mut expected_total: u256 = 0; // actual value set up in the while loop
381 | 
382 |         let mut i: felt252 = expected_pledger_count.into();
383 |         let first_pledger: ContractAddress = i.try_into().unwrap();
384 |         let first_amount = 100000;
385 |         pledgeable.add(first_pledger, first_amount);
386 |         expected_total += first_amount;
387 |         i -= 1;
388 | 
389 |         while i != 0 {
390 |             let pledger: ContractAddress = i.try_into().unwrap();
391 |             let amount: u256 = i.into() * 100;
392 |             pledgeable.add(pledger, amount);
393 |             expected_total += amount;
394 |             i -= 1;
395 |         };
396 | 
397 |         assert_eq!(pledgeable.get_total(), expected_total);
398 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
399 |         assert_eq!(pledgeable.get(first_pledger), first_amount);
400 | 
401 |         let removed_amount = pledgeable.remove(first_pledger);
402 | 
403 |         expected_total -= first_amount;
404 | 
405 |         assert_eq!(removed_amount, first_amount);
406 |         assert_eq!(pledgeable.get_total(), expected_total);
407 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count - 1);
408 |         assert_eq!(pledgeable.get(first_pledger), 0);
409 |     }
410 | 
411 |     #[test]
412 |     fn test_remove_middle_of_1000_pledgers() {
413 |         let mut pledgeable: TestingState = Default::default();
414 | 
415 |         // set up 1000 pledgers
416 |         let expected_pledger_count: u32 = 1000;
417 |         let mut expected_total: u256 = 0; // actual value set up in the while loop
418 | 
419 |         let mut middle_pledger: ContractAddress = Zero::zero();
420 |         let mut middle_amount = 0;
421 | 
422 |         let mut i: felt252 = expected_pledger_count.into();
423 |         while i != 0 {
424 |             let pledger: ContractAddress = i.try_into().unwrap();
425 |             let amount: u256 = i.into() * 100;
426 |             pledgeable.add(pledger, amount);
427 |             expected_total += amount;
428 | 
429 |             if i == 500 {
430 |                 middle_pledger = pledger;
431 |                 middle_amount = amount;
432 |             }
433 | 
434 |             i -= 1;
435 |         };
436 | 
437 |         assert_eq!(pledgeable.get_total(), expected_total);
438 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
439 |         assert_eq!(pledgeable.get(middle_pledger), middle_amount);
440 | 
441 |         let removed_amount = pledgeable.remove(middle_pledger);
442 | 
443 |         expected_total -= middle_amount;
444 | 
445 |         assert_eq!(removed_amount, middle_amount);
446 |         assert_eq!(pledgeable.get_total(), expected_total);
447 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count - 1);
448 |         assert_eq!(pledgeable.get(middle_pledger), 0);
449 |     }
450 | 
451 |     #[test]
452 |     fn test_remove_last_of_1000_pledgers() {
453 |         let mut pledgeable: TestingState = Default::default();
454 | 
455 |         // set up 1000 pledgers
456 |         let expected_pledger_count: u32 = 1000;
457 |         let mut expected_total: u256 = 0; // actual value set up in the while loop
458 | 
459 |         let mut i: felt252 = expected_pledger_count.into();
460 |         let last_pledger: ContractAddress = i.try_into().unwrap();
461 |         let last_amount = 100000;
462 |         i -= 1; // leave place for the last pledger
463 | 
464 |         while i != 0 {
465 |             let pledger: ContractAddress = i.try_into().unwrap();
466 |             let amount: u256 = i.into() * 100;
467 |             pledgeable.add(pledger, amount);
468 |             expected_total += amount;
469 |             i -= 1;
470 |         };
471 | 
472 |         // add last pledger
473 |         pledgeable.add(last_pledger, last_amount);
474 |         expected_total += last_amount;
475 | 
476 |         assert_eq!(pledgeable.get_total(), expected_total);
477 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count);
478 |         assert_eq!(pledgeable.get(last_pledger), last_amount);
479 | 
480 |         let removed_amount = pledgeable.remove(last_pledger);
481 | 
482 |         expected_total -= last_amount;
483 | 
484 |         assert_eq!(removed_amount, last_amount);
485 |         assert_eq!(pledgeable.get_total(), expected_total);
486 |         assert_eq!(pledgeable.get_pledger_count(), expected_pledger_count - 1);
487 |         assert_eq!(pledgeable.get(last_pledger), 0);
488 |     }
489 | 
490 |     #[test]
491 |     fn test_array() {
492 |         let mut pledgeable: TestingState = Default::default();
493 |         let pledger_1 = contract_address_const::<'pledger_1'>();
494 |         let pledger_2 = contract_address_const::<'pledger_2'>();
495 |         let pledger_3 = contract_address_const::<'pledger_3'>();
496 | 
497 |         pledgeable.add(pledger_1, 1000);
498 |         pledgeable.add(pledger_2, 500);
499 |         pledgeable.add(pledger_3, 2500);
500 |         // 2nd pledge by pledger_2 *should not* increase the pledge count
501 |         pledgeable.add(pledger_2, 1500);
502 | 
503 |         let pledgers_arr = pledgeable.array();
504 | 
505 |         assert_eq!(pledgers_arr.len(), 3);
506 |         assert_eq!(pledger_3, *pledgers_arr[0]);
507 |         assert_eq!(2500, pledgeable.get(*pledgers_arr[0]));
508 |         assert_eq!(pledger_2, *pledgers_arr[1]);
509 |         assert_eq!(2000, pledgeable.get(*pledgers_arr[1]));
510 |         assert_eq!(pledger_1, *pledgers_arr[2]);
511 |         assert_eq!(1000, pledgeable.get(*pledgers_arr[2]));
512 |     }
513 | 
514 |     #[test]
515 |     fn test_array_1000_pledgers() {
516 |         let mut pledgeable: TestingState = Default::default();
517 | 
518 |         // set up 1000 pledgers
519 |         let mut pledgers: Array::<ContractAddress> = array![];
520 |         let mut i: felt252 = 1000;
521 |         while i != 0 {
522 |             let pledger: ContractAddress = i.try_into().unwrap();
523 |             let amount: u256 = i.into() * 100;
524 |             pledgeable.add(pledger, amount);
525 |             pledgers.append(pledger);
526 |             i -= 1;
527 |         };
528 | 
529 |         let pledgers_arr: Array::<ContractAddress> = pledgeable.array();
530 | 
531 |         assert_eq!(pledgers_arr.len(), pledgers.len());
532 | 
533 |         let mut i = 1000;
534 |         while let Option::Some(expected_pledger) = pledgers.pop_front() {
535 |             i -= 1;
536 |             // pledgers are fetched in reversed order
537 |             let actual_pledger: ContractAddress = *pledgers_arr.at(i);
538 |             assert_eq!(expected_pledger, actual_pledger);
539 |         }
540 |     }
541 | 
542 |     #[test]
543 |     fn test_get() {
544 |         let mut pledgeable: TestingState = Default::default();
545 |         let pledger_1 = contract_address_const::<'pledger_1'>();
546 |         let pledger_2 = contract_address_const::<'pledger_2'>();
547 |         let pledger_3 = contract_address_const::<'pledger_3'>();
548 | 
549 |         pledgeable.add(pledger_1, 1000);
550 |         pledgeable.add(pledger_2, 500);
551 |         // pledger_3 not added
552 | 
553 |         assert_eq!(pledgeable.get(pledger_1), 1000);
554 |         assert_eq!(pledgeable.get(pledger_2), 500);
555 |         assert_eq!(pledgeable.get(pledger_3), 0);
556 |     }
557 | }
558 | 
559 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/src/lib.cairo:
--------------------------------------------------------------------------------
1 | pub mod campaign;
2 | mod mock_upgrade;
3 | 
4 | #[cfg(test)]
5 | mod tests;
6 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/src/mock_upgrade.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::contract]
  2 | pub mod MockUpgrade {
  3 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
  4 |     use components::ownable::ownable_component::OwnableInternalTrait;
  5 |     use core::num::traits::Zero;
  6 |     use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
  7 |     use starknet::{
  8 |         ClassHash, ContractAddress, SyscallResultTrait, get_block_timestamp, get_caller_address,
  9 |         get_contract_address
 10 |     };
 11 |     use components::ownable::ownable_component;
 12 |     use crowdfunding::campaign::pledgeable::pledgeable_component;
 13 |     use crowdfunding::campaign::{ICampaign, Details, Campaign::Errors};
 14 | 
 15 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
 16 |     component!(path: pledgeable_component, storage: pledges, event: PledgeableEvent);
 17 | 
 18 |     #[abi(embed_v0)]
 19 |     pub impl OwnableImpl = ownable_component::Ownable<ContractState>;
 20 |     impl OwnableInternalImpl = ownable_component::OwnableInternalImpl<ContractState>;
 21 |     #[abi(embed_v0)]
 22 |     impl PledgeableImpl = pledgeable_component::Pledgeable<ContractState>;
 23 | 
 24 |     #[storage]
 25 |     struct Storage {
 26 |         canceled: bool,
 27 |         claimed: bool,
 28 |         creator: ContractAddress,
 29 |         description: ByteArray,
 30 |         end_time: u64,
 31 |         goal: u256,
 32 |         #[substorage(v0)]
 33 |         ownable: ownable_component::Storage,
 34 |         #[substorage(v0)]
 35 |         pledges: pledgeable_component::Storage,
 36 |         start_time: u64,
 37 |         title: ByteArray,
 38 |         token: IERC20Dispatcher,
 39 |     }
 40 | 
 41 |     #[event]
 42 |     #[derive(Drop, starknet::Event)]
 43 |     pub enum Event {
 44 |         Claimed: Claimed,
 45 |         Canceled: Canceled,
 46 |         #[flat]
 47 |         OwnableEvent: ownable_component::Event,
 48 |         PledgeableEvent: pledgeable_component::Event,
 49 |         PledgeMade: PledgeMade,
 50 |         Refunded: Refunded,
 51 |         RefundedAll: RefundedAll,
 52 |         Unpledged: Unpledged,
 53 |         Upgraded: Upgraded,
 54 |     }
 55 | 
 56 |     #[derive(Drop, starknet::Event)]
 57 |     pub struct Canceled {
 58 |         pub reason: ByteArray,
 59 |     }
 60 | 
 61 |     #[derive(Drop, starknet::Event)]
 62 |     pub struct Claimed {
 63 |         pub amount: u256,
 64 |     }
 65 | 
 66 |     #[derive(Drop, starknet::Event)]
 67 |     pub struct PledgeMade {
 68 |         #[key]
 69 |         pub pledger: ContractAddress,
 70 |         pub amount: u256,
 71 |     }
 72 | 
 73 |     #[derive(Drop, starknet::Event)]
 74 |     pub struct Refunded {
 75 |         #[key]
 76 |         pub pledger: ContractAddress,
 77 |         pub amount: u256,
 78 |         pub reason: ByteArray,
 79 |     }
 80 | 
 81 |     #[derive(Drop, starknet::Event)]
 82 |     pub struct RefundedAll {
 83 |         pub reason: ByteArray,
 84 |     }
 85 | 
 86 |     #[derive(Drop, starknet::Event)]
 87 |     pub struct Unpledged {
 88 |         #[key]
 89 |         pub pledger: ContractAddress,
 90 |         pub amount: u256,
 91 |         pub reason: ByteArray,
 92 |     }
 93 | 
 94 |     #[derive(Drop, starknet::Event)]
 95 |     pub struct Upgraded {
 96 |         pub implementation: ClassHash
 97 |     }
 98 | 
 99 |     const NINETY_DAYS: u64 = 90 * 24 * 60 * 60;
100 | 
101 |     #[constructor]
102 |     fn constructor(
103 |         ref self: ContractState,
104 |         creator: ContractAddress,
105 |         title: ByteArray,
106 |         description: ByteArray,
107 |         goal: u256,
108 |         start_time: u64,
109 |         end_time: u64,
110 |         token_address: ContractAddress,
111 |     ) {
112 |         assert(creator.is_non_zero(), Errors::CREATOR_ZERO);
113 |         assert(title.len() > 0, Errors::TITLE_EMPTY);
114 |         assert(goal > 0, Errors::ZERO_GOAL);
115 |         assert(start_time >= get_block_timestamp(), Errors::START_TIME_IN_PAST);
116 |         assert(end_time >= start_time, Errors::END_BEFORE_START);
117 |         assert(end_time <= get_block_timestamp() + NINETY_DAYS, Errors::END_BIGGER_THAN_MAX);
118 |         assert(token_address.is_non_zero(), Errors::ZERO_ADDRESS_TOKEN);
119 | 
120 |         self.creator.write(creator);
121 |         self.title.write(title);
122 |         self.goal.write(goal);
123 |         self.description.write(description);
124 |         self.start_time.write(start_time);
125 |         self.end_time.write(end_time);
126 |         self.token.write(IERC20Dispatcher { contract_address: token_address });
127 |         self.ownable._init(get_caller_address());
128 |     }
129 | 
130 |     #[abi(embed_v0)]
131 |     impl MockUpgrade of ICampaign<ContractState> {
132 |         fn cancel(ref self: ContractState, reason: ByteArray) {
133 |             self._assert_only_creator();
134 |             assert(!self.canceled.read(), Errors::CANCELED);
135 |             assert(!self.claimed.read(), Errors::CLAIMED);
136 | 
137 |             self.canceled.write(true);
138 | 
139 |             self._refund_all(reason.clone());
140 | 
141 |             self.emit(Event::Canceled(Canceled { reason }));
142 |         }
143 | 
144 |         fn claim(ref self: ContractState) {
145 |             self._assert_only_creator();
146 |             assert(self._is_started(), Errors::NOT_STARTED);
147 |             assert(self._is_ended(), Errors::STILL_ACTIVE);
148 |             assert(self._is_goal_reached(), Errors::GOAL_NOT_REACHED);
149 |             assert(!self.claimed.read(), Errors::CLAIMED);
150 | 
151 |             let this = get_contract_address();
152 |             let token = self.token.read();
153 |             let amount = token.balance_of(this);
154 |             assert(amount > 0, Errors::ZERO_PLEDGES);
155 | 
156 |             self.claimed.write(true);
157 | 
158 |             // no need to reset the pledges, as the campaign has ended
159 |             // and the data can be used as a testament to how much was raised
160 | 
161 |             let owner = get_caller_address();
162 |             let success = token.transfer(owner, amount);
163 |             assert(success, Errors::TRANSFER_FAILED);
164 | 
165 |             self.emit(Event::Claimed(Claimed { amount }));
166 |         }
167 | 
168 |         fn get_details(self: @ContractState) -> Details {
169 |             Details {
170 |                 creator: self.creator.read(),
171 |                 title: self.title.read(),
172 |                 description: self.description.read(),
173 |                 goal: self.goal.read(),
174 |                 start_time: self.start_time.read(),
175 |                 end_time: self.end_time.read(),
176 |                 claimed: self.claimed.read(),
177 |                 canceled: self.canceled.read(),
178 |                 token: self.token.read().contract_address,
179 |                 total_pledges: self.pledges.get_total(),
180 |             }
181 |         }
182 | 
183 |         fn get_pledge(self: @ContractState, pledger: ContractAddress) -> u256 {
184 |             self.pledges.get(pledger)
185 |         }
186 | 
187 |         fn get_pledgers(self: @ContractState) -> Array<ContractAddress> {
188 |             self.pledges.array()
189 |         }
190 | 
191 |         fn pledge(ref self: ContractState, amount: u256) {
192 |             assert(self._is_started(), Errors::NOT_STARTED);
193 |             assert(!self._is_ended(), Errors::ENDED);
194 |             assert(!self.canceled.read(), Errors::CANCELED);
195 |             assert(amount > 0, Errors::ZERO_DONATION);
196 | 
197 |             let pledger = get_caller_address();
198 |             let this = get_contract_address();
199 |             let success = self.token.read().transfer_from(pledger, this, amount);
200 |             assert(success, Errors::TRANSFER_FAILED);
201 | 
202 |             self.pledges.add(pledger, amount);
203 | 
204 |             self.emit(Event::PledgeMade(PledgeMade { pledger, amount }));
205 |         }
206 | 
207 |         fn refund(ref self: ContractState, pledger: ContractAddress, reason: ByteArray) {
208 |             self._assert_only_creator();
209 |             assert(self._is_started(), Errors::NOT_STARTED);
210 |             assert(!self.claimed.read(), Errors::CLAIMED);
211 |             assert(!self.canceled.read(), Errors::CANCELED);
212 |             assert(pledger.is_non_zero(), Errors::ZERO_ADDRESS_PLEDGER);
213 |             assert(self.pledges.get(pledger) != 0, Errors::NOTHING_TO_REFUND);
214 | 
215 |             let amount = self._refund(pledger);
216 | 
217 |             self.emit(Event::Refunded(Refunded { pledger, amount, reason }))
218 |         }
219 | 
220 |         fn unpledge(ref self: ContractState, reason: ByteArray) {
221 |             assert(self._is_started(), Errors::NOT_STARTED);
222 |             assert(!self._is_goal_reached(), Errors::PLEDGES_LOCKED);
223 |             assert(self.pledges.get(get_caller_address()) != 0, Errors::NOTHING_TO_UNPLEDGE);
224 | 
225 |             let pledger = get_caller_address();
226 |             let amount = self._refund(pledger);
227 | 
228 |             self.emit(Event::Unpledged(Unpledged { pledger, amount, reason }));
229 |         }
230 | 
231 |         fn upgrade(ref self: ContractState, impl_hash: ClassHash, new_end_time: Option<u64>) {
232 |             self.ownable._assert_only_owner();
233 |             assert(impl_hash.is_non_zero(), Errors::CLASS_HASH_ZERO);
234 | 
235 |             // only active campaigns have funds to refund and an end time to update
236 |             if self._is_started() {
237 |                 if let Option::Some(end_time) = new_end_time {
238 |                     assert(end_time >= get_block_timestamp(), Errors::END_BEFORE_NOW);
239 |                     assert(
240 |                         end_time <= get_block_timestamp() + NINETY_DAYS, Errors::END_BIGGER_THAN_MAX
241 |                     );
242 |                     self.end_time.write(end_time);
243 |                 };
244 |                 self._refund_all("contract upgraded");
245 |             }
246 | 
247 |             starknet::syscalls::replace_class_syscall(impl_hash).unwrap_syscall();
248 | 
249 |             self.emit(Event::Upgraded(Upgraded { implementation: impl_hash }));
250 |         }
251 |     }
252 | 
253 |     #[generate_trait]
254 |     impl MockUpgradeInternalImpl of MockUpgradeInternalTrait {
255 |         fn _assert_only_creator(self: @ContractState) {
256 |             let caller = get_caller_address();
257 |             assert(caller.is_non_zero(), Errors::ZERO_ADDRESS_CALLER);
258 |             assert(caller == self.creator.read(), Errors::NOT_CREATOR);
259 |         }
260 | 
261 |         fn _is_ended(self: @ContractState) -> bool {
262 |             get_block_timestamp() >= self.end_time.read()
263 |         }
264 | 
265 |         fn _is_goal_reached(self: @ContractState) -> bool {
266 |             self.pledges.get_total() >= self.goal.read()
267 |         }
268 | 
269 |         fn _is_started(self: @ContractState) -> bool {
270 |             get_block_timestamp() >= self.start_time.read()
271 |         }
272 | 
273 |         fn _refund(ref self: ContractState, pledger: ContractAddress) -> u256 {
274 |             let amount = self.pledges.remove(pledger);
275 | 
276 |             let success = self.token.read().transfer(pledger, amount);
277 |             assert(success, Errors::TRANSFER_FAILED);
278 | 
279 |             amount
280 |         }
281 | 
282 |         fn _refund_all(ref self: ContractState, reason: ByteArray) {
283 |             let mut pledges = self.pledges.array();
284 |             while let Option::Some(pledger) = pledges.pop_front() {
285 |                 self._refund(pledger);
286 |             };
287 |             self.emit(Event::RefundedAll(RefundedAll { reason }));
288 |         }
289 |     }
290 | }
291 | 


--------------------------------------------------------------------------------
/listings/applications/crowdfunding/src/tests.cairo:
--------------------------------------------------------------------------------
  1 | use starknet::{ContractAddress, get_block_timestamp, contract_address_const,};
  2 | use snforge_std::{
  3 |     declare, ContractClass, ContractClassTrait, start_cheat_caller_address,
  4 |     stop_cheat_caller_address, spy_events, EventSpyAssertionsTrait, get_class_hash,
  5 |     DeclareResultTrait, start_cheat_block_timestamp_global
  6 | };
  7 | 
  8 | use crowdfunding::campaign::{Campaign, ICampaignDispatcher, ICampaignDispatcherTrait};
  9 | use components::ownable::{IOwnableDispatcher, IOwnableDispatcherTrait};
 10 | use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 11 | 
 12 | /// Deploy a campaign contract with the provided data
 13 | fn deploy(
 14 |     contract: ContractClass,
 15 |     title: ByteArray,
 16 |     description: ByteArray,
 17 |     goal: u256,
 18 |     start_time: u64,
 19 |     end_time: u64,
 20 |     token: ContractAddress
 21 | ) -> ICampaignDispatcher {
 22 |     let creator = contract_address_const::<'creator'>();
 23 |     let mut calldata: Array::<felt252> = array![];
 24 |     ((creator, title, description, goal), start_time, end_time, token).serialize(ref calldata);
 25 | 
 26 |     let contract_address = contract.precalculate_address(@calldata);
 27 |     let owner = contract_address_const::<'owner'>();
 28 |     start_cheat_caller_address(contract_address, owner);
 29 | 
 30 |     contract.deploy(@calldata).unwrap();
 31 | 
 32 |     stop_cheat_caller_address(contract_address);
 33 | 
 34 |     ICampaignDispatcher { contract_address }
 35 | }
 36 | 
 37 | fn deploy_with_token(
 38 |     contract: ContractClass, token: ContractClass
 39 | ) -> (ICampaignDispatcher, IERC20Dispatcher) {
 40 |     // define ERC20 data
 41 |     let token_name: ByteArray = "My Token";
 42 |     let token_symbol: ByteArray = "MTKN";
 43 |     let token_supply: u256 = 100000;
 44 |     let token_owner = contract_address_const::<'token_owner'>();
 45 |     let token_recipient = token_owner;
 46 | 
 47 |     // deploy ERC20 token
 48 |     let mut token_constructor_calldata = array![];
 49 |     ((token_name, token_symbol, token_supply, token_recipient), token_owner)
 50 |         .serialize(ref token_constructor_calldata);
 51 |     let (token_address, _) = token.deploy(@token_constructor_calldata).unwrap();
 52 | 
 53 |     // transfer amounts to some pledgers
 54 |     let pledger_1 = contract_address_const::<'pledger_1'>();
 55 |     let pledger_2 = contract_address_const::<'pledger_2'>();
 56 |     let pledger_3 = contract_address_const::<'pledger_3'>();
 57 | 
 58 |     start_cheat_caller_address(token_address, token_owner);
 59 |     let token_dispatcher = IERC20Dispatcher { contract_address: token_address };
 60 |     token_dispatcher.transfer(pledger_1, 10000);
 61 |     token_dispatcher.transfer(pledger_2, 10000);
 62 |     token_dispatcher.transfer(pledger_3, 10000);
 63 | 
 64 |     // deploy the actual Campaign contract
 65 |     let start_time = get_block_timestamp();
 66 |     let end_time = start_time + 60;
 67 |     let campaign_dispatcher = deploy(
 68 |         contract, "title 1", "description 1", 10000, start_time, end_time, token_address
 69 |     );
 70 | 
 71 |     // approve the pledges for each pledger
 72 |     start_cheat_caller_address(token_address, pledger_1);
 73 |     token_dispatcher.approve(campaign_dispatcher.contract_address, 10000);
 74 |     start_cheat_caller_address(token_address, pledger_2);
 75 |     token_dispatcher.approve(campaign_dispatcher.contract_address, 10000);
 76 |     start_cheat_caller_address(token_address, pledger_3);
 77 |     token_dispatcher.approve(campaign_dispatcher.contract_address, 10000);
 78 | 
 79 |     // NOTE: don't forget to stop the caller address cheat on the ERC20 contract!!
 80 |     // Otherwise, any call to this contract from any source will have the cheated
 81 |     // address as the caller
 82 |     stop_cheat_caller_address(token_address);
 83 | 
 84 |     (campaign_dispatcher, token_dispatcher)
 85 | }
 86 | 
 87 | #[test]
 88 | fn test_deploy() {
 89 |     let start_time = get_block_timestamp();
 90 |     let end_time = start_time + 60;
 91 |     let contract = *declare("Campaign").unwrap().contract_class();
 92 |     let campaign = deploy(
 93 |         contract,
 94 |         "title 1",
 95 |         "description 1",
 96 |         10000,
 97 |         start_time,
 98 |         end_time,
 99 |         contract_address_const::<'token'>()
100 |     );
101 | 
102 |     let details = campaign.get_details();
103 |     assert_eq!(details.title, "title 1");
104 |     assert_eq!(details.description, "description 1");
105 |     assert_eq!(details.goal, 10000);
106 |     assert_eq!(details.start_time, start_time);
107 |     assert_eq!(details.end_time, end_time);
108 |     assert_eq!(details.claimed, false);
109 |     assert_eq!(details.canceled, false);
110 |     assert_eq!(details.token, contract_address_const::<'token'>());
111 |     assert_eq!(details.total_pledges, 0);
112 |     assert_eq!(details.creator, contract_address_const::<'creator'>());
113 | 
114 |     let owner: ContractAddress = contract_address_const::<'owner'>();
115 |     let campaign_ownable = IOwnableDispatcher { contract_address: campaign.contract_address };
116 |     assert_eq!(campaign_ownable.owner(), owner);
117 | }
118 | 
119 | #[test]
120 | fn test_successful_campaign() {
121 |     let token_class = *declare("ERC20Upgradeable").unwrap().contract_class();
122 |     let contract_class = *declare("Campaign").unwrap().contract_class();
123 |     let (campaign, token) = deploy_with_token(contract_class, token_class);
124 | 
125 |     let creator = contract_address_const::<'creator'>();
126 |     let pledger_1 = contract_address_const::<'pledger_1'>();
127 |     let pledger_2 = contract_address_const::<'pledger_2'>();
128 |     let pledger_3 = contract_address_const::<'pledger_3'>();
129 | 
130 |     let mut spy = spy_events();
131 | 
132 |     // 1st donation
133 |     start_cheat_caller_address(campaign.contract_address, pledger_1);
134 |     let mut prev_balance = token.balance_of(pledger_1);
135 |     campaign.pledge(3000);
136 |     assert_eq!(campaign.get_details().total_pledges, 3000);
137 |     assert_eq!(campaign.get_pledge(pledger_1), 3000);
138 |     assert_eq!(token.balance_of(pledger_1), prev_balance - 3000);
139 | 
140 |     spy
141 |         .assert_emitted(
142 |             @array![
143 |                 (
144 |                     campaign.contract_address,
145 |                     Campaign::Event::PledgeMade(
146 |                         Campaign::PledgeMade { pledger: pledger_1, amount: 3000 }
147 |                     )
148 |                 )
149 |             ]
150 |         );
151 | 
152 |     // 2nd donation
153 |     start_cheat_caller_address(campaign.contract_address, pledger_2);
154 |     prev_balance = token.balance_of(pledger_2);
155 |     campaign.pledge(500);
156 |     assert_eq!(campaign.get_details().total_pledges, 3500);
157 |     assert_eq!(campaign.get_pledge(pledger_2), 500);
158 |     assert_eq!(token.balance_of(pledger_2), prev_balance - 500);
159 | 
160 |     spy
161 |         .assert_emitted(
162 |             @array![
163 |                 (
164 |                     campaign.contract_address,
165 |                     Campaign::Event::PledgeMade(
166 |                         Campaign::PledgeMade { pledger: pledger_2, amount: 500 }
167 |                     )
168 |                 )
169 |             ]
170 |         );
171 | 
172 |     // 3rd donation
173 |     start_cheat_caller_address(campaign.contract_address, pledger_3);
174 |     prev_balance = token.balance_of(pledger_3);
175 |     campaign.pledge(7000);
176 |     assert_eq!(campaign.get_details().total_pledges, 10500);
177 |     assert_eq!(campaign.get_pledge(pledger_3), 7000);
178 |     assert_eq!(token.balance_of(pledger_3), prev_balance - 7000);
179 | 
180 |     spy
181 |         .assert_emitted(
182 |             @array![
183 |                 (
184 |                     campaign.contract_address,
185 |                     Campaign::Event::PledgeMade(
186 |                         Campaign::PledgeMade { pledger: pledger_3, amount: 7000 }
187 |                     )
188 |                 )
189 |             ]
190 |         );
191 | 
192 |     // claim
193 |     start_cheat_block_timestamp_global(campaign.get_details().end_time);
194 |     start_cheat_caller_address(campaign.contract_address, creator);
195 |     prev_balance = token.balance_of(creator);
196 |     campaign.claim();
197 |     assert_eq!(token.balance_of(creator), prev_balance + 10500);
198 |     assert!(campaign.get_details().claimed);
199 | 
200 |     spy
201 |         .assert_emitted(
202 |             @array![
203 |                 (
204 |                     campaign.contract_address,
205 |                     Campaign::Event::Claimed(Campaign::Claimed { amount: 10500 })
206 |                 )
207 |             ]
208 |         );
209 | }
210 | 
211 | #[test]
212 | fn test_upgrade_class_hash() {
213 |     let new_class_hash = *(declare("MockUpgrade").unwrap().contract_class()).class_hash;
214 |     let owner = contract_address_const::<'owner'>();
215 | 
216 |     // test pending campaign
217 |     let contract_class = *declare("Campaign").unwrap().contract_class();
218 |     let token_class = *declare("ERC20Upgradeable").unwrap().contract_class();
219 |     let (campaign, _) = deploy_with_token(contract_class, token_class);
220 |     let mut spy = spy_events();
221 | 
222 |     start_cheat_caller_address(campaign.contract_address, owner);
223 |     campaign.upgrade(new_class_hash, Option::None);
224 |     stop_cheat_caller_address(campaign.contract_address);
225 | 
226 |     assert_eq!(get_class_hash(campaign.contract_address), new_class_hash);
227 | 
228 |     spy
229 |         .assert_emitted(
230 |             @array![
231 |                 (
232 |                     campaign.contract_address,
233 |                     Campaign::Event::Upgraded(Campaign::Upgraded { implementation: new_class_hash })
234 |                 )
235 |             ]
236 |         );
237 | 
238 |     // test active campaign
239 |     let (campaign, token) = deploy_with_token(contract_class, token_class);
240 |     let mut spy = spy_events();
241 |     let duration: u64 = 60;
242 |     let pledger_1 = contract_address_const::<'pledger_1'>();
243 |     let pledger_2 = contract_address_const::<'pledger_2'>();
244 |     let pledger_3 = contract_address_const::<'pledger_3'>();
245 |     let prev_balance_pledger_1 = token.balance_of(pledger_1);
246 |     let prev_balance_pledger_2 = token.balance_of(pledger_2);
247 |     let prev_balance_pledger_3 = token.balance_of(pledger_3);
248 | 
249 |     start_cheat_caller_address(campaign.contract_address, pledger_1);
250 |     campaign.pledge(3000);
251 |     start_cheat_caller_address(campaign.contract_address, pledger_2);
252 |     campaign.pledge(1000);
253 |     start_cheat_caller_address(campaign.contract_address, pledger_3);
254 |     campaign.pledge(2000);
255 | 
256 |     start_cheat_caller_address(campaign.contract_address, owner);
257 |     campaign.upgrade(new_class_hash, Option::Some(duration));
258 |     stop_cheat_caller_address(campaign.contract_address);
259 | 
260 |     assert_eq!(prev_balance_pledger_1, token.balance_of(pledger_1));
261 |     assert_eq!(prev_balance_pledger_2, token.balance_of(pledger_2));
262 |     assert_eq!(prev_balance_pledger_3, token.balance_of(pledger_3));
263 |     assert_eq!(campaign.get_details().total_pledges, 0);
264 |     assert_eq!(campaign.get_details().end_time, get_block_timestamp() + duration);
265 | 
266 |     spy
267 |         .assert_emitted(
268 |             @array![
269 |                 (
270 |                     campaign.contract_address,
271 |                     Campaign::Event::Upgraded(Campaign::Upgraded { implementation: new_class_hash })
272 |                 ),
273 |                 (
274 |                     campaign.contract_address,
275 |                     Campaign::Event::RefundedAll(
276 |                         Campaign::RefundedAll { reason: "contract upgraded" }
277 |                     )
278 |                 )
279 |             ]
280 |         );
281 | }
282 | 
283 | #[test]
284 | fn test_cancel() {
285 |     let contract_class = *declare("Campaign").unwrap().contract_class();
286 |     let token_class = *declare("ERC20Upgradeable").unwrap().contract_class();
287 | 
288 |     // test canceled campaign
289 |     let (campaign, token) = deploy_with_token(contract_class, token_class);
290 |     let mut spy = spy_events();
291 |     let creator = contract_address_const::<'creator'>();
292 |     let pledger_1 = contract_address_const::<'pledger_1'>();
293 |     let pledger_2 = contract_address_const::<'pledger_2'>();
294 |     let pledger_3 = contract_address_const::<'pledger_3'>();
295 |     let pledge_1: u256 = 3000;
296 |     let pledge_2: u256 = 3000;
297 |     let pledge_3: u256 = 3000;
298 |     let prev_balance_pledger_1 = token.balance_of(pledger_1);
299 |     let prev_balance_pledger_2 = token.balance_of(pledger_2);
300 |     let prev_balance_pledger_3 = token.balance_of(pledger_3);
301 | 
302 |     start_cheat_caller_address(campaign.contract_address, pledger_1);
303 |     campaign.pledge(pledge_1);
304 |     start_cheat_caller_address(campaign.contract_address, pledger_2);
305 |     campaign.pledge(pledge_2);
306 |     start_cheat_caller_address(campaign.contract_address, pledger_3);
307 |     campaign.pledge(pledge_3);
308 |     assert_eq!(campaign.get_details().total_pledges, pledge_1 + pledge_2 + pledge_3);
309 |     assert_eq!(token.balance_of(pledger_1), prev_balance_pledger_1 - pledge_1);
310 |     assert_eq!(token.balance_of(pledger_2), prev_balance_pledger_2 - pledge_2);
311 |     assert_eq!(token.balance_of(pledger_3), prev_balance_pledger_3 - pledge_3);
312 | 
313 |     start_cheat_caller_address(campaign.contract_address, creator);
314 |     campaign.cancel("testing");
315 |     stop_cheat_caller_address(campaign.contract_address);
316 | 
317 |     assert_eq!(prev_balance_pledger_1, token.balance_of(pledger_1));
318 |     assert_eq!(prev_balance_pledger_2, token.balance_of(pledger_2));
319 |     assert_eq!(prev_balance_pledger_3, token.balance_of(pledger_3));
320 |     assert_eq!(campaign.get_details().total_pledges, 0);
321 |     assert!(campaign.get_details().canceled);
322 | 
323 |     spy
324 |         .assert_emitted(
325 |             @array![
326 |                 (
327 |                     campaign.contract_address,
328 |                     Campaign::Event::RefundedAll(Campaign::RefundedAll { reason: "testing" })
329 |                 ),
330 |                 (
331 |                     campaign.contract_address,
332 |                     Campaign::Event::Canceled(Campaign::Canceled { reason: "testing" })
333 |                 )
334 |             ]
335 |         );
336 | 
337 |     // test failed campaign
338 |     let (campaign, token) = deploy_with_token(contract_class, token_class);
339 |     let mut spy = spy_events();
340 |     let creator = contract_address_const::<'creator'>();
341 |     let pledger_1 = contract_address_const::<'pledger_1'>();
342 |     let pledger_2 = contract_address_const::<'pledger_2'>();
343 |     let pledger_3 = contract_address_const::<'pledger_3'>();
344 |     let pledge_1: u256 = 3000;
345 |     let pledge_2: u256 = 3000;
346 |     let pledge_3: u256 = 3000;
347 |     let prev_balance_pledger_1 = token.balance_of(pledger_1);
348 |     let prev_balance_pledger_2 = token.balance_of(pledger_2);
349 |     let prev_balance_pledger_3 = token.balance_of(pledger_3);
350 | 
351 |     start_cheat_caller_address(campaign.contract_address, pledger_1);
352 |     campaign.pledge(pledge_1);
353 |     start_cheat_caller_address(campaign.contract_address, pledger_2);
354 |     campaign.pledge(pledge_2);
355 |     start_cheat_caller_address(campaign.contract_address, pledger_3);
356 |     campaign.pledge(pledge_3);
357 |     assert_eq!(campaign.get_details().total_pledges, pledge_1 + pledge_2 + pledge_3);
358 |     assert_eq!(token.balance_of(pledger_1), prev_balance_pledger_1 - pledge_1);
359 |     assert_eq!(token.balance_of(pledger_2), prev_balance_pledger_2 - pledge_2);
360 |     assert_eq!(token.balance_of(pledger_3), prev_balance_pledger_3 - pledge_3);
361 | 
362 |     start_cheat_block_timestamp_global(campaign.get_details().end_time);
363 | 
364 |     start_cheat_caller_address(campaign.contract_address, creator);
365 |     campaign.cancel("testing");
366 |     stop_cheat_caller_address(campaign.contract_address);
367 | 
368 |     assert_eq!(prev_balance_pledger_1, token.balance_of(pledger_1));
369 |     assert_eq!(prev_balance_pledger_2, token.balance_of(pledger_2));
370 |     assert_eq!(prev_balance_pledger_3, token.balance_of(pledger_3));
371 |     assert_eq!(campaign.get_details().total_pledges, 0);
372 |     assert!(campaign.get_details().canceled);
373 | 
374 |     spy
375 |         .assert_emitted(
376 |             @array![
377 |                 (
378 |                     campaign.contract_address,
379 |                     Campaign::Event::RefundedAll(Campaign::RefundedAll { reason: "testing" })
380 |                 ),
381 |                 (
382 |                     campaign.contract_address,
383 |                     Campaign::Event::Canceled(Campaign::Canceled { reason: "testing" })
384 |                 )
385 |             ]
386 |         );
387 | }
388 | 
389 | #[test]
390 | fn test_refund() {
391 |     // setup
392 |     let (campaign, token) = deploy_with_token(
393 |         *declare("Campaign").unwrap().contract_class(),
394 |         *declare("ERC20Upgradeable").unwrap().contract_class()
395 |     );
396 |     let mut spy = spy_events();
397 |     let creator = contract_address_const::<'creator'>();
398 |     let pledger_1 = contract_address_const::<'pledger_1'>();
399 |     let pledger_2 = contract_address_const::<'pledger_2'>();
400 |     let amount_1: u256 = 3000;
401 |     let amount_2: u256 = 1500;
402 |     let prev_balance_1 = token.balance_of(pledger_1);
403 |     let prev_balance_2 = token.balance_of(pledger_2);
404 | 
405 |     // donate
406 |     start_cheat_caller_address(campaign.contract_address, pledger_1);
407 |     campaign.pledge(amount_1);
408 |     assert_eq!(campaign.get_details().total_pledges, amount_1);
409 |     assert_eq!(campaign.get_pledge(pledger_1), amount_1);
410 |     assert_eq!(token.balance_of(pledger_1), prev_balance_1 - amount_1);
411 | 
412 |     start_cheat_caller_address(campaign.contract_address, pledger_2);
413 |     campaign.pledge(amount_2);
414 |     assert_eq!(campaign.get_details().total_pledges, amount_1 + amount_2);
415 |     assert_eq!(campaign.get_pledge(pledger_2), amount_2);
416 |     assert_eq!(token.balance_of(pledger_2), prev_balance_2 - amount_2);
417 | 
418 |     // refund
419 |     start_cheat_caller_address(campaign.contract_address, creator);
420 |     campaign.refund(pledger_1, "testing");
421 |     assert_eq!(campaign.get_details().total_pledges, amount_2);
422 |     assert_eq!(campaign.get_pledge(pledger_2), amount_2);
423 |     assert_eq!(token.balance_of(pledger_2), prev_balance_2 - amount_2);
424 |     assert_eq!(token.balance_of(pledger_1), prev_balance_1);
425 | 
426 |     spy
427 |         .assert_emitted(
428 |             @array![
429 |                 (
430 |                     campaign.contract_address,
431 |                     Campaign::Event::Refunded(
432 |                         Campaign::Refunded {
433 |                             pledger: pledger_1, amount: amount_1, reason: "testing"
434 |                         }
435 |                     )
436 |                 )
437 |             ]
438 |         );
439 | }
440 | 
441 | #[test]
442 | fn test_unpledge() {
443 |     // setup
444 |     let (campaign, token) = deploy_with_token(
445 |         *declare("Campaign").unwrap().contract_class(),
446 |         *declare("ERC20Upgradeable").unwrap().contract_class()
447 |     );
448 |     let mut spy = spy_events();
449 |     let pledger = contract_address_const::<'pledger_1'>();
450 |     let amount: u256 = 3000;
451 |     let prev_balance = token.balance_of(pledger);
452 | 
453 |     // donate
454 |     start_cheat_caller_address(campaign.contract_address, pledger);
455 |     campaign.pledge(amount);
456 |     assert_eq!(campaign.get_details().total_pledges, amount);
457 |     assert_eq!(campaign.get_pledge(pledger), amount);
458 |     assert_eq!(token.balance_of(pledger), prev_balance - amount);
459 | 
460 |     // unpledge
461 |     campaign.unpledge("testing");
462 |     assert_eq!(campaign.get_details().total_pledges, 0);
463 |     assert_eq!(campaign.get_pledge(pledger), 0);
464 |     assert_eq!(token.balance_of(pledger), prev_balance);
465 | 
466 |     spy
467 |         .assert_emitted(
468 |             @array![
469 |                 (
470 |                     campaign.contract_address,
471 |                     Campaign::Event::Unpledged(
472 |                         Campaign::Unpledged { pledger, amount, reason: "testing" }
473 |                     )
474 |                 )
475 |             ]
476 |         );
477 | }
478 | 


--------------------------------------------------------------------------------
/listings/applications/erc20/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/erc20/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "erc20"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [lib]
 7 | 
 8 | [dependencies]
 9 | starknet.workspace = true
10 | 
11 | [dev-dependencies]
12 | cairo_test.workspace = true
13 | 
14 | [scripts]
15 | test.workspace = true
16 | 
17 | [[target.starknet-contract]]
18 | 


--------------------------------------------------------------------------------
/listings/applications/erc20/src/lib.cairo:
--------------------------------------------------------------------------------
1 | pub mod token;
2 | 


--------------------------------------------------------------------------------
/listings/applications/erc20/src/token.cairo:
--------------------------------------------------------------------------------
  1 | use starknet::ContractAddress;
  2 | 
  3 | // [!region interface]
  4 | #[starknet::interface]
  5 | pub trait IERC20<TContractState> {
  6 |     fn get_name(self: @TContractState) -> felt252;
  7 |     fn get_symbol(self: @TContractState) -> felt252;
  8 |     fn get_decimals(self: @TContractState) -> u8;
  9 |     fn get_total_supply(self: @TContractState) -> felt252;
 10 |     fn balance_of(self: @TContractState, account: ContractAddress) -> felt252;
 11 |     fn allowance(
 12 |         self: @TContractState, owner: ContractAddress, spender: ContractAddress
 13 |     ) -> felt252;
 14 |     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: felt252);
 15 |     fn transfer_from(
 16 |         ref self: TContractState,
 17 |         sender: ContractAddress,
 18 |         recipient: ContractAddress,
 19 |         amount: felt252
 20 |     );
 21 |     fn approve(ref self: TContractState, spender: ContractAddress, amount: felt252);
 22 |     fn increase_allowance(ref self: TContractState, spender: ContractAddress, added_value: felt252);
 23 |     fn decrease_allowance(
 24 |         ref self: TContractState, spender: ContractAddress, subtracted_value: felt252
 25 |     );
 26 | }
 27 | // [!endregion interface]
 28 | 
 29 | // [!region erc20]
 30 | #[starknet::contract]
 31 | pub mod erc20 {
 32 |     use core::num::traits::Zero;
 33 |     use starknet::get_caller_address;
 34 |     use starknet::contract_address_const;
 35 |     use starknet::ContractAddress;
 36 |     use starknet::storage::{
 37 |         Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
 38 |         StoragePointerWriteAccess
 39 |     };
 40 | 
 41 |     #[storage]
 42 |     struct Storage {
 43 |         name: felt252,
 44 |         symbol: felt252,
 45 |         decimals: u8,
 46 |         total_supply: felt252,
 47 |         balances: Map::<ContractAddress, felt252>,
 48 |         allowances: Map::<(ContractAddress, ContractAddress), felt252>,
 49 |     }
 50 | 
 51 |     #[event]
 52 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 53 |     pub enum Event {
 54 |         Transfer: Transfer,
 55 |         Approval: Approval,
 56 |     }
 57 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 58 |     pub struct Transfer {
 59 |         pub from: ContractAddress,
 60 |         pub to: ContractAddress,
 61 |         pub value: felt252,
 62 |     }
 63 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 64 |     pub struct Approval {
 65 |         pub owner: ContractAddress,
 66 |         pub spender: ContractAddress,
 67 |         pub value: felt252,
 68 |     }
 69 | 
 70 |     mod Errors {
 71 |         pub const APPROVE_FROM_ZERO: felt252 = 'ERC20: approve from 0';
 72 |         pub const APPROVE_TO_ZERO: felt252 = 'ERC20: approve to 0';
 73 |         pub const TRANSFER_FROM_ZERO: felt252 = 'ERC20: transfer from 0';
 74 |         pub const TRANSFER_TO_ZERO: felt252 = 'ERC20: transfer to 0';
 75 |         pub const BURN_FROM_ZERO: felt252 = 'ERC20: burn from 0';
 76 |         pub const MINT_TO_ZERO: felt252 = 'ERC20: mint to 0';
 77 |     }
 78 | 
 79 |     #[constructor]
 80 |     fn constructor(
 81 |         ref self: ContractState,
 82 |         recipient: ContractAddress,
 83 |         name: felt252,
 84 |         decimals: u8,
 85 |         initial_supply: felt252,
 86 |         symbol: felt252
 87 |     ) {
 88 |         self.name.write(name);
 89 |         self.symbol.write(symbol);
 90 |         self.decimals.write(decimals);
 91 |         self.mint(recipient, initial_supply);
 92 |     }
 93 | 
 94 |     #[abi(embed_v0)]
 95 |     impl IERC20Impl of super::IERC20<ContractState> {
 96 |         fn get_name(self: @ContractState) -> felt252 {
 97 |             self.name.read()
 98 |         }
 99 | 
100 |         fn get_symbol(self: @ContractState) -> felt252 {
101 |             self.symbol.read()
102 |         }
103 | 
104 |         fn get_decimals(self: @ContractState) -> u8 {
105 |             self.decimals.read()
106 |         }
107 | 
108 |         fn get_total_supply(self: @ContractState) -> felt252 {
109 |             self.total_supply.read()
110 |         }
111 | 
112 |         fn balance_of(self: @ContractState, account: ContractAddress) -> felt252 {
113 |             self.balances.read(account)
114 |         }
115 | 
116 |         fn allowance(
117 |             self: @ContractState, owner: ContractAddress, spender: ContractAddress
118 |         ) -> felt252 {
119 |             self.allowances.read((owner, spender))
120 |         }
121 | 
122 |         fn transfer(ref self: ContractState, recipient: ContractAddress, amount: felt252) {
123 |             let sender = get_caller_address();
124 |             self._transfer(sender, recipient, amount);
125 |         }
126 | 
127 |         fn transfer_from(
128 |             ref self: ContractState,
129 |             sender: ContractAddress,
130 |             recipient: ContractAddress,
131 |             amount: felt252
132 |         ) {
133 |             let caller = get_caller_address();
134 |             self.spend_allowance(sender, caller, amount);
135 |             self._transfer(sender, recipient, amount);
136 |         }
137 | 
138 |         fn approve(ref self: ContractState, spender: ContractAddress, amount: felt252) {
139 |             let caller = get_caller_address();
140 |             self.approve_helper(caller, spender, amount);
141 |         }
142 | 
143 |         fn increase_allowance(
144 |             ref self: ContractState, spender: ContractAddress, added_value: felt252
145 |         ) {
146 |             let caller = get_caller_address();
147 |             self
148 |                 .approve_helper(
149 |                     caller, spender, self.allowances.read((caller, spender)) + added_value
150 |                 );
151 |         }
152 | 
153 |         fn decrease_allowance(
154 |             ref self: ContractState, spender: ContractAddress, subtracted_value: felt252
155 |         ) {
156 |             let caller = get_caller_address();
157 |             self
158 |                 .approve_helper(
159 |                     caller, spender, self.allowances.read((caller, spender)) - subtracted_value
160 |                 );
161 |         }
162 |     }
163 | 
164 |     #[generate_trait]
165 |     impl InternalImpl of InternalTrait {
166 |         fn _transfer(
167 |             ref self: ContractState,
168 |             sender: ContractAddress,
169 |             recipient: ContractAddress,
170 |             amount: felt252
171 |         ) {
172 |             assert(sender.is_non_zero(), Errors::TRANSFER_FROM_ZERO);
173 |             assert(recipient.is_non_zero(), Errors::TRANSFER_TO_ZERO);
174 |             self.balances.write(sender, self.balances.read(sender) - amount);
175 |             self.balances.write(recipient, self.balances.read(recipient) + amount);
176 |             self.emit(Transfer { from: sender, to: recipient, value: amount });
177 |         }
178 | 
179 |         fn spend_allowance(
180 |             ref self: ContractState,
181 |             owner: ContractAddress,
182 |             spender: ContractAddress,
183 |             amount: felt252
184 |         ) {
185 |             let allowance = self.allowances.read((owner, spender));
186 |             self.allowances.write((owner, spender), allowance - amount);
187 |         }
188 | 
189 |         fn approve_helper(
190 |             ref self: ContractState,
191 |             owner: ContractAddress,
192 |             spender: ContractAddress,
193 |             amount: felt252
194 |         ) {
195 |             assert(spender.is_non_zero(), Errors::APPROVE_TO_ZERO);
196 |             self.allowances.write((owner, spender), amount);
197 |             self.emit(Approval { owner, spender, value: amount });
198 |         }
199 | 
200 |         fn mint(ref self: ContractState, recipient: ContractAddress, amount: felt252) {
201 |             assert(recipient.is_non_zero(), Errors::MINT_TO_ZERO);
202 |             let supply = self.total_supply.read() + amount;
203 |             self.total_supply.write(supply);
204 |             let balance = self.balances.read(recipient) + amount;
205 |             self.balances.write(recipient, balance);
206 |             self
207 |                 .emit(
208 |                     Event::Transfer(
209 |                         Transfer {
210 |                             from: contract_address_const::<0>(), to: recipient, value: amount
211 |                         }
212 |                     )
213 |                 );
214 |         }
215 |     }
216 | }
217 | // [!endregion erc20]
218 | 
219 | #[cfg(test)]
220 | mod tests {
221 |     use super::{erc20, IERC20Dispatcher, IERC20DispatcherTrait, erc20::{Event, Transfer, Approval}};
222 | 
223 |     use starknet::{
224 |         ContractAddress, SyscallResultTrait, syscalls::deploy_syscall, contract_address_const
225 |     };
226 |     use core::num::traits::Zero;
227 | 
228 |     use starknet::testing::set_contract_address;
229 | 
230 |     const token_name: felt252 = 'myToken';
231 |     const decimals: u8 = 18;
232 |     const initial_supply: felt252 = 100000;
233 |     const symbols: felt252 = 'mtk';
234 | 
235 |     fn deploy() -> (IERC20Dispatcher, ContractAddress) {
236 |         let recipient: ContractAddress = contract_address_const::<'initialized_recipient'>();
237 | 
238 |         let (contract_address, _) = deploy_syscall(
239 |             erc20::TEST_CLASS_HASH.try_into().unwrap(),
240 |             recipient.into(),
241 |             array![recipient.into(), token_name, decimals.into(), initial_supply, symbols].span(),
242 |             false
243 |         )
244 |             .unwrap_syscall();
245 | 
246 |         (IERC20Dispatcher { contract_address }, contract_address)
247 |     }
248 | 
249 | 
250 |     #[test]
251 |     #[should_panic(expected: ('ERC20: mint to 0', 'CONSTRUCTOR_FAILED'))]
252 |     fn test_deploy_when_recipient_is_address_zero() {
253 |         let recipient: ContractAddress = Zero::zero();
254 | 
255 |         let (_contract_address, _) = deploy_syscall(
256 |             erc20::TEST_CLASS_HASH.try_into().unwrap(),
257 |             recipient.into(),
258 |             array![recipient.into(), token_name, decimals.into(), initial_supply, symbols].span(),
259 |             false
260 |         )
261 |             .unwrap_syscall();
262 |     }
263 |     #[test]
264 |     fn test_deploy_success() {
265 |         let recipient = contract_address_const::<'initialized_recipient'>();
266 |         let (_, contract_address) = deploy();
267 |         assert_eq!(
268 |             starknet::testing::pop_log(contract_address),
269 |             Option::Some(
270 |                 Event::Transfer(
271 |                     Transfer { from: Zero::zero(), to: recipient, value: initial_supply }
272 |                 )
273 |             )
274 |         );
275 |     }
276 | 
277 | 
278 |     #[test]
279 |     fn test_get_name() {
280 |         let (dispatcher, _) = deploy();
281 |         let name = dispatcher.get_name();
282 |         assert(name == token_name, 'wrong token name');
283 |     }
284 | 
285 |     #[test]
286 |     fn test_get_symbol() {
287 |         let (dispatcher, _) = deploy();
288 |         assert(dispatcher.get_symbol() == symbols, 'wrong symbol');
289 |     }
290 | 
291 |     #[test]
292 |     fn test_get_decimals() {
293 |         let (dispatcher, _) = deploy();
294 |         assert(dispatcher.get_decimals() == decimals, 'wrong decimals');
295 |     }
296 | 
297 |     #[test]
298 |     fn test_total_supply() {
299 |         let (dispatcher, _) = deploy();
300 |         assert(dispatcher.get_total_supply() == initial_supply, 'wrong total supply');
301 |     }
302 | 
303 |     #[test]
304 |     fn test_balance_of_recipient_deployed() {
305 |         let recipient = contract_address_const::<'initialized_recipient'>();
306 |         let (dispatcher, _) = deploy();
307 |         assert(
308 |             dispatcher.balance_of(recipient) == initial_supply, 'incorrect balance of recipient'
309 |         );
310 |     }
311 | 
312 |     #[test]
313 |     fn test_allowance_without_approval() {
314 |         let caller = contract_address_const::<'caller'>();
315 |         let spender = contract_address_const::<'spender'>();
316 |         let (dispatcher, _) = deploy();
317 |         set_contract_address(caller);
318 |         assert(dispatcher.allowance(caller, spender) == 0, 'incorrect allowance')
319 |     }
320 | 
321 |     #[test]
322 |     fn test_allowance_after_approval() {
323 |         let caller = contract_address_const::<'caller'>();
324 |         let spender = contract_address_const::<'spender'>();
325 |         let (dispatcher, _) = deploy();
326 |         let amount = 100;
327 |         set_contract_address(caller);
328 |         dispatcher.approve(spender, amount);
329 |         assert(dispatcher.allowance(caller, spender) == amount, 'incorrect allowance')
330 |     }
331 | 
332 |     #[test]
333 |     #[should_panic(expected: ('ERC20: approve to 0', 'ENTRYPOINT_FAILED'))]
334 |     fn test_approval_spender_is_address_zero() {
335 |         let spender: ContractAddress = Zero::zero();
336 |         let amount = 100;
337 |         let (dispatcher, _) = deploy();
338 |         dispatcher.approve(spender, amount);
339 |     }
340 | 
341 |     #[test]
342 |     fn test_approval_success() {
343 |         let recipient = contract_address_const::<'initialized_recipient'>();
344 |         let spender = contract_address_const::<'spender'>();
345 |         let value = 100;
346 |         let (dispatcher, contract_address) = deploy();
347 |         let caller = contract_address_const::<'caller'>();
348 |         set_contract_address(caller);
349 |         dispatcher.approve(spender, value);
350 |         set_contract_address(contract_address);
351 | 
352 |         assert_eq!(
353 |             starknet::testing::pop_log(contract_address),
354 |             Option::Some(
355 |                 Event::Transfer(
356 |                     Transfer { from: Zero::zero(), to: recipient, value: initial_supply }
357 |                 )
358 |             )
359 |         );
360 | 
361 |         assert_eq!(
362 |             starknet::testing::pop_log(contract_address),
363 |             Option::Some(Event::Approval(Approval { owner: caller, spender, value }))
364 |         );
365 |     }
366 | 
367 |     #[test]
368 |     #[should_panic(expected: ('ERC20: approve to 0', 'ENTRYPOINT_FAILED'))]
369 |     fn test_should_increase_allowance_with_spender_zero_address() {
370 |         let spender = Zero::zero();
371 |         let amount = 100;
372 |         let (dispatcher, _) = deploy();
373 |         dispatcher.increase_allowance(spender, amount);
374 |     }
375 | 
376 |     #[test]
377 |     fn test_should_increase_allowance() {
378 |         let caller = contract_address_const::<'caller'>();
379 |         let recipient = contract_address_const::<'initialized_recipient'>();
380 |         let spender = contract_address_const::<'spender'>();
381 |         let amount = 100;
382 |         let (dispatcher, contract_address) = deploy();
383 |         set_contract_address(caller);
384 |         dispatcher.approve(spender, amount);
385 |         assert(dispatcher.allowance(caller, spender) == amount, 'incorrect allowance');
386 |         set_contract_address(caller);
387 |         dispatcher.increase_allowance(spender, 100);
388 |         assert(
389 |             dispatcher.allowance(caller, spender) == amount + 100, 'incorrect increased allowance'
390 |         );
391 | 
392 |         // emits one transfer event and two approval events
393 | 
394 |         assert_eq!(
395 |             starknet::testing::pop_log(contract_address),
396 |             Option::Some(
397 |                 Event::Transfer(
398 |                     Transfer { from: Zero::zero(), to: recipient, value: initial_supply }
399 |                 )
400 |             )
401 |         );
402 | 
403 |         assert_eq!(
404 |             starknet::testing::pop_log(contract_address),
405 |             Option::Some(Event::Approval(Approval { owner: caller, spender, value: amount }))
406 |         );
407 | 
408 |         assert_eq!(
409 |             starknet::testing::pop_log(contract_address),
410 |             Option::Some(Event::Approval(Approval { owner: caller, spender, value: amount + 100 }))
411 |         );
412 |     }
413 | 
414 |     #[test]
415 |     #[should_panic(expected: ('ERC20: approve to 0', 'ENTRYPOINT_FAILED'))]
416 |     fn test_should_decrease_allowance_with_spender_zero_address() {
417 |         let spender = Zero::zero();
418 |         let amount = 100;
419 |         let (dispatcher, _) = deploy();
420 |         dispatcher.decrease_allowance(spender, amount);
421 |     }
422 | 
423 |     #[test]
424 |     fn test_should_decrease_allowance() {
425 |         let caller = contract_address_const::<'caller'>();
426 |         let recipient = contract_address_const::<'initialized_recipient'>();
427 |         let spender = contract_address_const::<'spender'>();
428 |         let amount = 100;
429 |         let (dispatcher, contract_address) = deploy();
430 |         set_contract_address(caller);
431 |         dispatcher.approve(spender, amount);
432 |         assert(dispatcher.allowance(caller, spender) == amount, 'incorrect allowance');
433 | 
434 |         set_contract_address(caller);
435 |         dispatcher.decrease_allowance(spender, 90);
436 |         assert(
437 |             dispatcher.allowance(caller, spender) == amount - 90, 'incorrect decreased allowance'
438 |         );
439 | 
440 |         // emits one transfer event and two approval events
441 | 
442 |         assert_eq!(
443 |             starknet::testing::pop_log(contract_address),
444 |             Option::Some(
445 |                 Event::Transfer(
446 |                     Transfer { from: Zero::zero(), to: recipient, value: initial_supply }
447 |                 )
448 |             )
449 |         );
450 | 
451 |         assert_eq!(
452 |             starknet::testing::pop_log(contract_address),
453 |             Option::Some(Event::Approval(Approval { owner: caller, spender, value: amount }))
454 |         );
455 | 
456 |         assert_eq!(
457 |             starknet::testing::pop_log(contract_address),
458 |             Option::Some(Event::Approval(Approval { owner: caller, spender, value: amount - 90 }))
459 |         );
460 |     }
461 | 
462 |     #[test]
463 |     #[should_panic(expected: ('ERC20: transfer from 0', 'ENTRYPOINT_FAILED'))]
464 |     fn test_transfer_when_sender_is_address_zero() {
465 |         let receiver = contract_address_const::<'spender'>();
466 |         let amount = 100;
467 |         let (dispatcher, _) = deploy();
468 |         dispatcher.transfer(receiver, amount);
469 |     }
470 | 
471 |     #[test]
472 |     #[should_panic(expected: ('ERC20: transfer to 0', 'ENTRYPOINT_FAILED'))]
473 |     #[should_panic]
474 |     fn test_transfer_when_recipient_is_address_zero() {
475 |         let caller = contract_address_const::<'caller'>();
476 |         let receiver = Zero::zero();
477 |         let amount = 100;
478 |         let (dispatcher, _) = deploy();
479 |         set_contract_address(caller);
480 |         dispatcher.transfer(receiver, amount);
481 |     }
482 | 
483 |     #[test]
484 |     fn test_transfer_success() {
485 |         let caller = contract_address_const::<'initialized_recipient'>();
486 |         let receiver = contract_address_const::<'receiver'>();
487 |         let amount = 100;
488 |         let (dispatcher, contract_address) = deploy();
489 |         set_contract_address(caller);
490 |         dispatcher.transfer(receiver, amount);
491 |         assert_eq!(dispatcher.balance_of(receiver), amount);
492 | 
493 |         // emits two transfer events
494 |         assert_eq!(
495 |             starknet::testing::pop_log(contract_address),
496 |             Option::Some(
497 |                 Event::Transfer(Transfer { from: Zero::zero(), to: caller, value: initial_supply })
498 |             )
499 |         );
500 | 
501 |         assert_eq!(
502 |             starknet::testing::pop_log(contract_address),
503 |             Option::Some(Event::Transfer(Transfer { from: caller, to: receiver, value: amount }))
504 |         );
505 |     }
506 | 
507 | 
508 |     #[test]
509 |     #[should_panic(expected: ('ERC20: transfer from 0', 'ENTRYPOINT_FAILED'))]
510 |     #[should_panic]
511 |     fn test_transferFrom_when_sender_is_address_zero() {
512 |         let sender = Zero::zero();
513 |         let amount = 100;
514 |         let receiver = contract_address_const::<'spender'>();
515 |         let (dispatcher, _) = deploy();
516 |         dispatcher.transfer_from(sender, receiver, amount);
517 |     }
518 | 
519 |     #[test]
520 |     #[should_panic(expected: ('ERC20: transfer to 0', 'ENTRYPOINT_FAILED'))]
521 |     #[should_panic]
522 |     fn test_transferFrom_when_recipient_is_address_zero() {
523 |         let caller = contract_address_const::<'caller'>();
524 |         let receiver = Zero::zero();
525 |         let amount = 100;
526 |         let (dispatcher, _) = deploy();
527 |         set_contract_address(caller);
528 |         dispatcher.transfer_from(caller, receiver, amount);
529 |     }
530 | 
531 |     #[test]
532 |     fn test_transferFrom_success() {
533 |         let caller = contract_address_const::<'initialized_recipient'>();
534 |         let receiver = contract_address_const::<'receiver'>();
535 |         let amount = 100;
536 |         let (dispatcher, contract_address) = deploy();
537 |         set_contract_address(caller);
538 |         dispatcher.transfer_from(caller, receiver, amount);
539 |         assert_eq!(dispatcher.balance_of(receiver), amount);
540 | 
541 |         // emits two transfer events
542 | 
543 |         assert_eq!(
544 |             starknet::testing::pop_log(contract_address),
545 |             Option::Some(
546 |                 Event::Transfer(Transfer { from: Zero::zero(), to: caller, value: initial_supply })
547 |             )
548 |         );
549 | 
550 |         assert_eq!(
551 |             starknet::testing::pop_log(contract_address),
552 |             Option::Some(Event::Transfer(Transfer { from: caller, to: receiver, value: amount }))
553 |         );
554 |     }
555 | }
556 | 


--------------------------------------------------------------------------------
/listings/applications/merkle_tree/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/merkle_tree/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "merkle_tree"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/applications/merkle_tree/src/contract.cairo:
--------------------------------------------------------------------------------
  1 | #[generate_trait]
  2 | pub impl ByteArrayHashTraitImpl of ByteArrayHashTrait {
  3 |     fn hash(self: @ByteArray) -> felt252 {
  4 |         let mut serialized_byte_arr: Array<felt252> = ArrayTrait::new();
  5 |         self.serialize(ref serialized_byte_arr);
  6 | 
  7 |         core::poseidon::poseidon_hash_span(serialized_byte_arr.span())
  8 |     }
  9 | }
 10 | 
 11 | #[starknet::interface]
 12 | pub trait IMerkleTree<TContractState> {
 13 |     fn build_tree(ref self: TContractState, data: Array<ByteArray>) -> Array<felt252>;
 14 |     fn get_root(self: @TContractState) -> felt252;
 15 |     // function to verify if leaf node exists in the merkle tree
 16 |     fn verify(
 17 |         self: @TContractState, proof: Array<felt252>, root: felt252, leaf: felt252, index: usize
 18 |     ) -> bool;
 19 | }
 20 | 
 21 | mod errors {
 22 |     pub const NOT_POW_2: felt252 = 'Data length is not a power of 2';
 23 |     pub const NOT_PRESENT: felt252 = 'No element in merkle tree';
 24 | }
 25 | 
 26 | #[starknet::contract]
 27 | pub mod MerkleTree {
 28 |     use core::poseidon::PoseidonTrait;
 29 |     use core::hash::{HashStateTrait, HashStateExTrait};
 30 |     use starknet::storage::{
 31 |         StoragePointerWriteAccess, StoragePointerReadAccess, Vec, MutableVecTrait, VecTrait
 32 |     };
 33 |     use super::ByteArrayHashTrait;
 34 | 
 35 |     #[storage]
 36 |     struct Storage {
 37 |         pub hashes: Vec<felt252>
 38 |     }
 39 | 
 40 |     #[derive(Drop, Serde, Copy)]
 41 |     struct Vec2 {
 42 |         x: u32,
 43 |         y: u32
 44 |     }
 45 | 
 46 |     #[abi(embed_v0)]
 47 |     impl IMerkleTreeImpl of super::IMerkleTree<ContractState> {
 48 |         fn build_tree(ref self: ContractState, mut data: Array<ByteArray>) -> Array<felt252> {
 49 |             let data_len = data.len();
 50 |             assert(data_len > 0 && (data_len & (data_len - 1)) == 0, super::errors::NOT_POW_2);
 51 | 
 52 |             let mut _hashes: Array<felt252> = ArrayTrait::new();
 53 | 
 54 |             // first, hash every leaf
 55 |             for value in data {
 56 |                 _hashes.append(value.hash());
 57 |             };
 58 | 
 59 |             // then, hash all levels above leaves
 60 |             let mut current_nodes_lvl_len = data_len;
 61 |             let mut hashes_offset = 0;
 62 | 
 63 |             while current_nodes_lvl_len > 0 {
 64 |                 let mut i = 0;
 65 |                 while i < current_nodes_lvl_len - 1 {
 66 |                     let left_elem = *_hashes.at(hashes_offset + i);
 67 |                     let right_elem = *_hashes.at(hashes_offset + i + 1);
 68 | 
 69 |                     let hash = PoseidonTrait::new().update_with((left_elem, right_elem)).finalize();
 70 |                     _hashes.append(hash);
 71 | 
 72 |                     i += 2;
 73 |                 };
 74 | 
 75 |                 hashes_offset += current_nodes_lvl_len;
 76 |                 current_nodes_lvl_len /= 2;
 77 |             };
 78 | 
 79 |             // write to the contract state (useful for the get_root function)
 80 |             for hash in _hashes.span() {
 81 |                 self.hashes.append().write(*hash);
 82 |             };
 83 | 
 84 |             _hashes
 85 |         }
 86 | 
 87 |         fn get_root(self: @ContractState) -> felt252 {
 88 |             let merkle_tree_length = self.hashes.len();
 89 |             assert(merkle_tree_length > 0, super::errors::NOT_PRESENT);
 90 | 
 91 |             self.hashes.at(merkle_tree_length - 1).read()
 92 |         }
 93 | 
 94 |         fn verify(
 95 |             self: @ContractState,
 96 |             mut proof: Array<felt252>,
 97 |             root: felt252,
 98 |             leaf: felt252,
 99 |             mut index: usize
100 |         ) -> bool {
101 |             let mut current_hash = leaf;
102 | 
103 |             while let Option::Some(value) = proof.pop_front() {
104 |                 current_hash =
105 |                     if index % 2 == 0 {
106 |                         PoseidonTrait::new().update_with((current_hash, value)).finalize()
107 |                     } else {
108 |                         PoseidonTrait::new().update_with((value, current_hash)).finalize()
109 |                     };
110 | 
111 |                 index /= 2;
112 |             };
113 | 
114 |             current_hash == root
115 |         }
116 |     }
117 | }
118 | 


--------------------------------------------------------------------------------
/listings/applications/merkle_tree/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/applications/merkle_tree/src/tests.cairo:
--------------------------------------------------------------------------------
  1 | use merkle_tree::contract::IMerkleTreeDispatcherTrait;
  2 | use merkle_tree::contract::{IMerkleTreeDispatcher, MerkleTree, ByteArrayHashTrait};
  3 | use starknet::syscalls::deploy_syscall;
  4 | use starknet::{ContractAddress, SyscallResultTrait};
  5 | use starknet::testing::set_contract_address;
  6 | use core::poseidon::PoseidonTrait;
  7 | use core::hash::{HashStateTrait, HashStateExTrait};
  8 | use starknet::storage::{VecTrait, StoragePointerReadAccess};
  9 | 
 10 | fn deploy_util(class_hash: felt252, calldata: Array<felt252>) -> ContractAddress {
 11 |     let (address, _) = deploy_syscall(class_hash.try_into().unwrap(), 0, calldata.span(), false)
 12 |         .unwrap_syscall();
 13 |     address
 14 | }
 15 | 
 16 | fn setup() -> IMerkleTreeDispatcher {
 17 |     let contract_address = deploy_util(MerkleTree::TEST_CLASS_HASH, array![]);
 18 | 
 19 |     IMerkleTreeDispatcher { contract_address }
 20 | }
 21 | 
 22 | #[test]
 23 | fn should_deploy() {
 24 |     let deploy = setup();
 25 | 
 26 |     let state = @MerkleTree::contract_state_for_testing();
 27 |     // "link" a new MerkleTree struct to the deployed MerkleTree contract
 28 |     // in order to access its internal state fields for assertions
 29 |     set_contract_address(deploy.contract_address);
 30 | 
 31 |     assert_eq!(state.hashes.len(), 0);
 32 | }
 33 | 
 34 | #[test]
 35 | fn build_tree_succeeds() {
 36 |     /// Set up
 37 |     let deploy = setup();
 38 | 
 39 |     let data_1 = "alice -> bob: 2";
 40 |     let data_2 = "bob -> john: 5";
 41 |     let data_3 = "alice -> john: 1";
 42 |     let data_4 = "john -> alex: 8";
 43 |     let arguments = array![data_1.clone(), data_2.clone(), data_3.clone(), data_4.clone()];
 44 | 
 45 |     /// When
 46 |     let actual_hashes = deploy.build_tree(arguments);
 47 | 
 48 |     /// Then
 49 |     let mut expected_hashes: Array<felt252> = array![];
 50 | 
 51 |     // leaves' hashes
 52 |     expected_hashes.append(data_1.hash());
 53 |     expected_hashes.append(data_2.hash());
 54 |     expected_hashes.append(data_3.hash());
 55 |     expected_hashes.append(data_4.hash());
 56 | 
 57 |     // hashes for level above leaves
 58 |     let hash_0 = PoseidonTrait::new()
 59 |         .update_with((*expected_hashes.at(0), *expected_hashes.at(1)))
 60 |         .finalize();
 61 |     let hash_1 = PoseidonTrait::new()
 62 |         .update_with((*expected_hashes.at(2), *expected_hashes.at(3)))
 63 |         .finalize();
 64 |     expected_hashes.append(hash_0);
 65 |     expected_hashes.append(hash_1);
 66 | 
 67 |     // root hash
 68 |     let root_hash = PoseidonTrait::new().update_with((hash_0, hash_1)).finalize();
 69 |     expected_hashes.append(root_hash);
 70 | 
 71 |     // verify returned result
 72 |     assert_eq!(actual_hashes, expected_hashes);
 73 | 
 74 |     // verify get_root
 75 |     assert_eq!(deploy.get_root(), root_hash);
 76 | 
 77 |     // verify contract storage state
 78 | 
 79 |     let state = @MerkleTree::contract_state_for_testing();
 80 |     // "link" a new MerkleTree struct to the deployed MerkleTree contract
 81 |     // in order to access its internal state fields for assertions
 82 |     set_contract_address(deploy.contract_address);
 83 | 
 84 |     assert_eq!(state.hashes.len(), expected_hashes.len().into());
 85 | 
 86 |     for i in 0
 87 |         ..expected_hashes
 88 |             .len() {
 89 |                 assert_eq!(state.hashes.at(i.into()).read(), *expected_hashes.at(i));
 90 |             }
 91 | }
 92 | 
 93 | #[test]
 94 | #[should_panic(expected: ('Data length is not a power of 2', 'ENTRYPOINT_FAILED'))]
 95 | fn build_tree_fails() {
 96 |     /// Set up
 97 |     let deploy = setup();
 98 | 
 99 |     let data_1 = "alice -> bob: 2";
100 |     let data_2 = "bob -> john: 5";
101 |     let data_3 = "alice -> john: 1";
102 |     // number of arguments not a power of 2
103 |     let arguments = array![data_1, data_2, data_3];
104 | 
105 |     /// When
106 |     deploy.build_tree(arguments);
107 | }
108 | 
109 | #[test]
110 | fn verify_leaf_succeeds() {
111 |     /// Set up
112 |     let deploy = setup();
113 | 
114 |     let data_1 = "bob -> alice: 1";
115 |     let data_2 = "alex -> john: 3";
116 |     let data_3 = "alice -> alex: 8";
117 |     let data_4 = "alex -> bob: 8";
118 |     let arguments = array![data_1.clone(), data_2.clone(), data_3.clone(), data_4.clone()];
119 | 
120 |     let hashes = deploy.build_tree(arguments);
121 | 
122 |     //       ----> hashes tree :
123 |     //
124 |     //              hashes[6]
125 |     //            /         \
126 |     //        hashes[4]    hashes[5]
127 |     //       /     \          /      \
128 |     //  hashes[0] hashes[1]  hashes[2] hashes[3]
129 | 
130 |     let res = deploy
131 |         .verify(
132 |             array![*hashes.at(3), *hashes.at(4)], // proof
133 |             *hashes.at(6), // root
134 |             data_3.hash(), // leaf
135 |             2 // leaf index
136 |         );
137 | 
138 |     assert(res, 'Leaf should be in merkle tree');
139 | }
140 | 
141 | #[test]
142 | #[available_gas(20000000)]
143 | fn verify_leaf_fails() {
144 |     /// Set up
145 |     let deploy = setup();
146 | 
147 |     let data_1 = "bob -> alice: 1";
148 |     let data_2 = "alex -> john: 3";
149 |     let data_3 = "alice -> alex: 8";
150 |     let data_4 = "alex -> bob: 8";
151 |     let arguments = array![data_1.clone(), data_2.clone(), data_3.clone(), data_4.clone()];
152 | 
153 |     let hashes = deploy.build_tree(arguments);
154 | 
155 |     //       ----- hashes tree -----
156 |     //              hashes[6]
157 |     //            /          \
158 |     //        hashes[4]     hashes[5]
159 |     //       /     \          /       \
160 |     //  hashes[0] hashes[1]  hashes[2] hashes[3]
161 | 
162 |     let wrong_leaf: ByteArray = "alice -> alex: 9";
163 |     let res = deploy
164 |         .verify(
165 |             array![*hashes.at(3), *hashes.at(4)], // proof
166 |             *hashes.at(6), // root
167 |             wrong_leaf.hash(), // leaf
168 |             2 // leaf index
169 |         );
170 |     assert(!res, '1- Leaf should NOT be in tree');
171 | 
172 |     let wrong_proof = array![*hashes.at(4), *hashes.at(3)];
173 |     let res = deploy
174 |         .verify(
175 |             wrong_proof, // proof
176 |              *hashes.at(6), // root
177 |              data_3.hash(), // leaf
178 |              2 // leaf index
179 |         );
180 |     assert(!res, '2- Leaf should NOT be in tree');
181 | }
182 | 
183 | 


--------------------------------------------------------------------------------
/listings/applications/nft_dutch_auction/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/nft_dutch_auction/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "nft_dutch_auction"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | erc20 = { path = "../erc20" }
 8 | starknet.workspace = true
 9 | 
10 | [dev-dependencies]
11 | assert_macros.workspace = true
12 | snforge_std.workspace = true
13 | 
14 | [scripts]
15 | test.workspace = true
16 | 
17 | [[target.starknet-contract]]
18 | build-external-contracts = ["erc20::token::erc20"]
19 | 


--------------------------------------------------------------------------------
/listings/applications/nft_dutch_auction/src/erc721.cairo:
--------------------------------------------------------------------------------
  1 | use starknet::ContractAddress;
  2 | 
  3 | #[starknet::interface]
  4 | pub trait IERC721<TContractState> {
  5 |     fn get_name(self: @TContractState) -> felt252;
  6 |     fn get_symbol(self: @TContractState) -> felt252;
  7 |     fn get_token_uri(self: @TContractState, token_id: u256) -> felt252;
  8 |     fn balance_of(self: @TContractState, account: ContractAddress) -> u256;
  9 |     fn owner_of(self: @TContractState, token_id: u256) -> ContractAddress;
 10 |     fn get_approved(self: @TContractState, token_id: u256) -> ContractAddress;
 11 |     fn is_approved_for_all(
 12 |         self: @TContractState, owner: ContractAddress, operator: ContractAddress
 13 |     ) -> bool;
 14 |     fn approve(ref self: TContractState, to: ContractAddress, token_id: u256);
 15 |     fn set_approval_for_all(ref self: TContractState, operator: ContractAddress, approved: bool);
 16 |     fn transfer_from(
 17 |         ref self: TContractState, from: ContractAddress, to: ContractAddress, token_id: u256
 18 |     );
 19 |     fn mint(ref self: TContractState, to: ContractAddress, token_id: u256);
 20 | }
 21 | 
 22 | #[starknet::contract]
 23 | mod ERC721 {
 24 |     ////////////////////////////////
 25 |     // library imports
 26 |     ////////////////////////////////
 27 |     use starknet::{ContractAddress, get_caller_address};
 28 |     use starknet::storage::{
 29 |         Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
 30 |         StoragePointerWriteAccess
 31 |     };
 32 |     use core::num::traits::Zero;
 33 | 
 34 |     ////////////////////////////////
 35 |     // storage variables
 36 |     ////////////////////////////////
 37 |     #[storage]
 38 |     struct Storage {
 39 |         name: felt252,
 40 |         symbol: felt252,
 41 |         owners: Map::<u256, ContractAddress>,
 42 |         balances: Map::<ContractAddress, u256>,
 43 |         token_approvals: Map::<u256, ContractAddress>,
 44 |         operator_approvals: Map::<(ContractAddress, ContractAddress), bool>,
 45 |         token_uri: Map<u256, felt252>,
 46 |     }
 47 | 
 48 |     #[event]
 49 |     #[derive(Drop, starknet::Event)]
 50 |     enum Event {
 51 |         Approval: Approval,
 52 |         Transfer: Transfer,
 53 |         ApprovalForAll: ApprovalForAll
 54 |     }
 55 | 
 56 |     ////////////////////////////////
 57 |     // Approval event emitted on token approval
 58 |     ////////////////////////////////
 59 |     #[derive(Drop, starknet::Event)]
 60 |     struct Approval {
 61 |         owner: ContractAddress,
 62 |         to: ContractAddress,
 63 |         token_id: u256
 64 |     }
 65 | 
 66 |     ////////////////////////////////
 67 |     // Transfer event emitted on token transfer
 68 |     ////////////////////////////////
 69 |     #[derive(Drop, starknet::Event)]
 70 |     struct Transfer {
 71 |         from: ContractAddress,
 72 |         to: ContractAddress,
 73 |         token_id: u256
 74 |     }
 75 | 
 76 |     ////////////////////////////////
 77 |     // ApprovalForAll event emitted on approval for operators
 78 |     ////////////////////////////////
 79 |     #[derive(Drop, starknet::Event)]
 80 |     struct ApprovalForAll {
 81 |         owner: ContractAddress,
 82 |         operator: ContractAddress,
 83 |         approved: bool
 84 |     }
 85 | 
 86 | 
 87 |     ////////////////////////////////
 88 |     // Constructor - initialized on deployment
 89 |     ////////////////////////////////
 90 |     #[constructor]
 91 |     fn constructor(ref self: ContractState, _name: felt252, _symbol: felt252) {
 92 |         self.name.write(_name);
 93 |         self.symbol.write(_symbol);
 94 |     }
 95 | 
 96 |     #[abi(embed_v0)]
 97 |     impl IERC721Impl of super::IERC721<ContractState> {
 98 |         ////////////////////////////////
 99 |         // get_name function returns token name
100 |         ////////////////////////////////
101 |         fn get_name(self: @ContractState) -> felt252 {
102 |             self.name.read()
103 |         }
104 | 
105 |         ////////////////////////////////
106 |         // get_symbol function returns token symbol
107 |         ////////////////////////////////
108 |         fn get_symbol(self: @ContractState) -> felt252 {
109 |             self.symbol.read()
110 |         }
111 | 
112 |         ////////////////////////////////
113 |         // token_uri returns the token uri
114 |         ////////////////////////////////
115 |         fn get_token_uri(self: @ContractState, token_id: u256) -> felt252 {
116 |             assert(self._exists(token_id), 'ERC721: invalid token ID');
117 |             self.token_uri.read(token_id)
118 |         }
119 | 
120 |         ////////////////////////////////
121 |         // balance_of function returns token balance
122 |         ////////////////////////////////
123 |         fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {
124 |             assert(account.is_non_zero(), 'ERC721: address zero');
125 |             self.balances.read(account)
126 |         }
127 | 
128 |         ////////////////////////////////
129 |         // owner_of function returns owner of token_id
130 |         ////////////////////////////////
131 |         fn owner_of(self: @ContractState, token_id: u256) -> ContractAddress {
132 |             let owner = self.owners.read(token_id);
133 |             owner
134 |         }
135 | 
136 |         ////////////////////////////////
137 |         // get_approved function returns approved address for a token
138 |         ////////////////////////////////
139 |         fn get_approved(self: @ContractState, token_id: u256) -> ContractAddress {
140 |             assert(self._exists(token_id), 'ERC721: invalid token ID');
141 |             self.token_approvals.read(token_id)
142 |         }
143 | 
144 |         ////////////////////////////////
145 |         // is_approved_for_all function returns approved operator for a token
146 |         ////////////////////////////////
147 |         fn is_approved_for_all(
148 |             self: @ContractState, owner: ContractAddress, operator: ContractAddress
149 |         ) -> bool {
150 |             self.operator_approvals.read((owner, operator))
151 |         }
152 | 
153 |         ////////////////////////////////
154 |         // approve function approves an address to spend a token
155 |         ////////////////////////////////
156 |         fn approve(ref self: ContractState, to: ContractAddress, token_id: u256) {
157 |             let owner = self.owner_of(token_id);
158 |             assert(to != owner, 'Approval to current owner');
159 |             assert(
160 |                 get_caller_address() == owner
161 |                     || self.is_approved_for_all(owner, get_caller_address()),
162 |                 'Not token owner'
163 |             );
164 |             self.token_approvals.write(token_id, to);
165 |             self.emit(Approval { owner: self.owner_of(token_id), to: to, token_id: token_id });
166 |         }
167 | 
168 |         ////////////////////////////////
169 |         // set_approval_for_all function approves an operator to spend all tokens
170 |         ////////////////////////////////
171 |         fn set_approval_for_all(
172 |             ref self: ContractState, operator: ContractAddress, approved: bool
173 |         ) {
174 |             let owner = get_caller_address();
175 |             assert(owner != operator, 'ERC721: approve to caller');
176 |             self.operator_approvals.write((owner, operator), approved);
177 |             self.emit(ApprovalForAll { owner: owner, operator: operator, approved: approved });
178 |         }
179 | 
180 |         ////////////////////////////////
181 |         // transfer_from function is used to transfer a token
182 |         ////////////////////////////////
183 |         fn transfer_from(
184 |             ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256
185 |         ) {
186 |             assert(
187 |                 self._is_approved_or_owner(get_caller_address(), token_id),
188 |                 'neither owner nor approved'
189 |             );
190 |             self._transfer(from, to, token_id);
191 |         }
192 | 
193 |         fn mint(ref self: ContractState, to: ContractAddress, token_id: u256) {
194 |             self._mint(to, token_id);
195 |         }
196 |     }
197 | 
198 |     #[generate_trait]
199 |     impl ERC721HelperImpl of ERC721HelperTrait {
200 |         ////////////////////////////////
201 |         // internal function to check if a token exists
202 |         ////////////////////////////////
203 |         fn _exists(self: @ContractState, token_id: u256) -> bool {
204 |             // check that owner of token is not zero
205 |             self.owner_of(token_id).is_non_zero()
206 |         }
207 | 
208 |         ////////////////////////////////
209 |         // _is_approved_or_owner checks if an address is an approved spender or owner
210 |         ////////////////////////////////
211 |         fn _is_approved_or_owner(
212 |             self: @ContractState, spender: ContractAddress, token_id: u256
213 |         ) -> bool {
214 |             let owner = self.owners.read(token_id);
215 |             spender == owner
216 |                 || self.is_approved_for_all(owner, spender)
217 |                 || self.get_approved(token_id) == spender
218 |         }
219 | 
220 |         ////////////////////////////////
221 |         // internal function that sets the token uri
222 |         ////////////////////////////////
223 |         fn _set_token_uri(ref self: ContractState, token_id: u256, token_uri: felt252) {
224 |             assert(self._exists(token_id), 'ERC721: invalid token ID');
225 |             self.token_uri.write(token_id, token_uri)
226 |         }
227 | 
228 |         ////////////////////////////////
229 |         // internal function that performs the transfer logic
230 |         ////////////////////////////////
231 |         fn _transfer(
232 |             ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256
233 |         ) {
234 |             // check that from address is equal to owner of token
235 |             assert(from == self.owner_of(token_id), 'ERC721: Caller is not owner');
236 |             // check that to address is not zero
237 |             assert(to.is_non_zero(), 'ERC721: transfer to 0 address');
238 | 
239 |             // remove previously made approvals
240 |             self.token_approvals.write(token_id, Zero::zero());
241 | 
242 |             // increase balance of to address, decrease balance of from address
243 |             self.balances.write(from, self.balances.read(from) - 1.into());
244 |             self.balances.write(to, self.balances.read(to) + 1.into());
245 | 
246 |             // update token_id owner
247 |             self.owners.write(token_id, to);
248 | 
249 |             // emit the Transfer event
250 |             self.emit(Transfer { from: from, to: to, token_id: token_id });
251 |         }
252 | 
253 |         ////////////////////////////////
254 |         // _mint function mints a new token to the to address
255 |         ////////////////////////////////
256 |         fn _mint(ref self: ContractState, to: ContractAddress, token_id: u256) {
257 |             assert(to.is_non_zero(), 'TO_IS_ZERO_ADDRESS');
258 | 
259 |             // Ensures token_id is unique
260 |             assert(!self.owner_of(token_id).is_non_zero(), 'ERC721: Token already minted');
261 | 
262 |             // Increase receiver balance
263 |             let receiver_balance = self.balances.read(to);
264 |             self.balances.write(to, receiver_balance + 1.into());
265 | 
266 |             // Update token_id owner
267 |             self.owners.write(token_id, to);
268 | 
269 |             // emit Transfer event
270 |             self.emit(Transfer { from: Zero::zero(), to: to, token_id: token_id });
271 |         }
272 | 
273 |         ////////////////////////////////
274 |         // _burn function burns token from owner's account
275 |         ////////////////////////////////
276 |         fn _burn(ref self: ContractState, token_id: u256) {
277 |             let owner = self.owner_of(token_id);
278 | 
279 |             // Clear approvals
280 |             self.token_approvals.write(token_id, Zero::zero());
281 | 
282 |             // Decrease owner balance
283 |             let owner_balance = self.balances.read(owner);
284 |             self.balances.write(owner, owner_balance - 1.into());
285 | 
286 |             // Delete owner
287 |             self.owners.write(token_id, Zero::zero());
288 |             // emit the Transfer event
289 |             self.emit(Transfer { from: owner, to: Zero::zero(), token_id: token_id });
290 |         }
291 |     }
292 | }
293 | 


--------------------------------------------------------------------------------
/listings/applications/nft_dutch_auction/src/lib.cairo:
--------------------------------------------------------------------------------
1 | pub mod nft_dutch_auction;
2 | pub mod erc721;
3 | 


--------------------------------------------------------------------------------
/listings/applications/nft_dutch_auction/src/nft_dutch_auction.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | use starknet::ContractAddress;
  3 | 
  4 | #[starknet::interface]
  5 | pub trait IERC20<TContractState> {
  6 |     fn get_name(self: @TContractState) -> felt252;
  7 |     fn get_symbol(self: @TContractState) -> felt252;
  8 |     fn get_decimals(self: @TContractState) -> u8;
  9 |     fn get_total_supply(self: @TContractState) -> felt252;
 10 |     fn balance_of(self: @TContractState, account: ContractAddress) -> felt252;
 11 |     fn allowance(
 12 |         self: @TContractState, owner: ContractAddress, spender: ContractAddress
 13 |     ) -> felt252;
 14 |     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: felt252);
 15 |     fn transfer_from(
 16 |         ref self: TContractState,
 17 |         sender: ContractAddress,
 18 |         recipient: ContractAddress,
 19 |         amount: felt252
 20 |     );
 21 |     fn approve(ref self: TContractState, spender: ContractAddress, amount: felt252);
 22 |     fn increase_allowance(ref self: TContractState, spender: ContractAddress, added_value: felt252);
 23 |     fn decrease_allowance(
 24 |         ref self: TContractState, spender: ContractAddress, subtracted_value: felt252
 25 |     );
 26 | }
 27 | 
 28 | #[starknet::interface]
 29 | trait IERC721<TContractState> {
 30 |     fn get_name(self: @TContractState) -> felt252;
 31 |     fn get_symbol(self: @TContractState) -> felt252;
 32 |     fn get_token_uri(self: @TContractState, token_id: u256) -> felt252;
 33 |     fn balance_of(self: @TContractState, account: ContractAddress) -> u256;
 34 |     fn owner_of(self: @TContractState, token_id: u256) -> ContractAddress;
 35 |     fn get_approved(self: @TContractState, token_id: u256) -> ContractAddress;
 36 |     fn is_approved_for_all(
 37 |         self: @TContractState, owner: ContractAddress, operator: ContractAddress
 38 |     ) -> bool;
 39 |     fn approve(ref self: TContractState, to: ContractAddress, token_id: u256);
 40 |     fn set_approval_for_all(ref self: TContractState, operator: ContractAddress, approved: bool);
 41 |     fn transfer_from(
 42 |         ref self: TContractState, from: ContractAddress, to: ContractAddress, token_id: u256
 43 |     );
 44 |     fn mint(ref self: TContractState, to: ContractAddress, token_id: u256);
 45 | }
 46 | 
 47 | #[starknet::interface]
 48 | pub trait INFTDutchAuction<TContractState> {
 49 |     fn buy(ref self: TContractState, token_id: u256);
 50 |     fn get_price(self: @TContractState) -> u64;
 51 | }
 52 | 
 53 | #[starknet::contract]
 54 | pub mod NFTDutchAuction {
 55 |     use super::{IERC20Dispatcher, IERC20DispatcherTrait, IERC721Dispatcher, IERC721DispatcherTrait};
 56 |     use starknet::{ContractAddress, get_caller_address, get_block_timestamp};
 57 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 58 | 
 59 |     #[storage]
 60 |     struct Storage {
 61 |         erc20_token: ContractAddress,
 62 |         erc721_token: ContractAddress,
 63 |         starting_price: u64,
 64 |         seller: ContractAddress,
 65 |         duration: u64,
 66 |         discount_rate: u64,
 67 |         start_at: u64,
 68 |         expires_at: u64,
 69 |         purchase_count: u128,
 70 |         total_supply: u128
 71 |     }
 72 | 
 73 |     mod Errors {
 74 |         pub const AUCTION_ENDED: felt252 = 'auction has ended';
 75 |         pub const LOW_STARTING_PRICE: felt252 = 'low starting price';
 76 |         pub const INSUFFICIENT_BALANCE: felt252 = 'insufficient balance';
 77 |     }
 78 | 
 79 |     #[constructor]
 80 |     fn constructor(
 81 |         ref self: ContractState,
 82 |         erc20_token: ContractAddress,
 83 |         erc721_token: ContractAddress,
 84 |         starting_price: u64,
 85 |         seller: ContractAddress,
 86 |         duration: u64,
 87 |         discount_rate: u64,
 88 |         total_supply: u128
 89 |     ) {
 90 |         assert(starting_price >= discount_rate * duration, Errors::LOW_STARTING_PRICE);
 91 | 
 92 |         self.erc20_token.write(erc20_token);
 93 |         self.erc721_token.write(erc721_token);
 94 |         self.starting_price.write(starting_price);
 95 |         self.seller.write(seller);
 96 |         self.duration.write(duration);
 97 |         self.discount_rate.write(discount_rate);
 98 |         self.start_at.write(get_block_timestamp());
 99 |         self.expires_at.write(get_block_timestamp() + duration * 1000);
100 |         self.total_supply.write(total_supply);
101 |     }
102 | 
103 |     #[abi(embed_v0)]
104 |     impl NFTDutchAuction of super::INFTDutchAuction<ContractState> {
105 |         fn get_price(self: @ContractState) -> u64 {
106 |             let time_elapsed = (get_block_timestamp() - self.start_at.read())
107 |                 / 1000; // Ignore milliseconds
108 |             let discount = self.discount_rate.read() * time_elapsed;
109 |             self.starting_price.read() - discount
110 |         }
111 | 
112 |         fn buy(ref self: ContractState, token_id: u256) {
113 |             // Check duration
114 |             assert(get_block_timestamp() < self.expires_at.read(), Errors::AUCTION_ENDED);
115 |             // Check total supply
116 |             assert(self.purchase_count.read() < self.total_supply.read(), Errors::AUCTION_ENDED);
117 | 
118 |             let erc20_dispatcher = IERC20Dispatcher { contract_address: self.erc20_token.read() };
119 |             let erc721_dispatcher = IERC721Dispatcher {
120 |                 contract_address: self.erc721_token.read()
121 |             };
122 | 
123 |             let caller = get_caller_address();
124 |             // Get NFT price
125 |             let price: u256 = self.get_price().into();
126 |             let buyer_balance: u256 = erc20_dispatcher.balance_of(caller).into();
127 |             // Ensure buyer has enough token for payment
128 |             assert(buyer_balance >= price, Errors::INSUFFICIENT_BALANCE);
129 |             // Transfer payment token from buyer to seller
130 |             erc20_dispatcher.transfer_from(caller, self.seller.read(), price.try_into().unwrap());
131 |             // Mint token to buyer's address
132 |             erc721_dispatcher.mint(caller, token_id);
133 |             // Increase purchase count
134 |             self.purchase_count.write(self.purchase_count.read() + 1);
135 |         }
136 |     }
137 | }
138 | // [!endregion contract]
139 | 
140 | #[cfg(test)]
141 | mod tests {
142 |     use starknet::ContractAddress;
143 |     use snforge_std::{
144 |         declare, DeclareResultTrait, ContractClassTrait, cheat_caller_address, CheatSpan,
145 |         cheat_block_timestamp
146 |     };
147 |     use nft_dutch_auction::erc721::{IERC721Dispatcher, IERC721DispatcherTrait};
148 |     use super::{INFTDutchAuctionDispatcher, INFTDutchAuctionDispatcherTrait};
149 |     use erc20::token::{IERC20Dispatcher, IERC20DispatcherTrait};
150 | 
151 |     // ERC721 token
152 |     pub const erc721_name: felt252 = 'My NFT';
153 |     pub const erc721_symbol: felt252 = 'MNFT';
154 | 
155 |     // ERC20 token
156 |     pub const erc20_name: felt252 = 'My Token';
157 |     pub const erc20_symbol: felt252 = 'MTKN';
158 |     pub const erc20_recipient: felt252 = 'admin';
159 |     pub const erc20_decimals: u8 = 1_u8;
160 |     pub const erc20_initial_supply: u128 = 10000_u128;
161 | 
162 |     // NFT Auction
163 |     pub const starting_price: felt252 = 500;
164 |     pub const seller: felt252 = 'seller';
165 |     pub const duration: felt252 = 60; // in seconds
166 |     pub const discount_rate: felt252 = 5;
167 |     pub const total_supply: felt252 = 2;
168 | 
169 |     fn get_contract_addresses() -> (ContractAddress, ContractAddress, ContractAddress) {
170 |         let erc721 = declare("ERC721").unwrap().contract_class();
171 |         let erc721_constructor_calldata = array![erc721_name, erc721_symbol];
172 |         let (erc721_address, _) = erc721.deploy(@erc721_constructor_calldata).unwrap();
173 |         let erc20 = declare("erc20").unwrap().contract_class();
174 |         let erc20_constructor_calldata = array![
175 |             erc20_recipient,
176 |             erc20_name,
177 |             erc20_decimals.into(),
178 |             erc20_initial_supply.into(),
179 |             erc20_symbol
180 |         ];
181 |         let (erc20_address, _) = erc20.deploy(@erc20_constructor_calldata).unwrap();
182 |         let nft_auction = declare("NFTDutchAuction").unwrap().contract_class();
183 |         let nft_auction_constructor_calldata = array![
184 |             erc20_address.into(),
185 |             erc721_address.into(),
186 |             starting_price,
187 |             seller,
188 |             duration,
189 |             discount_rate,
190 |             total_supply
191 |         ];
192 |         let (nft_auction_address, _) = nft_auction
193 |             .deploy(@nft_auction_constructor_calldata)
194 |             .unwrap();
195 |         (erc721_address, erc20_address, nft_auction_address)
196 |     }
197 | 
198 |     #[test]
199 |     fn test_buy() {
200 |         let (erc721_address, erc20_address, nft_auction_address) = get_contract_addresses();
201 |         let erc721_dispatcher = IERC721Dispatcher { contract_address: erc721_address };
202 |         let erc20_dispatcher = IERC20Dispatcher { contract_address: erc20_address };
203 |         let nft_auction_dispatcher = INFTDutchAuctionDispatcher {
204 |             contract_address: nft_auction_address
205 |         };
206 |         let erc20_admin: ContractAddress = 'admin'.try_into().unwrap();
207 |         let seller: ContractAddress = 'seller'.try_into().unwrap();
208 |         let buyer: ContractAddress = 'buyer'.try_into().unwrap();
209 | 
210 |         // Transfer erc20 tokens to buyer
211 |         assert_eq!(erc20_dispatcher.balance_of(buyer), 0.into());
212 |         cheat_caller_address(erc20_address, erc20_admin, CheatSpan::TargetCalls(1));
213 |         let transfer_amt = 5000;
214 |         erc20_dispatcher.transfer(buyer, transfer_amt.into());
215 |         assert_eq!(erc20_dispatcher.balance_of(buyer), transfer_amt.into());
216 | 
217 |         // Buy token
218 |         cheat_caller_address(nft_auction_address, buyer, CheatSpan::TargetCalls(3));
219 |         cheat_caller_address(erc20_address, buyer, CheatSpan::TargetCalls(2));
220 | 
221 |         let nft_id_1 = 1;
222 |         let seller_bal_before_buy = erc20_dispatcher.balance_of(seller);
223 |         let buyer_bal_before_buy = erc20_dispatcher.balance_of(buyer);
224 |         let nft_price = nft_auction_dispatcher.get_price().into();
225 | 
226 |         // buyer approves nft auction contract to spend own erc20 token
227 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
228 | 
229 |         nft_auction_dispatcher.buy(nft_id_1);
230 | 
231 |         let seller_bal_after_buy = erc20_dispatcher.balance_of(seller);
232 |         let buyer_bal_after_buy = erc20_dispatcher.balance_of(buyer);
233 | 
234 |         assert_eq!(seller_bal_after_buy, seller_bal_before_buy + nft_price);
235 |         assert_eq!(buyer_bal_after_buy, buyer_bal_before_buy - nft_price);
236 |         assert_eq!(erc721_dispatcher.owner_of(nft_id_1), buyer);
237 | 
238 |         // Forward block timestamp in order for a reduced nft price
239 |         let forward_blocktime_by = 4000; // milliseconds
240 |         cheat_block_timestamp(nft_auction_address, forward_blocktime_by, CheatSpan::TargetCalls(1));
241 | 
242 |         // Buy token again after some time
243 |         let nft_id_2 = 2;
244 | 
245 |         // buyer approves nft auction contract to spend own erc20 token
246 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
247 | 
248 |         assert_ne!(erc721_dispatcher.owner_of(nft_id_2), buyer);
249 |         nft_auction_dispatcher.buy(nft_id_2);
250 |         assert_eq!(erc721_dispatcher.owner_of(nft_id_2), buyer);
251 |     }
252 | 
253 |     #[test]
254 |     #[should_panic(expected: 'auction has ended')]
255 |     fn test_buy_should_panic_when_total_supply_reached() {
256 |         let (_, erc20_address, nft_auction_address) = get_contract_addresses();
257 |         let erc20_dispatcher = IERC20Dispatcher { contract_address: erc20_address };
258 |         let nft_auction_dispatcher = INFTDutchAuctionDispatcher {
259 |             contract_address: nft_auction_address
260 |         };
261 |         let erc20_admin: ContractAddress = 'admin'.try_into().unwrap();
262 |         let buyer: ContractAddress = 'buyer'.try_into().unwrap();
263 | 
264 |         // Transfer erc20 tokens to buyer
265 |         cheat_caller_address(erc20_address, erc20_admin, CheatSpan::TargetCalls(1));
266 |         let transfer_amt = 5000;
267 |         erc20_dispatcher.transfer(buyer, transfer_amt.into());
268 | 
269 |         // Buy token
270 |         cheat_caller_address(nft_auction_address, buyer, CheatSpan::TargetCalls(4));
271 |         cheat_caller_address(erc20_address, buyer, CheatSpan::TargetCalls(3));
272 | 
273 |         let nft_id_1 = 1;
274 |         let nft_price = nft_auction_dispatcher.get_price().into();
275 | 
276 |         // buyer approves nft auction contract to spend own erc20 token
277 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
278 |         nft_auction_dispatcher.buy(nft_id_1);
279 | 
280 |         // Forward block timestamp in order for a reduced nft price
281 |         let forward_blocktime_by = 4000; // 4 seconds (in milliseconds)
282 |         cheat_block_timestamp(nft_auction_address, forward_blocktime_by, CheatSpan::TargetCalls(1));
283 | 
284 |         // Buy token again after some time
285 |         let nft_id_2 = 2;
286 |         // buyer approves nft auction contract to spend own erc20 token
287 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
288 |         nft_auction_dispatcher.buy(nft_id_2);
289 | 
290 |         // Buy token again after the total supply has reached
291 |         let nft_id_3 = 3;
292 |         // buyer approves nft auction contract to spend own erc20 token
293 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
294 |         nft_auction_dispatcher.buy(nft_id_3);
295 |     }
296 | 
297 |     #[test]
298 |     #[should_panic(expected: 'auction has ended')]
299 |     fn test_buy_should_panic_when_duration_ended() {
300 |         let (_, erc20_address, nft_auction_address) = get_contract_addresses();
301 |         let erc20_dispatcher = IERC20Dispatcher { contract_address: erc20_address };
302 |         let nft_auction_dispatcher = INFTDutchAuctionDispatcher {
303 |             contract_address: nft_auction_address
304 |         };
305 |         let erc20_admin: ContractAddress = 'admin'.try_into().unwrap();
306 |         let buyer: ContractAddress = 'buyer'.try_into().unwrap();
307 | 
308 |         // Transfer erc20 tokens to buyer
309 |         cheat_caller_address(erc20_address, erc20_admin, CheatSpan::TargetCalls(1));
310 |         let transfer_amt = 5000;
311 |         erc20_dispatcher.transfer(buyer, transfer_amt.into());
312 | 
313 |         // Buy token
314 |         cheat_caller_address(nft_auction_address, buyer, CheatSpan::TargetCalls(4));
315 |         cheat_caller_address(erc20_address, buyer, CheatSpan::TargetCalls(3));
316 | 
317 |         let nft_id_1 = 1;
318 |         let nft_price = nft_auction_dispatcher.get_price().into();
319 | 
320 |         // buyer approves nft auction contract to spend own erc20 token
321 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
322 |         nft_auction_dispatcher.buy(nft_id_1);
323 | 
324 |         // Forward block timestamp to a time after duration has ended
325 |         // During deployment, duration was set to 60 seconds
326 |         let forward_blocktime_by = 61000; // 61 seconds (in milliseconds)
327 |         cheat_block_timestamp(nft_auction_address, forward_blocktime_by, CheatSpan::TargetCalls(1));
328 | 
329 |         // Buy token again after some time
330 |         let nft_id_2 = 2;
331 |         // buyer approves nft auction contract to spend own erc20 token
332 |         erc20_dispatcher.approve(nft_auction_address, nft_price);
333 |         nft_auction_dispatcher.buy(nft_id_2);
334 |     }
335 | 
336 |     #[test]
337 |     fn test_price_decreases_after_some_time() {
338 |         let (_, _, nft_auction_address) = get_contract_addresses();
339 |         let nft_auction_dispatcher = INFTDutchAuctionDispatcher {
340 |             contract_address: nft_auction_address
341 |         };
342 | 
343 |         let nft_price_before_time_travel = nft_auction_dispatcher.get_price();
344 | 
345 |         // Forward time
346 |         let forward_blocktime_by = 10000; // 10 seconds (in milliseconds)
347 |         cheat_block_timestamp(nft_auction_address, forward_blocktime_by, CheatSpan::TargetCalls(1));
348 | 
349 |         let nft_price_after_time_travel = nft_auction_dispatcher.get_price();
350 | 
351 |         println!("price: {:?}", nft_price_after_time_travel);
352 | 
353 |         assert_gt!(nft_price_before_time_travel, nft_price_after_time_travel);
354 |     }
355 | }
356 | 


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/.env.example:
--------------------------------------------------------------------------------
1 | PRIVATE_KEY = "PASTE_PRIVATE_KEY_HERE"


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/.gitignore:
--------------------------------------------------------------------------------
1 | .env


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "simple_storage"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "simple_storage"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/abi.json:
--------------------------------------------------------------------------------
  1 | {
  2 |     "sierra_program": [
  3 |         "0x1",
  4 |         "0x5",
  5 |         "0x0",
  6 |         "0x2",
  7 |         "0x6",
  8 |         "0x3",
  9 |         "0x98",
 10 |         "0x68",
 11 |         "0x18",
 12 |         "0x52616e6765436865636b",
 13 |         "0x800000000000000100000000000000000000000000000000",
 14 |         "0x436f6e7374",
 15 |         "0x800000000000000000000000000000000000000000000002",
 16 |         "0x1",
 17 |         "0x16",
 18 |         "0x2",
 19 |         "0x53746f726555313238202d206e6f6e2075313238",
 20 |         "0x4661696c656420746f20646573657269616c697a6520706172616d202331",
 21 |         "0x4f7574206f6620676173",
 22 |         "0x4172726179",
 23 |         "0x800000000000000300000000000000000000000000000001",
 24 |         "0x536e617073686f74",
 25 |         "0x800000000000000700000000000000000000000000000001",
 26 |         "0x4",
 27 |         "0x537472756374",
 28 |         "0x800000000000000700000000000000000000000000000002",
 29 |         "0x0",
 30 |         "0x1baeba72e79e9db2587cf44fedb2f3700b2075a5e8e39a562584862c4b71f62",
 31 |         "0x5",
 32 |         "0x2ee1e2b1b89f8c495f200e4956278a4d47395fe262f27b52e5865c9524c08c3",
 33 |         "0x6",
 34 |         "0x9",
 35 |         "0x753332",
 36 |         "0x800000000000000700000000000000000000000000000000",
 37 |         "0x53746f7261676541646472657373",
 38 |         "0x53746f726167654261736541646472657373",
 39 |         "0x4275696c74696e436f737473",
 40 |         "0x53797374656d",
 41 |         "0x800000000000000f00000000000000000000000000000001",
 42 |         "0x16a4c8d7c05909052238a862d8cc3e7975bf05a07b3a69c6b28951083a6d672",
 43 |         "0x800000000000000300000000000000000000000000000003",
 44 |         "0xe",
 45 |         "0x456e756d",
 46 |         "0x9931c641b913035ae674b400b61a51476d506bbe8bba2ff8a6272790aba9e6",
 47 |         "0x7",
 48 |         "0xf",
 49 |         "0x496e70757420746f6f206c6f6e6720666f7220617267756d656e7473",
 50 |         "0x75313238",
 51 |         "0x426f78",
 52 |         "0x800000000000000700000000000000000000000000000003",
 53 |         "0x29d7d57c04a880978e7b3689f6218e507f3be17588744b58dc17762447ad0e7",
 54 |         "0x14",
 55 |         "0x13",
 56 |         "0x66656c74323532",
 57 |         "0x4761734275696c74696e",
 58 |         "0x35",
 59 |         "0x7265766f6b655f61705f747261636b696e67",
 60 |         "0x77697468647261775f676173",
 61 |         "0x6272616e63685f616c69676e",
 62 |         "0x7374727563745f6465636f6e737472756374",
 63 |         "0x656e61626c655f61705f747261636b696e67",
 64 |         "0x73746f72655f74656d70",
 65 |         "0x61727261795f736e617073686f745f706f705f66726f6e74",
 66 |         "0x656e756d5f696e6974",
 67 |         "0x15",
 68 |         "0x6a756d70",
 69 |         "0x7374727563745f636f6e737472756374",
 70 |         "0x656e756d5f6d61746368",
 71 |         "0x756e626f78",
 72 |         "0x72656e616d65",
 73 |         "0x75313238735f66726f6d5f66656c74323532",
 74 |         "0x64697361626c655f61705f747261636b696e67",
 75 |         "0x64726f70",
 76 |         "0x12",
 77 |         "0x61727261795f6e6577",
 78 |         "0x636f6e73745f61735f696d6d656469617465",
 79 |         "0x11",
 80 |         "0x61727261795f617070656e64",
 81 |         "0x10",
 82 |         "0x17",
 83 |         "0xd",
 84 |         "0x6765745f6275696c74696e5f636f737473",
 85 |         "0xc",
 86 |         "0x77697468647261775f6761735f616c6c",
 87 |         "0x73746f726167655f626173655f616464726573735f636f6e7374",
 88 |         "0x3f21dadc69f28434fd7a4035b4cee8d901bf7ef13138a70c3f754bf85806657",
 89 |         "0x753132385f746f5f66656c74323532",
 90 |         "0x73746f726167655f616464726573735f66726f6d5f62617365",
 91 |         "0x8",
 92 |         "0xa",
 93 |         "0x73746f726167655f77726974655f73797363616c6c",
 94 |         "0x736e617073686f745f74616b65",
 95 |         "0x3",
 96 |         "0x73746f726167655f726561645f73797363616c6c",
 97 |         "0xeb",
 98 |         "0xffffffffffffffff",
 99 |         "0x74",
100 |         "0xb",
101 |         "0x63",
102 |         "0x5d",
103 |         "0x19",
104 |         "0x1a",
105 |         "0x1b",
106 |         "0x2b",
107 |         "0x1c",
108 |         "0x1d",
109 |         "0x1e",
110 |         "0x1f",
111 |         "0x20",
112 |         "0x21",
113 |         "0x22",
114 |         "0x23",
115 |         "0x24",
116 |         "0x25",
117 |         "0x4f",
118 |         "0x26",
119 |         "0x27",
120 |         "0x28",
121 |         "0x29",
122 |         "0x2a",
123 |         "0x2c",
124 |         "0x2d",
125 |         "0x46",
126 |         "0x2e",
127 |         "0x2f",
128 |         "0x30",
129 |         "0x31",
130 |         "0x32",
131 |         "0x33",
132 |         "0x34",
133 |         "0x36",
134 |         "0x37",
135 |         "0x38",
136 |         "0x39",
137 |         "0x3a",
138 |         "0x3b",
139 |         "0x3c",
140 |         "0x3d",
141 |         "0x3e",
142 |         "0x3f",
143 |         "0x40",
144 |         "0x67",
145 |         "0x41",
146 |         "0x42",
147 |         "0x43",
148 |         "0x44",
149 |         "0x45",
150 |         "0x47",
151 |         "0x48",
152 |         "0x49",
153 |         "0x4a",
154 |         "0x4b",
155 |         "0x4c",
156 |         "0xdd",
157 |         "0x97",
158 |         "0xd0",
159 |         "0xc3",
160 |         "0xb7",
161 |         "0xc8",
162 |         "0x82",
163 |         "0x876",
164 |         "0x11100f050e0d06050c0b0a0706050403090706050403080706050403020100",
165 |         "0x101f121e10021d191c191b191a191812071705040316051512111014051312",
166 |         "0x6050e2815121e10192726070605040325052405231220220f052105151220",
167 |         "0x536120505351234160505331232123112302f022e192d2c052b052a122922",
168 |         "0x5053b0507380507372c05053a123938050535140505351207380507370605",
169 |         "0x542410505402b05054014050540123f123e060505350605053d0605053c38",
170 |         "0x50535470505350507460507372505053a2105053a06050545440505430605",
171 |         "0x5351705053550050543124f124e4d07054c124b4a05053512494605053548",
172 |         "0x40540505431207460507372405053a1605053a0f0505400f05055312525105",
173 |         "0x70512125705121212560f05053505050543125516050540070505432c0505",
174 |         "0x125705120f12500557055405541212570512071224160758140f0757070512",
175 |         "0x55105241212570512071259054a5117075707500516120f0557050f051412",
176 |         "0x125705120712124405125112210557054a05171248055705170550124a0557",
177 |         "0x210557054605171248055705590550124605570525054a1225055705125912",
178 |         "0x57052c0525122c0557054405211212570512071241055a4405570721054812",
179 |         "0x1257051207125c0047545b06380757072b0f0744122b0557052b0546122b05",
180 |         "0x570512411212570512071260055f5e5d075707480516123805570538051412",
181 |         "0x471261055705120612125705060538121257055e052b121257055d052c1212",
182 |         "0x5d1264055705125c1263055705626107001262055705620546126205570512",
183 |         "0x140557051405601238055705380514126605570565055e1265055705636407",
184 |         "0x124112125705120712660714380f0566055705660562120705570507056112",
185 |         "0x67143854651267055705670564126705570512631212570560052c12125705",
186 |         "0x126e055705060567126d0557051266121257051207126c6b076a6968075707",
187 |         "0x126f0557056f056c125f0557055f056b125f0557051269126f0557056d0568",
188 |         "0x125705120712757473547271700757076e6f5f0769146d1268055705680514",
189 |         "0x7905570578055f1212570577056f12787707570576056e1276055705120612",
190 |         "0x557057005601268055705680514127a0557052f0571122f05570579057012",
191 |         "0x5c121257051207127a7170680f057a0557057a056212710557057105611270",
192 |         "0x1268055705680514127d0557057c055e127c055705757b075d127b05570512",
193 |         "0x7127d7473680f057d0557057d056212740557057405611273055705730560",
194 |         "0x57057f0546127f0557051273127e0557051206121257050605381212570512",
195 |         "0x82055e12820557058081075d1281055705125c12800557057f7e0700127f05",
196 |         "0x5621207055705070561126c0557056c0560126b0557056b05141283055705",
197 |         "0x1257055c0538121257050005381212570512071283076c6b0f058305570583",
198 |         "0x41057412125705120712128505125112840557054705141212570548052c12",
199 |         "0x86055705120612125705124112840557050f05141212570548052c12125705",
200 |         "0x89055705125c12880557058786070012870557058705461287055705127512",
201 |         "0x5705140560128405570584051412720557058a055e128a0557058889075d12",
202 |         "0x12125705120712720714840f05720557057205621207055705070561121405",
203 |         "0x700128c0557058c0546128c0557051273128b055705120612125705540576",
204 |         "0x12900557058f055e128f0557058d8e075d128e055705125c128d0557058c8b",
205 |         "0x90055705900562120705570507056112240557052405601216055705160514",
206 |         "0x570512071224160791140f0757070512070512125705121212900724160f05",
207 |         "0x7125905925117075707500516120f0557050f051412500557055405541212",
208 |         "0x557051247124a05570512061212570551052b1212570517052c1212570512",
209 |         "0x52125075d1225055705125c1221055705484a070012480557054805461248",
210 |         "0x705611214055705140560120f0557050f0514124405570546055e12460557",
211 |         "0x12570559052c121257051207124407140f0f05440557054405621207055705",
212 |         "0x12063807932b2c07570741140f546512410557054105641241055705126312",
213 |         "0x5c056b125c0557051269120005570547056812470557051266121257051207",
214 |         "0x5d545707005c072b0f77122c0557052c0514120005570500056c125c055705",
215 |         "0x61125d0557055d05601260055705600546121257051207126362615494605e",
216 |         "0x512061212570512071268676654956564075707602c0744125e0557055e05",
217 |         "0x6f126e6d0757056c056e126c0557056b690700126b05570565056712690557",
218 |         "0x1412700557055f0571125f0557056f0570126f0557056e055f121257056d05",
219 |         "0x570055705700562125e0557055e0561125d0557055d056012640557056405",
220 |         "0x557051206121257056805381212570567053812125705120712705e5d640f",
221 |         "0x57056605141274055705737107001273055705730546127305570512781271",
222 |         "0x96051251127805570574057912770557055e056112760557055d0560127505",
223 |         "0x77055705620561127605570561056012750557052c05141212570512071212",
224 |         "0x557052f055e122f0557057879075d1279055705125c127805570563057912",
225 |         "0x57057a0562127705570577056112760557057605601275055705750514127a",
226 |         "0x546127c0557051273127b0557051206121257051207127a7776750f057a05",
227 |         "0x127f0557057d7e075d127e055705125c127d0557057c7b0700127c0557057c",
228 |         "0x70557050705611206055705060560123805570538051412800557057f055e",
229 |         "0x512061212570554057612125705120712800706380f058005570580056212",
230 |         "0x5125c12830557058281070012820557058205461282055705127312810557",
231 |         "0x5601216055705160514128705570586055e12860557058384075d12840557",
232 |         "0x47120f07870724160f05870557058705621207055705070561122405570524",
233 |         "0x9754070512464847120f164847120f1254070512464847120f1648"
234 |     ],
235 |     "sierra_program_debug_info": {
236 |         "type_names": [
237 |             [
238 |                 0,
239 |                 "RangeCheck"
240 |             ],
241 |             [
242 |                 1,
243 |                 "Const<felt252, 476442828812030857794232422692155113556837216824>"
244 |             ],
245 |             [
246 |                 2,
247 |                 "Const<felt252, 485748461484230571791265682659113160264223489397539653310998840191492913>"
248 |             ],
249 |             [
250 |                 3,
251 |                 "Const<felt252, 375233589013918064796019>"
252 |             ],
253 |             [
254 |                 4,
255 |                 "Array<felt252>"
256 |             ],
257 |             [
258 |                 5,
259 |                 "Snapshot<Array<felt252>>"
260 |             ],
261 |             [
262 |                 6,
263 |                 "core::array::Span::<core::felt252>"
264 |             ],
265 |             [
266 |                 7,
267 |                 "Tuple<core::array::Span::<core::felt252>>"
268 |             ],
269 |             [
270 |                 8,
271 |                 "Const<u32, 0>"
272 |             ],
273 |             [
274 |                 9,
275 |                 "u32"
276 |             ],
277 |             [
278 |                 10,
279 |                 "StorageAddress"
280 |             ],
281 |             [
282 |                 11,
283 |                 "StorageBaseAddress"
284 |             ],
285 |             [
286 |                 12,
287 |                 "BuiltinCosts"
288 |             ],
289 |             [
290 |                 13,
291 |                 "System"
292 |             ],
293 |             [
294 |                 14,
295 |                 "core::panics::Panic"
296 |             ],
297 |             [
298 |                 15,
299 |                 "Tuple<core::panics::Panic, Array<felt252>>"
300 |             ],
301 |             [
302 |                 16,
303 |                 "core::panics::PanicResult::<(core::array::Span::<core::felt252>,)>"
304 |             ],
305 |             [
306 |                 17,
307 |                 "Const<felt252, 7733229381460288120802334208475838166080759535023995805565484692595>"
308 |             ],
309 |             [
310 |                 18,
311 |                 "u128"
312 |             ],
313 |             [
314 |                 19,
315 |                 "Unit"
316 |             ],
317 |             [
318 |                 20,
319 |                 "Box<felt252>"
320 |             ],
321 |             [
322 |                 21,
323 |                 "core::option::Option::<core::box::Box::<@core::felt252>>"
324 |             ],
325 |             [
326 |                 22,
327 |                 "felt252"
328 |             ],
329 |             [
330 |                 23,
331 |                 "GasBuiltin"
332 |             ]
333 |         ],
334 |         "libfunc_names": [
335 |             [
336 |                 0,
337 |                 "revoke_ap_tracking"
338 |             ],
339 |             [
340 |                 1,
341 |                 "withdraw_gas"
342 |             ],
343 |             [
344 |                 2,
345 |                 "branch_align"
346 |             ],
347 |             [
348 |                 3,
349 |                 "struct_deconstruct<core::array::Span::<core::felt252>>"
350 |             ],
351 |             [
352 |                 4,
353 |                 "enable_ap_tracking"
354 |             ],
355 |             [
356 |                 5,
357 |                 "store_temp<RangeCheck>"
358 |             ],
359 |             [
360 |                 6,
361 |                 "array_snapshot_pop_front<felt252>"
362 |             ],
363 |             [
364 |                 7,
365 |                 "enum_init<core::option::Option::<core::box::Box::<@core::felt252>>, 0>"
366 |             ],
367 |             [
368 |                 8,
369 |                 "store_temp<Snapshot<Array<felt252>>>"
370 |             ],
371 |             [
372 |                 9,
373 |                 "store_temp<core::option::Option::<core::box::Box::<@core::felt252>>>"
374 |             ],
375 |             [
376 |                 10,
377 |                 "jump"
378 |             ],
379 |             [
380 |                 11,
381 |                 "struct_construct<Unit>"
382 |             ],
383 |             [
384 |                 12,
385 |                 "enum_init<core::option::Option::<core::box::Box::<@core::felt252>>, 1>"
386 |             ],
387 |             [
388 |                 13,
389 |                 "enum_match<core::option::Option::<core::box::Box::<@core::felt252>>>"
390 |             ],
391 |             [
392 |                 14,
393 |                 "unbox<felt252>"
394 |             ],
395 |             [
396 |                 15,
397 |                 "rename<felt252>"
398 |             ],
399 |             [
400 |                 16,
401 |                 "store_temp<felt252>"
402 |             ],
403 |             [
404 |                 17,
405 |                 "u128s_from_felt252"
406 |             ],
407 |             [
408 |                 18,
409 |                 "disable_ap_tracking"
410 |             ],
411 |             [
412 |                 19,
413 |                 "drop<Snapshot<Array<felt252>>>"
414 |             ],
415 |             [
416 |                 20,
417 |                 "drop<Box<felt252>>"
418 |             ],
419 |             [
420 |                 21,
421 |                 "drop<u128>"
422 |             ],
423 |             [
424 |                 22,
425 |                 "array_new<felt252>"
426 |             ],
427 |             [
428 |                 23,
429 |                 "const_as_immediate<Const<felt252, 7733229381460288120802334208475838166080759535023995805565484692595>>"
430 |             ],
431 |             [
432 |                 24,
433 |                 "array_append<felt252>"
434 |             ],
435 |             [
436 |                 25,
437 |                 "struct_construct<core::panics::Panic>"
438 |             ],
439 |             [
440 |                 26,
441 |                 "struct_construct<Tuple<core::panics::Panic, Array<felt252>>>"
442 |             ],
443 |             [
444 |                 27,
445 |                 "enum_init<core::panics::PanicResult::<(core::array::Span::<core::felt252>,)>, 1>"
446 |             ],
447 |             [
448 |                 28,
449 |                 "store_temp<GasBuiltin>"
450 |             ],
451 |             [
452 |                 29,
453 |                 "store_temp<System>"
454 |             ],
455 |             [
456 |                 30,
457 |                 "store_temp<core::panics::PanicResult::<(core::array::Span::<core::felt252>,)>>"
458 |             ],
459 |             [
460 |                 31,
461 |                 "get_builtin_costs"
462 |             ],
463 |             [
464 |                 32,
465 |                 "store_temp<BuiltinCosts>"
466 |             ],
467 |             [
468 |                 33,
469 |                 "withdraw_gas_all"
470 |             ],
471 |             [
472 |                 34,
473 |                 "storage_base_address_const<1784720371058305772862806735021375459770416459932804101453333227736919991895>"
474 |             ],
475 |             [
476 |                 35,
477 |                 "u128_to_felt252"
478 |             ],
479 |             [
480 |                 36,
481 |                 "storage_address_from_base"
482 |             ],
483 |             [
484 |                 37,
485 |                 "const_as_immediate<Const<u32, 0>>"
486 |             ],
487 |             [
488 |                 38,
489 |                 "store_temp<u32>"
490 |             ],
491 |             [
492 |                 39,
493 |                 "store_temp<StorageAddress>"
494 |             ],
495 |             [
496 |                 40,
497 |                 "storage_write_syscall"
498 |             ],
499 |             [
500 |                 41,
501 |                 "snapshot_take<Array<felt252>>"
502 |             ],
503 |             [
504 |                 42,
505 |                 "drop<Array<felt252>>"
506 |             ],
507 |             [
508 |                 43,
509 |                 "struct_construct<core::array::Span::<core::felt252>>"
510 |             ],
511 |             [
512 |                 44,
513 |                 "struct_construct<Tuple<core::array::Span::<core::felt252>>>"
514 |             ],
515 |             [
516 |                 45,
517 |                 "enum_init<core::panics::PanicResult::<(core::array::Span::<core::felt252>,)>, 0>"
518 |             ],
519 |             [
520 |                 46,
521 |                 "const_as_immediate<Const<felt252, 375233589013918064796019>>"
522 |             ],
523 |             [
524 |                 47,
525 |                 "drop<Unit>"
526 |             ],
527 |             [
528 |                 48,
529 |                 "const_as_immediate<Const<felt252, 485748461484230571791265682659113160264223489397539653310998840191492913>>"
530 |             ],
531 |             [
532 |                 49,
533 |                 "drop<core::array::Span::<core::felt252>>"
534 |             ],
535 |             [
536 |                 50,
537 |                 "storage_read_syscall"
538 |             ],
539 |             [
540 |                 51,
541 |                 "const_as_immediate<Const<felt252, 476442828812030857794232422692155113556837216824>>"
542 |             ],
543 |             [
544 |                 52,
545 |                 "store_temp<Array<felt252>>"
546 |             ]
547 |         ],
548 |         "user_func_names": [
549 |             [
550 |                 0,
551 |                 "simple_storage::storage::SimpleStorage::__wrapper__SimpleStorage__set"
552 |             ],
553 |             [
554 |                 1,
555 |                 "simple_storage::storage::SimpleStorage::__wrapper__SimpleStorage__get"
556 |             ]
557 |         ]
558 |     },
559 |     "contract_class_version": "0.1.0",
560 |     "entry_points_by_type": {
561 |         "EXTERNAL": [
562 |             {
563 |                 "selector": "0x17c00f03de8b5bd58d2016b59d251c13056b989171c5852949903bc043bc27",
564 |                 "function_idx": 1
565 |             },
566 |             {
567 |                 "selector": "0x2f67e6aeaad1ab7487a680eb9d3363a597afa7a3de33fa9bf3ae6edcb88435d",
568 |                 "function_idx": 0
569 |             }
570 |         ],
571 |         "L1_HANDLER": [],
572 |         "CONSTRUCTOR": []
573 |     },
574 |     "abi": [
575 |         {
576 |             "type": "impl",
577 |             "name": "SimpleStorage",
578 |             "interface_name": "simple_storage::storage::ISimpleStorage"
579 |         },
580 |         {
581 |             "type": "interface",
582 |             "name": "simple_storage::storage::ISimpleStorage",
583 |             "items": [
584 |                 {
585 |                     "type": "function",
586 |                     "name": "set",
587 |                     "inputs": [
588 |                         {
589 |                             "name": "x",
590 |                             "type": "core::integer::u128"
591 |                         }
592 |                     ],
593 |                     "outputs": [],
594 |                     "state_mutability": "external"
595 |                 },
596 |                 {
597 |                     "type": "function",
598 |                     "name": "get",
599 |                     "inputs": [],
600 |                     "outputs": [
601 |                         {
602 |                             "type": "core::integer::u128"
603 |                         }
604 |                     ],
605 |                     "state_mutability": "view"
606 |                 }
607 |             ]
608 |         },
609 |         {
610 |             "type": "event",
611 |             "name": "simple_storage::storage::SimpleStorage::Event",
612 |             "kind": "enum",
613 |             "variants": []
614 |         }
615 |     ]
616 | }


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/index.js:
--------------------------------------------------------------------------------
 1 | // [!region imports]
 2 | import { Account, RpcProvider, json, Contract } from "starknet";
 3 | import fs from "fs";
 4 | import * as dotenv from "dotenv";
 5 | dotenv.config();
 6 | // [!endregion imports]
 7 | 
 8 | // [!region provider]
 9 | const provider = new RpcProvider({
10 |   nodeUrl: "https://free-rpc.nethermind.io/sepolia-juno",
11 | });
12 | // [!endregion provider]
13 | 
14 | const accountAddress =
15 |   "0x067981c7F9f55BCbdD4e0d0a9C5BBCeA77dAcB42cccbf13554A847d6353F728e";
16 | // [!region account]
17 | const privateKey = process.env.PRIVATE_KEY;
18 | // "1" is added to show that our account is deployed using Cairo 1.0.
19 | const account = new Account(provider, accountAddress, privateKey, "1");
20 | // [!endregion account]
21 | 
22 | const contractAddress =
23 |   "0x01bb7d67375782ab08178b444dbda2b0c1c9ff4469c421124f54e1d8257f2e97";
24 | // [!region contract]
25 | const compiledContractAbi = json.parse(
26 |   fs.readFileSync("./abi.json").toString("ascii")
27 | );
28 | const storageContract = new Contract(
29 |   compiledContractAbi.abi,
30 |   contractAddress,
31 |   provider
32 | );
33 | // [!endregion contract]
34 | 
35 | // [!region get]
36 | let getData = await storageContract.get();
37 | console.log("Stored_data:", getData.toString());
38 | // [!endregion get]
39 | 
40 | // [!region set]
41 | storageContract.connect(account);
42 | const myCall = storageContract.populate("set", [59]);
43 | const res = await storageContract.set(myCall.calldata);
44 | await provider.waitForTransaction(res.transaction_hash);
45 | 
46 | // Get the stored data after setting it
47 | getData = await storageContract.get();
48 | console.log("Stored_data after set():", getData.toString());
49 | // [!endregion set]
50 | 


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod storage;
2 | 


--------------------------------------------------------------------------------
/listings/applications/simple_storage_starknetjs/src/storage.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::interface]
 3 | trait ISimpleStorage<T> {
 4 |     fn set(ref self: T, x: u128);
 5 |     fn get(self: @T) -> u128;
 6 | }
 7 | 
 8 | #[starknet::contract]
 9 | mod SimpleStorage {
10 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         stored_data: u128
15 |     }
16 | 
17 |     #[abi(embed_v0)]
18 |     impl SimpleStorage of super::ISimpleStorage<ContractState> {
19 |         fn set(ref self: ContractState, x: u128) {
20 |             self.stored_data.write(x);
21 |         }
22 | 
23 |         fn get(self: @ContractState) -> u128 {
24 |             self.stored_data.read()
25 |         }
26 |     }
27 | }
28 | // [!endregion contract]
29 | 
30 | 
31 | 


--------------------------------------------------------------------------------
/listings/applications/simple_vault/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/simple_vault/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "simple_vault"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | erc20 = { path = "../erc20" }
 9 | 
10 | [dev-dependencies]
11 | cairo_test.workspace = true
12 | 
13 | [scripts]
14 | test.workspace = true
15 | 
16 | [[target.starknet-contract]]
17 | 


--------------------------------------------------------------------------------
/listings/applications/simple_vault/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod simple_vault;
2 | 
3 | #[cfg(test)]
4 | mod tests;
5 | 


--------------------------------------------------------------------------------
/listings/applications/simple_vault/src/simple_vault.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | use starknet::ContractAddress;
  3 | 
  4 | // In order to make contract calls within our Vault,
  5 | // we need to have the interface of the remote ERC20 contract defined to import the Dispatcher.
  6 | #[starknet::interface]
  7 | pub trait IERC20<TContractState> {
  8 |     fn get_name(self: @TContractState) -> felt252;
  9 |     fn get_symbol(self: @TContractState) -> felt252;
 10 |     fn get_decimals(self: @TContractState) -> u8;
 11 |     fn get_total_supply(self: @TContractState) -> felt252;
 12 |     fn balance_of(self: @TContractState, account: ContractAddress) -> felt252;
 13 |     fn allowance(
 14 |         self: @TContractState, owner: ContractAddress, spender: ContractAddress
 15 |     ) -> felt252;
 16 |     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: felt252);
 17 |     fn transfer_from(
 18 |         ref self: TContractState,
 19 |         sender: ContractAddress,
 20 |         recipient: ContractAddress,
 21 |         amount: felt252
 22 |     );
 23 |     fn approve(ref self: TContractState, spender: ContractAddress, amount: felt252);
 24 |     fn increase_allowance(ref self: TContractState, spender: ContractAddress, added_value: felt252);
 25 |     fn decrease_allowance(
 26 |         ref self: TContractState, spender: ContractAddress, subtracted_value: felt252
 27 |     );
 28 | }
 29 | 
 30 | #[starknet::interface]
 31 | pub trait ISimpleVault<TContractState> {
 32 |     fn deposit(ref self: TContractState, amount: u256);
 33 |     fn withdraw(ref self: TContractState, shares: u256);
 34 |     fn user_balance_of(ref self: TContractState, account: ContractAddress) -> u256;
 35 |     fn contract_total_supply(ref self: TContractState) -> u256;
 36 | }
 37 | 
 38 | #[starknet::contract]
 39 | pub mod SimpleVault {
 40 |     use super::{IERC20Dispatcher, IERC20DispatcherTrait};
 41 |     use starknet::{ContractAddress, get_caller_address, get_contract_address};
 42 |     use starknet::storage::{
 43 |         Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
 44 |         StoragePointerWriteAccess
 45 |     };
 46 | 
 47 |     #[storage]
 48 |     struct Storage {
 49 |         token: IERC20Dispatcher,
 50 |         total_supply: u256,
 51 |         balance_of: Map<ContractAddress, u256>
 52 |     }
 53 | 
 54 |     #[constructor]
 55 |     fn constructor(ref self: ContractState, token: ContractAddress) {
 56 |         self.token.write(IERC20Dispatcher { contract_address: token });
 57 |     }
 58 | 
 59 |     #[generate_trait]
 60 |     impl PrivateFunctions of PrivateFunctionsTrait {
 61 |         fn _mint(ref self: ContractState, to: ContractAddress, shares: u256) {
 62 |             self.total_supply.write(self.total_supply.read() + shares);
 63 |             self.balance_of.write(to, self.balance_of.read(to) + shares);
 64 |         }
 65 | 
 66 |         fn _burn(ref self: ContractState, from: ContractAddress, shares: u256) {
 67 |             self.total_supply.write(self.total_supply.read() - shares);
 68 |             self.balance_of.write(from, self.balance_of.read(from) - shares);
 69 |         }
 70 |     }
 71 | 
 72 |     #[abi(embed_v0)]
 73 |     impl SimpleVault of super::ISimpleVault<ContractState> {
 74 |         fn user_balance_of(ref self: ContractState, account: ContractAddress) -> u256 {
 75 |             self.balance_of.read(account)
 76 |         }
 77 | 
 78 |         fn contract_total_supply(ref self: ContractState) -> u256 {
 79 |             self.total_supply.read()
 80 |         }
 81 | 
 82 |         fn deposit(ref self: ContractState, amount: u256) {
 83 |             // a = amount
 84 |             // B = balance of token before deposit
 85 |             // T = total supply
 86 |             // s = shares to mint
 87 |             //
 88 |             // (T + s) / T = (a + B) / B
 89 |             //
 90 |             // s = aT / B
 91 |             let caller = get_caller_address();
 92 |             let this = get_contract_address();
 93 | 
 94 |             let mut shares = 0;
 95 |             if self.total_supply.read() == 0 {
 96 |                 shares = amount;
 97 |             } else {
 98 |                 let balance: u256 = self.token.read().balance_of(this).try_into().unwrap();
 99 |                 shares = (amount * self.total_supply.read()) / balance;
100 |             }
101 | 
102 |             PrivateFunctions::_mint(ref self, caller, shares);
103 | 
104 |             let amount_felt252: felt252 = amount.low.into();
105 |             self.token.read().transfer_from(caller, this, amount_felt252);
106 |         }
107 | 
108 |         fn withdraw(ref self: ContractState, shares: u256) {
109 |             // a = amount
110 |             // B = balance of token before withdraw
111 |             // T = total supply
112 |             // s = shares to burn
113 |             //
114 |             // (T - s) / T = (B - a) / B
115 |             //
116 |             // a = sB / T
117 |             let caller = get_caller_address();
118 |             let this = get_contract_address();
119 | 
120 |             let balance = self.user_balance_of(this);
121 |             let amount = (shares * balance) / self.total_supply.read();
122 |             PrivateFunctions::_burn(ref self, caller, shares);
123 |             let amount_felt252: felt252 = amount.low.into();
124 |             self.token.read().transfer(caller, amount_felt252);
125 |         }
126 |     }
127 | }
128 | // [!endregion contract]
129 | 
130 | #[cfg(test)]
131 | mod tests {
132 |     use super::{SimpleVault, ISimpleVaultDispatcher, ISimpleVaultDispatcherTrait,};
133 |     use erc20::token::{
134 |         IERC20DispatcherTrait as IERC20DispatcherTrait_token,
135 |         IERC20Dispatcher as IERC20Dispatcher_token
136 |     };
137 |     use starknet::testing::{set_contract_address, set_account_contract_address};
138 |     use starknet::{
139 |         ContractAddress, SyscallResultTrait, syscalls::deploy_syscall, contract_address_const
140 |     };
141 | 
142 |     const token_name: felt252 = 'myToken';
143 |     const decimals: u8 = 18;
144 |     const initial_supply: felt252 = 100000;
145 |     const symbols: felt252 = 'mtk';
146 | 
147 |     fn deploy() -> (ISimpleVaultDispatcher, ContractAddress, IERC20Dispatcher_token) {
148 |         let _token_address: ContractAddress = contract_address_const::<'token_address'>();
149 |         let caller = contract_address_const::<'caller'>();
150 | 
151 |         let (token_contract_address, _) = deploy_syscall(
152 |             erc20::token::erc20::TEST_CLASS_HASH.try_into().unwrap(),
153 |             caller.into(),
154 |             array![caller.into(), 'myToken', '8', '1000'.into(), 'MYT'].span(),
155 |             false
156 |         )
157 |             .unwrap_syscall();
158 | 
159 |         let (contract_address, _) = deploy_syscall(
160 |             SimpleVault::TEST_CLASS_HASH.try_into().unwrap(),
161 |             0,
162 |             array![token_contract_address.into()].span(),
163 |             false
164 |         )
165 |             .unwrap_syscall();
166 | 
167 |         (
168 |             ISimpleVaultDispatcher { contract_address },
169 |             contract_address,
170 |             IERC20Dispatcher_token { contract_address: token_contract_address }
171 |         )
172 |     }
173 | 
174 |     #[test]
175 |     fn test_deposit() {
176 |         let caller = contract_address_const::<'caller'>();
177 |         let (dispatcher, vault_address, token_dispatcher) = deploy();
178 | 
179 |         // Approve the vault to transfer tokens on behalf of the caller
180 |         let amount: felt252 = 10.into();
181 |         token_dispatcher.approve(vault_address.into(), amount);
182 |         set_contract_address(caller);
183 | 
184 |         // Deposit tokens into the vault
185 |         let amount: u256 = 10.into();
186 |         let _deposit = dispatcher.deposit(amount);
187 |         println!("deposit :{:?}", _deposit);
188 | 
189 |         // Check balances and total supply
190 |         let balance_of_caller = dispatcher.user_balance_of(caller);
191 |         let total_supply = dispatcher.contract_total_supply();
192 | 
193 |         assert_eq!(balance_of_caller, amount);
194 |         assert_eq!(total_supply, amount);
195 |     }
196 | 
197 |     #[test]
198 |     fn test_deposit_withdraw() {
199 |         let caller = contract_address_const::<'caller'>();
200 |         let (dispatcher, vault_address, token_dispatcher) = deploy();
201 | 
202 |         // Approve the vault to transfer tokens on behalf of the caller
203 |         let amount: felt252 = 10.into();
204 |         token_dispatcher.approve(vault_address.into(), amount);
205 |         set_contract_address(caller);
206 |         set_account_contract_address(vault_address);
207 | 
208 |         // Deposit tokens into the vault
209 |         let amount: u256 = 10.into();
210 |         dispatcher.deposit(amount);
211 |         dispatcher.withdraw(amount);
212 | 
213 |         // Check balances of user in the vault after withdraw
214 |         let balance_of_caller = dispatcher.user_balance_of(caller);
215 | 
216 |         assert_eq!(balance_of_caller, 0.into());
217 |     }
218 | }
219 | 


--------------------------------------------------------------------------------
/listings/applications/simple_vault/src/tests.cairo:
--------------------------------------------------------------------------------
1 | mod tests { // TODO
2 | }
3 | 


--------------------------------------------------------------------------------
/listings/applications/staking/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/staking/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "staking"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | openzeppelin.workspace = true
 9 | 
10 | [dev-dependencies]
11 | cairo_test.workspace = true
12 | 
13 | [scripts]
14 | test.workspace = true
15 | 
16 | [[target.starknet-contract]]
17 | 


--------------------------------------------------------------------------------
/listings/applications/staking/src/contract.cairo:
--------------------------------------------------------------------------------
  1 | use starknet::ContractAddress;
  2 | 
  3 | #[starknet::interface]
  4 | pub trait IStakingContract<TContractState> {
  5 |     fn set_reward_amount(ref self: TContractState, amount: u256);
  6 |     fn set_reward_duration(ref self: TContractState, duration: u256);
  7 |     fn stake(ref self: TContractState, amount: u256);
  8 |     fn withdraw(ref self: TContractState, amount: u256);
  9 |     fn get_rewards(self: @TContractState, account: ContractAddress) -> u256;
 10 |     fn claim_rewards(ref self: TContractState);
 11 | }
 12 | 
 13 | mod Errors {
 14 |     pub const NULL_REWARDS: felt252 = 'Reward amount must be > 0';
 15 |     pub const NOT_ENOUGH_REWARDS: felt252 = 'Reward amount must be > balance';
 16 |     pub const NULL_AMOUNT: felt252 = 'Amount must be > 0';
 17 |     pub const NULL_DURATION: felt252 = 'Duration must be > 0';
 18 |     pub const UNFINISHED_DURATION: felt252 = 'Reward duration not finished';
 19 |     pub const NOT_OWNER: felt252 = 'Caller is not the owner';
 20 |     pub const NOT_ENOUGH_BALANCE: felt252 = 'Balance too low';
 21 | }
 22 | 
 23 | #[starknet::contract]
 24 | pub mod StakingContract {
 25 |     use core::starknet::event::EventEmitter;
 26 |     use core::num::traits::Zero;
 27 |     use starknet::{ContractAddress, get_caller_address, get_block_timestamp, get_contract_address};
 28 |     use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
 29 |     use starknet::storage::{
 30 |         Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
 31 |         StoragePointerWriteAccess
 32 |     };
 33 | 
 34 |     #[storage]
 35 |     struct Storage {
 36 |         pub staking_token: IERC20Dispatcher,
 37 |         pub reward_token: IERC20Dispatcher,
 38 |         pub owner: ContractAddress,
 39 |         pub reward_rate: u256,
 40 |         pub duration: u256,
 41 |         pub current_reward_per_staked_token: u256,
 42 |         pub finish_at: u256,
 43 |         // last time an operation (staking / withdrawal / rewards claimed) was registered
 44 |         pub last_updated_at: u256,
 45 |         pub last_user_reward_per_staked_token: Map::<ContractAddress, u256>,
 46 |         pub unclaimed_rewards: Map::<ContractAddress, u256>,
 47 |         pub total_distributed_rewards: u256,
 48 |         // total amount of staked tokens
 49 |         pub total_supply: u256,
 50 |         // amount of staked tokens per user
 51 |         pub balance_of: Map::<ContractAddress, u256>,
 52 |     }
 53 | 
 54 |     #[event]
 55 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 56 |     pub enum Event {
 57 |         Deposit: Deposit,
 58 |         Withdrawal: Withdrawal,
 59 |         RewardsFinished: RewardsFinished,
 60 |     }
 61 | 
 62 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 63 |     pub struct Deposit {
 64 |         pub user: ContractAddress,
 65 |         pub amount: u256,
 66 |     }
 67 | 
 68 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 69 |     pub struct Withdrawal {
 70 |         pub user: ContractAddress,
 71 |         pub amount: u256,
 72 |     }
 73 | 
 74 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 75 |     pub struct RewardsFinished {
 76 |         pub msg: felt252,
 77 |     }
 78 | 
 79 |     #[constructor]
 80 |     fn constructor(
 81 |         ref self: ContractState,
 82 |         staking_token_address: ContractAddress,
 83 |         reward_token_address: ContractAddress,
 84 |     ) {
 85 |         self.staking_token.write(IERC20Dispatcher { contract_address: staking_token_address });
 86 |         self.reward_token.write(IERC20Dispatcher { contract_address: reward_token_address });
 87 | 
 88 |         self.owner.write(get_caller_address());
 89 |     }
 90 | 
 91 |     #[abi(embed_v0)]
 92 |     impl StakingContract of super::IStakingContract<ContractState> {
 93 |         fn set_reward_duration(ref self: ContractState, duration: u256) {
 94 |             self.only_owner();
 95 | 
 96 |             assert(duration > 0, super::Errors::NULL_DURATION);
 97 | 
 98 |             // can only set duration if the previous duration has already finished
 99 |             assert(
100 |                 self.finish_at.read() < get_block_timestamp().into(),
101 |                 super::Errors::UNFINISHED_DURATION
102 |             );
103 | 
104 |             self.duration.write(duration);
105 |         }
106 | 
107 |         fn set_reward_amount(ref self: ContractState, amount: u256) {
108 |             self.only_owner();
109 |             self.update_rewards(Zero::zero());
110 | 
111 |             assert(amount > 0, super::Errors::NULL_REWARDS);
112 |             assert(self.duration.read() > 0, super::Errors::NULL_DURATION);
113 | 
114 |             let block_timestamp: u256 = get_block_timestamp().into();
115 | 
116 |             let rate = if self.finish_at.read() < block_timestamp {
117 |                 amount / self.duration.read()
118 |             } else {
119 |                 let remaining_rewards = self.reward_rate.read()
120 |                     * (self.finish_at.read() - block_timestamp);
121 |                 (remaining_rewards + amount) / self.duration.read()
122 |             };
123 | 
124 |             assert(
125 |                 self.reward_token.read().balance_of(get_contract_address()) >= rate
126 |                     * self.duration.read(),
127 |                 super::Errors::NOT_ENOUGH_REWARDS
128 |             );
129 | 
130 |             self.reward_rate.write(rate);
131 | 
132 |             // even if the previous reward duration has not finished, we reset the finish_at
133 |             // variable
134 |             self.finish_at.write(block_timestamp + self.duration.read());
135 |             self.last_updated_at.write(block_timestamp);
136 | 
137 |             // reset total distributed rewards
138 |             self.total_distributed_rewards.write(0);
139 |         }
140 | 
141 |         fn stake(ref self: ContractState, amount: u256) {
142 |             assert(amount > 0, super::Errors::NULL_AMOUNT);
143 | 
144 |             let user = get_caller_address();
145 |             self.update_rewards(user);
146 | 
147 |             self.balance_of.write(user, self.balance_of.read(user) + amount);
148 |             self.total_supply.write(self.total_supply.read() + amount);
149 |             self.staking_token.read().transfer_from(user, get_contract_address(), amount);
150 | 
151 |             self.emit(Deposit { user, amount });
152 |         }
153 | 
154 |         fn withdraw(ref self: ContractState, amount: u256) {
155 |             assert(amount > 0, super::Errors::NULL_AMOUNT);
156 | 
157 |             let user = get_caller_address();
158 | 
159 |             assert(
160 |                 self.staking_token.read().balance_of(user) >= amount,
161 |                 super::Errors::NOT_ENOUGH_BALANCE
162 |             );
163 | 
164 |             self.update_rewards(user);
165 | 
166 |             self.balance_of.write(user, self.balance_of.read(user) - amount);
167 |             self.total_supply.write(self.total_supply.read() - amount);
168 |             self.staking_token.read().transfer(user, amount);
169 | 
170 |             self.emit(Withdrawal { user, amount });
171 |         }
172 | 
173 |         fn get_rewards(self: @ContractState, account: ContractAddress) -> u256 {
174 |             self.unclaimed_rewards.read(account) + self.compute_new_rewards(account)
175 |         }
176 | 
177 |         fn claim_rewards(ref self: ContractState) {
178 |             let user = get_caller_address();
179 |             self.update_rewards(user);
180 | 
181 |             let rewards = self.unclaimed_rewards.read(user);
182 | 
183 |             if rewards > 0 {
184 |                 self.unclaimed_rewards.write(user, 0);
185 |                 self.reward_token.read().transfer(user, rewards);
186 |             }
187 |         }
188 |     }
189 | 
190 |     #[generate_trait]
191 |     impl PrivateFunctions of PrivateFunctionsTrait {
192 |         // call this function every time a user (including owner) performs a state-modifying action
193 |         fn update_rewards(ref self: ContractState, account: ContractAddress) {
194 |             self
195 |                 .current_reward_per_staked_token
196 |                 .write(self.compute_current_reward_per_staked_token());
197 | 
198 |             self.last_updated_at.write(self.last_time_applicable());
199 | 
200 |             if account.is_non_zero() {
201 |                 self.distribute_user_rewards(account);
202 | 
203 |                 self
204 |                     .last_user_reward_per_staked_token
205 |                     .write(account, self.current_reward_per_staked_token.read());
206 | 
207 |                 self.send_rewards_finished_event();
208 |             }
209 |         }
210 | 
211 |         fn distribute_user_rewards(ref self: ContractState, account: ContractAddress) {
212 |             // compute earned rewards since last update for the user `account`
213 |             let user_rewards = self.get_rewards(account);
214 |             self.unclaimed_rewards.write(account, user_rewards);
215 | 
216 |             // track amount of total rewards distributed
217 |             self
218 |                 .total_distributed_rewards
219 |                 .write(self.total_distributed_rewards.read() + user_rewards);
220 |         }
221 | 
222 |         fn send_rewards_finished_event(ref self: ContractState) {
223 |             // check whether we should send a RewardsFinished event
224 |             if self.last_updated_at.read() == self.finish_at.read() {
225 |                 let total_rewards = self.reward_rate.read() * self.duration.read();
226 | 
227 |                 if total_rewards != 0 && self.total_distributed_rewards.read() == total_rewards {
228 |                     // owner should set up NEW rewards into the contract
229 |                     self.emit(RewardsFinished { msg: 'Rewards all distributed' });
230 |                 } else {
231 |                     // owner should set up rewards into the contract (or add duration by setting up
232 |                     // rewards)
233 |                     self.emit(RewardsFinished { msg: 'Rewards not active yet' });
234 |                 }
235 |             }
236 |         }
237 | 
238 |         fn compute_current_reward_per_staked_token(self: @ContractState) -> u256 {
239 |             if self.total_supply.read() == 0 {
240 |                 self.current_reward_per_staked_token.read()
241 |             } else {
242 |                 self.current_reward_per_staked_token.read()
243 |                     + self.reward_rate.read()
244 |                         * (self.last_time_applicable() - self.last_updated_at.read())
245 |                         / self.total_supply.read()
246 |             }
247 |         }
248 | 
249 |         fn compute_new_rewards(self: @ContractState, account: ContractAddress) -> u256 {
250 |             self.balance_of.read(account)
251 |                 * (self.current_reward_per_staked_token.read()
252 |                     - self.last_user_reward_per_staked_token.read(account))
253 |         }
254 | 
255 |         #[inline(always)]
256 |         fn last_time_applicable(self: @ContractState) -> u256 {
257 |             Self::min(self.finish_at.read(), get_block_timestamp().into())
258 |         }
259 | 
260 |         #[inline(always)]
261 |         fn min(x: u256, y: u256) -> u256 {
262 |             if (x <= y) {
263 |                 x
264 |             } else {
265 |                 y
266 |             }
267 |         }
268 | 
269 |         fn only_owner(self: @ContractState) {
270 |             let caller = get_caller_address();
271 |             assert(caller == self.owner.read(), super::Errors::NOT_OWNER);
272 |         }
273 |     }
274 | }
275 | 


--------------------------------------------------------------------------------
/listings/applications/staking/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 
3 | #[cfg(test)]
4 | mod tests {
5 |     mod tokens;
6 |     mod staking_tests;
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/applications/staking/src/tests/staking_tests.cairo:
--------------------------------------------------------------------------------
  1 | mod tests {
  2 |     use openzeppelin::token::erc20::interface::IERC20DispatcherTrait;
  3 |     use openzeppelin::token::erc20::erc20::ERC20Component::InternalTrait;
  4 |     use staking::contract::IStakingContractDispatcherTrait;
  5 |     use staking::tests::tokens::{RewardToken, StakingToken};
  6 |     use staking::contract::{
  7 |         StakingContract, IStakingContractDispatcher, StakingContract::Event,
  8 |         StakingContract::Deposit, StakingContract::Withdrawal, StakingContract::RewardsFinished
  9 |     };
 10 |     use openzeppelin::token::erc20::{interface::IERC20Dispatcher};
 11 |     use starknet::syscalls::deploy_syscall;
 12 |     use starknet::SyscallResultTrait;
 13 |     use core::serde::Serde;
 14 |     use starknet::testing::{set_contract_address, set_block_timestamp, pop_log};
 15 |     use starknet::{contract_address_const, ContractAddress};
 16 |     use starknet::storage::{StoragePointerReadAccess, StorageMapReadAccess};
 17 | 
 18 |     #[derive(Copy, Drop)]
 19 |     struct Deployment {
 20 |         contract: IStakingContractDispatcher,
 21 |         staking_token: IERC20Dispatcher,
 22 |         reward_token: IERC20Dispatcher
 23 |     }
 24 | 
 25 |     fn deploy_util(class_hash: felt252, calldata: Array<felt252>) -> ContractAddress {
 26 |         let (address, _) = deploy_syscall(class_hash.try_into().unwrap(), 0, calldata.span(), false)
 27 |             .unwrap_syscall();
 28 | 
 29 |         address
 30 |     }
 31 | 
 32 |     fn deploy_erc20(
 33 |         class_hash: felt252, name: ByteArray, symbol: ByteArray
 34 |     ) -> (ContractAddress, IERC20Dispatcher) {
 35 |         let supply: u256 = 1000000;
 36 |         let recipient = contract_address_const::<'recipient'>();
 37 | 
 38 |         let mut call_data: Array<felt252> = ArrayTrait::new();
 39 |         Serde::serialize(@name, ref call_data);
 40 |         Serde::serialize(@symbol, ref call_data);
 41 |         Serde::serialize(@supply, ref call_data);
 42 |         Serde::serialize(@recipient, ref call_data);
 43 | 
 44 |         let address = deploy_util(class_hash, call_data);
 45 |         (address, IERC20Dispatcher { contract_address: address })
 46 |     }
 47 | 
 48 |     fn deploy_staking_contract(
 49 |         staking_token_address: ContractAddress, reward_token_address: ContractAddress
 50 |     ) -> (ContractAddress, IStakingContractDispatcher) {
 51 |         let mut calldata: Array<felt252> = array![];
 52 |         calldata.append(staking_token_address.into());
 53 |         calldata.append(reward_token_address.into());
 54 | 
 55 |         let staking_contract_address = deploy_util(StakingContract::TEST_CLASS_HASH, calldata);
 56 |         (
 57 |             staking_contract_address,
 58 |             IStakingContractDispatcher { contract_address: staking_contract_address }
 59 |         )
 60 |     }
 61 | 
 62 |     fn setup() -> Deployment {
 63 |         let (staking_token_address, staking_token) = deploy_erc20(
 64 |             StakingToken::TEST_CLASS_HASH, "StakingToken", "StakingTKN",
 65 |         );
 66 |         let (reward_token_address, reward_token) = deploy_erc20(
 67 |             RewardToken::TEST_CLASS_HASH, "RewardToken", "RewardTKN",
 68 |         );
 69 | 
 70 |         let (_, staking_contract) = deploy_staking_contract(
 71 |             staking_token_address, reward_token_address
 72 |         );
 73 | 
 74 |         Deployment { contract: staking_contract, staking_token, reward_token }
 75 |     }
 76 | 
 77 |     fn mint_and_approve_staking_tokens_to(
 78 |         recipient: ContractAddress, amount: u256, deploy: Deployment, value_to_approve: u256
 79 |     ) {
 80 |         // mint tokens
 81 |         let mut state = StakingToken::contract_state_for_testing();
 82 |         // pretend as if we were in the deployed staking token contract
 83 |         set_contract_address(deploy.staking_token.contract_address);
 84 |         state.erc20.mint(recipient, amount);
 85 | 
 86 |         // approve staking contract to spend user's tokens
 87 |         set_contract_address(recipient);
 88 |         deploy.staking_token.approve(deploy.contract.contract_address, value_to_approve);
 89 |     }
 90 | 
 91 |     fn mint_reward_tokens_to(
 92 |         deployed_contract: ContractAddress, amount: u256, reward_token_address: ContractAddress
 93 |     ) {
 94 |         // mint tokens
 95 |         let mut state = RewardToken::contract_state_for_testing();
 96 |         // pretend as if we were in the deployed reward token contract
 97 |         set_contract_address(reward_token_address);
 98 |         state.erc20.mint(deployed_contract, amount);
 99 |     }
100 | 
101 |     #[test]
102 |     fn should_deploy() {
103 |         /// setup
104 |         let owner = contract_address_const::<'owner'>();
105 |         set_contract_address(owner);
106 | 
107 |         /// when
108 |         let deploy = setup();
109 | 
110 |         // "link" a new StakingContract struct to the deployed StakingContract contract
111 |         // in order to access its internal state fields for assertions
112 |         let state = @StakingContract::contract_state_for_testing();
113 |         // pretend as if we were in the deployed contract
114 |         set_contract_address(deploy.contract.contract_address);
115 | 
116 |         /// then
117 |         assert_eq!(state.owner.read(), owner);
118 |         assert_eq!(
119 |             state.staking_token.read().contract_address, deploy.staking_token.contract_address
120 |         );
121 |         assert_eq!(
122 |             state.reward_token.read().contract_address, deploy.reward_token.contract_address
123 |         );
124 |     }
125 | 
126 |     #[test]
127 |     fn stake_and_withdraw_succeed() {
128 |         /// set up
129 | 
130 |         // deploy
131 |         let owner = contract_address_const::<'owner'>();
132 |         set_contract_address(owner);
133 |         let deploy = setup();
134 | 
135 |         // mint staking tokens to a user
136 |         let user = contract_address_const::<'user'>();
137 |         let stake_amount = 40;
138 |         let amount_tokens_minted = 100;
139 |         mint_and_approve_staking_tokens_to(user, amount_tokens_minted, deploy, stake_amount);
140 | 
141 |         /// when - staking
142 |         set_contract_address(user);
143 |         deploy.contract.stake(stake_amount);
144 | 
145 |         /// then
146 |         // so far the user has 60 tokens left and staked 40 tokens
147 |         let state = @StakingContract::contract_state_for_testing();
148 |         set_contract_address(deploy.contract.contract_address);
149 |         assert_eq!(state.balance_of.read(user), stake_amount);
150 |         assert_eq!(state.total_supply.read(), stake_amount);
151 |         assert_eq!(deploy.staking_token.balance_of(user), amount_tokens_minted - stake_amount);
152 | 
153 |         // check 1st & 2nd event - when user stakes
154 |         assert_eq!(
155 |             pop_log(deploy.contract.contract_address),
156 |             Option::Some(Event::RewardsFinished(RewardsFinished { msg: 'Rewards not active yet' }))
157 |         );
158 |         assert_eq!(
159 |             pop_log(deploy.contract.contract_address),
160 |             Option::Some(Event::Deposit(Deposit { user, amount: stake_amount }))
161 |         );
162 | 
163 |         /// when - withdrawal
164 |         set_contract_address(user);
165 |         let withdrawal_amount = 20;
166 |         deploy.contract.withdraw(withdrawal_amount);
167 | 
168 |         /// then
169 |         // at the end the user has 80 tokens left and 20 tokens staked
170 |         let state = @StakingContract::contract_state_for_testing();
171 |         set_contract_address(deploy.contract.contract_address);
172 |         assert_eq!(state.balance_of.read(user), stake_amount - withdrawal_amount);
173 |         assert_eq!(state.total_supply.read(), stake_amount - withdrawal_amount);
174 |         assert_eq!(
175 |             deploy.staking_token.balance_of(user),
176 |             amount_tokens_minted - stake_amount + withdrawal_amount
177 |         );
178 | 
179 |         // check 3rd & 4th events - when user withdraws
180 |         assert_eq!(
181 |             pop_log(deploy.contract.contract_address),
182 |             Option::Some(Event::RewardsFinished(RewardsFinished { msg: 'Rewards not active yet' }))
183 |         );
184 |         assert_eq!(
185 |             pop_log(deploy.contract.contract_address),
186 |             Option::Some(Event::Withdrawal(Withdrawal { user, amount: withdrawal_amount }))
187 |         );
188 |     }
189 | 
190 |     #[test]
191 |     fn claim_rewards_3_users_scenario() {
192 |         /// set up
193 | 
194 |         // deploy
195 |         let owner = contract_address_const::<'owner'>();
196 |         set_contract_address(owner);
197 |         let deploy = setup();
198 | 
199 |         // mint reward tokens to the deployed contract
200 |         let reward_tokens_amount = 1000;
201 |         mint_reward_tokens_to(
202 |             deploy.contract.contract_address,
203 |             reward_tokens_amount,
204 |             deploy.reward_token.contract_address
205 |         );
206 | 
207 |         // owner sets up rewards duration and amount
208 |         let block_timestamp: u256 = 1000;
209 |         set_block_timestamp(block_timestamp.try_into().unwrap());
210 |         let reward_duration = 100;
211 |         // have to set again the contract_address because it got changed in mint_reward_tokens_to
212 |         // function
213 |         set_contract_address(owner);
214 |         deploy.contract.set_reward_duration(reward_duration);
215 |         deploy.contract.set_reward_amount(reward_tokens_amount);
216 | 
217 |         // check reward rate, last updated at and finish dates
218 |         let state = @StakingContract::contract_state_for_testing();
219 |         set_contract_address(deploy.contract.contract_address);
220 |         assert_eq!(state.reward_rate.read(), reward_tokens_amount / reward_duration);
221 |         assert_eq!(state.finish_at.read(), block_timestamp + reward_duration);
222 |         assert_eq!(state.last_updated_at.read(), block_timestamp);
223 | 
224 |         // mint staking tokens to alice
225 |         let alice = contract_address_const::<'alice'>();
226 |         let alice_stake_amount = 40;
227 |         let alice_amount_tokens_minted = 100;
228 |         mint_and_approve_staking_tokens_to(
229 |             alice, alice_amount_tokens_minted, deploy, alice_stake_amount
230 |         );
231 | 
232 |         // alice stakes
233 |         set_contract_address(alice);
234 |         deploy.contract.stake(alice_stake_amount);
235 | 
236 |         // timestamp = 1000
237 |         // r0 = 0
238 |         // last updated at = 1000
239 |         // last RPST (reward per staked token) for alice = r0 = 0
240 |         // total supply = 40
241 | 
242 |         // mint staking tokens to bob
243 |         let bob = contract_address_const::<'bob'>();
244 |         let bob_stake_amount = 10;
245 |         let bob_amount_tokens_minted = 100;
246 |         mint_and_approve_staking_tokens_to(bob, bob_amount_tokens_minted, deploy, bob_stake_amount);
247 | 
248 |         // bob stakes
249 |         set_contract_address(bob);
250 |         set_block_timestamp(block_timestamp.try_into().unwrap() + 20);
251 |         deploy.contract.stake(bob_stake_amount);
252 | 
253 |         // timestamp = 1020
254 |         // r1 = r0 + 10 * (1020 - 1000) / 40 = 5
255 |         // last updated at = 1020
256 |         // last RPST for alice = r0 = 0
257 |         // last RPST for bob = r1 = 5
258 |         // total supply = 50
259 | 
260 |         // mint staking tokens to john
261 |         let john = contract_address_const::<'john'>();
262 |         let john_stake_amount = 30;
263 |         let john_amount_tokens_minted = 100;
264 |         mint_and_approve_staking_tokens_to(
265 |             john, john_amount_tokens_minted, deploy, john_stake_amount
266 |         );
267 | 
268 |         // john stakes
269 |         set_contract_address(john);
270 |         set_block_timestamp(block_timestamp.try_into().unwrap() + 30);
271 |         deploy.contract.stake(john_stake_amount);
272 | 
273 |         // timestamp = 1030
274 |         // r2 = r1 + 10 * (1030 - 1020) / 50 = 7
275 |         // last updated at = 1030
276 |         // last RPST for alice = r0 = 0
277 |         // last RPST for bob = r1 = 5
278 |         // last RPST for john = r2 = 7
279 |         // total supply = 80
280 | 
281 |         // bob withdraws
282 |         set_contract_address(bob);
283 |         set_block_timestamp(block_timestamp.try_into().unwrap() + 50);
284 |         deploy.contract.withdraw(bob_stake_amount);
285 | 
286 |         // timestamp = 1050
287 |         // r3 = r2 + 10 * (1050 - 1030) / 80 = 7 + 2 (< 2.5) = 9
288 |         // last updated at = 1050
289 |         // bob rewards = 0 + staked_tokens * (r3 - r1) = 10 * (9 - 5) = 40
290 |         // last RPST for alice = r0 = 0
291 |         // last RPST for bob = r3 = 9
292 |         // last RPST for john = r2 = 7
293 |         // total supply = 70
294 | 
295 |         // john withdraws some of its staked tokens
296 |         set_contract_address(john);
297 |         set_block_timestamp(block_timestamp.try_into().unwrap() + 80);
298 |         deploy.contract.withdraw(john_stake_amount - 10);
299 | 
300 |         // timestamp = 1080
301 |         // r4 = r3 + 10 * (1080 - 1050) / 70 = 9 + 4 (< 4.2857...) = 13
302 |         // last updated at = 1080
303 |         // bob rewards = 40
304 |         // john rewards = 0 + staked_tokens * (r4 - r2) = 30 * (13 - 7) = 180
305 |         // last RPST for alice = r0 = 0
306 |         // last RPST for bob = r3 = 9
307 |         // last RPST for john = r4 = 13
308 |         // total supply = 50
309 | 
310 |         // alice withdraws
311 |         set_contract_address(alice);
312 |         set_block_timestamp(block_timestamp.try_into().unwrap() + 90);
313 |         deploy.contract.withdraw(alice_stake_amount);
314 | 
315 |         // timestamp = 1090
316 |         // r5 = r4 + 10 * (1090 - 1080) / 50 = 13 + 2 = 15
317 |         // last updated at = 1090
318 |         // alice rewards = 0 + staked_tokens * (r5 - r0) = 40 * (15 - 0) = 600
319 |         // bob rewards = 40
320 |         // john rewards = 180
321 |         // last RPST for alice = r5 = 15
322 |         // last RPST for bob = r3 = 9
323 |         // last RPST for john = r4 = 13
324 |         // total supply = 10
325 | 
326 |         /// when
327 | 
328 |         // timestamp after the duration is finished
329 |         set_block_timestamp(
330 |             block_timestamp.try_into().unwrap() + reward_duration.try_into().unwrap() + 10
331 |         );
332 | 
333 |         // alice claims
334 |         deploy.contract.claim_rewards();
335 | 
336 |         // bob claims
337 |         set_contract_address(bob);
338 |         deploy.contract.claim_rewards();
339 | 
340 |         // john claims
341 |         set_contract_address(john);
342 |         deploy.contract.claim_rewards();
343 | 
344 |         // timestamp = 1110
345 |         // r6 = r5 + 10 * (1100 - 1090) / 10 = 15 + 10 = 25
346 |         // last updated at = 1100 (becomes same as finish_at)
347 |         // alice rewards = 600 + staked_tokens * (r6 - r5) = 600 + 0 * (25 - 15) = 600 -> 0
348 |         // (claimed)
349 |         // bob rewards = 40 + staked_tokens * (r6 - r3) = 40 + 0 * (25 - 9) = 40 -> 0 (claimed)
350 |         // john rewards = 180 + staked_tokens * (r6 - r4) = 180 + 10 * (25 - 13) = 300 -> 0
351 |         // (claimed)
352 |         // last RPST for alice = r6 = 25
353 |         // last RPST for bob = r6 = 25
354 |         // last RPST for john = r6 = 25
355 |         // total supply = 10
356 | 
357 |         /// then
358 | 
359 |         let state = @StakingContract::contract_state_for_testing();
360 |         set_contract_address(deploy.contract.contract_address);
361 | 
362 |         // check amount of unclaimed reward tokens for each user
363 |         assert(state.unclaimed_rewards.read(alice) == 0, 'Alice: unclaimed rewards');
364 |         assert(state.unclaimed_rewards.read(bob) == 0, 'Bob: unclaimed rewards');
365 |         assert(state.unclaimed_rewards.read(john) == 0, 'John: unclaimed rewards');
366 | 
367 |         // check amount of staked tokens left in contract for each user
368 |         assert(state.balance_of.read(alice) == 0, 'Alice: staked tokens left');
369 |         assert(state.balance_of.read(bob) == 0, 'Bob: staked tokens left');
370 |         assert(state.balance_of.read(john) == 10, 'John: wrong staked tokens');
371 | 
372 |         // check amount of reward tokens for each user
373 |         let alice_rewards = deploy.reward_token.balance_of(alice);
374 |         let bob_rewards = deploy.reward_token.balance_of(bob);
375 |         let john_rewards = deploy.reward_token.balance_of(john);
376 |         let deployed_contract_rewards = deploy
377 |             .reward_token
378 |             .balance_of(deploy.contract.contract_address);
379 |         assert_eq!(alice_rewards, 600);
380 |         assert_eq!(bob_rewards, 40);
381 |         assert_eq!(john_rewards, 300);
382 |         // 1000 - 600 - 40 - 300 = 60
383 |         assert_eq!(deployed_contract_rewards, 60);
384 | 
385 |         // check amount of staking tokens each user has back in their balance
386 |         let alice_staking_tokens = deploy.staking_token.balance_of(alice);
387 |         let bob_staking_tokens = deploy.staking_token.balance_of(bob);
388 |         let john_staking_tokens = deploy.staking_token.balance_of(john);
389 |         assert_eq!(alice_staking_tokens, alice_amount_tokens_minted);
390 |         assert_eq!(bob_staking_tokens, bob_amount_tokens_minted);
391 |         assert_eq!(john_staking_tokens, john_amount_tokens_minted - 10);
392 |     }
393 | 
394 |     #[test]
395 |     fn all_rewards_distributed_event() {
396 |         /// set up
397 | 
398 |         // deploy
399 |         let owner = contract_address_const::<'owner'>();
400 |         set_contract_address(owner);
401 |         let deploy = setup();
402 | 
403 |         // mint reward tokens to the deployed contract
404 |         let reward_tokens_amount = 1000;
405 |         mint_reward_tokens_to(
406 |             deploy.contract.contract_address,
407 |             reward_tokens_amount,
408 |             deploy.reward_token.contract_address
409 |         );
410 | 
411 |         // owner sets up rewards duration and amount
412 |         let block_timestamp: u256 = 1000;
413 |         set_block_timestamp(block_timestamp.try_into().unwrap());
414 |         let reward_duration = 100;
415 |         // have to set again the contract_address because it got changed in mint_reward_tokens_to
416 |         // function
417 |         set_contract_address(owner);
418 |         deploy.contract.set_reward_duration(reward_duration);
419 |         deploy.contract.set_reward_amount(reward_tokens_amount);
420 | 
421 |         // mint staking tokens to alice
422 |         let alice = contract_address_const::<'alice'>();
423 |         let alice_stake_amount = 100;
424 |         mint_and_approve_staking_tokens_to(alice, alice_stake_amount, deploy, alice_stake_amount);
425 | 
426 |         // alice stakes
427 |         set_contract_address(alice);
428 |         deploy.contract.stake(alice_stake_amount);
429 | 
430 |         // alice claims her rewards after the duration is over
431 |         set_block_timestamp(
432 |             block_timestamp.try_into().unwrap() + reward_duration.try_into().unwrap()
433 |         );
434 |         deploy.contract.claim_rewards();
435 | 
436 |         /// when
437 | 
438 |         // mint staking tokens to bob
439 |         let bob = contract_address_const::<'bob'>();
440 |         let bob_stake_amount = 50;
441 |         mint_and_approve_staking_tokens_to(bob, bob_stake_amount, deploy, bob_stake_amount);
442 | 
443 |         // bob stakes
444 |         set_contract_address(bob);
445 |         deploy.contract.stake(bob_stake_amount);
446 | 
447 |         /// then
448 | 
449 |         // check 1st event - when alice stakes
450 |         assert_eq!(
451 |             pop_log(deploy.contract.contract_address),
452 |             Option::Some(Event::Deposit(Deposit { user: alice, amount: alice_stake_amount }))
453 |         );
454 |         // check 2nd event - when alice claims
455 |         assert_eq!(
456 |             pop_log(deploy.contract.contract_address),
457 |             Option::Some(Event::RewardsFinished(RewardsFinished { msg: 'Rewards all distributed' }))
458 |         );
459 |         // check 3rd & 4th events - when bob stakes
460 |         assert_eq!(
461 |             pop_log(deploy.contract.contract_address),
462 |             Option::Some(Event::RewardsFinished(RewardsFinished { msg: 'Rewards all distributed' }))
463 |         );
464 |         assert_eq!(
465 |             pop_log(deploy.contract.contract_address),
466 |             Option::Some(Event::Deposit(Deposit { user: bob, amount: bob_stake_amount }))
467 |         );
468 |     }
469 | 
470 |     #[test]
471 |     fn set_up_reward_complex() {
472 |         /// Set up
473 | 
474 |         // deploy
475 |         let owner = contract_address_const::<'owner'>();
476 |         set_contract_address(owner);
477 |         let deploy = setup();
478 | 
479 |         // mint reward tokens to the deployed contract
480 |         let reward_tokens_amount = 1000;
481 |         mint_reward_tokens_to(
482 |             deploy.contract.contract_address,
483 |             reward_tokens_amount,
484 |             deploy.reward_token.contract_address
485 |         );
486 | 
487 |         // owner sets up rewards duration and amount
488 |         let block_timestamp: u256 = 1000;
489 |         set_block_timestamp(block_timestamp.try_into().unwrap());
490 |         let reward_duration = 100;
491 |         let initial_reward = 400;
492 |         // have to set again the contract_address because it got changed in mint_reward_tokens_to
493 |         // function
494 |         set_contract_address(owner);
495 |         deploy.contract.set_reward_duration(reward_duration);
496 |         deploy.contract.set_reward_amount(initial_reward);
497 | 
498 |         // middle check
499 |         let state = @StakingContract::contract_state_for_testing();
500 |         set_contract_address(deploy.contract.contract_address);
501 | 
502 |         // timestamp = 1000
503 |         // finish_at = 1100
504 |         // reward_rate = 400 / 100 = 4 tokens/timestamp_unit
505 | 
506 |         assert_eq!(state.finish_at.read(), block_timestamp + reward_duration);
507 |         assert_eq!(state.last_updated_at.read(), block_timestamp);
508 |         assert_eq!(state.reward_rate.read(), 4);
509 | 
510 |         /// When
511 | 
512 |         // in the middle of the duration, the owner adds some rewards
513 |         let middle_timestamp = block_timestamp + 50;
514 |         set_block_timestamp(middle_timestamp.try_into().unwrap());
515 |         let rewards_to_add = 300;
516 |         set_contract_address(owner);
517 |         deploy.contract.set_reward_amount(rewards_to_add);
518 | 
519 |         /// Then
520 | 
521 |         // timestamp = 1050
522 |         // old_finish_at = 1100
523 |         // old_reward_rate = 4
524 |         // remaining_rewards = 4 * (1100 - 1050) = 200 tokens
525 |         // new_reward_rate = (200 + 300) / 100 = 5
526 |         // new_finish_at = 1050 + 100 = 1150
527 | 
528 |         let state = @StakingContract::contract_state_for_testing();
529 |         set_contract_address(deploy.contract.contract_address);
530 | 
531 |         // the finish_at date is reset
532 |         assert_eq!(state.finish_at.read(), middle_timestamp + reward_duration);
533 |         assert_eq!(state.last_updated_at.read(), middle_timestamp);
534 |         assert_eq!(state.reward_rate.read(), 5);
535 |     }
536 | }
537 | 


--------------------------------------------------------------------------------
/listings/applications/staking/src/tests/tokens.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | pub mod RewardToken {
 3 |     use openzeppelin::token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
 4 |     use starknet::ContractAddress;
 5 | 
 6 |     component!(path: ERC20Component, storage: erc20, event: ERC20Event);
 7 | 
 8 |     #[abi(embed_v0)]
 9 |     impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
10 |     impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         #[substorage(v0)]
15 |         pub erc20: ERC20Component::Storage,
16 |     }
17 | 
18 |     #[event]
19 |     #[derive(Drop, starknet::Event)]
20 |     enum Event {
21 |         #[flat]
22 |         ERC20Event: ERC20Component::Event,
23 |     }
24 | 
25 |     #[constructor]
26 |     fn constructor(
27 |         ref self: ContractState,
28 |         name: ByteArray,
29 |         symbol: ByteArray,
30 |         initial_supply: u256,
31 |         recipient: ContractAddress
32 |     ) {
33 |         self.erc20.initializer(name, symbol);
34 |         self.erc20.mint(recipient, initial_supply);
35 |     }
36 | }
37 | 
38 | #[starknet::contract]
39 | pub mod StakingToken {
40 |     use openzeppelin::token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
41 |     use starknet::ContractAddress;
42 | 
43 |     component!(path: ERC20Component, storage: erc20, event: ERC20Event);
44 | 
45 |     #[abi(embed_v0)]
46 |     impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
47 |     impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;
48 | 
49 |     #[storage]
50 |     struct Storage {
51 |         #[substorage(v0)]
52 |         pub erc20: ERC20Component::Storage,
53 |     }
54 | 
55 |     #[event]
56 |     #[derive(Drop, starknet::Event)]
57 |     enum Event {
58 |         #[flat]
59 |         ERC20Event: ERC20Component::Event,
60 |     }
61 | 
62 |     #[constructor]
63 |     fn constructor(
64 |         ref self: ContractState,
65 |         name: ByteArray,
66 |         symbol: ByteArray,
67 |         initial_supply: u256,
68 |         recipient: ContractAddress
69 |     ) {
70 |         self.erc20.initializer(name, symbol);
71 |         self.erc20.mint(recipient, initial_supply);
72 |     }
73 | }
74 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "timelock"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | openzeppelin.workspace = true
 9 | components.workspace = true
10 | 
11 | [dev-dependencies]
12 | assert_macros.workspace = true
13 | snforge_std.workspace = true
14 | 
15 | [scripts]
16 | test.workspace = true
17 | 
18 | [[target.starknet-contract]]
19 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/src/erc721.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | pub mod ERC721 {
 3 |     use starknet::ContractAddress;
 4 |     use openzeppelin::introspection::src5::SRC5Component;
 5 |     use openzeppelin::token::erc721::{ERC721Component, ERC721HooksEmptyImpl};
 6 | 
 7 |     component!(path: ERC721Component, storage: erc721, event: ERC721Event);
 8 |     component!(path: SRC5Component, storage: src5, event: SRC5Event);
 9 | 
10 |     // ERC20Mixin
11 |     #[abi(embed_v0)]
12 |     impl ERC721MixinImpl = ERC721Component::ERC721MixinImpl<ContractState>;
13 |     impl ERC721InternalImpl = ERC721Component::InternalImpl<ContractState>;
14 | 
15 |     #[storage]
16 |     struct Storage {
17 |         #[substorage(v0)]
18 |         src5: SRC5Component::Storage,
19 |         #[substorage(v0)]
20 |         erc721: ERC721Component::Storage,
21 |     }
22 | 
23 |     #[event]
24 |     #[derive(Drop, starknet::Event)]
25 |     enum Event {
26 |         #[flat]
27 |         SRC5Event: SRC5Component::Event,
28 |         #[flat]
29 |         ERC721Event: ERC721Component::Event,
30 |     }
31 | 
32 |     #[constructor]
33 |     fn constructor(
34 |         ref self: ContractState,
35 |         name: ByteArray,
36 |         symbol: ByteArray,
37 |         base_uri: ByteArray,
38 |         recipient: ContractAddress,
39 |         token_id: u256
40 |     ) {
41 |         self.erc721.initializer(name, symbol, base_uri);
42 |         self.erc721.mint(recipient, token_id);
43 |     }
44 | }
45 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/src/lib.cairo:
--------------------------------------------------------------------------------
1 | #[cfg(test)]
2 | mod tests {
3 |     #[feature("safe_dispatcher")]
4 |     mod timelock;
5 |     mod utils;
6 | }
7 | mod erc721;
8 | mod timelock;
9 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/src/tests/timelock.cairo:
--------------------------------------------------------------------------------
  1 | use core::panic_with_felt252;
  2 | use starknet::account::Call;
  3 | use core::poseidon::{PoseidonTrait, poseidon_hash_span};
  4 | use core::hash::HashStateTrait;
  5 | use snforge_std::{
  6 |     cheat_caller_address, cheat_block_timestamp, CheatSpan, spy_events, EventSpyAssertionsTrait
  7 | };
  8 | use openzeppelin::token::erc721::interface::IERC721DispatcherTrait;
  9 | use openzeppelin::token::erc721::erc721::ERC721Component;
 10 | use components::ownable;
 11 | use timelock::timelock::{TimeLock, ITimeLockDispatcherTrait, ITimeLockSafeDispatcherTrait};
 12 | use timelock::tests::utils::{TimeLockTestTrait, TOKEN_ID, OTHER};
 13 | 
 14 | #[test]
 15 | fn test_get_tx_id_success() {
 16 |     let timelock_test = TimeLockTestTrait::setup();
 17 |     let timestamp = timelock_test.get_timestamp();
 18 |     let tx_id = timelock_test.timelock.get_tx_id(timelock_test.get_call(), timestamp);
 19 |     let Call { to, selector, calldata } = timelock_test.get_call();
 20 |     let hash = PoseidonTrait::new()
 21 |         .update(to.into())
 22 |         .update(selector.into())
 23 |         .update(poseidon_hash_span(calldata))
 24 |         .update(timestamp.into())
 25 |         .finalize();
 26 |     assert_eq!(tx_id, hash);
 27 | }
 28 | 
 29 | #[test]
 30 | fn test_queue_only_owner() {
 31 |     let timelock_test = TimeLockTestTrait::setup();
 32 |     cheat_caller_address(timelock_test.timelock_address, OTHER(), CheatSpan::TargetCalls(1));
 33 |     match timelock_test
 34 |         .timelock_safe
 35 |         .queue(timelock_test.get_call(), timelock_test.get_timestamp()) {
 36 |         Result::Ok(_) => panic_with_felt252('FAIL'),
 37 |         Result::Err(panic_data) => { assert_eq!(*panic_data.at(0), ownable::Errors::UNAUTHORIZED); }
 38 |     }
 39 | }
 40 | 
 41 | #[test]
 42 | fn test_queue_already_queued() {
 43 |     let timelock_test = TimeLockTestTrait::setup();
 44 |     let timestamp = timelock_test.get_timestamp();
 45 |     timelock_test.timelock.queue(timelock_test.get_call(), timestamp);
 46 |     match timelock_test.timelock_safe.queue(timelock_test.get_call(), timestamp) {
 47 |         Result::Ok(_) => panic_with_felt252('FAIL'),
 48 |         Result::Err(panic_data) => {
 49 |             assert_eq!(*panic_data.at(0), TimeLock::Errors::ALREADY_QUEUED);
 50 |         }
 51 |     }
 52 | }
 53 | 
 54 | #[test]
 55 | fn test_queue_timestamp_not_in_range() {
 56 |     let timelock_test = TimeLockTestTrait::setup();
 57 |     match timelock_test.timelock_safe.queue(timelock_test.get_call(), 0) {
 58 |         Result::Ok(_) => panic_with_felt252('FAIL'),
 59 |         Result::Err(panic_data) => {
 60 |             assert_eq!(*panic_data.at(0), TimeLock::Errors::TIMESTAMP_NOT_IN_RANGE);
 61 |         }
 62 |     }
 63 |     match timelock_test
 64 |         .timelock_safe
 65 |         .queue(timelock_test.get_call(), timelock_test.get_timestamp() + TimeLock::MAX_DELAY) {
 66 |         Result::Ok(_) => panic_with_felt252('FAIL'),
 67 |         Result::Err(panic_data) => {
 68 |             assert_eq!(*panic_data.at(0), TimeLock::Errors::TIMESTAMP_NOT_IN_RANGE);
 69 |         }
 70 |     }
 71 | }
 72 | 
 73 | #[test]
 74 | fn test_queue_success() {
 75 |     let timelock_test = TimeLockTestTrait::setup();
 76 |     let mut spy = spy_events();
 77 |     let timestamp = timelock_test.get_timestamp();
 78 |     let tx_id = timelock_test.timelock.queue(timelock_test.get_call(), timestamp);
 79 |     spy
 80 |         .assert_emitted(
 81 |             @array![
 82 |                 (
 83 |                     timelock_test.timelock_address,
 84 |                     TimeLock::Event::Queue(
 85 |                         TimeLock::Queue { tx_id, call: timelock_test.get_call(), timestamp }
 86 |                     )
 87 |                 )
 88 |             ]
 89 |         );
 90 |     assert_eq!(tx_id, timelock_test.timelock.get_tx_id(timelock_test.get_call(), timestamp));
 91 | }
 92 | 
 93 | #[test]
 94 | fn test_execute_only_owner() {
 95 |     let timelock_test = TimeLockTestTrait::setup();
 96 |     cheat_caller_address(timelock_test.timelock_address, OTHER(), CheatSpan::TargetCalls(1));
 97 |     match timelock_test
 98 |         .timelock_safe
 99 |         .execute(timelock_test.get_call(), timelock_test.get_timestamp()) {
100 |         Result::Ok(_) => panic_with_felt252('FAIL'),
101 |         Result::Err(panic_data) => { assert_eq!(*panic_data.at(0), ownable::Errors::UNAUTHORIZED); }
102 |     }
103 | }
104 | 
105 | #[test]
106 | fn test_execute_not_queued() {
107 |     let timelock_test = TimeLockTestTrait::setup();
108 |     match timelock_test
109 |         .timelock_safe
110 |         .execute(timelock_test.get_call(), timelock_test.get_timestamp()) {
111 |         Result::Ok(_) => panic_with_felt252('FAIL'),
112 |         Result::Err(panic_data) => { assert_eq!(*panic_data.at(0), TimeLock::Errors::NOT_QUEUED); }
113 |     }
114 | }
115 | 
116 | #[test]
117 | fn test_execute_timestamp_not_passed() {
118 |     let timelock_test = TimeLockTestTrait::setup();
119 |     let timestamp = timelock_test.get_timestamp();
120 |     timelock_test.timelock.queue(timelock_test.get_call(), timestamp);
121 |     match timelock_test.timelock_safe.execute(timelock_test.get_call(), timestamp) {
122 |         Result::Ok(_) => panic_with_felt252('FAIL'),
123 |         Result::Err(panic_data) => {
124 |             assert_eq!(*panic_data.at(0), TimeLock::Errors::TIMESTAMP_NOT_PASSED);
125 |         }
126 |     }
127 | }
128 | 
129 | #[test]
130 | fn test_execute_timestamp_expired() {
131 |     let timelock_test = TimeLockTestTrait::setup();
132 |     let timestamp = timelock_test.get_timestamp();
133 |     timelock_test.timelock.queue(timelock_test.get_call(), timestamp);
134 |     cheat_block_timestamp(
135 |         timelock_test.timelock_address,
136 |         timestamp + TimeLock::GRACE_PERIOD + 1,
137 |         CheatSpan::TargetCalls(1)
138 |     );
139 |     match timelock_test.timelock_safe.execute(timelock_test.get_call(), timestamp) {
140 |         Result::Ok(_) => panic_with_felt252('FAIL'),
141 |         Result::Err(panic_data) => {
142 |             assert_eq!(*panic_data.at(0), TimeLock::Errors::TIMESTAMP_EXPIRED);
143 |         }
144 |     }
145 | }
146 | 
147 | #[test]
148 | fn test_execute_success() {
149 |     let timelock_test = TimeLockTestTrait::setup();
150 |     let timestamp = timelock_test.get_timestamp();
151 |     let tx_id = timelock_test.timelock.get_tx_id(timelock_test.get_call(), timestamp);
152 |     timelock_test.timelock.queue(timelock_test.get_call(), timestamp);
153 |     timelock_test.erc721.approve(timelock_test.timelock_address, TOKEN_ID);
154 |     cheat_block_timestamp(timelock_test.timelock_address, timestamp + 1, CheatSpan::TargetCalls(1));
155 |     let mut spy = spy_events();
156 |     timelock_test.timelock.execute(timelock_test.get_call(), timestamp);
157 |     spy
158 |         .assert_emitted(
159 |             @array![
160 |                 (
161 |                     timelock_test.timelock_address,
162 |                     TimeLock::Event::Execute(
163 |                         TimeLock::Execute { tx_id, call: timelock_test.get_call(), timestamp }
164 |                     )
165 |                 )
166 |             ]
167 |         );
168 | }
169 | 
170 | #[test]
171 | fn test_execute_failed() {
172 |     let timelock_test = TimeLockTestTrait::setup();
173 |     let timestamp = timelock_test.get_timestamp();
174 |     timelock_test.timelock.queue(timelock_test.get_call(), timestamp);
175 |     cheat_block_timestamp(timelock_test.timelock_address, timestamp + 1, CheatSpan::TargetCalls(1));
176 |     match timelock_test.timelock_safe.execute(timelock_test.get_call(), timestamp) {
177 |         Result::Ok(_) => panic_with_felt252('FAIL'),
178 |         Result::Err(panic_data) => {
179 |             assert_eq!(*panic_data.at(0), ERC721Component::Errors::UNAUTHORIZED);
180 |         }
181 |     }
182 | }
183 | 
184 | #[test]
185 | fn test_cancel_only_owner() {
186 |     let timelock_test = TimeLockTestTrait::setup();
187 |     let tx_id = timelock_test
188 |         .timelock
189 |         .get_tx_id(timelock_test.get_call(), timelock_test.get_timestamp());
190 |     cheat_caller_address(timelock_test.timelock_address, OTHER(), CheatSpan::TargetCalls(1));
191 |     match timelock_test.timelock_safe.cancel(tx_id) {
192 |         Result::Ok(_) => panic_with_felt252('FAIL'),
193 |         Result::Err(panic_data) => { assert_eq!(*panic_data.at(0), ownable::Errors::UNAUTHORIZED); }
194 |     }
195 | }
196 | 
197 | #[test]
198 | fn test_cancel_not_queued() {
199 |     let timelock_test = TimeLockTestTrait::setup();
200 |     let tx_id = timelock_test
201 |         .timelock
202 |         .get_tx_id(timelock_test.get_call(), timelock_test.get_timestamp());
203 |     match timelock_test.timelock_safe.cancel(tx_id) {
204 |         Result::Ok(_) => panic_with_felt252('FAIL'),
205 |         Result::Err(panic_data) => { assert_eq!(*panic_data.at(0), TimeLock::Errors::NOT_QUEUED); }
206 |     }
207 | }
208 | 
209 | #[test]
210 | fn test_cancel_success() {
211 |     let timelock_test = TimeLockTestTrait::setup();
212 |     let tx_id = timelock_test
213 |         .timelock
214 |         .queue(timelock_test.get_call(), timelock_test.get_timestamp());
215 |     let mut spy = spy_events();
216 |     timelock_test.timelock.cancel(tx_id);
217 |     spy
218 |         .assert_emitted(
219 |             @array![
220 |                 (
221 |                     timelock_test.timelock_address,
222 |                     TimeLock::Event::Cancel(TimeLock::Cancel { tx_id })
223 |                 )
224 |             ]
225 |         );
226 | }
227 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/src/tests/utils.cairo:
--------------------------------------------------------------------------------
 1 | use starknet::{ContractAddress, contract_address_const, get_block_timestamp};
 2 | use starknet::account::Call;
 3 | use snforge_std::{declare, ContractClassTrait, test_address, DeclareResultTrait};
 4 | use openzeppelin::utils::serde::SerializedAppend;
 5 | use openzeppelin::token::erc721::interface::IERC721Dispatcher;
 6 | use timelock::timelock::{TimeLock, ITimeLockDispatcher, ITimeLockSafeDispatcher};
 7 | 
 8 | pub const TOKEN_ID: u256 = 1;
 9 | 
10 | pub fn NAME() -> ByteArray {
11 |     "NAME"
12 | }
13 | 
14 | pub fn SYMBOL() -> ByteArray {
15 |     "SYMBOL"
16 | }
17 | 
18 | pub fn BASE_URI() -> ByteArray {
19 |     "https://api.example.com/v1/"
20 | }
21 | 
22 | pub fn OTHER() -> ContractAddress {
23 |     contract_address_const::<'OTHER'>()
24 | }
25 | 
26 | #[derive(Copy, Drop)]
27 | pub struct TimeLockTest {
28 |     pub timelock_address: ContractAddress,
29 |     pub timelock: ITimeLockDispatcher,
30 |     pub timelock_safe: ITimeLockSafeDispatcher,
31 |     pub erc721_address: ContractAddress,
32 |     pub erc721: IERC721Dispatcher,
33 | }
34 | 
35 | #[generate_trait]
36 | pub impl TimeLockTestImpl of TimeLockTestTrait {
37 |     fn setup() -> TimeLockTest {
38 |         let timelock_contract = *declare("TimeLock").unwrap().contract_class();
39 |         let mut timelock_calldata = array![];
40 |         let (timelock_address, _) = timelock_contract.deploy(@timelock_calldata).unwrap();
41 |         let timelock = ITimeLockDispatcher { contract_address: timelock_address };
42 |         let timelock_safe = ITimeLockSafeDispatcher { contract_address: timelock_address };
43 |         let erc721_contract = *declare("ERC721").unwrap().contract_class();
44 |         let mut erc721_calldata = array![];
45 |         erc721_calldata.append_serde(NAME());
46 |         erc721_calldata.append_serde(SYMBOL());
47 |         erc721_calldata.append_serde(BASE_URI());
48 |         erc721_calldata.append_serde(test_address());
49 |         erc721_calldata.append_serde(TOKEN_ID);
50 |         let (erc721_address, _) = erc721_contract.deploy(@erc721_calldata).unwrap();
51 |         let erc721 = IERC721Dispatcher { contract_address: erc721_address };
52 |         TimeLockTest { timelock_address, timelock, timelock_safe, erc721_address, erc721 }
53 |     }
54 |     fn get_call(self: @TimeLockTest) -> Call {
55 |         let mut calldata = array![];
56 |         calldata.append_serde(test_address());
57 |         calldata.append_serde(*self.timelock_address);
58 |         calldata.append_serde(TOKEN_ID);
59 |         Call {
60 |             to: *self.erc721_address,
61 |             selector: selector!("transfer_from"),
62 |             calldata: calldata.span()
63 |         }
64 |     }
65 |     fn get_timestamp(self: @TimeLockTest) -> u64 {
66 |         get_block_timestamp() + TimeLock::MIN_DELAY
67 |     }
68 | }
69 | 


--------------------------------------------------------------------------------
/listings/applications/timelock/src/timelock.cairo:
--------------------------------------------------------------------------------
  1 | use starknet::account::Call;
  2 | 
  3 | #[starknet::interface]
  4 | pub trait ITimeLock<TState> {
  5 |     fn get_tx_id(self: @TState, call: Call, timestamp: u64) -> felt252;
  6 |     fn queue(ref self: TState, call: Call, timestamp: u64) -> felt252;
  7 |     fn execute(ref self: TState, call: Call, timestamp: u64) -> Span<felt252>;
  8 |     fn cancel(ref self: TState, tx_id: felt252);
  9 | }
 10 | 
 11 | #[starknet::contract]
 12 | pub mod TimeLock {
 13 |     use core::poseidon::{PoseidonTrait, poseidon_hash_span};
 14 |     use core::hash::HashStateTrait;
 15 |     use starknet::{get_caller_address, get_block_timestamp, SyscallResultTrait, syscalls};
 16 |     use starknet::account::Call;
 17 |     use components::ownable::ownable_component;
 18 |     use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
 19 | 
 20 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
 21 | 
 22 |     // Ownable
 23 |     #[abi(embed_v0)]
 24 |     impl OwnableImpl = ownable_component::Ownable<ContractState>;
 25 |     impl OwnableInternalImpl = ownable_component::OwnableInternalImpl<ContractState>;
 26 | 
 27 |     #[storage]
 28 |     struct Storage {
 29 |         #[substorage(v0)]
 30 |         ownable: ownable_component::Storage,
 31 |         queued: Map::<felt252, bool>,
 32 |     }
 33 | 
 34 |     #[event]
 35 |     #[derive(Drop, starknet::Event)]
 36 |     pub enum Event {
 37 |         #[flat]
 38 |         OwnableEvent: ownable_component::Event,
 39 |         Queue: Queue,
 40 |         Execute: Execute,
 41 |         Cancel: Cancel
 42 |     }
 43 | 
 44 |     #[derive(Drop, starknet::Event)]
 45 |     pub struct Queue {
 46 |         #[key]
 47 |         pub tx_id: felt252,
 48 |         pub call: Call,
 49 |         pub timestamp: u64
 50 |     }
 51 | 
 52 |     #[derive(Drop, starknet::Event)]
 53 |     pub struct Execute {
 54 |         #[key]
 55 |         pub tx_id: felt252,
 56 |         pub call: Call,
 57 |         pub timestamp: u64
 58 |     }
 59 | 
 60 |     #[derive(Drop, starknet::Event)]
 61 |     pub struct Cancel {
 62 |         #[key]
 63 |         pub tx_id: felt252
 64 |     }
 65 | 
 66 |     pub const MIN_DELAY: u64 = 10; // seconds
 67 |     pub const MAX_DELAY: u64 = 1000; // seconds
 68 |     pub const GRACE_PERIOD: u64 = 1000; // seconds
 69 | 
 70 |     pub mod Errors {
 71 |         pub const ALREADY_QUEUED: felt252 = 'TimeLock: already queued';
 72 |         pub const TIMESTAMP_NOT_IN_RANGE: felt252 = 'TimeLock: timestamp range';
 73 |         pub const NOT_QUEUED: felt252 = 'TimeLock: not queued';
 74 |         pub const TIMESTAMP_NOT_PASSED: felt252 = 'TimeLock: timestamp not passed';
 75 |         pub const TIMESTAMP_EXPIRED: felt252 = 'TimeLock: timestamp expired';
 76 |     }
 77 | 
 78 |     #[constructor]
 79 |     fn constructor(ref self: ContractState) {
 80 |         self.ownable._init(get_caller_address());
 81 |     }
 82 | 
 83 |     #[abi(embed_v0)]
 84 |     impl TimeLockImpl of super::ITimeLock<ContractState> {
 85 |         fn get_tx_id(self: @ContractState, call: Call, timestamp: u64) -> felt252 {
 86 |             PoseidonTrait::new()
 87 |                 .update(call.to.into())
 88 |                 .update(call.selector.into())
 89 |                 .update(poseidon_hash_span(call.calldata))
 90 |                 .update(timestamp.into())
 91 |                 .finalize()
 92 |         }
 93 | 
 94 |         fn queue(ref self: ContractState, call: Call, timestamp: u64) -> felt252 {
 95 |             self.ownable._assert_only_owner();
 96 | 
 97 |             let tx_id = self.get_tx_id(self._copy_call(@call), timestamp);
 98 |             assert(!self.queued.read(tx_id), Errors::ALREADY_QUEUED);
 99 |             // ---|------------|---------------|-------
100 |             //  block    block + min     block + max
101 |             let block_timestamp = get_block_timestamp();
102 |             assert(
103 |                 timestamp >= block_timestamp
104 |                     + MIN_DELAY && timestamp <= block_timestamp
105 |                     + MAX_DELAY,
106 |                 Errors::TIMESTAMP_NOT_IN_RANGE
107 |             );
108 | 
109 |             self.queued.write(tx_id, true);
110 |             self.emit(Queue { tx_id, call: self._copy_call(@call), timestamp });
111 | 
112 |             tx_id
113 |         }
114 | 
115 |         fn execute(ref self: ContractState, call: Call, timestamp: u64) -> Span<felt252> {
116 |             self.ownable._assert_only_owner();
117 | 
118 |             let tx_id = self.get_tx_id(self._copy_call(@call), timestamp);
119 |             assert(self.queued.read(tx_id), Errors::NOT_QUEUED);
120 |             // ----|-------------------|-------
121 |             //  timestamp    timestamp + grace period
122 |             let block_timestamp = get_block_timestamp();
123 |             assert(block_timestamp >= timestamp, Errors::TIMESTAMP_NOT_PASSED);
124 |             assert(block_timestamp <= timestamp + GRACE_PERIOD, Errors::TIMESTAMP_EXPIRED);
125 | 
126 |             self.queued.write(tx_id, false);
127 | 
128 |             let result = syscalls::call_contract_syscall(call.to, call.selector, call.calldata)
129 |                 .unwrap_syscall();
130 | 
131 |             self.emit(Execute { tx_id, call: self._copy_call(@call), timestamp });
132 | 
133 |             result
134 |         }
135 | 
136 |         fn cancel(ref self: ContractState, tx_id: felt252) {
137 |             self.ownable._assert_only_owner();
138 | 
139 |             assert(self.queued.read(tx_id), Errors::NOT_QUEUED);
140 | 
141 |             self.queued.write(tx_id, false);
142 | 
143 |             self.emit(Cancel { tx_id });
144 |         }
145 |     }
146 | 
147 |     #[generate_trait]
148 |     impl InternalImpl of InternalTrait {
149 |         fn _copy_call(self: @ContractState, call: @Call) -> Call {
150 |             Call { to: *call.to, selector: *call.selector, calldata: *call.calldata }
151 |         }
152 |     }
153 | }
154 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "upgradeable_contract"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "upgradeable_contract"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod upgradeable_contract_v0;
2 | mod upgradeable_contract_v1;
3 | 
4 | #[cfg(test)]
5 | mod tests;
6 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/src/tests.cairo:
--------------------------------------------------------------------------------
 1 | mod tests {
 2 |     use starknet::class_hash::ClassHash;
 3 | 
 4 |     use super::super::upgradeable_contract_v0::{
 5 |         UpgradeableContract_V0, IUpgradeableContractDispatcher as IUpgradeableContractDispatcher_v0,
 6 |         IUpgradeableContractDispatcherTrait as UpgradeableContractDispatcherTrait_v0,
 7 |         UpgradeableContract_V0::{Event, Upgraded}
 8 |     };
 9 | 
10 |     use super::super::upgradeable_contract_v1::{
11 |         UpgradeableContract_V1, IUpgradeableContractDispatcher as IUpgradeableContractDispatcher_v1,
12 |         IUpgradeableContractDispatcherTrait as UpgradeableContractDispatcherTrait_v1
13 |     };
14 | 
15 | 
16 |     use starknet::{
17 |         ContractAddress, SyscallResultTrait, syscalls::deploy_syscall, get_caller_address,
18 |         contract_address_const
19 |     };
20 |     use core::num::traits::Zero;
21 | 
22 |     use starknet::testing::{set_contract_address, set_account_contract_address};
23 | 
24 |     // deploy v0 contract
25 |     fn deploy_v0() -> (IUpgradeableContractDispatcher_v0, ContractAddress, ClassHash) {
26 |         let (contract_address, _) = deploy_syscall(
27 |             UpgradeableContract_V0::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
28 |         )
29 |             .unwrap_syscall();
30 |         (
31 |             IUpgradeableContractDispatcher_v0 { contract_address },
32 |             contract_address,
33 |             UpgradeableContract_V0::TEST_CLASS_HASH.try_into().unwrap()
34 |         )
35 |     }
36 | 
37 |     //  deploy v1 contract
38 |     fn deploy_v1() -> (IUpgradeableContractDispatcher_v1, ContractAddress, ClassHash) {
39 |         let (contract_address, _) = deploy_syscall(
40 |             UpgradeableContract_V1::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
41 |         )
42 |             .unwrap_syscall();
43 |         (
44 |             IUpgradeableContractDispatcher_v1 { contract_address },
45 |             contract_address,
46 |             UpgradeableContract_V1::TEST_CLASS_HASH.try_into().unwrap()
47 |         )
48 |     }
49 | 
50 |     #[test]
51 |     fn test_deploy_v0() {
52 |         deploy_v0();
53 |     }
54 | 
55 |     #[test]
56 |     fn test_deploy_v1() {
57 |         deploy_v1();
58 |     }
59 | 
60 |     #[test]
61 |     fn test_version_from_v0() {
62 |         let (dispatcher, _, _) = deploy_v0();
63 |         assert(dispatcher.version() == 0, 'incorrect version');
64 |     }
65 | 
66 |     #[test]
67 |     #[should_panic(expected: ('Class hash cannot be zero', 'ENTRYPOINT_FAILED'))]
68 |     fn test_upgrade_when_classhash_is_zero() {
69 |         let (dispatcher_v0, _, _) = deploy_v0();
70 |         dispatcher_v0.upgrade(Zero::zero());
71 |     }
72 | 
73 |     #[test]
74 |     fn test_successful_upgrade_from_v0_to_v1() {
75 |         let (dispatcher_v0, contract_address, _) = deploy_v0();
76 |         let (_, _, class_hash) = deploy_v1();
77 |         dispatcher_v0.upgrade(class_hash);
78 |         // emit event
79 |         assert_eq!(
80 |             starknet::testing::pop_log(contract_address),
81 |             Option::Some(Event::Upgraded(Upgraded { implementation: class_hash }))
82 |         );
83 | 
84 |         assert(dispatcher_v0.version() == 1, ' version did not upgrade');
85 |     }
86 | }
87 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/src/upgradeable_contract_v0.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | use starknet::class_hash::ClassHash;
 3 | 
 4 | #[starknet::interface]
 5 | pub trait IUpgradeableContract<TContractState> {
 6 |     fn upgrade(ref self: TContractState, impl_hash: ClassHash);
 7 |     fn version(self: @TContractState) -> u8;
 8 | }
 9 | 
10 | #[starknet::contract]
11 | pub mod UpgradeableContract_V0 {
12 |     use starknet::class_hash::ClassHash;
13 |     use starknet::SyscallResultTrait;
14 |     use core::num::traits::Zero;
15 | 
16 |     #[storage]
17 |     struct Storage {}
18 | 
19 |     #[event]
20 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
21 |     pub enum Event {
22 |         Upgraded: Upgraded,
23 |     }
24 | 
25 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
26 |     pub struct Upgraded {
27 |         pub implementation: ClassHash
28 |     }
29 | 
30 |     #[abi(embed_v0)]
31 |     impl UpgradeableContract of super::IUpgradeableContract<ContractState> {
32 |         // [!region upgrade]
33 |         fn upgrade(ref self: ContractState, impl_hash: ClassHash) {
34 |             assert(impl_hash.is_non_zero(), 'Class hash cannot be zero');
35 |             starknet::syscalls::replace_class_syscall(impl_hash).unwrap_syscall();
36 |             self.emit(Event::Upgraded(Upgraded { implementation: impl_hash }))
37 |         }
38 |         // [!endregion upgrade]
39 | 
40 |         fn version(self: @ContractState) -> u8 {
41 |             0
42 |         }
43 |     }
44 | }
45 | // [!endregion contract]
46 | 
47 | 
48 | 


--------------------------------------------------------------------------------
/listings/applications/upgradeable_contract/src/upgradeable_contract_v1.cairo:
--------------------------------------------------------------------------------
 1 | use starknet::class_hash::ClassHash;
 2 | 
 3 | #[starknet::interface]
 4 | pub trait IUpgradeableContract<TContractState> {
 5 |     fn upgrade(ref self: TContractState, impl_hash: ClassHash);
 6 |     fn version(self: @TContractState) -> u8;
 7 | }
 8 | 
 9 | #[starknet::contract]
10 | pub mod UpgradeableContract_V1 {
11 |     use starknet::class_hash::ClassHash;
12 |     use starknet::SyscallResultTrait;
13 |     use core::num::traits::Zero;
14 | 
15 |     #[storage]
16 |     struct Storage {}
17 | 
18 |     #[event]
19 |     #[derive(Drop, starknet::Event)]
20 |     enum Event {
21 |         Upgraded: Upgraded
22 |     }
23 | 
24 |     #[derive(Drop, starknet::Event)]
25 |     struct Upgraded {
26 |         implementation: ClassHash
27 |     }
28 | 
29 |     #[abi(embed_v0)]
30 |     impl UpgradeableContract of super::IUpgradeableContract<ContractState> {
31 |         fn upgrade(ref self: ContractState, impl_hash: ClassHash) {
32 |             assert(impl_hash.is_non_zero(), 'Class hash cannot be zero');
33 |             starknet::syscalls::replace_class_syscall(impl_hash).unwrap_syscall();
34 |             self.emit(Event::Upgraded(Upgraded { implementation: impl_hash }))
35 |         }
36 | 
37 |         fn version(self: @ContractState) -> u8 {
38 |             1
39 |         }
40 |     }
41 | }
42 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "cairo_cheatsheet"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "cairo_cheatsheet"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | allowed-libfuncs-list.name = "experimental"
17 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/array_example.cairo:
--------------------------------------------------------------------------------
 1 | fn array() -> bool {
 2 |     let mut arr = array![];
 3 |     arr.append(10);
 4 |     arr.append(20);
 5 |     arr.append(30);
 6 | 
 7 |     assert(arr.len() == 3, 'array length should be 3');
 8 | 
 9 |     let first_value = arr.pop_front().unwrap();
10 |     assert(first_value == 10, 'first value should match');
11 | 
12 |     let second_value = *arr.at(0);
13 |     assert(second_value == 20, 'second value should match');
14 | 
15 |     // Returns true if an array is empty, and false if it isn't.
16 |     arr.is_empty()
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/dict_example.cairo:
--------------------------------------------------------------------------------
 1 | // [!region sheet]
 2 | use core::dict::Felt252Dict;
 3 | 
 4 | fn dict() {
 5 |     let mut Auctions: Felt252Dict<u64> = Default::default();
 6 | 
 7 |     Auctions.insert('Bola', 30);
 8 |     Auctions.insert('Maria', 40);
 9 | 
10 |     let bola_balance = Auctions.get('Bola');
11 |     assert!(bola_balance == 30, "Bola balance should be 30");
12 | 
13 |     let maria_balance = Auctions.get('Maria');
14 |     assert!(maria_balance == 40, "Maria balance should be 40");
15 | }
16 | // [!endregion sheet]
17 | 
18 | 
19 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/enum_example.cairo:
--------------------------------------------------------------------------------
 1 | // [!region enums]
 2 | #[derive(Drop, Serde, Copy, starknet::Store)]
 3 | struct Position {
 4 |     x: u32,
 5 |     y: u32,
 6 | }
 7 | 
 8 | #[derive(Drop, Serde, Copy, starknet::Store)]
 9 | enum UserCommand {
10 |     Login,
11 |     UpdateProfile,
12 |     Logout,
13 | }
14 | 
15 | #[derive(Drop, Serde, Copy, starknet::Store)]
16 | enum Action {
17 |     Quit,
18 |     Move: Position,
19 |     SendMessage: felt252,
20 |     ChangeAvatarColor: (u8, u8, u8),
21 |     ProfileState: UserCommand
22 | }
23 | // [!endregion enums]
24 | 
25 | // [!region enum_contract]
26 | #[starknet::interface]
27 | trait IEnumContract<TContractState> {
28 |     fn register_action(ref self: TContractState, action: Action);
29 |     fn generate_default_actions_list(self: @TContractState) -> Array<Action>;
30 | }
31 | 
32 | #[starknet::contract]
33 | mod EnumContract {
34 |     use starknet::storage::StoragePointerWriteAccess;
35 |     use super::IEnumContract;
36 |     use super::{Action, Position, UserCommand};
37 | 
38 |     #[storage]
39 |     struct Storage {
40 |         most_recent_action: Action,
41 |     }
42 | 
43 |     #[abi(embed_v0)]
44 |     impl IEnumContractImpl of IEnumContract<ContractState> {
45 |         fn register_action(ref self: ContractState, action: Action) {
46 |             // quick note: match takes ownership of variable (but enum Action implements Copy trait)
47 |             match action {
48 |                 Action::Quit => { println!("Quit"); },
49 |                 Action::Move(value) => { println!("Move with x: {} and y: {}", value.x, value.y); },
50 |                 Action::SendMessage(msg) => { println!("Write with message: {}", msg); },
51 |                 Action::ChangeAvatarColor((
52 |                     r, g, b
53 |                 )) => { println!("Change color to r: {}, g: {}, b: {}", r, g, b); },
54 |                 Action::ProfileState(state) => {
55 |                     let profile_state = match state {
56 |                         UserCommand::Login => 1,
57 |                         UserCommand::UpdateProfile => 2,
58 |                         UserCommand::Logout => 3,
59 |                     };
60 |                     println!("profile_state: {}", profile_state);
61 |                 }
62 |             };
63 | 
64 |             self.most_recent_action.write(action);
65 |         }
66 | 
67 |         fn generate_default_actions_list(self: @ContractState) -> Array<Action> {
68 |             let actions = array![
69 |                 Action::Quit,
70 |                 Action::Move(Position { x: 1, y: 2 }),
71 |                 Action::SendMessage('here is my message'),
72 |                 Action::ChangeAvatarColor((1, 2, 3)),
73 |                 Action::ProfileState(UserCommand::Login),
74 |             ];
75 | 
76 |             actions
77 |         }
78 |     }
79 | }
80 | // [!endregion enum_contract]
81 | 
82 | 
83 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/felt_example.cairo:
--------------------------------------------------------------------------------
1 | fn felt() {
2 |     // [!region sheet]
3 |     let felt: felt252 = 100;
4 |     let felt_as_str = 'Hello Starknet!';
5 | 
6 |     let _felt = felt + felt_as_str;
7 |     // [!endregion sheet]
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/if_let_example.cairo:
--------------------------------------------------------------------------------
 1 | // [!region sheet]
 2 | #[derive(Drop)]
 3 | enum Foo {
 4 |     Bar,
 5 |     Baz,
 6 |     Qux: usize,
 7 | }
 8 | 
 9 | fn if_let() {
10 |     let number = Option::Some(0_usize);
11 |     let letter: Option<usize> = Option::None;
12 | 
13 |     // "if `let` destructures `number` into `Some(i)`:
14 |     // evaluate the block (`{}`).
15 |     if let Option::Some(i) = number {
16 |         println!("Matched {}", i);
17 |     }
18 | 
19 |     // If you need to specify a failure, use an else:
20 |     if let Option::Some(i) = letter {
21 |         println!("Matched {}", i);
22 |     } else {
23 |         // Destructure failed. Change to the failure case.
24 |         println!("Didn't match a number.");
25 |     }
26 | 
27 |     // Using `if let` with enum
28 |     let a = Foo::Bar;
29 |     let b = Foo::Baz;
30 |     let c = Foo::Qux(100);
31 | 
32 |     // Variable a matches Foo::Bar
33 |     if let Foo::Bar = a {
34 |         println!("a is foobar");
35 |     }
36 | 
37 |     // Variable b does not match Foo::Bar
38 |     // So this will print nothing
39 |     if let Foo::Bar = b {
40 |         println!("b is foobar");
41 |     }
42 | 
43 |     // Variable c matches Foo::Qux which has a value
44 |     // Similar to Some() in the previous example
45 |     if let Foo::Qux(value) = c {
46 |         println!("c is {}", value);
47 |     }
48 | }
49 | // [!endregion sheet]
50 | 
51 | 
52 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | mod array_example;
 2 | mod mapping_example;
 3 | mod felt_example;
 4 | mod loop_example;
 5 | mod while_example;
 6 | mod enum_example;
 7 | mod match_example;
 8 | mod struct_example;
 9 | mod type_casting_example;
10 | mod while_let_example;
11 | mod if_let_example;
12 | mod dict_example;
13 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/loop_example.cairo:
--------------------------------------------------------------------------------
 1 | fn do_loop() {
 2 |     // [!region sheet]
 3 |     let mut arr = array![];
 4 | 
 5 |     // Same as ~ while (i < 10) arr.append(i++);
 6 |     let mut i: u32 = 0;
 7 |     let limit = 10;
 8 |     loop {
 9 |         if i == limit {
10 |             break;
11 |         };
12 | 
13 |         arr.append(i);
14 | 
15 |         i += 1;
16 |     };
17 |     // [!endregion sheet]
18 | }
19 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/mapping_example.cairo:
--------------------------------------------------------------------------------
 1 | use starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait IMappingExample<TContractState> {
 5 |     fn register_user(ref self: TContractState, student_add: ContractAddress, studentName: felt252);
 6 |     fn record_student_score(
 7 |         ref self: TContractState, student_add: ContractAddress, subject: felt252, score: u16
 8 |     );
 9 |     fn view_student_name(self: @TContractState, student_add: ContractAddress) -> felt252;
10 |     fn view_student_score(
11 |         self: @TContractState, student_add: ContractAddress, subject: felt252
12 |     ) -> u16;
13 | }
14 | 
15 | #[starknet::contract]
16 | mod MappingContract {
17 |     use starknet::ContractAddress;
18 |     use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
19 | 
20 |     #[storage]
21 |     struct Storage {
22 |         students_name: Map::<ContractAddress, felt252>,
23 |         students_result_record: Map::<(ContractAddress, felt252), u16>,
24 |     }
25 | 
26 |     #[abi(embed_v0)]
27 |     impl External of super::IMappingExample<ContractState> {
28 |         fn register_user(
29 |             ref self: ContractState, student_add: ContractAddress, studentName: felt252
30 |         ) {
31 |             self.students_name.write(student_add, studentName);
32 |         }
33 | 
34 |         fn record_student_score(
35 |             ref self: ContractState, student_add: ContractAddress, subject: felt252, score: u16
36 |         ) {
37 |             self.students_result_record.write((student_add, subject), score);
38 |         }
39 | 
40 |         fn view_student_name(self: @ContractState, student_add: ContractAddress) -> felt252 {
41 |             self.students_name.read(student_add)
42 |         }
43 | 
44 |         fn view_student_score(
45 |             self: @ContractState, student_add: ContractAddress, subject: felt252
46 |         ) -> u16 {
47 |             // for a 2D mapping its important to take note of the amount of brackets being used.
48 |             self.students_result_record.read((student_add, subject))
49 |         }
50 |     }
51 | }
52 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/match_example.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop, Serde)]
 2 | enum Colour {
 3 |     Red,
 4 |     Blue,
 5 |     Green,
 6 |     Orange,
 7 |     Black
 8 | }
 9 | 
10 | #[derive(Drop, Serde)]
11 | enum Coin {
12 |     Penny,
13 |     Nickel,
14 |     Dime,
15 |     Quarter,
16 | }
17 | 
18 | fn value_in_cents(coin: Coin) -> felt252 {
19 |     match coin {
20 |         Coin::Penny => 1,
21 |         Coin::Nickel => 5,
22 |         Coin::Dime => 10,
23 |         Coin::Quarter => 25,
24 |     }
25 | }
26 | 
27 | fn specified_colour(colour: Colour) -> felt252 {
28 |     let mut response: felt252 = '';
29 | 
30 |     match colour {
31 |         Colour::Red => { response = 'You passed in Red'; },
32 |         Colour::Blue => { response = 'You passed in Blue'; },
33 |         Colour::Green => { response = 'You passed in Green'; },
34 |         Colour::Orange => { response = 'You passed in Orange'; },
35 |         Colour::Black => { response = 'You passed in Black'; },
36 |     };
37 | 
38 |     response
39 | }
40 | 
41 | fn quiz(num: felt252) -> felt252 {
42 |     let mut response: felt252 = '';
43 | 
44 |     match num {
45 |         0 => { response = 'You failed' },
46 |         _ => { response = 'You Passed' },
47 |     };
48 | 
49 |     response
50 | }
51 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/struct_example.cairo:
--------------------------------------------------------------------------------
1 | // With Store, you can store Data's structs in the storage part of contracts.
2 | #[derive(Drop, starknet::Store)]
3 | struct Data {
4 |     address: starknet::ContractAddress,
5 |     age: u8
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/tuple_example.cairo:
--------------------------------------------------------------------------------
 1 | fn tuple() {
 2 |     // [!region sheet]
 3 |     let address = "0x000";
 4 |     let age = 20;
 5 |     let active = true;
 6 | 
 7 |     // Create tuple
 8 |     let user_tuple = (address, age, active);
 9 | 
10 |     // Access tuple
11 |     let (address, age, active) = stored_tuple;
12 |     // [!endregion sheet]
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/type_casting_example.cairo:
--------------------------------------------------------------------------------
 1 | fn type_casting() {
 2 |     // [!region sheet]
 3 |     let a_number: u32 = 15;
 4 |     let my_felt252 = 15;
 5 | 
 6 |     // Since a u32 might not fit in a u8 and a u16, we need to use try_into,
 7 |     // then unwrap the Option<T> type thats returned.
 8 |     let _new_u8: u8 = a_number.try_into().unwrap();
 9 |     let new_u16: u16 = a_number.try_into().unwrap();
10 | 
11 |     // since new_u32 is the of the same type (u32) as rand_number, we can directly assign them,
12 |     // or use the .into() method.
13 |     let _new_u32: u32 = a_number;
14 | 
15 |     // When typecasting from a smaller size to an equal or larger size we use the .into() method.
16 |     // Note: u64 and u128 are larger than u32, so a u32 type will always fit into them.
17 |     let _new_u64: u64 = a_number.into();
18 |     let _new_u128: u128 = a_number.into();
19 | 
20 |     // Since a felt252 is smaller than a u256, we can use the into() method
21 |     let _new_u256: u256 = my_felt252.into();
22 |     let _new_felt252: felt252 = new_u16.into();
23 | 
24 |     // Note: usize is smaller than felt252, so we use try_into
25 |     let _new_usize: usize = my_felt252.try_into().unwrap();
26 |     // [!endregion sheet]
27 | }
28 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/while_example.cairo:
--------------------------------------------------------------------------------
 1 | fn do_loop() {
 2 |     // [!region sheet]
 3 |     let mut arr = array![];
 4 | 
 5 |     let mut i: u32 = 0;
 6 |     while (i < 10) {
 7 |         arr.append(i);
 8 |         i += 1;
 9 |     };
10 |     // [!endregion sheet]
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/cairo_cheatsheet/src/while_let_example.cairo:
--------------------------------------------------------------------------------
 1 | fn while_let() {
 2 |     // [!region sheet]
 3 |     let mut option = Option::Some(0_usize);
 4 | 
 5 |     // "while `let` destructures `option` into `Some(i)`,
 6 |     // evaluate the block (`{}`), else `break`
 7 |     while let Option::Some(i) = option {
 8 |         if i > 0 {
 9 |             println!("Greater than 0, break...");
10 |             option = Option::None;
11 |         } else {
12 |             println!("`i` is `{:?}`. Try again.", i);
13 |             option = Option::Some(i + 1);
14 |         }
15 |     }
16 |     // [!endregion sheet]
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/getting-started/bytearray/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/listings/getting-started/bytearray/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "constructor"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/bytearray/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "bytearray"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/bytearray/src/bytearray.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IMessage<TContractState> {
 3 |     fn append(ref self: TContractState, str: ByteArray);
 4 |     fn prepend(ref self: TContractState, str: ByteArray);
 5 | }
 6 | 
 7 | // [!region contract]
 8 | #[starknet::contract]
 9 | pub mod MessageContract {
10 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         pub message: ByteArray
15 |     }
16 | 
17 |     #[constructor]
18 |     fn constructor(ref self: ContractState) {
19 |         self.message.write("World!");
20 |     }
21 | 
22 |     #[abi(embed_v0)]
23 |     impl MessageContract of super::IMessage<ContractState> {
24 |         fn append(ref self: ContractState, str: ByteArray) {
25 |             self.message.write(self.message.read() + str);
26 |         }
27 | 
28 |         fn prepend(ref self: ContractState, str: ByteArray) {
29 |             self.message.write(str + self.message.read());
30 |         }
31 |     }
32 | }
33 | // [!endregion contract]
34 | 
35 | #[cfg(test)]
36 | mod tests {
37 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
38 |     use bytearray::bytearray::{MessageContract, IMessage};
39 | 
40 |     #[test]
41 |     #[available_gas(2000000000)]
42 |     fn message_contract_tests() {
43 |         let mut state = MessageContract::contract_state_for_testing();
44 |         state.message.write("World!");
45 | 
46 |         let message = state.message.read();
47 |         assert(message == "World!", 'wrong message');
48 | 
49 |         state.append(" Good day, sir!");
50 |         assert(state.message.read() == "World! Good day, sir!", 'wrong message (append)');
51 | 
52 |         state.prepend("Hello, ");
53 |         assert(state.message.read() == "Hello, World! Good day, sir!", 'wrong message (prepend)');
54 |     }
55 | }
56 | 


--------------------------------------------------------------------------------
/listings/getting-started/bytearray/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod bytearray;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/calling_other_contracts/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/calling_other_contracts/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "calling_other_contracts"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/calling_other_contracts/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "calling_other_contracts"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/calling_other_contracts/src/caller.cairo:
--------------------------------------------------------------------------------
 1 | // [!region callee_contract]
 2 | // This will automatically generate ICalleeDispatcher and ICalleeDispatcherTrait
 3 | #[starknet::interface]
 4 | pub trait ICallee<TContractState> {
 5 |     fn set_value(ref self: TContractState, value: u128) -> u128;
 6 | }
 7 | 
 8 | #[starknet::contract]
 9 | pub mod Callee {
10 |     use starknet::storage::StoragePointerWriteAccess;
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         pub value: u128,
15 |     }
16 | 
17 |     #[abi(embed_v0)]
18 |     impl ICalleeImpl of super::ICallee<ContractState> {
19 |         fn set_value(ref self: ContractState, value: u128) -> u128 {
20 |             self.value.write(value);
21 |             value
22 |         }
23 |     }
24 | }
25 | // [!endregion callee_contract]
26 | 
27 | #[starknet::interface]
28 | pub trait ICaller<TContractState> {
29 |     fn set_value_from_address(
30 |         ref self: TContractState, addr: starknet::ContractAddress, value: u128
31 |     );
32 | }
33 | 
34 | // [!region caller_contract]
35 | #[starknet::contract]
36 | pub mod Caller {
37 |     // We need to import the dispatcher of the callee contract
38 |     // If you don't have a proper import, you can redefine the interface by yourself
39 |     use super::{ICalleeDispatcher, ICalleeDispatcherTrait};
40 |     use starknet::ContractAddress;
41 | 
42 |     #[storage]
43 |     struct Storage {}
44 | 
45 |     #[abi(embed_v0)]
46 |     impl ICallerImpl of super::ICaller<ContractState> {
47 |         fn set_value_from_address(ref self: ContractState, addr: ContractAddress, value: u128) {
48 |             ICalleeDispatcher { contract_address: addr }.set_value(value);
49 |         }
50 |     }
51 | }
52 | // [!endregion caller_contract]
53 | 
54 | #[cfg(test)]
55 | mod tests {
56 |     use super::{Callee, ICalleeDispatcher, Caller, ICallerDispatcher, ICallerDispatcherTrait};
57 |     use starknet::{testing::set_contract_address, syscalls::deploy_syscall, SyscallResultTrait};
58 |     use starknet::storage::StoragePointerReadAccess;
59 | 
60 |     fn deploy() -> (ICalleeDispatcher, ICallerDispatcher) {
61 |         let (address_callee, _) = deploy_syscall(
62 |             Callee::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
63 |         )
64 |             .unwrap_syscall();
65 |         let (address_caller, _) = deploy_syscall(
66 |             Caller::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
67 |         )
68 |             .unwrap_syscall();
69 |         (
70 |             ICalleeDispatcher { contract_address: address_callee },
71 |             ICallerDispatcher { contract_address: address_caller }
72 |         )
73 |     }
74 | 
75 |     #[test]
76 |     fn test_caller() {
77 |         let init_value: u128 = 42;
78 | 
79 |         let (callee, caller) = deploy();
80 |         caller.set_value_from_address(callee.contract_address, init_value);
81 | 
82 |         let state = @Callee::contract_state_for_testing();
83 |         set_contract_address(callee.contract_address);
84 | 
85 |         let value_read: u128 = state.value.read();
86 | 
87 |         assert_eq!(value_read, init_value);
88 |     }
89 | }
90 | 


--------------------------------------------------------------------------------
/listings/getting-started/calling_other_contracts/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod caller;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/constructor/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/listings/getting-started/constructor/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "constructor"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/constructor/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "constructor"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/constructor/src/constructor.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::contract]
 3 | pub mod ExampleConstructor {
 4 |     use starknet::ContractAddress;
 5 |     use starknet::storage::{Map, StorageMapWriteAccess};
 6 | 
 7 |     #[storage]
 8 |     struct Storage {
 9 |         pub names: Map::<ContractAddress, felt252>,
10 |     }
11 | 
12 |     // The constructor is decorated with a `#[constructor]` attribute.
13 |     // It is not inside an `impl` block.
14 |     #[constructor]
15 |     fn constructor(ref self: ContractState, name: felt252, address: ContractAddress) {
16 |         self.names.write(address, name);
17 |     }
18 | }
19 | // [!endregion contract]
20 | 
21 | // [!region tests]
22 | #[cfg(test)]
23 | mod tests {
24 |     use super::ExampleConstructor;
25 |     use starknet::{ContractAddress, SyscallResultTrait, syscalls::deploy_syscall};
26 |     use starknet::{contract_address_const, testing::{set_contract_address}};
27 |     use starknet::storage::StorageMapReadAccess;
28 | 
29 |     #[test]
30 |     fn should_deploy_with_constructor_init_value() {
31 |         let name: felt252 = 'bob';
32 |         let address: ContractAddress = contract_address_const::<'caller'>();
33 | 
34 |         let (contract_address, _) = deploy_syscall(
35 |             ExampleConstructor::TEST_CLASS_HASH.try_into().unwrap(),
36 |             0,
37 |             array![name, address.into()].span(),
38 |             false
39 |         )
40 |             .unwrap_syscall();
41 | 
42 |         let state = @ExampleConstructor::contract_state_for_testing();
43 |         set_contract_address(contract_address);
44 | 
45 |         let name = state.names.read(address);
46 |         assert_eq!(name, 'bob');
47 |     }
48 | }
49 | // [!endregion tests]
50 | 
51 | 
52 | 


--------------------------------------------------------------------------------
/listings/getting-started/constructor/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod constructor;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/counter/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/counter/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "counter"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/counter/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "counter"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/counter/src/counter.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::interface]
  2 | pub trait ISimpleCounter<TContractState> {
  3 |     fn get_current_count(self: @TContractState) -> u128;
  4 |     fn increment(ref self: TContractState);
  5 |     fn decrement(ref self: TContractState);
  6 | }
  7 | 
  8 | // [!region contract]
  9 | #[starknet::contract]
 10 | pub mod SimpleCounter {
 11 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 12 | 
 13 |     #[storage]
 14 |     struct Storage {
 15 |         // Counter variable
 16 |         pub counter: u128,
 17 |     }
 18 | 
 19 |     #[constructor]
 20 |     fn constructor(ref self: ContractState, init_value: u128) {
 21 |         // Store initial value
 22 |         self.counter.write(init_value);
 23 |     }
 24 | 
 25 |     #[abi(embed_v0)]
 26 |     impl SimpleCounter of super::ISimpleCounter<ContractState> {
 27 |         fn get_current_count(self: @ContractState) -> u128 {
 28 |             return self.counter.read();
 29 |         }
 30 | 
 31 |         fn increment(ref self: ContractState) {
 32 |             // Store counter value + 1
 33 |             let counter = self.counter.read() + 1;
 34 |             self.counter.write(counter);
 35 |         }
 36 | 
 37 |         fn decrement(ref self: ContractState) {
 38 |             // Store counter value - 1
 39 |             let counter = self.counter.read() - 1;
 40 |             self.counter.write(counter);
 41 |         }
 42 |     }
 43 | }
 44 | // [!endregion contract]
 45 | 
 46 | #[cfg(test)]
 47 | mod test {
 48 |     use super::{SimpleCounter, ISimpleCounterDispatcher, ISimpleCounterDispatcherTrait};
 49 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
 50 | 
 51 |     fn deploy(init_value: u128) -> ISimpleCounterDispatcher {
 52 |         let (contract_address, _) = deploy_syscall(
 53 |             SimpleCounter::TEST_CLASS_HASH.try_into().unwrap(),
 54 |             0,
 55 |             array![init_value.into()].span(),
 56 |             false
 57 |         )
 58 |             .unwrap_syscall();
 59 |         ISimpleCounterDispatcher { contract_address }
 60 |     }
 61 | 
 62 |     #[test]
 63 |     fn should_deploy() {
 64 |         let init_value = 10;
 65 |         let contract = deploy(init_value);
 66 | 
 67 |         let read_value = contract.get_current_count();
 68 |         assert_eq!(read_value, init_value);
 69 |     }
 70 | 
 71 |     #[test]
 72 |     fn should_increment() {
 73 |         let init_value = 10;
 74 |         let contract = deploy(init_value);
 75 | 
 76 |         contract.increment();
 77 |         assert_eq!(contract.get_current_count(), init_value + 1);
 78 | 
 79 |         contract.increment();
 80 |         contract.increment();
 81 |         assert_eq!(contract.get_current_count(), init_value + 3);
 82 |     }
 83 | 
 84 |     #[test]
 85 |     fn should_decrement() {
 86 |         let init_value = 10;
 87 |         let contract = deploy(init_value);
 88 | 
 89 |         contract.decrement();
 90 |         assert_eq!(contract.get_current_count(), init_value - 1);
 91 | 
 92 |         contract.decrement();
 93 |         contract.decrement();
 94 |         assert_eq!(contract.get_current_count(), init_value - 3);
 95 |     }
 96 | 
 97 |     #[test]
 98 |     fn should_increment_and_decrement() {
 99 |         let init_value = 10;
100 |         let contract = deploy(init_value);
101 | 
102 |         contract.increment();
103 |         contract.decrement();
104 |         assert_eq!(contract.get_current_count(), init_value);
105 | 
106 |         contract.decrement();
107 |         contract.increment();
108 |         assert_eq!(contract.get_current_count(), init_value);
109 |     }
110 | }
111 | 


--------------------------------------------------------------------------------
/listings/getting-started/counter/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod counter;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/custom_type_serde/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/custom_type_serde/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "custom_type_serde"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/custom_type_serde/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "custom_type_serde"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/custom_type_serde/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait ISerdeCustomType<TContractState> {
 3 |     fn person_input(ref self: TContractState, person: Person);
 4 |     fn person_output(self: @TContractState) -> Person;
 5 | }
 6 | 
 7 | // [!region contract]
 8 | // Deriving the `Serde` trait allows us to use
 9 | // the `Person` type as an entrypoint parameter and as a return value
10 | #[derive(Drop, Serde)]
11 | pub struct Person {
12 |     pub age: u8,
13 |     pub name: felt252
14 | }
15 | 
16 | #[starknet::contract]
17 | pub mod SerdeCustomType {
18 |     use super::Person;
19 | 
20 |     #[storage]
21 |     struct Storage {}
22 | 
23 |     #[abi(embed_v0)]
24 |     impl SerdeCustomType of super::ISerdeCustomType<ContractState> {
25 |         fn person_input(ref self: ContractState, person: Person) {}
26 | 
27 |         fn person_output(self: @ContractState) -> Person {
28 |             Person { age: 10, name: 'Joe' }
29 |         }
30 |     }
31 | }
32 | // [!endregion contract]
33 | 
34 | #[cfg(test)]
35 | mod tests {
36 |     use super::{
37 |         SerdeCustomType, Person, ISerdeCustomTypeDispatcher, ISerdeCustomTypeDispatcherTrait
38 |     };
39 |     use starknet::{syscalls::deploy_syscall, SyscallResultTrait};
40 | 
41 |     fn deploy() -> ISerdeCustomTypeDispatcher {
42 |         let (contract_address, _) = deploy_syscall(
43 |             SerdeCustomType::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
44 |         )
45 |             .unwrap_syscall();
46 |         ISerdeCustomTypeDispatcher { contract_address }
47 |     }
48 | 
49 |     #[test]
50 |     fn should_deploy() {
51 |         deploy();
52 |     }
53 | 
54 |     #[test]
55 |     fn should_get_person_output() {
56 |         let contract = deploy();
57 |         let expected_person = Person { age: 10, name: 'Joe' };
58 |         let received_person = contract.person_output();
59 |         let age_received = received_person.age;
60 |         let name_received = received_person.name;
61 | 
62 |         assert(age_received == expected_person.age, 'Wrong age value');
63 |         assert(name_received == expected_person.name, 'Wrong name value');
64 |     }
65 | 
66 |     #[test]
67 |     #[available_gas(2000000000)]
68 |     fn should_call_person_input() {
69 |         let contract = deploy();
70 |         let expected_person = Person { age: 10, name: 'Joe' };
71 |         contract.person_input(expected_person);
72 |     }
73 | }
74 | 


--------------------------------------------------------------------------------
/listings/getting-started/custom_type_serde/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "errors"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "errors"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/src/custom_errors.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait ICustomErrorsExample<TContractState> {
 3 |     fn test_assert(self: @TContractState, i: u256);
 4 |     fn test_panic(self: @TContractState, i: u256);
 5 | }
 6 | 
 7 | // [!region contract]
 8 | pub mod Errors {
 9 |     pub const NOT_POSITIVE: felt252 = 'must be greater than 0';
10 |     pub const NOT_NULL: felt252 = 'must not be null';
11 | }
12 | 
13 | #[starknet::contract]
14 | pub mod CustomErrorsExample {
15 |     use super::Errors;
16 | 
17 |     #[storage]
18 |     struct Storage {}
19 | 
20 |     #[abi(embed_v0)]
21 |     impl CustomErrorsExample of super::ICustomErrorsExample<ContractState> {
22 |         fn test_assert(self: @ContractState, i: u256) {
23 |             assert(i > 0, Errors::NOT_POSITIVE);
24 |         }
25 | 
26 |         fn test_panic(self: @ContractState, i: u256) {
27 |             if (i == 0) {
28 |                 core::panic_with_felt252(Errors::NOT_NULL);
29 |             }
30 |         }
31 |     }
32 | }
33 | // [!endregion contract]
34 | 
35 | #[cfg(test)]
36 | mod test {
37 |     use super::{
38 |         CustomErrorsExample, ICustomErrorsExampleDispatcher, ICustomErrorsExampleDispatcherTrait
39 |     };
40 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
41 | 
42 |     fn deploy() -> ICustomErrorsExampleDispatcher {
43 |         let (contract_address, _) = deploy_syscall(
44 |             CustomErrorsExample::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
45 |         )
46 |             .unwrap_syscall();
47 |         ICustomErrorsExampleDispatcher { contract_address }
48 |     }
49 | 
50 |     #[test]
51 |     #[should_panic(expected: ('must not be null', 'ENTRYPOINT_FAILED'))]
52 |     fn should_panic() {
53 |         let contract = deploy();
54 |         contract.test_panic(0);
55 |     }
56 | 
57 |     #[test]
58 |     #[should_panic(expected: ('must be greater than 0', 'ENTRYPOINT_FAILED'))]
59 |     fn should_assert() {
60 |         let contract = deploy();
61 |         contract.test_assert(0);
62 |     }
63 | }
64 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod simple_errors;
2 | mod custom_errors;
3 | mod vault_errors;
4 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/src/simple_errors.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IErrorsExample<TContractState> {
 3 |     fn test_assert(self: @TContractState, i: u256);
 4 |     fn test_panic(self: @TContractState, i: u256);
 5 | }
 6 | 
 7 | // [!region contract]
 8 | #[starknet::contract]
 9 | pub mod ErrorsExample {
10 |     #[storage]
11 |     struct Storage {}
12 | 
13 |     #[abi(embed_v0)]
14 |     impl ErrorsExample of super::IErrorsExample<ContractState> {
15 |         fn test_assert(self: @ContractState, i: u256) {
16 |             // Assert used to validate a condition
17 |             // and abort execution if the condition is not met
18 |             assert(i > 0, 'i must be greater than 0');
19 |         }
20 | 
21 |         fn test_panic(self: @ContractState, i: u256) {
22 |             if (i == 0) {
23 |                 // Panic used to abort execution directly
24 |                 core::panic_with_felt252('i must not be 0');
25 |             }
26 |         }
27 |     }
28 | }
29 | // [!endregion contract]
30 | 
31 | #[cfg(test)]
32 | mod test {
33 |     use super::{ErrorsExample, IErrorsExampleDispatcher, IErrorsExampleDispatcherTrait};
34 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
35 | 
36 |     fn deploy() -> IErrorsExampleDispatcher {
37 |         let (contract_address, _) = deploy_syscall(
38 |             ErrorsExample::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
39 |         )
40 |             .unwrap_syscall();
41 |         IErrorsExampleDispatcher { contract_address }
42 |     }
43 | 
44 |     #[test]
45 |     #[should_panic(expected: ('i must not be 0', 'ENTRYPOINT_FAILED'))]
46 |     fn should_panic() {
47 |         let contract = deploy();
48 |         contract.test_panic(0);
49 |     }
50 | 
51 |     #[test]
52 |     #[should_panic(expected: ('i must be greater than 0', 'ENTRYPOINT_FAILED'))]
53 |     fn should_assert() {
54 |         let contract = deploy();
55 |         contract.test_assert(0);
56 |     }
57 | }
58 | 


--------------------------------------------------------------------------------
/listings/getting-started/errors/src/vault_errors.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IVaultErrorsExample<TContractState> {
 3 |     fn deposit(ref self: TContractState, amount: u256);
 4 |     fn withdraw(ref self: TContractState, amount: u256);
 5 | }
 6 | 
 7 | // [!region contract]
 8 | pub mod VaultErrors {
 9 |     pub const INSUFFICIENT_BALANCE: felt252 = 'insufficient_balance';
10 |     // you can define more errors here
11 | }
12 | 
13 | #[starknet::contract]
14 | pub mod VaultErrorsExample {
15 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
16 |     use super::VaultErrors;
17 | 
18 |     #[storage]
19 |     struct Storage {
20 |         balance: u256,
21 |     }
22 | 
23 |     #[abi(embed_v0)]
24 |     impl VaultErrorsExample of super::IVaultErrorsExample<ContractState> {
25 |         fn deposit(ref self: ContractState, amount: u256) {
26 |             let mut balance = self.balance.read();
27 |             balance = balance + amount;
28 |             self.balance.write(balance);
29 |         }
30 | 
31 |         fn withdraw(ref self: ContractState, amount: u256) {
32 |             let mut balance = self.balance.read();
33 | 
34 |             assert(balance >= amount, VaultErrors::INSUFFICIENT_BALANCE);
35 | 
36 |             // Or using panic:
37 |             if (balance < amount) {
38 |                 core::panic_with_felt252(VaultErrors::INSUFFICIENT_BALANCE);
39 |             }
40 | 
41 |             let balance = balance - amount;
42 | 
43 |             self.balance.write(balance);
44 |         }
45 |     }
46 | }
47 | // [!endregion contract]
48 | 
49 | #[cfg(test)]
50 | mod test {
51 |     use super::{
52 |         VaultErrorsExample, IVaultErrorsExampleDispatcher, IVaultErrorsExampleDispatcherTrait
53 |     };
54 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
55 | 
56 |     fn deploy() -> IVaultErrorsExampleDispatcher {
57 |         let (contract_address, _) = deploy_syscall(
58 |             VaultErrorsExample::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
59 |         )
60 |             .unwrap_syscall();
61 |         IVaultErrorsExampleDispatcher { contract_address }
62 |     }
63 | 
64 |     #[test]
65 |     fn should_deposit_and_withdraw() {
66 |         let mut contract = deploy();
67 |         contract.deposit(10);
68 |         contract.withdraw(5);
69 |     }
70 | 
71 |     #[test]
72 |     #[should_panic(expected: ('insufficient_balance', 'ENTRYPOINT_FAILED'))]
73 |     fn should_panic_on_insufficient_balance() {
74 |         let mut contract = deploy();
75 |         contract.deposit(10);
76 |         contract.withdraw(15);
77 |     }
78 | }
79 | 


--------------------------------------------------------------------------------
/listings/getting-started/events/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/events/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "events"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/events/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "events"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/events/src/counter.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::interface]
  2 | pub trait IEventCounter<TContractState> {
  3 |     fn increment(ref self: TContractState, amount: u128);
  4 | }
  5 | 
  6 | // [!region contract]
  7 | #[starknet::contract]
  8 | pub mod EventCounter {
  9 |     use starknet::{get_caller_address, ContractAddress};
 10 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 11 | 
 12 |     #[storage]
 13 |     struct Storage {
 14 |         // Counter value
 15 |         pub counter: u128,
 16 |     }
 17 | 
 18 |     #[event]
 19 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 20 |     // The event enum must be annotated with the `#[event]` attribute.
 21 |     // It must also derive at least the `Drop` and `starknet::Event` traits.
 22 |     pub enum Event {
 23 |         CounterIncreased: CounterIncreased,
 24 |         UserIncreaseCounter: UserIncreaseCounter
 25 |     }
 26 | 
 27 |     // By deriving the `starknet::Event` trait, we indicate to the compiler that
 28 |     // this struct will be used when emitting events.
 29 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 30 |     pub struct CounterIncreased {
 31 |         pub amount: u128
 32 |     }
 33 | 
 34 |     #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
 35 |     pub struct UserIncreaseCounter {
 36 |         // The `#[key]` attribute indicates that this event will be indexed.
 37 |         // You can also use `#[flat]` for nested structs.
 38 |         #[key]
 39 |         pub user: ContractAddress,
 40 |         pub new_value: u128,
 41 |     }
 42 | 
 43 |     #[abi(embed_v0)]
 44 |     impl EventCounter of super::IEventCounter<ContractState> {
 45 |         fn increment(ref self: ContractState, amount: u128) {
 46 |             self.counter.write(self.counter.read() + amount);
 47 |             // Emit event
 48 |             // [!region emit]
 49 |             self.emit(Event::CounterIncreased(CounterIncreased { amount }));
 50 |             self
 51 |                 .emit(
 52 |                     Event::UserIncreaseCounter(
 53 |                         UserIncreaseCounter {
 54 |                             user: get_caller_address(), new_value: self.counter.read()
 55 |                         }
 56 |                     )
 57 |                 );
 58 |             // [!endregion emit]
 59 |         }
 60 |     }
 61 | }
 62 | // [!endregion contract]
 63 | 
 64 | #[cfg(test)]
 65 | mod tests {
 66 |     use super::{
 67 |         EventCounter, EventCounter::{Event, CounterIncreased, UserIncreaseCounter},
 68 |         IEventCounterDispatcherTrait, IEventCounterDispatcher
 69 |     };
 70 |     use starknet::{contract_address_const, SyscallResultTrait, syscalls::deploy_syscall};
 71 |     use starknet::testing::set_contract_address;
 72 |     use starknet::storage::StoragePointerReadAccess;
 73 | 
 74 |     #[test]
 75 |     fn test_increment_events() {
 76 |         let (contract_address, _) = deploy_syscall(
 77 |             EventCounter::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
 78 |         )
 79 |             .unwrap_syscall();
 80 |         let mut contract = IEventCounterDispatcher { contract_address };
 81 |         let state = @EventCounter::contract_state_for_testing();
 82 | 
 83 |         let amount = 10;
 84 |         let caller = contract_address_const::<'caller'>();
 85 | 
 86 |         // fake caller
 87 |         set_contract_address(caller);
 88 |         contract.increment(amount);
 89 |         // set back to the contract for reading state
 90 |         set_contract_address(contract_address);
 91 |         assert_eq!(state.counter.read(), amount);
 92 | 
 93 |         // Notice the order: the first event emitted is the first to be popped.
 94 |         // [!region test_events]
 95 |         assert_eq!(
 96 |             starknet::testing::pop_log(contract_address),
 97 |             Option::Some(Event::CounterIncreased(CounterIncreased { amount }))
 98 |         );
 99 |         // [!endregion test_events]
100 |         assert_eq!(
101 |             starknet::testing::pop_log(contract_address),
102 |             Option::Some(
103 |                 Event::UserIncreaseCounter(UserIncreaseCounter { user: caller, new_value: amount })
104 |             )
105 |         );
106 |     }
107 | }
108 | 


--------------------------------------------------------------------------------
/listings/getting-started/events/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod counter;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/factory/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/factory/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "factory"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/factory/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "factory"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/factory/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod simple_factory;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/factory/src/simple_factory.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | pub use starknet::{ContractAddress, ClassHash};
  3 | 
  4 | #[starknet::interface]
  5 | pub trait ICounterFactory<TContractState> {
  6 |     /// Create a new counter contract from stored arguments
  7 |     fn create_counter(ref self: TContractState) -> ContractAddress;
  8 | 
  9 |     /// Create a new counter contract from the given arguments
 10 |     fn create_counter_at(ref self: TContractState, init_value: u128) -> ContractAddress;
 11 | 
 12 |     /// Update the argument
 13 |     fn update_init_value(ref self: TContractState, init_value: u128);
 14 | 
 15 |     /// Update the class hash of the Counter contract to deploy when creating a new counter
 16 |     fn update_counter_class_hash(ref self: TContractState, counter_class_hash: ClassHash);
 17 | }
 18 | 
 19 | #[starknet::contract]
 20 | pub mod CounterFactory {
 21 |     use starknet::{ContractAddress, ClassHash, SyscallResultTrait, syscalls::deploy_syscall};
 22 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 23 | 
 24 |     #[storage]
 25 |     struct Storage {
 26 |         /// Store the constructor arguments of the contract to deploy
 27 |         init_value: u128,
 28 |         /// Store the class hash of the contract to deploy
 29 |         counter_class_hash: ClassHash,
 30 |     }
 31 | 
 32 |     #[constructor]
 33 |     fn constructor(ref self: ContractState, init_value: u128, class_hash: ClassHash) {
 34 |         self.init_value.write(init_value);
 35 |         self.counter_class_hash.write(class_hash);
 36 |     }
 37 | 
 38 |     #[abi(embed_v0)]
 39 |     impl Factory of super::ICounterFactory<ContractState> {
 40 |         // [!region deploy]
 41 |         fn create_counter_at(ref self: ContractState, init_value: u128) -> ContractAddress {
 42 |             // Constructor arguments
 43 |             let mut constructor_calldata: Array::<felt252> = array![init_value.into()];
 44 | 
 45 |             // Contract deployment
 46 |             let (deployed_address, _) = deploy_syscall(
 47 |                 self.counter_class_hash.read(), 0, constructor_calldata.span(), false
 48 |             )
 49 |                 .unwrap_syscall();
 50 | 
 51 |             deployed_address
 52 |         }
 53 |         // [!endregion deploy]
 54 | 
 55 |         fn create_counter(ref self: ContractState) -> ContractAddress {
 56 |             self.create_counter_at(self.init_value.read())
 57 |         }
 58 | 
 59 |         fn update_init_value(ref self: ContractState, init_value: u128) {
 60 |             self.init_value.write(init_value);
 61 |         }
 62 | 
 63 |         fn update_counter_class_hash(ref self: ContractState, counter_class_hash: ClassHash) {
 64 |             self.counter_class_hash.write(counter_class_hash);
 65 |         }
 66 |     }
 67 | }
 68 | // [!endregion contract]
 69 | 
 70 | #[cfg(test)]
 71 | mod tests {
 72 |     use super::{CounterFactory, ICounterFactoryDispatcher, ICounterFactoryDispatcherTrait};
 73 |     use starknet::{SyscallResultTrait, ClassHash, syscalls::deploy_syscall};
 74 | 
 75 |     // Define a target contract to deploy
 76 |     mod target {
 77 |         #[starknet::interface]
 78 |         pub trait ISimpleCounter<TContractState> {
 79 |             fn get_current_count(self: @TContractState) -> u128;
 80 |             fn increment(ref self: TContractState);
 81 |             fn decrement(ref self: TContractState);
 82 |         }
 83 | 
 84 |         #[starknet::contract]
 85 |         pub mod SimpleCounter {
 86 |             use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 87 | 
 88 |             #[storage]
 89 |             struct Storage {
 90 |                 // Counter variable
 91 |                 counter: u128,
 92 |             }
 93 | 
 94 |             #[constructor]
 95 |             fn constructor(ref self: ContractState, init_value: u128) {
 96 |                 // Store initial value
 97 |                 self.counter.write(init_value);
 98 |             }
 99 | 
100 |             #[abi(embed_v0)]
101 |             impl SimpleCounter of super::ISimpleCounter<ContractState> {
102 |                 fn get_current_count(self: @ContractState) -> u128 {
103 |                     self.counter.read()
104 |                 }
105 | 
106 |                 fn increment(ref self: ContractState) {
107 |                     // Store counter value + 1
108 |                     let mut counter: u128 = self.counter.read() + 1;
109 |                     self.counter.write(counter);
110 |                 }
111 |                 fn decrement(ref self: ContractState) {
112 |                     // Store counter value - 1
113 |                     let mut counter: u128 = self.counter.read() - 1;
114 |                     self.counter.write(counter);
115 |                 }
116 |             }
117 |         }
118 |     }
119 |     use target::ISimpleCounterDispatcherTrait;
120 | 
121 |     /// Deploy a counter factory contract
122 |     fn deploy_factory(
123 |         counter_class_hash: ClassHash, init_value: u128
124 |     ) -> ICounterFactoryDispatcher {
125 |         let mut constructor_calldata: Array::<felt252> = array![
126 |             init_value.into(), counter_class_hash.into()
127 |         ];
128 | 
129 |         let (contract_address, _) = deploy_syscall(
130 |             CounterFactory::TEST_CLASS_HASH.try_into().unwrap(),
131 |             0,
132 |             constructor_calldata.span(),
133 |             false
134 |         )
135 |             .unwrap_syscall();
136 | 
137 |         ICounterFactoryDispatcher { contract_address }
138 |     }
139 | 
140 |     #[test]
141 |     fn test_deploy_counter_constructor() {
142 |         let init_value = 10;
143 | 
144 |         let counter_class_hash: ClassHash = target::SimpleCounter::TEST_CLASS_HASH
145 |             .try_into()
146 |             .unwrap();
147 |         let factory = deploy_factory(counter_class_hash, init_value);
148 | 
149 |         let counter_address = factory.create_counter();
150 |         let counter = target::ISimpleCounterDispatcher { contract_address: counter_address };
151 | 
152 |         assert_eq!(counter.get_current_count(), init_value);
153 |     }
154 | 
155 |     #[test]
156 |     fn test_deploy_counter_argument() {
157 |         let init_value = 10;
158 |         let argument_value = 20;
159 | 
160 |         let counter_class_hash: ClassHash = target::SimpleCounter::TEST_CLASS_HASH
161 |             .try_into()
162 |             .unwrap();
163 |         let factory = deploy_factory(counter_class_hash, init_value);
164 | 
165 |         let counter_address = factory.create_counter_at(argument_value);
166 |         let counter = target::ISimpleCounterDispatcher { contract_address: counter_address };
167 | 
168 |         assert_eq!(counter.get_current_count(), argument_value);
169 |     }
170 | 
171 |     #[test]
172 |     fn test_deploy_multiple() {
173 |         let init_value = 10;
174 |         let argument_value = 20;
175 | 
176 |         let counter_class_hash: ClassHash = target::SimpleCounter::TEST_CLASS_HASH
177 |             .try_into()
178 |             .unwrap();
179 |         let factory = deploy_factory(counter_class_hash, init_value);
180 | 
181 |         let mut counter_address = factory.create_counter();
182 |         let counter_1 = target::ISimpleCounterDispatcher { contract_address: counter_address };
183 | 
184 |         counter_address = factory.create_counter_at(argument_value);
185 |         let counter_2 = target::ISimpleCounterDispatcher { contract_address: counter_address };
186 | 
187 |         assert_eq!(counter_1.get_current_count(), init_value);
188 |         assert_eq!(counter_2.get_current_count(), argument_value);
189 |     }
190 | }
191 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "interfaces_traits"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "interfaces_traits"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/src/explicit.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::interface]
 3 | pub trait IExplicitInterfaceContract<TContractState> {
 4 |     fn get_value(self: @TContractState) -> u32;
 5 |     fn set_value(ref self: TContractState, value: u32);
 6 | }
 7 | 
 8 | #[starknet::contract]
 9 | pub mod ExplicitInterfaceContract {
10 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         value: u32
15 |     }
16 | 
17 |     #[abi(embed_v0)]
18 |     impl ExplicitInterfaceContract of super::IExplicitInterfaceContract<ContractState> {
19 |         fn get_value(self: @ContractState) -> u32 {
20 |             self.value.read()
21 |         }
22 | 
23 |         fn set_value(ref self: ContractState, value: u32) {
24 |             self.value.write(value);
25 |         }
26 |     }
27 | }
28 | // [!endregion contract]
29 | 
30 | #[cfg(test)]
31 | mod tests {
32 |     use super::{
33 |         ExplicitInterfaceContract, IExplicitInterfaceContractDispatcher,
34 |         IExplicitInterfaceContractDispatcherTrait
35 |     };
36 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
37 | 
38 |     #[test]
39 |     fn test_interface() {
40 |         let (contract_address, _) = deploy_syscall(
41 |             ExplicitInterfaceContract::TEST_CLASS_HASH.try_into().unwrap(),
42 |             0,
43 |             array![].span(),
44 |             false
45 |         )
46 |             .unwrap_syscall();
47 |         let mut contract = IExplicitInterfaceContractDispatcher { contract_address };
48 | 
49 |         let value: u32 = 20;
50 |         contract.set_value(value);
51 | 
52 |         let read_value = contract.get_value();
53 | 
54 |         assert_eq!(read_value, value);
55 |     }
56 | }
57 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/src/implicit.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::contract]
 3 | pub mod ImplicitInterfaceContract {
 4 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 5 | 
 6 |     #[storage]
 7 |     struct Storage {
 8 |         value: u32
 9 |     }
10 | 
11 |     #[abi(per_item)]
12 |     #[generate_trait]
13 |     pub impl ImplicitInterfaceContract of IImplicitInterfaceContract {
14 |         #[external(v0)]
15 |         fn get_value(self: @ContractState) -> u32 {
16 |             self.value.read()
17 |         }
18 | 
19 |         #[external(v0)]
20 |         fn set_value(ref self: ContractState, value: u32) {
21 |             self.value.write(value);
22 |         }
23 |     }
24 | }
25 | // [!endregion contract]
26 | 
27 | #[cfg(test)]
28 | mod tests {
29 |     use super::{ImplicitInterfaceContract, ImplicitInterfaceContract::IImplicitInterfaceContract};
30 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall, testing::set_contract_address};
31 | 
32 |     #[test]
33 |     fn test_interface() {
34 |         let (contract_address, _) = deploy_syscall(
35 |             ImplicitInterfaceContract::TEST_CLASS_HASH.try_into().unwrap(),
36 |             0,
37 |             array![].span(),
38 |             false
39 |         )
40 |             .unwrap_syscall();
41 |         set_contract_address(contract_address);
42 |         let mut state = ImplicitInterfaceContract::contract_state_for_testing();
43 | 
44 |         let value = 42;
45 |         state.set_value(value);
46 |         let read_value = state.get_value();
47 | 
48 |         assert_eq!(read_value, value);
49 |     }
50 | }
51 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/src/implicit_internal.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::interface]
 3 | pub trait IImplicitInternalContract<TContractState> {
 4 |     fn add(ref self: TContractState, nb: u32);
 5 |     fn get_value(self: @TContractState) -> u32;
 6 |     fn get_const(self: @TContractState) -> u32;
 7 | }
 8 | 
 9 | #[starknet::contract]
10 | pub mod ImplicitInternalContract {
11 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
12 | 
13 |     #[storage]
14 |     struct Storage {
15 |         value: u32
16 |     }
17 | 
18 |     #[generate_trait]
19 |     impl InternalFunctions of InternalFunctionsTrait {
20 |         fn set_value(ref self: ContractState, value: u32) {
21 |             self.value.write(value);
22 |         }
23 | 
24 |         fn get_const() -> u32 {
25 |             42
26 |         }
27 |     }
28 | 
29 |     #[constructor]
30 |     fn constructor(ref self: ContractState) {
31 |         self.set_value(0);
32 |     }
33 | 
34 |     #[abi(embed_v0)]
35 |     impl ImplicitInternalContract of super::IImplicitInternalContract<ContractState> {
36 |         fn add(ref self: ContractState, nb: u32) {
37 |             self.set_value(self.value.read() + nb);
38 |         }
39 | 
40 |         fn get_value(self: @ContractState) -> u32 {
41 |             self.value.read()
42 |         }
43 | 
44 |         fn get_const(self: @ContractState) -> u32 {
45 |             self.get_const()
46 |         }
47 |     }
48 | }
49 | // [!endregion contract]
50 | 
51 | #[cfg(test)]
52 | mod tests {
53 |     use super::{
54 |         ImplicitInternalContract, IImplicitInternalContractDispatcher,
55 |         IImplicitInternalContractDispatcherTrait
56 |     };
57 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
58 | 
59 |     #[test]
60 |     fn test_interface() {
61 |         // Set up.
62 |         let (contract_address, _) = deploy_syscall(
63 |             ImplicitInternalContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
64 |         )
65 |             .unwrap_syscall();
66 |         let mut contract = IImplicitInternalContractDispatcher { contract_address };
67 | 
68 |         let initial_value: u32 = 0;
69 |         assert_eq!(contract.get_value(), initial_value);
70 | 
71 |         let add_value: u32 = 10;
72 |         contract.add(add_value);
73 | 
74 |         assert_eq!(contract.get_value(), initial_value + add_value);
75 |     }
76 | }
77 | 


--------------------------------------------------------------------------------
/listings/getting-started/interfaces_traits/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod explicit;
2 | mod implicit_internal;
3 | mod implicit;
4 | 


--------------------------------------------------------------------------------
/listings/getting-started/mappings/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/mappings/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "maps"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/mappings/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "mappings"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/mappings/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod mappings;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/mappings/src/mappings.cairo:
--------------------------------------------------------------------------------
 1 | use starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | pub trait IMapContract<TContractState> {
 5 |     fn set(ref self: TContractState, key: ContractAddress, value: felt252);
 6 |     fn get(self: @TContractState, key: ContractAddress) -> felt252;
 7 | }
 8 | 
 9 | // [!region contract]
10 | #[starknet::contract]
11 | pub mod MapContract {
12 |     use starknet::ContractAddress;
13 |     use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
14 | 
15 |     #[storage]
16 |     struct Storage {
17 |         map: Map::<ContractAddress, felt252>,
18 |     }
19 | 
20 |     #[abi(embed_v0)]
21 |     impl MapContractImpl of super::IMapContract<ContractState> {
22 |         fn set(ref self: ContractState, key: ContractAddress, value: felt252) {
23 |             self.map.write(key, value);
24 |         }
25 | 
26 |         fn get(self: @ContractState, key: ContractAddress) -> felt252 {
27 |             self.map.read(key)
28 |         }
29 |     }
30 | }
31 | // [!endregion contract]
32 | 
33 | #[cfg(test)]
34 | mod test {
35 |     use super::{MapContract, IMapContractDispatcher, IMapContractDispatcherTrait};
36 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
37 | 
38 |     #[test]
39 |     fn test_deploy_and_set_get() {
40 |         let (contract_address, _) = deploy_syscall(
41 |             MapContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
42 |         )
43 |             .unwrap_syscall();
44 |         let mut contract = IMapContractDispatcher { contract_address };
45 | 
46 |         // Write to map.
47 |         let value: felt252 = 1;
48 |         contract.set(key: contract_address, value: value);
49 | 
50 |         // Read from map.
51 |         let read_value = contract.get(contract_address);
52 |         assert(read_value == 1, 'wrong value read');
53 |     }
54 | }
55 | 


--------------------------------------------------------------------------------
/listings/getting-started/storage/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/storage/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "storage"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/storage/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "storage"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/storage/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::contract]
 3 | pub mod Contract {
 4 |     #[storage]
 5 |     struct Storage {
 6 |         pub a: u128,
 7 |         pub b: u8,
 8 |         pub c: u256
 9 |     }
10 | }
11 | // [!endregion contract]
12 | 
13 | #[cfg(test)]
14 | mod test {
15 |     use super::Contract;
16 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
17 |     use starknet::storage::StoragePointerReadAccess;
18 | 
19 |     #[test]
20 |     fn test_can_deploy() {
21 |         let (_contract_address, _) = deploy_syscall(
22 |             Contract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
23 |         )
24 |             .unwrap_syscall();
25 |     }
26 | 
27 |     #[test]
28 |     fn test_storage_members() {
29 |         let state = @Contract::contract_state_for_testing();
30 |         assert_eq!(state.a.read(), 0_u128);
31 |         assert_eq!(state.b.read(), 0_u8);
32 |         assert_eq!(state.c.read(), 0_u256);
33 |     }
34 | }
35 | 


--------------------------------------------------------------------------------
/listings/getting-started/storage/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod minimal_contract;
2 | mod contract;
3 | 


--------------------------------------------------------------------------------
/listings/getting-started/storage/src/minimal_contract.cairo:
--------------------------------------------------------------------------------
 1 | // [!region contract]
 2 | #[starknet::contract]
 3 | pub mod Contract {
 4 |     #[storage]
 5 |     struct Storage {}
 6 | }
 7 | // [!endregion contract]
 8 | 
 9 | // [!region tests]
10 | #[cfg(test)]
11 | mod test {
12 |     use super::Contract;
13 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
14 | 
15 |     #[test]
16 |     fn test_can_deploy() {
17 |         let (_contract_address, _) = deploy_syscall(
18 |             Contract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
19 |         )
20 |             .unwrap_syscall();
21 |         // Not much to test
22 |     }
23 | }
24 | // [!endregion tests]
25 | 
26 | 
27 | 


--------------------------------------------------------------------------------
/listings/getting-started/storing_custom_types/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/storing_custom_types/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "storing_custom_types"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/storing_custom_types/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "storing_custom_types"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/storing_custom_types/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IStoringCustomType<TContractState> {
 3 |     fn set_person(ref self: TContractState, person: Person);
 4 |     fn set_name(ref self: TContractState, name: felt252);
 5 | }
 6 | 
 7 | // [!region contract]
 8 | // Deriving the starknet::Store trait
 9 | // allows us to store the `Person` struct in the contract's storage.
10 | #[derive(Drop, Serde, Copy, starknet::Store)]
11 | pub struct Person {
12 |     pub age: u8,
13 |     pub name: felt252
14 | }
15 | 
16 | #[starknet::contract]
17 | pub mod StoringCustomType {
18 |     use starknet::storage::StoragePointerWriteAccess;
19 |     use super::Person;
20 | 
21 |     #[storage]
22 |     struct Storage {
23 |         pub person: Person
24 |     }
25 | 
26 |     #[abi(embed_v0)]
27 |     impl StoringCustomType of super::IStoringCustomType<ContractState> {
28 |         fn set_person(ref self: ContractState, person: Person) {
29 |             self.person.write(person);
30 |         }
31 | 
32 |         // [!region set_name]
33 |         fn set_name(ref self: ContractState, name: felt252) {
34 |             self.person.name.write(name);
35 |         }
36 |         // [!endregion set_name]
37 |     }
38 | }
39 | // [!endregion contract]
40 | 
41 | #[cfg(test)]
42 | mod tests {
43 |     use super::{IStoringCustomType, StoringCustomType, Person,};
44 |     use starknet::storage::StoragePointerReadAccess;
45 | 
46 |     #[test]
47 |     fn can_call_set_person() {
48 |         let mut state = StoringCustomType::contract_state_for_testing();
49 | 
50 |         let person = Person { age: 10, name: 'Joe' };
51 | 
52 |         state.set_person(person);
53 | 
54 |         let read_person = state.person.read();
55 | 
56 |         assert_eq!(person.age, read_person.age);
57 |         assert_eq!(person.name, read_person.name);
58 |     }
59 | 
60 |     #[test]
61 |     fn can_call_set_name() {
62 |         let mut state = StoringCustomType::contract_state_for_testing();
63 | 
64 |         state.set_name('John');
65 | 
66 |         let read_person = state.person.read();
67 |         assert_eq!(read_person.name, 'John');
68 |     }
69 | }
70 | 


--------------------------------------------------------------------------------
/listings/getting-started/storing_custom_types/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/testing_how_to/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/testing_how_to/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "sbe_testing"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/testing_how_to/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "testing_how_to"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/testing_how_to/src/contract.cairo:
--------------------------------------------------------------------------------
  1 | // [!region contract]
  2 | #[starknet::interface]
  3 | pub trait ISimpleContract<TContractState> {
  4 |     fn get_value(self: @TContractState) -> u32;
  5 |     fn get_owner(self: @TContractState) -> starknet::ContractAddress;
  6 |     fn set_value(ref self: TContractState, value: u32);
  7 | }
  8 | 
  9 | #[starknet::contract]
 10 | pub mod SimpleContract {
 11 |     use starknet::{get_caller_address, ContractAddress};
 12 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 13 | 
 14 |     #[storage]
 15 |     struct Storage {
 16 |         pub value: u32,
 17 |         pub owner: ContractAddress
 18 |     }
 19 | 
 20 |     #[constructor]
 21 |     pub fn constructor(ref self: ContractState, initial_value: u32) {
 22 |         self.value.write(initial_value);
 23 |         self.owner.write(get_caller_address());
 24 |     }
 25 | 
 26 |     #[abi(embed_v0)]
 27 |     pub impl SimpleContractImpl of super::ISimpleContract<ContractState> {
 28 |         fn get_value(self: @ContractState) -> u32 {
 29 |             self.value.read()
 30 |         }
 31 | 
 32 |         fn get_owner(self: @ContractState) -> ContractAddress {
 33 |             self.owner.read()
 34 |         }
 35 | 
 36 |         fn set_value(ref self: ContractState, value: u32) {
 37 |             assert(self.owner.read() == get_caller_address(), 'Not owner');
 38 |             self.value.write(value);
 39 |         }
 40 |     }
 41 | }
 42 | // [!endregion contract]
 43 | 
 44 | // [!region tests]
 45 | #[cfg(test)]
 46 | mod tests {
 47 |     // Import the interface and dispatcher to be able to interact with the contract.
 48 |     use super::{SimpleContract, ISimpleContractDispatcher, ISimpleContractDispatcherTrait};
 49 | 
 50 |     // Import the deploy syscall to be able to deploy the contract.
 51 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
 52 |     use starknet::{get_contract_address, contract_address_const};
 53 | 
 54 |     // Use starknet test utils to fake the contract_address
 55 |     use starknet::testing::set_contract_address;
 56 | 
 57 |     // Deploy the contract and return its dispatcher.
 58 |     fn deploy(initial_value: u32) -> ISimpleContractDispatcher {
 59 |         // Declare and deploy
 60 |         let (contract_address, _) = deploy_syscall(
 61 |             SimpleContract::TEST_CLASS_HASH.try_into().unwrap(),
 62 |             0,
 63 |             array![initial_value.into()].span(),
 64 |             false
 65 |         )
 66 |             .unwrap_syscall();
 67 | 
 68 |         // Return the dispatcher.
 69 |         // The dispatcher allows to interact with the contract based on its interface.
 70 |         ISimpleContractDispatcher { contract_address }
 71 |     }
 72 | 
 73 |     #[test]
 74 |     fn test_deploy() {
 75 |         let initial_value: u32 = 10;
 76 |         let contract = deploy(initial_value);
 77 | 
 78 |         assert_eq!(contract.get_value(), initial_value);
 79 |         assert_eq!(contract.get_owner(), get_contract_address());
 80 |     }
 81 | 
 82 |     #[test]
 83 |     fn test_set_as_owner() {
 84 |         // Fake the contract address to owner
 85 |         let owner = contract_address_const::<'owner'>();
 86 |         set_contract_address(owner);
 87 | 
 88 |         // When deploying the contract, the owner is the caller.
 89 |         let contract = deploy(10);
 90 |         assert_eq!(contract.get_owner(), owner);
 91 | 
 92 |         // As the current caller is the owner, the value can be set.
 93 |         let new_value: u32 = 20;
 94 |         contract.set_value(new_value);
 95 | 
 96 |         assert_eq!(contract.get_value(), new_value);
 97 |     }
 98 | 
 99 |     #[test]
100 |     #[should_panic]
101 |     fn test_set_not_owner() {
102 |         let owner = contract_address_const::<'owner'>();
103 |         set_contract_address(owner);
104 |         let contract = deploy(10);
105 | 
106 |         // Fake the contract address to another address
107 |         let not_owner = contract_address_const::<'not owner'>();
108 |         set_contract_address(not_owner);
109 | 
110 |         // As the current caller is not the owner, the value cannot be set.
111 |         let new_value: u32 = 20;
112 |         contract.set_value(new_value);
113 |         // Panic expected
114 |     }
115 | 
116 |     #[test]
117 |     #[available_gas(150000)]
118 |     fn test_deploy_gas() {
119 |         deploy(10);
120 |     }
121 | }
122 | // [!endregion tests]
123 | 
124 | // [!region tests_with_state]
125 | #[cfg(test)]
126 | mod tests_with_states {
127 |     // Only import the contract and implementation
128 |     use super::SimpleContract;
129 |     use SimpleContract::SimpleContractImpl;
130 | 
131 |     use starknet::contract_address_const;
132 |     use starknet::testing::set_caller_address;
133 |     use core::num::traits::Zero;
134 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
135 | 
136 |     #[test]
137 |     fn test_standalone_state() {
138 |         let mut state = SimpleContract::contract_state_for_testing();
139 | 
140 |         // As no contract was deployed, the constructor was not called on the state
141 |         // - with valueContractMemberStateTrait
142 |         assert_eq!(state.value.read(), 0);
143 |         // - with SimpleContractImpl
144 |         assert_eq!(state.get_value(), 0);
145 |         assert_eq!(state.owner.read(), Zero::zero());
146 | 
147 |         // We can still directly call the constructor to initialize the state.
148 |         let owner = contract_address_const::<'owner'>();
149 |         // We are not setting the contract address but the caller address here,
150 |         // as we are not deploying the contract but directly calling the constructor function.
151 |         set_caller_address(owner);
152 | 
153 |         let initial_value: u32 = 10;
154 |         SimpleContract::constructor(ref state, initial_value);
155 |         assert_eq!(state.get_value(), initial_value);
156 |         assert_eq!(state.get_owner(), owner);
157 | 
158 |         // As the current caller is the owner, the value can be set.
159 |         let new_value: u32 = 20;
160 |         state.set_value(new_value);
161 |         assert_eq!(state.get_value(), new_value);
162 |     }
163 | 
164 |     // But we can also deploy the contract and interact with it using the dispatcher
165 |     // as shown in the previous tests, and still use the state for testing.
166 |     use super::{ISimpleContractDispatcher, ISimpleContractDispatcherTrait};
167 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall, testing::set_contract_address};
168 | 
169 |     #[test]
170 |     fn test_state_with_contract() {
171 |         let owner = contract_address_const::<'owner'>();
172 |         let not_owner = contract_address_const::<'not owner'>();
173 | 
174 |         // Deploy as owner
175 |         let initial_value: u32 = 10;
176 |         set_contract_address(owner);
177 |         let (contract_address, _) = deploy_syscall(
178 |             SimpleContract::TEST_CLASS_HASH.try_into().unwrap(),
179 |             0,
180 |             array![initial_value.into()].span(),
181 |             false
182 |         )
183 |             .unwrap_syscall();
184 |         let mut contract = ISimpleContractDispatcher { contract_address };
185 | 
186 |         // create the state
187 |         // - Set back as not owner
188 |         set_contract_address(not_owner);
189 |         let mut state = SimpleContract::contract_state_for_testing();
190 |         // - Currently, the state is not 'linked' to the contract
191 |         assert_ne!(state.get_value(), initial_value);
192 |         assert_ne!(state.get_owner(), owner);
193 |         // - Link the state to the contract by setting the contract address
194 |         set_contract_address(contract.contract_address);
195 |         assert_eq!(state.get_value(), initial_value);
196 |         assert_eq!(state.get_owner(), owner);
197 | 
198 |         // Mutating the state from the contract changes the testing state
199 |         set_contract_address(owner);
200 |         let new_value: u32 = 20;
201 |         contract.set_value(new_value);
202 |         set_contract_address(contract.contract_address);
203 |         assert_eq!(state.get_value(), new_value);
204 | 
205 |         // Mutating the state from the testing state changes the contract state
206 |         set_caller_address(owner);
207 |         state.set_value(initial_value);
208 |         assert_eq!(contract.get_value(), initial_value);
209 | 
210 |         // Directly mutating the state allows to change state
211 |         // in ways that are not allowed by the contract, such as changing the owner.
212 |         let new_owner = contract_address_const::<'new owner'>();
213 |         state.owner.write(new_owner);
214 |         assert_eq!(contract.get_owner(), new_owner);
215 | 
216 |         set_caller_address(new_owner);
217 |         state.set_value(new_value);
218 |         assert_eq!(contract.get_value(), new_value);
219 |     }
220 | }
221 | // [!endregion tests]
222 | 
223 | 
224 | 


--------------------------------------------------------------------------------
/listings/getting-started/testing_how_to/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod contract;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "variables"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "variables"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/src/global_variables.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IGlobalExample<TContractState> {
 3 |     fn foo(ref self: TContractState);
 4 | }
 5 | 
 6 | // [!region contract]
 7 | #[starknet::contract]
 8 | pub mod GlobalExample {
 9 |     // import the required functions from the starknet core library
10 |     use starknet::get_caller_address;
11 | 
12 |     #[storage]
13 |     struct Storage {}
14 | 
15 |     #[abi(embed_v0)]
16 |     impl GlobalExampleImpl of super::IGlobalExample<ContractState> {
17 |         fn foo(ref self: ContractState) {
18 |             // Call the get_caller_address function to get the sender address
19 |             let _caller = get_caller_address();
20 |             // ...
21 |         }
22 |     }
23 | }
24 | // [!endregion contract]
25 | 
26 | #[cfg(test)]
27 | mod test {
28 |     use super::GlobalExample;
29 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
30 | 
31 |     #[test]
32 |     fn test_can_deploy() {
33 |         let (_contract_address, _) = deploy_syscall(
34 |             GlobalExample::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
35 |         )
36 |             .unwrap_syscall();
37 |         // Not much to test
38 |     }
39 | }
40 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod storage_variables;
2 | mod local_variables;
3 | mod global_variables;
4 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/src/local_variables.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait ILocalVariablesExample<TContractState> {
 3 |     fn do_something(self: @TContractState, value: u32) -> u32;
 4 | }
 5 | 
 6 | // [!region contract]
 7 | #[starknet::contract]
 8 | pub mod LocalVariablesExample {
 9 |     #[storage]
10 |     struct Storage {}
11 | 
12 |     #[abi(embed_v0)]
13 |     impl LocalVariablesExample of super::ILocalVariablesExample<ContractState> {
14 |         fn do_something(self: @ContractState, value: u32) -> u32 {
15 |             // This variable is local to the current block.
16 |             // It can't be accessed once it goes out of scope.
17 |             let increment = 10;
18 | 
19 |             {
20 |                 // The scope of a code block allows for local variable declaration
21 |                 // We can access variables defined in higher scopes.
22 |                 let sum = value + increment;
23 |                 sum
24 |             }
25 |             // We can't access the variable `sum` here, as it's out of scope.
26 |         }
27 |     }
28 | }
29 | // [!endregion contract]
30 | 
31 | #[cfg(test)]
32 | mod test {
33 |     use super::{
34 |         LocalVariablesExample, ILocalVariablesExampleDispatcher,
35 |         ILocalVariablesExampleDispatcherTrait
36 |     };
37 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
38 | 
39 |     #[test]
40 |     fn test_can_deploy_and_do_something() {
41 |         let (contract_address, _) = deploy_syscall(
42 |             LocalVariablesExample::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
43 |         )
44 |             .unwrap_syscall();
45 | 
46 |         let contract = ILocalVariablesExampleDispatcher { contract_address };
47 |         let value = 10;
48 |         let res = contract.do_something(value);
49 |         assert_eq!(res, value + 10);
50 |     }
51 | }
52 | 


--------------------------------------------------------------------------------
/listings/getting-started/variables/src/storage_variables.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IStorageVariableExample<TContractState> {
 3 |     fn set(ref self: TContractState, value: u32);
 4 |     fn get(self: @TContractState) -> u32;
 5 | }
 6 | 
 7 | // [!region contract]
 8 | #[starknet::contract]
 9 | pub mod StorageVariablesExample {
10 |     // You need to import these storage functions to read and write to storage variables
11 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
12 | 
13 |     // All storage variables are contained in a struct called Storage
14 |     // annotated with the `#[storage]` attribute
15 |     #[storage]
16 |     struct Storage {
17 |         // Storage variable holding a number
18 |         pub value: u32
19 |     }
20 | 
21 |     #[abi(embed_v0)]
22 |     impl StorageVariablesExample of super::IStorageVariableExample<ContractState> {
23 |         // Write to storage variables by sending a transaction
24 |         // that calls an external function
25 |         fn set(ref self: ContractState, value: u32) {
26 |             self.value.write(value);
27 |         }
28 | 
29 |         // Read from storage variables without sending transactions
30 |         fn get(self: @ContractState) -> u32 {
31 |             self.value.read()
32 |         }
33 |     }
34 | }
35 | // [!endregion contract]
36 | 
37 | #[cfg(test)]
38 | mod test {
39 |     use super::{
40 |         StorageVariablesExample, IStorageVariableExampleDispatcher,
41 |         IStorageVariableExampleDispatcherTrait
42 |     };
43 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
44 |     use starknet::testing::set_contract_address;
45 |     use starknet::storage::StoragePointerReadAccess;
46 | 
47 |     #[test]
48 |     fn test_can_deploy_and_mutate_storage() {
49 |         let (contract_address, _) = deploy_syscall(
50 |             StorageVariablesExample::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
51 |         )
52 |             .unwrap_syscall();
53 | 
54 |         let contract = IStorageVariableExampleDispatcher { contract_address };
55 | 
56 |         let initial_value = 10;
57 | 
58 |         contract.set(initial_value);
59 |         assert_eq!(contract.get(), initial_value);
60 | 
61 |         // With contract state directly
62 |         let state = @StorageVariablesExample::contract_state_for_testing();
63 |         set_contract_address(contract_address);
64 |         assert_eq!(state.value.read(), initial_value);
65 |     }
66 | }
67 | 


--------------------------------------------------------------------------------
/listings/getting-started/visibility/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/visibility/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "visibility"
6 | version.workspace = true
7 | 


--------------------------------------------------------------------------------
/listings/getting-started/visibility/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "visibility"
 3 | version.workspace = true
 4 | edition.workspace = true
 5 | 
 6 | [dependencies]
 7 | starknet.workspace = true
 8 | 
 9 | [dev-dependencies]
10 | cairo_test.workspace = true
11 | 
12 | [scripts]
13 | test.workspace = true
14 | 
15 | [[target.starknet-contract]]
16 | 


--------------------------------------------------------------------------------
/listings/getting-started/visibility/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod visibility;
2 | 


--------------------------------------------------------------------------------
/listings/getting-started/visibility/src/visibility.cairo:
--------------------------------------------------------------------------------
  1 | #[starknet::interface]
  2 | pub trait IExampleContract<TContractState> {
  3 |     fn set(ref self: TContractState, value: u32);
  4 |     fn get(self: @TContractState) -> u32;
  5 | }
  6 | 
  7 | // [!region contract]
  8 | #[starknet::contract]
  9 | pub mod ExampleContract {
 10 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 11 | 
 12 |     #[storage]
 13 |     struct Storage {
 14 |         pub value: u32
 15 |     }
 16 | 
 17 |     // The `#[abi(embed_v0)]` attribute indicates that all
 18 |     // the functions in this implementation can be called externally.
 19 |     // Omitting this attribute would make all the functions internal.
 20 |     #[abi(embed_v0)]
 21 |     impl ExampleContract of super::IExampleContract<ContractState> {
 22 |         // The `set` function can be called externally
 23 |         // because it is written inside an implementation marked as `#[abi(embed_v0)]`.
 24 |         // It can modify the contract's state as it is passed as a reference.
 25 |         fn set(ref self: ContractState, value: u32) {
 26 |             self.value.write(value);
 27 |         }
 28 | 
 29 |         // The `get` function can be called externally
 30 |         // because it is written inside an implementation marked as `#[abi(embed_v0)]`.
 31 |         // However, it can't modify the contract's state, as it is passed as a snapshot
 32 |         // -> It's only a "view" function.
 33 |         fn get(self: @ContractState) -> u32 {
 34 |             // We can call an internal function from any functions within the contract
 35 |             PrivateFunctionsTrait::_read_value(self)
 36 |         }
 37 |     }
 38 | 
 39 |     // The lack of the `#[abi(embed_v0)]` attribute indicates that all the functions in
 40 |     // this implementation can only be called internally.
 41 |     // We name the trait `PrivateFunctionsTrait` to indicate that it is an
 42 |     // internal trait allowing us to call internal functions.
 43 |     #[generate_trait]
 44 |     pub impl PrivateFunctions of PrivateFunctionsTrait {
 45 |         // The `_read_value` function is outside the implementation that is
 46 |         // marked as `#[abi(embed_v0)]`, so it's an _internal_ function
 47 |         // and can only be called from within the contract.
 48 |         // However, it can't modify the contract's state, as it is passed
 49 |         // as a snapshot: it is only a "view" function.
 50 |         fn _read_value(self: @ContractState) -> u32 {
 51 |             self.value.read()
 52 |         }
 53 |     }
 54 | }
 55 | // [!endregion contract]
 56 | 
 57 | #[cfg(test)]
 58 | mod test {
 59 |     use super::{ExampleContract, IExampleContractDispatcher, IExampleContractDispatcherTrait};
 60 |     use starknet::{SyscallResultTrait, syscalls::deploy_syscall};
 61 |     use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 62 | 
 63 |     // These imports will allow us to directly access and set the contract state:
 64 |     // - for `PrivateFunctionsTrait` internal functions access
 65 |     //   implementation need to be public to be able to access it
 66 |     use super::ExampleContract::PrivateFunctionsTrait;
 67 |     // to set the contract address for the state
 68 |     // and also be able to use the dispatcher on the same contract
 69 |     use starknet::testing::set_contract_address;
 70 | 
 71 |     #[test]
 72 |     fn can_call_set_and_get() {
 73 |         let (contract_address, _) = deploy_syscall(
 74 |             ExampleContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false
 75 |         )
 76 |             .unwrap_syscall();
 77 | 
 78 |         // You can interact with the external entrypoints of the contract using the dispatcher.
 79 |         let contract = IExampleContractDispatcher { contract_address };
 80 |         // But for internal functions, you need to use the contract state.
 81 |         let mut state = ExampleContract::contract_state_for_testing();
 82 |         set_contract_address(contract_address);
 83 | 
 84 |         // The contract dispatcher and state refer to the same contract.
 85 |         assert_eq!(contract.get(), state.value.read());
 86 | 
 87 |         // We can set from the dispatcher
 88 |         contract.set(42);
 89 |         assert_eq!(contract.get(), state.value.read());
 90 |         assert_eq!(42, state.value.read());
 91 |         assert_eq!(42, contract.get());
 92 | 
 93 |         // Or directly from the state for more complex operations
 94 |         state.value.write(24);
 95 |         assert_eq!(contract.get(), state.value.read());
 96 |         assert_eq!(24, state.value.read());
 97 |         assert_eq!(24, contract.get());
 98 | 
 99 |         // We can also access internal functions from the state
100 |         assert_eq!(state._read_value(), state.value.read());
101 |         assert_eq!(state._read_value(), contract.get());
102 |     }
103 | }
104 | 

