/listings/appendix/listing_01_clone/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_01_clone/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "clone"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_01_clone/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Clone, Drop)]
 2 | struct A {
 3 |     item: felt252,
 4 | }
 5 | 
 6 | fn main() {
 7 |     let first_struct = A { item: 2 };
 8 |     let second_struct = first_struct.clone();
 9 |     assert!(second_struct.item == 2, "Not equal");
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_02_copy/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_02_copy/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "copy"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_02_copy/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct A {
 3 |     item: felt252,
 4 | }
 5 | 
 6 | fn main() {
 7 |     let first_struct = A { item: 2 };
 8 |     let second_struct = first_struct;
 9 |     // Copy Trait prevents first_struct from moving into second_struct
10 |     assert!(second_struct.item == 2, "Not equal");
11 |     assert!(first_struct.item == 2, "Not Equal");
12 | }
13 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_03_debug/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_03_debug/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "debug"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_03_debug/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop, Debug)]
 2 | struct Point {
 3 |     x: u8,
 4 |     y: u8,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let p = Point { x: 1, y: 3 };
 9 |     println!("{:?}", p);
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_04_implpartialeq/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_04_implpartialeq/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "implpartialeq"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_04_implpartialeq/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | impl PartialEqImpl of PartialEq<Rectangle> {
 8 |     fn eq(lhs: @Rectangle, rhs: @Rectangle) -> bool {
 9 |         (*lhs.width) * (*lhs.height) == (*rhs.width) * (*rhs.height)
10 |     }
11 | 
12 |     fn ne(lhs: @Rectangle, rhs: @Rectangle) -> bool {
13 |         (*lhs.width) * (*lhs.height) != (*rhs.width) * (*rhs.height)
14 |     }
15 | }
16 | 
17 | fn main() {
18 |     let rect1 = Rectangle { width: 30, height: 50 };
19 |     let rect2 = Rectangle { width: 50, height: 30 };
20 | 
21 |     println!("Are rect1 and rect2 equal? {}", rect1 == rect2);
22 | }
23 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_05_partialeq/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_05_partialeq/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "partialeq"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_05_partialeq/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(PartialEq, Drop)]
 2 | struct A {
 3 |     item: felt252,
 4 | }
 5 | 
 6 | fn main() {
 7 |     let first_struct = A { item: 2 };
 8 |     let second_struct = A { item: 2 };
 9 |     assert!(first_struct == second_struct, "Structs are different");
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_06_serialize/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_06_serialize/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "serde"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_06_serialize/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Serde, Drop)]
 2 | struct A {
 3 |     item_one: felt252,
 4 |     item_two: felt252,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let first_struct = A { item_one: 2, item_two: 99 };
 9 |     let mut output_array = array![];
10 |     first_struct.serialize(ref output_array);
11 |     panic(output_array);
12 | }
13 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_07_default/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_07_default/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "default"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_07_default/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Default, Drop)]
 2 | struct A {
 3 |     item1: felt252,
 4 |     item2: u64,
 5 | }
 6 | 
 7 | #[derive(Default, Drop, PartialEq)]
 8 | enum CaseWithDefault {
 9 |     A: felt252,
10 |     B: u128,
11 |     #[default]
12 |     C: u64,
13 | }
14 | 
15 | fn main() {
16 |     let defaulted: A = Default::default();
17 |     assert!(defaulted.item1 == 0_felt252, "item1 mismatch");
18 |     assert!(defaulted.item2 == 0_u64, "item2 mismatch");
19 | 
20 |     let default_case: CaseWithDefault = Default::default();
21 |     assert!(default_case == CaseWithDefault::C(0_u64), "case mismatch");
22 | }
23 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_07_deserialize/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_07_deserialize/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "serde_2"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/appendix/listing_07_deserialize/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Serde, Drop)]
 2 | struct A {
 3 |     item_one: felt252,
 4 |     item_two: felt252,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let first_struct = A { item_one: 2, item_two: 99 };
 9 |     let mut output_array = array![];
10 |     first_struct.serialize(ref output_array);
11 |     let mut span_array = output_array.span();
12 |     let deserialized_struct: A = Serde::<A>::deserialize(ref span_array).unwrap();
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_00_consts/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_00_consts/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_00_consts"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_00_consts/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: const_expressions
 2 | struct AnyStruct {
 3 |     a: u256,
 4 |     b: u32,
 5 | }
 6 | 
 7 | enum AnyEnum {
 8 |     A: felt252,
 9 |     B: (usize, u256),
10 | }
11 | 
12 | const ONE_HOUR_IN_SECONDS: u32 = 3600;
13 | const STRUCT_INSTANCE: AnyStruct = AnyStruct { a: 0, b: 1 };
14 | const ENUM_INSTANCE: AnyEnum = AnyEnum::A('any enum');
15 | const BOOL_FIXED_SIZE_ARRAY: [bool; 2] = [true, false];
16 | // ANCHOR_END: const_expressions
17 | 
18 | mod consteval {
19 |     // ANCHOR: consteval_const
20 |     const ONE_HOUR_IN_SECONDS: u32 = consteval_int!(60 * 60);
21 |     // ANCHOR_END: consteval_const
22 | }
23 | 
24 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_variables_are_immutable"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_01_variables_are_immutable v0.1.0 (listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/Scarb.toml)
 3 | error: Cannot assign to an immutable variable.
 4 |  --> listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo:6:5
 5 |     x = 6;
 6 |     ^***^
 7 | 
 8 | error: could not compile `no_listing_01_variables_are_immutable` due to previous error
 9 | error: `scarb metadata` exited with error
10 | 
11 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo:
--------------------------------------------------------------------------------
1 | //TAG: does_not_compile
2 | 
3 | fn main() {
4 |     let x = 5;
5 |     println!("The value of x is: {}", x);
6 |     x = 6;
7 |     println!("The value of x is: {}", x);
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_02_adding_mut/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_02_adding_mut"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_adding_mut"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_02_adding_mut/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_02_adding_mut v0.1.0 (listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.toml)
3 |     Finished `dev` profile target(s) in 3 seconds
4 |      Running no_listing_02_adding_mut
5 | The value of x is: 5
6 | The value of x is: 6
7 | Run completed successfully, returning []
8 | 
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_02_adding_mut/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let mut x = 5;
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
5 |     println!("The value of x is: {}", x);
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_03_shadowing/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_03_shadowing"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_shadowing"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_03_shadowing/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_03_shadowing v0.1.0 (listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running no_listing_03_shadowing
5 | Inner scope x value is: 12
6 | Outer scope x value is: 6
7 | Run completed successfully, returning []
8 | 
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_03_shadowing/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let x = 5;
 3 |     let x = x + 1;
 4 |     {
 5 |         let x = x * 2;
 6 |         println!("Inner scope x value is: {}", x);
 7 |     }
 8 |     println!("Outer scope x value is: {}", x);
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_04_shadowing_different_type/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_04_shadowing_different_type/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_04_shadowing_different_type"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_04_shadowing_different_type/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_shadowing_different_type"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_04_shadowing_different_type/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let x: u64 = 2;
3 |     println!("The value of x is {} of type u64", x);
4 |     let x: felt252 = x.into(); // converts x to a felt, type annotation is required.
5 |     println!("The value of x is {} of type felt252", x);
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_mut_cant_change_type"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_05_mut_cant_change_type v0.1.0 (listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/Scarb.toml)
 3 | error: The value does not fit within the range of type core::integer::u64.
 4 |  --> listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo:6:9
 5 |     x = 'a short string';
 6 |         ^**************^
 7 | 
 8 | error: could not compile `no_listing_05_mut_cant_change_type` due to previous error
 9 | error: `scarb metadata` exited with error
10 | 
11 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo:
--------------------------------------------------------------------------------
1 | //TAG: does_not_compile
2 | 
3 | fn main() {
4 |     let mut x: u64 = 2;
5 |     println!("The value of x is: {}", x);
6 |     x = 5_u8;
7 |     println!("The value of x is: {}", x);
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_06_data_types/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_06_data_types/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_06_data_types"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_06_data_types/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_06_data_types"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_06_data_types/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let x: felt252 = 3;
3 |     let y: u32 = x.try_into().unwrap();
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_07_integer_types/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_07_integer_types/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_07_integer_types"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_07_integer_types/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_integer_types"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_07_integer_types/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn sub_u8s(x: u8, y: u8) -> u8 {
2 |     x - y
3 | }
4 | 
5 | fn main() {
6 |     sub_u8s(1, 3);
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_08_numeric_operations/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_08_numeric_operations/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_08_numeric_operations"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_08_numeric_operations/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_numeric_operations"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_08_numeric_operations/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     // addition
 3 |     let sum = 5_u128 + 10_u128;
 4 | 
 5 |     // subtraction
 6 |     let difference = 95_u128 - 4_u128;
 7 | 
 8 |     // multiplication
 9 |     let product = 4_u128 * 30_u128;
10 | 
11 |     // division
12 |     let quotient = 56_u128 / 32_u128; //result is 1
13 |     let quotient = 64_u128 / 32_u128; //result is 2
14 | 
15 |     // remainder
16 |     let remainder = 43_u128 % 5_u128; // result is 3
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_09_boolean_type/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_09_boolean_type/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_09_boolean_type"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_09_boolean_type/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_09_boolean_type"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_09_boolean_type/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let t = true;
3 | 
4 |     let f: bool = false; // with explicit type annotation
5 | }
6 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_10_short_string_type/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_10_short_string_type/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_10_short_string_type"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_10_short_string_type/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_10_short_string_type"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_10_short_string_type/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let my_first_char = 'C';
 3 |     let my_first_char_in_hex = 0x43;
 4 | 
 5 |     let my_first_string = 'Hello world';
 6 |     let my_first_string_in_hex = 0x48656C6C6F20776F726C64;
 7 | 
 8 |     let long_string: ByteArray = "this is a string which has more than 31 characters";
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_11_into/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_11_into/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_11_into"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_11_into/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let my_u8: u8 = 10;
 3 |     let my_u16: u16 = my_u8.into();
 4 |     let my_u32: u32 = my_u16.into();
 5 |     let my_u64: u64 = my_u32.into();
 6 |     let my_u128: u128 = my_u64.into();
 7 | 
 8 |     let my_felt252 = 10;
 9 |     // As a felt252 is smaller than a u256, we can use the into() method
10 |     let my_u256: u256 = my_felt252.into();
11 |     let my_other_felt252: felt252 = my_u8.into();
12 |     let my_third_felt252: felt252 = my_u16.into();
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_12_tuple_type/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_12_tuple_type/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_12_tuple_type"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_12_tuple_type/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_12_tuple_type"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_12_tuple_type/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let tup: (u32, u64, bool) = (10, 20, true);
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_13_tuple_destructuration"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_13_tuple_destructuration"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let tup = (500, 6, true);
 3 | 
 4 |     let (x, y, z) = tup;
 5 | 
 6 |     if y == 6 {
 7 |         println!("y is 6!");
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_14_tuple_types/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_14_tuple_types/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_14_tuple_types"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_14_tuple_types/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_14_tuple_types"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_14_tuple_types/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let (x, y): (felt252, felt252) = (2, 3);
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_15_functions/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_15_functions"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_15_functions"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_15_functions/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running no_listing_15_functions
5 | Hello, world!
6 | Another function.
7 | Run completed successfully, returning []
8 | 
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_15_functions/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn another_function() {
2 |     println!("Another function.");
3 | }
4 | 
5 | fn main() {
6 |     println!("Hello, world!");
7 |     another_function();
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_16_single_param/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_16_single_param"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_16_single_param"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_16_single_param/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running no_listing_16_single_param
5 | The value of x is: 5
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_16_single_param/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     another_function(5);
3 | }
4 | 
5 | fn another_function(x: felt252) {
6 |     println!("The value of x is: {}", x);
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_17_multiple_params/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_17_multiple_params"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_17_multiple_params"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_17_multiple_params/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
3 |     Finished `dev` profile target(s) in 3 seconds
4 |      Running no_listing_17_multiple_params
5 | The measurement is: 5h
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_17_multiple_params/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     print_labeled_measurement(5, "h");
3 | }
4 | 
5 | fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
6 |     println!("The measurement is: {value}{unit_label}");
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_18_named_parameters/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_18_named_parameters/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_32_named_parameters"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_18_named_parameters/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn foo(x: u8, y: u8) {}
 2 | 
 3 | fn main() {
 4 |     let first_arg = 3;
 5 |     let second_arg = 4;
 6 |     foo(x: first_arg, y: second_arg);
 7 |     let x = 1;
 8 |     let y = 2;
 9 |     foo(:x, :y)
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_19_statement/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_19_statement/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_01_statement"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_19_statement/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let y = 6;
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_18_statements_dont_return_values"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
 3 | error: Missing token TerminalRParen.
 4 |  --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
 5 |     let x = (let y = 6);
 6 |              ^
 7 | 
 8 | error: Missing token TerminalSemicolon.
 9 |  --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
10 |     let x = (let y = 6);
11 |              ^
12 | 
13 | error: Missing token TerminalSemicolon.
14 |  --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
15 |     let x = (let y = 6);
16 |                       ^
17 | 
18 | error: Skipped tokens. Expected: statement.
19 |  --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
20 |     let x = (let y = 6);
21 |                       ^^
22 | 
23 | warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
24 |  --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:9
25 |     let x = (let y = 6);
26 |         ^
27 | 
28 | warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
29 |  --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:18
30 |     let x = (let y = 6);
31 |                  ^
32 | 
33 | error: could not compile `no_listing_18_statements_dont_return_values` due to previous error
34 | error: `scarb metadata` exited with error
35 | 
36 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:
--------------------------------------------------------------------------------
1 | // TAGS: does_not_compile, ignore_fmt
2 | fn main() {
3 |     let x = (let y = 6);
4 | }


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_21_blocks_are_expressions/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_21_blocks_are_expressions/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_19_blocks_are_expressions"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_21_blocks_are_expressions/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: all
 2 | fn main() {
 3 |     //ANCHOR: block_expr
 4 |     let y = {
 5 |         let x = 3;
 6 |         x + 1
 7 |     };
 8 |     //ANCHOR_END: block_expr
 9 | 
10 |     println!("The value of y is: {}", y);
11 | }
12 | //ANCHOR_END: all
13 | 
14 | 
15 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_22_function_return_values/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_20_function_return_values"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_22_function_return_values/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running no_listing_20_function_return_values
5 | The value of x is: 5
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_22_function_return_values/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn five() -> u32 {
2 |     5
3 | }
4 | 
5 | fn main() {
6 |     let x = five();
7 |     println!("The value of x is: {}", x);
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_23_function_return_values_2/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_23_function_return_values_2/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_21_function_return_values_2"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_23_function_return_values_2/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let x = plus_one(5);
 3 | 
 4 |     println!("The value of x is: {}", x);
 5 | }
 6 | 
 7 | fn plus_one(x: u32) -> u32 {
 8 |     x + 1
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_22_function_return_invalid"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
 3 | error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 4 |  --> listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28
 5 | fn plus_one(x: u32) -> u32 {
 6 |                            ^
 7 | 
 8 | error: could not compile `no_listing_22_function_return_invalid` due to previous error
 9 | error: `scarb metadata` exited with error
10 | 
11 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | fn main() {
 4 |     let x = plus_one(5);
 5 | 
 6 |     println!("The value of x is: {}", x);
 7 | }
 8 | 
 9 | fn plus_one(x: u32) -> u32 {
10 |     x + 1;
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_25_comments/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_25_comments/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_23_comments"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_25_comments/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() -> felt252 {
2 |     1 + 4 // return the sum of 1 and 4
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_26_comments/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_26_comments/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_23_comments_2"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_26_comments/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() -> felt252 {
2 |     // this function performs a simple addition
3 |     1 + 4
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_27_if/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_24_if"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_27_if/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running no_listing_24_if
5 | condition was false and number = 3
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_27_if/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let number = 3;
 3 | 
 4 |     if number == 5 {
 5 |         println!("condition was true and number = {}", number);
 6 |     } else {
 7 |         println!("condition was false and number = {}", number);
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_28_bis_if_not_bool"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb build 
 2 |    Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
 3 | error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 4 |  --> listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:4:18
 5 |     let number = 3;
 6 |                  ^
 7 | 
 8 | error: could not compile `no_listing_28_bis_if_not_bool` due to previous error
 9 | 
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | fn main() {
 4 |     let number = 3;
 5 | 
 6 |     if number {
 7 |         println!("number was three");
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_29_ter_if_not_equal_zero/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_29_ter_if_not_equal_zero/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_24_ter_if_not_equal_zero"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_29_ter_if_not_equal_zero/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let number = 3;
3 | 
4 |     if number != 0 {
5 |         println!("number was something other than zero");
6 |     }
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_30_else_if/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_25_else_if"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_30_else_if/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
3 |     Finished `dev` profile target(s) in 3 seconds
4 |      Running no_listing_25_else_if
5 | number is 3
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_30_else_if/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let number = 3;
 3 | 
 4 |     if number == 12 {
 5 |         println!("number is 12");
 6 |     } else if number == 3 {
 7 |         println!("number is 3");
 8 |     } else if number - 2 == 1 {
 9 |         println!("number minus 2 is 1");
10 |     } else {
11 |         println!("number not found");
12 |     }
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_31_if_let/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_26_if_let"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_31_if_let/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running no_listing_26_if_let
5 | condition was true and number is 5
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_31_if_let/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let condition = true;
 3 |     let number = if condition {
 4 |         5
 5 |     } else {
 6 |         6
 7 |     };
 8 | 
 9 |     if number == 5 {
10 |         println!("condition was true and number is {}", number);
11 |     }
12 | }
13 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_27_infinite_loop"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/output.txt:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/output.txt


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     loop {
3 |         println!("again!");
4 |     }
5 | }
6 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_33_loop_break/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_33_loop_break/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_28_loop_break"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_33_loop_break/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut i: usize = 0;
 3 |     loop {
 4 |         if i > 10 {
 5 |             break;
 6 |         }
 7 |         println!("i = {}", i);
 8 |         i += 1;
 9 |     }
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_34_loop_continue/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_34_loop_continue/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_29_loop_continue"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_34_loop_continue/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut i: usize = 0;
 3 |     loop {
 4 |         if i > 10 {
 5 |             break;
 6 |         }
 7 |         if i == 5 {
 8 |             i += 1;
 9 |             continue;
10 |         }
11 |         println!("i = {}", i);
12 |         i += 1;
13 |     }
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_35_loop_return_values/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_35_loop_return_values/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_30_loop_return_values"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_35_loop_return_values/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut counter = 0;
 3 | 
 4 |     let result = loop {
 5 |         if counter == 10 {
 6 |             break counter * 2;
 7 |         }
 8 |         counter += 1;
 9 |     };
10 | 
11 |     println!("The result is {}", result);
12 | }
13 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_36_while_loop/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_31_while_loop"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_36_while_loop/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut number = 3;
 3 | 
 4 |     while number != 0 {
 5 |         println!("{number}!");
 6 |         number -= 1;
 7 |     };
 8 | 
 9 |     println!("LIFTOFF!!!");
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_37_item_doc_comments/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_37_item_doc_comments/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_37_item_doc_comments"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_37_item_doc_comments/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | /// Returns the sum of `arg1` and `arg2`.
 2 | /// `arg1` cannot be zero.
 3 | ///
 4 | /// # Panics
 5 | ///
 6 | /// This function will panic if `arg1` is `0`.
 7 | ///
 8 | /// # Examples
 9 | ///
10 | /// ```
11 | /// let a: felt252 = 2;
12 | /// let b: felt252 = 3;
13 | /// let c: felt252 = add(a, b);
14 | /// assert(c == a + b, "Should equal a + b");
15 | /// ```
16 | fn add(arg1: felt252, arg2: felt252) -> felt252 {
17 |     assert(arg1 != 0, 'Cannot be zero');
18 |     arg1 + arg2
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_38_mod_doc_comments/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_38_mod_doc_comments/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_38_mod_doc_comments"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_38_mod_doc_comments/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //! # my_module and implementation
 2 | //!
 3 | //! This is an example description of my_module and some of its features.
 4 | //!
 5 | //! # Examples
 6 | //!
 7 | //! ```
 8 | //! mod my_other_module {
 9 | //!   use path::to::my_module;
10 | //!
11 | //!   fn foo() {
12 | //!     my_module.bar();
13 | //!   }
14 | //! }
15 | //! ```
16 | mod my_module { // rest of implementation...
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_39_tryinto/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_39_tryinto/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_39_tryinto"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_39_tryinto/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let my_u256: u256 = 10;
 3 | 
 4 |     // Since a u256 might not fit in a felt252, we need to unwrap the Option<T> type
 5 |     let my_felt252: felt252 = my_u256.try_into().unwrap();
 6 |     let my_u128: u128 = my_felt252.try_into().unwrap();
 7 |     let my_u64: u64 = my_u128.try_into().unwrap();
 8 |     let my_u32: u32 = my_u64.try_into().unwrap();
 9 |     let my_u16: u16 = my_u32.try_into().unwrap();
10 |     let my_u8: u8 = my_u16.try_into().unwrap();
11 | 
12 |     let my_large_u16: u16 = 2048;
13 |     let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_40_fixed_size_arr_type/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_40_fixed_size_arr_type/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_40_fixed_size_arr_type"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_40_fixed_size_arr_type/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let arr1: [u64; 5] = [1, 2, 3, 4, 5];
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_41_fixed_size_arr_months"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     //ANCHOR: months
 3 |     let months = [
 4 |         'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
 5 |         'October', 'November', 'December',
 6 |     ];
 7 | 
 8 |     //ANCHOR_END: months
 9 | 
10 |     //ANCHOR: repeated_values
11 |     let a = [3; 5];
12 |     //ANCHOR_END: repeated_values
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_42_fixed_size_arr_accessing_elements/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_42_fixed_size_arr_accessing_elements/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_42_fixed_size_arr_accessing_elements"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_42_fixed_size_arr_accessing_elements/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let my_arr = [1, 2, 3, 4, 5];
3 | 
4 |     // Accessing elements of a fixed-size array by deconstruction
5 |     let [a, b, c, _, _] = my_arr;
6 |     println!("c: {}", c); // c: 3    
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_44_fixed_size_arr_accessing_elements_span/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_44_fixed_size_arr_accessing_elements_span/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_44_fixed_size_arr_accessing_elements_span"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_44_fixed_size_arr_accessing_elements_span/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let my_arr = [1, 2, 3, 4, 5];
3 | 
4 |     // Accessing elements of a fixed-size array by index
5 |     let my_span = my_arr.span();
6 |     println!("my_span[2]: {}", my_span[2]); // my_span[2]: 3
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_45_iter_loop_while"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
 3 |     Finished `dev` profile target(s) in 2 seconds
 4 |      Running no_listing_45_iter_loop_while
 5 | the value is: 10
 6 | the value is: 20
 7 | the value is: 30
 8 | the value is: 40
 9 | the value is: 50
10 | Run completed successfully, returning []
11 | 
12 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let a = [10, 20, 30, 40, 50].span();
 3 |     let mut index = 0;
 4 | 
 5 |     while index < 5 {
 6 |         println!("the value is: {}", a[index]);
 7 |         index += 1;
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_46_iter_loop_for/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_46_iter_loop_for"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_46_iter_loop_for/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let a = [10, 20, 30, 40, 50].span();
3 | 
4 |     for element in a {
5 |         println!("the value is: {element}");
6 |     }
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_47_for_range/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_47_for_range"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_47_for_range/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     for number in 1..4_u8 {
3 |         println!("{number}!");
4 |     };
5 |     println!("Go!!!");
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_loop_recursion/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_loop_recursion/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_loop_recursion"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | 
10 | [lib]
11 | sierra-text = true
12 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/examples/loop_example.cairo:
--------------------------------------------------------------------------------
 1 | fn main() -> felt252 {
 2 |     let mut x: felt252 = 0;
 3 |     loop {
 4 |         if x == 2 {
 5 |             break;
 6 |         } else {
 7 |             x += 1;
 8 |         }
 9 |     };
10 |     x
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/examples/recursion_example.cairo:
--------------------------------------------------------------------------------
 1 | fn main() -> felt252 {
 2 |     recursive_function(0)
 3 | }
 4 | 
 5 | fn recursive_function(mut x: felt252) -> felt252 {
 6 |     if x == 2 {
 7 |         x
 8 |     } else {
 9 |         recursive_function(x + 1)
10 |     }
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod examples {
2 |     mod loop_example;
3 |     mod recursion_example;
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_01_array_new_append/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_01_array_new_append/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_00_array_new_append"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_01_array_new_append/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let mut a = ArrayTrait::new();
3 |     a.append(0);
4 |     a.append(1);
5 |     a.append(2);
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_02_array_pop_front/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_02_array_pop_front/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_array_pop_front"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_02_array_pop_front/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut a = ArrayTrait::new();
 3 |     a.append(10);
 4 |     a.append(1);
 5 |     a.append(2);
 6 | 
 7 |     let first_value = a.pop_front().unwrap();
 8 |     println!("The first value is {}", first_value);
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_03_array_get/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_03_array_get/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_03_array_get"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_03_array_get/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_array_get"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_03_array_get/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() -> u128 {
 2 |     let mut arr = ArrayTrait::<u128>::new();
 3 |     arr.append(100);
 4 |     let index_to_access =
 5 |         1; // Change this value to see different results, what would happen if the index doesn't exist?
 6 |     match arr.get(index_to_access) {
 7 |         Option::Some(x) => {
 8 |             *x
 9 |                 .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
10 |             // It basically means "transform what get(idx) returned into a real value"
11 |         },
12 |         Option::None => { panic!("out of bounds") },
13 |     }
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_04_array_at/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_04_array_at/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_array_at"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_04_array_at/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut a = ArrayTrait::new();
 3 |     a.append(0);
 4 |     a.append(1);
 5 | 
 6 |     // using the `at()` method
 7 |     let first = *a.at(0);
 8 |     assert!(first == 0);
 9 |     // using the subscripting operator
10 |     let second = *a[1];
11 |     assert!(second == 1);
12 | }
13 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_06_array_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_06_array_macro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_array_macro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_06_array_macro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     //ANCHOR: no_macro
 3 |     let mut arr = ArrayTrait::new();
 4 |     arr.append(1);
 5 |     arr.append(2);
 6 |     arr.append(3);
 7 |     arr.append(4);
 8 |     arr.append(5);
 9 |     //ANCHOR_END: no_macro
10 | 
11 |     //ANCHOR: array_macro
12 |     let arr = array![1, 2, 3, 4, 5];
13 |     //ANCHOR_END: array_macro
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_07_array_with_enums/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_07_array_with_enums/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_array_with_enums"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_07_array_with_enums/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | enum Data {
 3 |     Integer: u128,
 4 |     Felt: felt252,
 5 |     Tuple: (u32, u32),
 6 | }
 7 | 
 8 | fn main() {
 9 |     let mut messages: Array<Data> = array![];
10 |     messages.append(Data::Integer(100));
11 |     messages.append(Data::Felt('hello world'));
12 |     messages.append(Data::Tuple((10, 30)));
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_08_array_span/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_08_array_span/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_array_span"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_08_array_span/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let mut array: Array<u8> = ArrayTrait::new();
3 |     array.span();
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_09_intro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_09_intro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_intro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_09_intro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::dict::Felt252Dict;
 2 | 
 3 | fn main() {
 4 |     let mut balances: Felt252Dict<u64> = Default::default();
 5 | 
 6 |     balances.insert('Alex', 100);
 7 |     balances.insert('Maria', 200);
 8 | 
 9 |     let alex_balance = balances.get('Alex');
10 |     assert!(alex_balance == 100, "Balance is not 100");
11 | 
12 |     let maria_balance = balances.get('Maria');
13 |     assert!(maria_balance == 200, "Balance is not 200");
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_10_intro_rewrite/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_10_intro_rewrite/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_intro_rewrite"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_10_intro_rewrite/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::dict::Felt252Dict;
 2 | 
 3 | fn main() {
 4 |     let mut balances: Felt252Dict<u64> = Default::default();
 5 | 
 6 |     // Insert Alex with 100 balance
 7 |     balances.insert('Alex', 100);
 8 |     // Check that Alex has indeed 100 associated with him
 9 |     let alex_balance = balances.get('Alex');
10 |     assert!(alex_balance == 100, "Alex balance is not 100");
11 | 
12 |     // Insert Alex again, this time with 200 balance
13 |     balances.insert('Alex', 200);
14 |     // Check the new balance is correct
15 |     let alex_balance_2 = balances.get('Alex');
16 |     assert!(alex_balance_2 == 200, "Alex balance is not 200");
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_11_entries/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_11_entries/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_09_entries"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_11_entries/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::dict::Felt252Dict;
 2 | 
 3 | // ANCHOR: struct
 4 | struct Entry<T> {
 5 |     key: felt252,
 6 |     previous_value: T,
 7 |     new_value: T,
 8 | }
 9 | // ANCHOR_END: struct
10 | 
11 | fn main() {
12 |     let mut balances: Felt252Dict<u64> = Default::default();
13 |     // ANCHOR: inserts
14 |     balances.insert('Alex', 100_u64);
15 |     balances.insert('Maria', 50_u64);
16 |     balances.insert('Alex', 200_u64);
17 |     balances.get('Maria');
18 |     // ANCHOR_END: inserts
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_12_custom_methods/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_12_custom_methods/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_10_custom_methods"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_12_custom_methods/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: imports
 2 | use core::dict::{Felt252Dict, Felt252DictEntryTrait};
 3 | // ANCHOR_END: imports
 4 | 
 5 | // ANCHOR: custom_get
 6 | fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
 7 |     ref dict: Felt252Dict<T>, key: felt252,
 8 | ) -> T {
 9 |     // Get the new entry and the previous value held at `key`
10 |     let (entry, prev_value) = dict.entry(key);
11 | 
12 |     // Store the value to return
13 |     let return_value = prev_value;
14 | 
15 |     // Update the entry with `prev_value` and get back ownership of the dictionary
16 |     dict = entry.finalize(prev_value);
17 | 
18 |     // Return the read value
19 |     return_value
20 | }
21 | // ANCHOR_END: custom_get
22 | 
23 | // ANCHOR: custom_insert
24 | fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
25 |     ref dict: Felt252Dict<T>, key: felt252, value: T,
26 | ) {
27 |     // Get the last entry associated with `key`
28 |     // Notice that if `key` does not exist, `_prev_value` will
29 |     // be the default value of T.
30 |     let (entry, _prev_value) = dict.entry(key);
31 | 
32 |     // Insert `entry` back in the dictionary with the updated value,
33 |     // and receive ownership of the dictionary
34 |     dict = entry.finalize(value);
35 | }
36 | // ANCHOR_END: custom_insert
37 | 
38 | // ANCHOR: main
39 | fn main() {
40 |     let mut dict: Felt252Dict<u64> = Default::default();
41 | 
42 |     custom_insert(ref dict, '0', 100);
43 | 
44 |     let val = custom_get(ref dict, '0');
45 | 
46 |     assert!(val == 100, "Expecting 100");
47 | }
48 | // ANCHOR_END: main
49 | 
50 | 
51 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_13_dict_of_complex/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_13_dict_of_complex/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_11_dict_of_complex"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_13_dict_of_complex/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | // ANCHOR: imports
 3 | use core::dict::Felt252Dict;
 4 | use core::nullable::{NullableTrait, match_nullable, FromNullableResult};
 5 | // ANCHOR_END: imports
 6 | 
 7 | // ANCHOR: header
 8 | fn main() {
 9 |     // Create the dictionary
10 |     let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();
11 | 
12 |     // Create the array to insert
13 |     let a = array![8, 9, 10];
14 | 
15 |     // Insert it as a `Span`
16 |     d.insert(0, NullableTrait::new(a.span()));
17 |     // ANCHOR_END: header
18 | 
19 |     // ANCHOR: footer
20 |     // Get value back
21 |     let val = d.get(0);
22 | 
23 |     // Search the value and assert it is not null
24 |     let span = match match_nullable(val) {
25 |         FromNullableResult::Null => panic!("No value found"),
26 |         FromNullableResult::NotNull(val) => val.unbox(),
27 |     };
28 | 
29 |     // Verify we are having the right values
30 |     assert!(*span.at(0) == 8, "Expecting 8");
31 |     assert!(*span.at(1) == 9, "Expecting 9");
32 |     assert!(*span.at(2) == 10, "Expecting 10");
33 | }
34 | // ANCHOR_END: footer
35 | 
36 | // ANCHOR_END: all
37 | 
38 | 
39 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_14_dict_of_array_insert/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_14_dict_of_array_insert/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_14_dict_of_array_insert"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_14_dict_of_array_insert/src/lib.cairo:
--------------------------------------------------------------------------------
1 | use core::dict::Felt252Dict;
2 | 
3 | fn main() {
4 |     let arr = array![20, 19, 26];
5 |     let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
6 |     dict.insert(0, NullableTrait::new(arr));
7 |     println!("Array inserted successfully.");
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_15_dict_of_array_attempt_get"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
 3 | error: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>.
 4 |  --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:13:20
 5 |     let val = dict.get(0); // This will cause a compiler error
 6 |                    ^*^
 7 | 
 8 | error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error
 9 | error: `scarb metadata` exited with error
10 | 
11 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | use core::nullable::{match_nullable, FromNullableResult};
 3 | use core::dict::Felt252Dict;
 4 | 
 5 | fn main() {
 6 |     let arr = array![20, 19, 26];
 7 |     let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
 8 |     dict.insert(0, NullableTrait::new(arr));
 9 |     println!("Array: {:?}", get_array_entry(ref dict, 0));
10 | }
11 | 
12 | fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
13 |     let val = dict.get(0); // This will cause a compiler error
14 |     let arr = match match_nullable(val) {
15 |         FromNullableResult::Null => panic!("No value!"),
16 |         FromNullableResult::NotNull(val) => val.unbox(),
17 |     };
18 |     arr.span()
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_16_dict_of_array/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_16_dict_of_array/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_16_dict_of_array"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch03-common-collections/no_listing_16_dict_of_array/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: all
 2 | use core::nullable::NullableTrait;
 3 | use core::dict::{Felt252Dict, Felt252DictEntryTrait};
 4 | 
 5 | //ANCHOR: append
 6 | fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
 7 |     let (entry, arr) = dict.entry(index);
 8 |     let mut unboxed_val = arr.deref_or(array![]);
 9 |     unboxed_val.append(value);
10 |     dict = entry.finalize(NullableTrait::new(unboxed_val));
11 | }
12 | //ANCHOR_END: append
13 | 
14 | //ANCHOR: get
15 | fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
16 |     let (entry, _arr) = dict.entry(index);
17 |     let mut arr = _arr.deref_or(array![]);
18 |     let span = arr.span();
19 |     dict = entry.finalize(NullableTrait::new(arr));
20 |     span
21 | }
22 | //ANCHOR_END: get
23 | 
24 | fn main() {
25 |     let arr = array![20, 19, 26];
26 |     let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
27 |     dict.insert(0, NullableTrait::new(arr));
28 |     println!("Before insertion: {:?}", get_array_entry(ref dict, 0));
29 | 
30 |     append_value(ref dict, 0, 30);
31 | 
32 |     println!("After insertion: {:?}", get_array_entry(ref dict, 0));
33 | }
34 | //ANCHOR_END: all
35 | 
36 | 
37 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_01_variable_and_scope/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_01_variable_and_scope/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_01"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_01_variable_and_scope/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: ignore_fmt
 2 | fn main() {
 3 |     // ANCHOR: here
 4 |     { // s is not valid here, its not yet declared
 5 |         let s = 'hello'; // s is valid from this point forward
 6 |         // do stuff with s
 7 |     } // this scope is now over, and s is no longer valid
 8 |     // ANCHOR_END: here
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_02_moving_return_values/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_02_moving_return_values/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_02"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_02_moving_return_values/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: ignore_fmt
 2 | #[derive(Drop)]
 3 | struct A {}
 4 | 
 5 | fn main() {
 6 |     let a1 = gives_ownership();           // gives_ownership moves its return
 7 |                                           // value into a1
 8 | 
 9 |     let a2 = A {};                        // a2 comes into scope
10 | 
11 |     let a3 = takes_and_gives_back(a2);    // a2 is moved into
12 |                                           // takes_and_gives_back, which also
13 |                                           // moves its return value into a3
14 | 
15 | } // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing
16 |   // happens. a1 goes out of scope and is dropped.
17 | 
18 | fn gives_ownership() -> A {               // gives_ownership will move its
19 |                                           // return value into the function
20 |                                           // that calls it
21 | 
22 |     let some_a = A {};                    // some_a comes into scope
23 | 
24 |     some_a                                // some_a is returned and
25 |                                           // moves ownership to the calling
26 |                                           // function
27 | }
28 | 
29 | // This function takes an instance some_a of A and returns it
30 | fn takes_and_gives_back(some_a: A) -> A { // some_a comes into scope
31 | 
32 |     some_a                                // some_a is returned and 
33 |                                           // moves ownership to the calling
34 |                                           // function
35 | }


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_03_returning_many_values/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_03_returning_many_values/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_03"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_03_returning_many_values/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let arr1: Array<u128> = array![];
 3 | 
 4 |     let (arr2, len) = calculate_length(arr1);
 5 | }
 6 | 
 7 | fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {
 8 |     let length = arr.len(); // len() returns the length of an array
 9 | 
10 |     (arr, length)
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_04"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling listing_04_04 v0.1.0 (listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/Scarb.toml)
 3 | error: Invalid left-hand side of assignment.
 4 |  --> listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:15:5
 5 |     rec.height = rec.width;
 6 |     ^********^
 7 | 
 8 | error: Invalid left-hand side of assignment.
 9 |  --> listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:16:5
10 |     rec.width = temp;
11 |     ^*******^
12 | 
13 | error: could not compile `listing_04_04` due to previous error
14 | error: `scarb metadata` exited with error
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | #[derive(Copy, Drop)]
 3 | struct Rectangle {
 4 |     height: u64,
 5 |     width: u64,
 6 | }
 7 | 
 8 | fn main() {
 9 |     let rec = Rectangle { height: 3, width: 10 };
10 |     flip(@rec);
11 | }
12 | 
13 | fn flip(rec: @Rectangle) {
14 |     let temp = rec.height;
15 |     rec.height = rec.width;
16 |     rec.width = temp;
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_05_mutable_reference/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_05_mutable_reference/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_05"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_05_mutable_reference/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling listing_04_05 v0.1.0 (listings/ch04-understanding-ownership/listing_05_mutable_reference/Scarb.toml)
3 |     Finished `dev` profile target(s) in 3 seconds
4 |      Running listing_04_05
5 | height: 10, width: 3
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/listing_05_mutable_reference/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct Rectangle {
 3 |     height: u64,
 4 |     width: u64,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let mut rec = Rectangle { height: 3, width: 10 };
 9 |     flip(ref rec);
10 |     println!("height: {}, width: {}", rec.height, rec.width);
11 | }
12 | 
13 | fn flip(ref rec: Rectangle) {
14 |     let temp = rec.height;
15 |     rec.height = rec.width;
16 |     rec.width = temp;
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_01_array/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_01_array/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_01_array"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_01_array/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_array"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_01_array/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let mut arr: Array<u128> = array![];
3 |     arr.append(1);
4 |     arr.append(2);
5 | }
6 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_pass_array_by_value"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_02_pass_array_by_value v0.1.0 (listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/Scarb.toml)
 3 | warn: Unhandled `#[must_use]` type `core::option::Option::<core::integer::u128>`
 4 |  --> listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:3:5
 5 |     arr.pop_front();
 6 |     ^*************^
 7 | 
 8 | error: Variable was previously moved.
 9 |  --> listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:9:9
10 |     foo(arr);
11 |         ^*^
12 | note: variable was previously used here:
13 |   --> listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:8:9
14 |     foo(arr);
15 |         ^*^
16 | note: Trait has no implementation in context: core::traits::Copy::<core::array::Array::<core::integer::u128>>.
17 | 
18 | error: could not compile `no_listing_02_pass_array_by_value` due to previous error
19 | error: `scarb metadata` exited with error
20 | 
21 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_run
 2 | fn foo(mut arr: Array<u128>) {
 3 |     arr.pop_front();
 4 | }
 5 | 
 6 | fn main() {
 7 |     let arr: Array<u128> = array![];
 8 |     foo(arr);
 9 |     foo(arr);
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_03_copy_trait/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_03_copy_trait/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_03_copy_trait"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_03_copy_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_copy_trait"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_03_copy_trait/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Point {
 3 |     x: u128,
 4 |     y: u128,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let p1 = Point { x: 5, y: 10 };
 9 |     foo(p1);
10 |     foo(p1);
11 | }
12 | 
13 | fn foo(p: Point) { // do something with p
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_04_no_drop_derive_fails/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_04_no_drop_derive_fails/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_no_drop_derive_fails"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_04_no_drop_derive_fails/src/lib.cairo:
--------------------------------------------------------------------------------
1 | //TAG: does_not_compile
2 | struct A {}
3 | 
4 | fn main() {
5 |     A {}; // error: Variable not dropped.
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_05_drop_derive_compiles/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_05_drop_derive_compiles/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_05_drop_derive_compiles"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_05_drop_derive_compiles/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_drop_derive_compiles"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_05_drop_derive_compiles/src/lib.cairo:
--------------------------------------------------------------------------------
1 | #[derive(Drop)]
2 | struct A {}
3 | 
4 | fn main() {
5 |     A {}; // Now there is no error.
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_06_no_destruct_compile_fails"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_06_no_destruct_compile_fails v0.1.0 (listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/Scarb.toml)
 3 | error: Variable not dropped.
 4 |  --> listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/src/lib.cairo:9:5
 5 |     A { dict: Default::default() };
 6 |     ^****************************^
 7 | note: Trait has no implementation in context: core::traits::Drop::<no_listing_06_no_destruct_compile_fails::A>.
 8 | note: Trait has no implementation in context: core::traits::Destruct::<no_listing_06_no_destruct_compile_fails::A>.
 9 | 
10 | error: could not compile `no_listing_06_no_destruct_compile_fails` due to previous error
11 | error: `scarb metadata` exited with error
12 | 
13 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | use core::dict::Felt252Dict;
 3 | 
 4 | struct A {
 5 |     dict: Felt252Dict<u128>,
 6 | }
 7 | 
 8 | fn main() {
 9 |     A { dict: Default::default() };
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_07_destruct_compiles/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_07_destruct_compiles/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_07_destruct_compiles"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_07_destruct_compiles/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_destruct_compiles"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_07_destruct_compiles/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::dict::Felt252Dict;
 2 | 
 3 | #[derive(Destruct)]
 4 | struct A {
 5 |     dict: Felt252Dict<u128>,
 6 | }
 7 | 
 8 | fn main() {
 9 |     A { dict: Default::default() }; // No error here
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_08_array_clone/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_08_array_clone/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_08_array_clone"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_08_array_clone/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_array_clone"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_08_array_clone/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let arr1: Array<u128> = array![];
3 |     let arr2 = arr1.clone();
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_09_snapshots/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_09_snapshots"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_09_snapshots"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_09_snapshots/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_09_snapshots v0.1.0 (listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.toml)
3 |     Finished `dev` profile target(s) in 3 seconds
4 |      Running no_listing_09_snapshots
5 | The length of the array when the snapshot was taken is 0
6 | The current length of the array is 1
7 | Run completed successfully, returning []
8 | 
9 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_09_snapshots/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut arr1: Array<u128> = array![];
 3 |     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time
 4 |     arr1.append(1); // Mutate `arr1` by appending a value
 5 |     let first_length = calculate_length(
 6 |         first_snapshot,
 7 |     ); // Calculate the length of the array when the snapshot was taken
 8 |     let second_length = calculate_length(@arr1); // Calculate the current length of the array
 9 |     println!("The length of the array when the snapshot was taken is {}", first_length);
10 |     println!("The current length of the array is {}", second_length);
11 | }
12 | 
13 | fn calculate_length(arr: @Array<u128>) -> usize {
14 |     arr.len()
15 | }
16 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_10_desnap/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_10_desnap/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_10_desnap"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_10_desnap/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_10_desnap"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch04-understanding-ownership/no_listing_10_desnap/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct Rectangle {
 3 |     height: u64,
 4 |     width: u64,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let rec = Rectangle { height: 3, width: 10 };
 9 |     let area = calculate_area(@rec);
10 |     println!("Area: {}", area);
11 | }
12 | 
13 | fn calculate_area(rec: @Rectangle) -> u64 {
14 |     // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.
15 |     // We need to transform the snapshots back into values using the desnap operator `*`.
16 |     // This is only possible if the type is copyable, which is the case for u64.
17 |     // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.
18 |     *rec.height * *rec.width
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_01_user_struct"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | // ANCHOR: user
 3 | #[derive(Drop)]
 4 | struct User {
 5 |     active: bool,
 6 |     username: ByteArray,
 7 |     email: ByteArray,
 8 |     sign_in_count: u64,
 9 | }
10 | // ANCHOR_END: user
11 | 
12 | // ANCHOR: main
13 | fn main() {
14 |     let user1 = User {
15 |         active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
16 |     };
17 |     let user2 = User {
18 |         sign_in_count: 1, username: "someusername123", active: true, email: "someone@example.com",
19 |     };
20 | }
21 | // ANCHOR_END: main
22 | 
23 | // ANCHOR_END: all
24 | 
25 | 
26 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_02_mut_struct"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | #[derive(Drop)]
 3 | struct User {
 4 |     active: bool,
 5 |     username: ByteArray,
 6 |     email: ByteArray,
 7 |     sign_in_count: u64,
 8 | }
 9 | // ANCHOR: main
10 | fn main() {
11 |     let mut user1 = User {
12 |         active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
13 |     };
14 |     user1.email = "anotheremail@example.com";
15 | }
16 | // ANCHOR_END: main
17 | 
18 | // ANCHOR: build_user
19 | fn build_user(email: ByteArray, username: ByteArray) -> User {
20 |     User { active: true, username: username, email: email, sign_in_count: 1 }
21 | }
22 | // ANCHOR_END: build_user
23 | 
24 | // ANCHOR: build_user2
25 | fn build_user_short(email: ByteArray, username: ByteArray) -> User {
26 |     User { active: true, username, email, sign_in_count: 1 }
27 | }
28 | // ANCHOR_END: build_user2
29 | // ANCHOR_END: all
30 | 
31 | 
32 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_06_no_struct"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling listing_04_06_no_struct v0.1.0 (listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/Scarb.toml)
3 |     Finished `dev` profile target(s) in 2 seconds
4 |      Running listing_04_06_no_struct
5 | Area is 300
6 | Run completed successfully, returning []
7 | 
8 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR:all
 2 | fn main() {
 3 |     let width = 30;
 4 |     let height = 10;
 5 |     let area = area(width, height);
 6 |     println!("Area is {}", area);
 7 | }
 8 | 
 9 | //ANCHOR: here
10 | fn area(width: u64, height: u64) -> u64 {
11 |     //ANCHOR_END: here
12 |     width * height
13 | }
14 | //ANCHOR_END:all
15 | 
16 | 
17 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_04_w_tuples/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_04_w_tuples/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_07_w_tuples"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_04_w_tuples/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let rectangle = (30, 10);
 3 |     let area = area(rectangle);
 4 |     println!("Area is {}", area);
 5 | }
 6 | 
 7 | fn area(dimension: (u64, u64)) -> u64 {
 8 |     let (x, y) = dimension;
 9 |     x * y
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_05_w_structs/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_05_w_structs/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_08_w_structs"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_05_w_structs/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | struct Rectangle {
 2 |     width: u64,
 3 |     height: u64,
 4 | }
 5 | 
 6 | fn main() {
 7 |     let rectangle = Rectangle { width: 30, height: 10 };
 8 |     let area = area(rectangle);
 9 |     println!("Area is {}", area);
10 | }
11 | 
12 | fn area(rectangle: Rectangle) -> u64 {
13 |     rectangle.width * rectangle.height
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_update_syntax/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_update_syntax/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_update_syntax"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_update_syntax/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::byte_array;
 2 | #[derive(Drop)]
 3 | struct User {
 4 |     active: bool,
 5 |     username: ByteArray,
 6 |     email: ByteArray,
 7 |     sign_in_count: u64,
 8 | }
 9 | 
10 | // ANCHOR: here
11 | fn main() {
12 |     // --snip--
13 |     // ANCHOR_END: here
14 | 
15 |     let user1 = User {
16 |         email: "someone@example.com", username: "someusername123", active: true, sign_in_count: 1,
17 |     };
18 |     // ANCHOR: here
19 | 
20 |     let user2 = User { email: "another@example.com", ..user1 };
21 | }
22 | // ANCHOR_END: here
23 | 
24 | 
25 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_without_update_syntax/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_without_update_syntax/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_without_update_syntax"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/listing_without_update_syntax/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct User {
 3 |     active: bool,
 4 |     username: ByteArray,
 5 |     email: ByteArray,
 6 |     sign_in_count: u64,
 7 | }
 8 | 
 9 | // ANCHOR: here
10 | fn main() {
11 |     // --snip--
12 |     // ANCHOR_END: here
13 | 
14 |     let user1 = User {
15 |         email: "someone@example.com", username: "someusername123", active: true, sign_in_count: 1,
16 |     };
17 |     // ANCHOR: here
18 | 
19 |     let user2 = User {
20 |         active: user1.active,
21 |         username: user1.username,
22 |         email: "another@example.com",
23 |         sign_in_count: user1.sign_in_count,
24 |     };
25 | }
26 | // ANCHOR_END: here
27 | 
28 | 
29 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_01_define_methods/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_01_define_methods/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_11"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_01_define_methods/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: all
 2 | #[derive(Copy, Drop)]
 3 | struct Rectangle {
 4 |     width: u64,
 5 |     height: u64,
 6 | }
 7 | 
 8 | //ANCHOR: trait_definition
 9 | trait RectangleTrait {
10 |     fn area(self: @Rectangle) -> u64;
11 | }
12 | //ANCHOR_END: trait_definition
13 | 
14 | //ANCHOR: trait_implementation
15 | impl RectangleImpl of RectangleTrait {
16 |     fn area(self: @Rectangle) -> u64 {
17 |         (*self.width) * (*self.height)
18 |     }
19 | }
20 | //ANCHOR_END: trait_implementation
21 | 
22 | //ANCHOR: main
23 | fn main() {
24 |     let rect1 = Rectangle { width: 30, height: 50 };
25 |     println!("Area is {}", rect1.area());
26 | }
27 | //ANCHOR_END: main
28 | //ANCHOR_END: all
29 | 
30 | 
31 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_02_gen_trait/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_02_gen_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_12"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_02_gen_trait/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | #[generate_trait]
 8 | impl RectangleImpl of RectangleTrait {
 9 |     fn area(self: @Rectangle) -> u64 {
10 |         (*self.width) * (*self.height)
11 |     }
12 | }
13 | 
14 | fn main() {
15 |     let rect1 = Rectangle { width: 30, height: 50 };
16 |     println!("Area is {}", rect1.area());
17 | }
18 | 
19 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_11"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | //ANCHOR: trait_impl
 8 | #[generate_trait]
 9 | impl RectangleImpl of RectangleTrait {
10 |     fn area(self: @Rectangle) -> u64 {
11 |         (*self.width) * (*self.height)
12 |     }
13 |     fn scale(ref self: Rectangle, factor: u64) {
14 |         self.width *= factor;
15 |         self.height *= factor;
16 |     }
17 | }
18 | //ANCHOR_END: trait_impl
19 | 
20 | //ANCHOR: main
21 | fn main() {
22 |     let mut rect2 = Rectangle { width: 10, height: 20 };
23 |     rect2.scale(2);
24 |     println!("The new size is (width: {}, height: {})", rect2.width, rect2.height);
25 | }
26 | //ANCHOR_END: main
27 | 
28 | 
29 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_12"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | // ANCHOR: trait_impl
 8 | #[generate_trait]
 9 | impl RectangleImpl of RectangleTrait {
10 |     fn area(self: @Rectangle) -> u64 {
11 |         *self.width * *self.height
12 |     }
13 | 
14 |     fn scale(ref self: Rectangle, factor: u64) {
15 |         self.width *= factor;
16 |         self.height *= factor;
17 |     }
18 | 
19 |     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {
20 |         *self.width > *other.width && *self.height > *other.height
21 |     }
22 | }
23 | // ANCHOR_END: trait_impl
24 | 
25 | // ANCHOR: main
26 | fn main() {
27 |     let rect1 = Rectangle { width: 30, height: 50 };
28 |     let rect2 = Rectangle { width: 10, height: 40 };
29 |     let rect3 = Rectangle { width: 60, height: 45 };
30 | 
31 |     println!("Can rect1 hold rect2? {}", rect1.can_hold(@rect2));
32 |     println!("Can rect1 hold rect3? {}", rect1.can_hold(@rect3));
33 | }
34 | // ANCHOR_END: main
35 | 
36 | 
37 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_13"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop, Debug)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | // ANCHOR: trait_impl
 8 | #[generate_trait]
 9 | impl RectangleImpl of RectangleTrait {
10 |     fn area(self: @Rectangle) -> u64 {
11 |         (*self.width) * (*self.height)
12 |     }
13 | 
14 |     fn new(width: u64, height: u64) -> Rectangle {
15 |         Rectangle { width, height }
16 |     }
17 | 
18 |     fn square(size: u64) -> Rectangle {
19 |         Rectangle { width: size, height: size }
20 |     }
21 | 
22 |     fn avg(lhs: @Rectangle, rhs: @Rectangle) -> Rectangle {
23 |         Rectangle {
24 |             width: ((*lhs.width) + (*rhs.width)) / 2, height: ((*lhs.height) + (*rhs.height)) / 2,
25 |         }
26 |     }
27 | }
28 | // ANCHOR_END: trait_impl
29 | 
30 | // ANCHOR: main
31 | fn main() {
32 |     let rect1 = RectangleTrait::new(30, 50);
33 |     let rect2 = RectangleTrait::square(10);
34 | 
35 |     println!(
36 |         "The average Rectangle of {:?} and {:?} is {:?}",
37 |         @rect1,
38 |         @rect2,
39 |         RectangleTrait::avg(@rect1, @rect2),
40 |     );
41 | }
42 | // ANCHOR_END: main
43 | 
44 | 
45 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_06_multiple_traits/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_06_multiple_traits/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_14"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_06_multiple_traits/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | // ANCHOR: here
 8 | #[generate_trait]
 9 | impl RectangleCalcImpl of RectangleCalc {
10 |     fn area(self: @Rectangle) -> u64 {
11 |         (*self.width) * (*self.height)
12 |     }
13 | }
14 | 
15 | #[generate_trait]
16 | impl RectangleCmpImpl of RectangleCmp {
17 |     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {
18 |         *self.width > *other.width && *self.height > *other.height
19 |     }
20 | }
21 | // ANCHOR_END: here
22 | 
23 | 
24 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_07_into/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_into"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_07_into/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // Compiler automatically imports the core library, so you can omit this import
 2 | use core::traits::Into;
 3 | 
 4 | #[derive(Drop, PartialEq)]
 5 | struct Rectangle {
 6 |     width: u64,
 7 |     height: u64,
 8 | }
 9 | 
10 | #[derive(Drop)]
11 | struct Square {
12 |     side_length: u64,
13 | }
14 | 
15 | impl SquareIntoRectangle of Into<Square, Rectangle> {
16 |     fn into(self: Square) -> Rectangle {
17 |         Rectangle { width: self.side_length, height: self.side_length }
18 |     }
19 | }
20 | 
21 | fn main() {
22 |     let square = Square { side_length: 5 };
23 |     // Compiler will complain if you remove the type annotation
24 |     let result: Rectangle = square.into();
25 |     let expected = Rectangle { width: 5, height: 5 };
26 |     assert!(
27 |         result == expected,
28 |         "A square is always convertible to a rectangle with the same width and height!",
29 |     );
30 | }
31 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_08_tryinto/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_tryinto"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch05-using-structs-to-structure-related-data/no_listing_08_tryinto/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // Compiler automatically imports the core library, so you can omit this import
 2 | use core::traits::TryInto;
 3 | 
 4 | #[derive(Drop)]
 5 | struct Rectangle {
 6 |     width: u64,
 7 |     height: u64,
 8 | }
 9 | 
10 | #[derive(Drop, PartialEq)]
11 | struct Square {
12 |     side_length: u64,
13 | }
14 | 
15 | impl RectangleIntoSquare of TryInto<Rectangle, Square> {
16 |     fn try_into(self: Rectangle) -> Option<Square> {
17 |         if self.height == self.width {
18 |             Option::Some(Square { side_length: self.height })
19 |         } else {
20 |             Option::None
21 |         }
22 |     }
23 | }
24 | 
25 | fn main() {
26 |     let rectangle = Rectangle { width: 8, height: 8 };
27 |     let result: Square = rectangle.try_into().unwrap();
28 |     let expected = Square { side_length: 8 };
29 |     assert!(
30 |         result == expected,
31 |         "Rectangle with equal width and height should be convertible to a square.",
32 |     );
33 | 
34 |     let rectangle = Rectangle { width: 5, height: 8 };
35 |     let result: Option<Square> = rectangle.try_into();
36 |     assert!(
37 |         result.is_none(),
38 |         "Rectangle with different width and height should not be convertible to a square.",
39 |     );
40 | }
41 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_01_enum_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_01_enum_example/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_01_enum_example"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_01_enum_example/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_enum_example"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_01_enum_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: enum_example
 2 | #[derive(Drop)]
 3 | enum Direction {
 4 |     North,
 5 |     East,
 6 |     South,
 7 |     West,
 8 | }
 9 | // ANCHOR_END: enum_example
10 | 
11 | fn main() {
12 |     // ANCHOR: here
13 |     let direction = Direction::North;
14 |     // ANCHOR_END: here
15 | }
16 | 
17 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_02_enum_with_values_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_02_enum_with_values_example/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_01_enum_with_values_example"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_02_enum_with_values_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: enum_example
 2 | #[derive(Drop)]
 3 | enum Direction {
 4 |     North: u128,
 5 |     East: u128,
 6 |     South: u128,
 7 |     West: u128,
 8 | }
 9 | // ANCHOR_END: enum_example
10 | 
11 | fn main() {
12 |     // ANCHOR: here
13 |     let direction = Direction::North(10);
14 |     // ANCHOR_END: here
15 | }
16 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_03_enum_message/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_03_enum_message/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_enum_message"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_03_enum_message/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | 
 3 | // ANCHOR: message
 4 | #[derive(Drop)]
 5 | enum Message {
 6 |     Quit,
 7 |     Echo: felt252,
 8 |     Move: (u128, u128),
 9 | }
10 | // ANCHOR_END: message
11 | 
12 | // ANCHOR: trait_impl
13 | trait Processing {
14 |     fn process(self: Message);
15 | }
16 | 
17 | impl ProcessingImpl of Processing {
18 |     fn process(self: Message) {
19 |         match self {
20 |             Message::Quit => { println!("quitting") },
21 |             Message::Echo(value) => { println!("echoing {}", value) },
22 |             Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
23 |         }
24 |     }
25 | }
26 | // ANCHOR_END: trait_impl
27 | fn main() {
28 |     // ANCHOR: main
29 |     let msg: Message = Message::Quit;
30 |     msg.process(); // prints "quitting"
31 |     // ANCHOR_END: main
32 | }
33 | //ANCHOR_END: all
34 | 
35 | 
36 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_04_enum_option/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_04_enum_option/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_enum_option"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_04_enum_option/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn find_value_recursive(mut arr: Span<felt252>, value: felt252, index: usize) -> Option<usize> {
 2 |     match arr.pop_front() {
 3 |         Option::Some(index_value) => { if (*index_value == value) {
 4 |             return Option::Some(index);
 5 |         } },
 6 |         Option::None => { return Option::None; },
 7 |     };
 8 | 
 9 |     find_value_recursive(arr, value, index + 1)
10 | }
11 | 
12 | fn find_value_iterative(mut arr: Span<felt252>, value: felt252) -> Option<usize> {
13 |     let mut result = Option::None;
14 |     let mut index = 0;
15 | 
16 |     while let Option::Some(array_value) = arr.pop_front() {
17 |         if (*array_value == value) {
18 |             result = Option::Some(index);
19 |             break;
20 |         };
21 | 
22 |         index += 1;
23 |     };
24 | 
25 |     result
26 | }
27 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_05_match_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_05_match_example/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_match_example"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_05_match_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | enum Coin {
 3 |     Penny,
 4 |     Nickel,
 5 |     Dime,
 6 |     Quarter,
 7 | }
 8 | 
 9 | // ANCHOR: function
10 | fn value_in_cents(coin: Coin) -> felt252 {
11 |     match coin {
12 |         Coin::Penny => 1,
13 |         Coin::Nickel => 5,
14 |         Coin::Dime => 10,
15 |         Coin::Quarter => 25,
16 |     }
17 | }
18 | // ANCHOR_END: function
19 | // ANCHOR_END: all
20 | 
21 | 
22 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_06_match_arms_block/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_06_match_arms_block/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_match_arms_block"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_06_match_arms_block/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | enum Coin {
 2 |     Penny,
 3 |     Nickel,
 4 |     Dime,
 5 |     Quarter,
 6 | }
 7 | 
 8 | // ANCHOR: here
 9 | fn value_in_cents(coin: Coin) -> felt252 {
10 |     match coin {
11 |         Coin::Penny => {
12 |             println!("Lucky penny!");
13 |             1
14 |         },
15 |         Coin::Nickel => 5,
16 |         Coin::Dime => 10,
17 |         Coin::Quarter => 25,
18 |     }
19 | }
20 | // ANCHOR_END: here
21 | 
22 | 
23 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_06_match_pattern_bind"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: enum_def
 2 | 
 3 | #[derive(Drop, Debug)] // Debug so we can inspect the state in a minute
 4 | enum UsState {
 5 |     Alabama,
 6 |     Alaska,
 7 | }
 8 | 
 9 | #[derive(Drop)]
10 | enum Coin {
11 |     Penny,
12 |     Nickel,
13 |     Dime,
14 |     Quarter: UsState,
15 | }
16 | // ANCHOR_END: enum_def
17 | 
18 | // ANCHOR: function
19 | fn value_in_cents(coin: Coin) -> felt252 {
20 |     match coin {
21 |         Coin::Penny => 1,
22 |         Coin::Nickel => 5,
23 |         Coin::Dime => 10,
24 |         Coin::Quarter(state) => {
25 |             println!("State quarter from {:?}!", state);
26 |             25
27 |         },
28 |     }
29 | }
30 | // ANCHOR_END: function
31 | 
32 | 
33 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_match_option"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR:all
 2 | fn plus_one(x: Option<u8>) -> Option<u8> {
 3 |     match x {
 4 |         //ANCHOR: option_some
 5 |         Option::Some(val) => Option::Some(val + 1),
 6 |         //ANCHOR_END: option_some
 7 |         // ANCHOR: option_none
 8 |         Option::None => Option::None,
 9 |         //ANCHOR_END: option_none
10 |     }
11 | }
12 | 
13 | fn main() {
14 |     let five: Option<u8> = Option::Some(5);
15 |     let six: Option<u8> = plus_one(five);
16 |     let none = plus_one(Option::None);
17 | }
18 | //ANCHOR_END:all
19 | 
20 | 
21 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_missing_match_arm"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_08_missing_match_arm v0.1.0 (listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/Scarb.toml)
 3 | error: Missing match arm: `None` not covered.
 4 |  --> listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:5:5
 5 |     match x {
 6 |     ^*******^
 7 | 
 8 | error: could not compile `no_listing_08_missing_match_arm` due to previous error
 9 | error: `scarb metadata` exited with error
10 | 
11 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | //ANCHOR: here
 4 | fn plus_one(x: Option<u8>) -> Option<u8> {
 5 |     match x {
 6 |         Option::Some(val) => Option::Some(val + 1),
 7 |     }
 8 | }
 9 | //ANCHOR_END: here
10 | 
11 | fn main() {
12 |     let five: Option<u8> = Option::Some(5);
13 |     let six: Option<u8> = plus_one(five);
14 |     println!("six: {}", six.unwrap());
15 |     let none = plus_one(Option::None);
16 |     println!("none: {}", none.unwrap());
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_10_match_catch_all/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_10_match_catch_all/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_09_match_catch_all"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_10_match_catch_all/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | enum Coin {
 2 |     Penny,
 3 |     Nickel,
 4 |     Dime,
 5 |     Quarter,
 6 | }
 7 | 
 8 | // ANCHOR: here
 9 | fn vending_machine_accept(coin: Coin) -> bool {
10 |     match coin {
11 |         Coin::Dime => true,
12 |         _ => false,
13 |     }
14 | }
15 | // ANCHOR_END: here
16 | 
17 | #[cfg(test)]
18 | mod test {
19 |     use super::*;
20 | 
21 |     #[test]
22 |     #[available_gas(2000000)]
23 |     fn test_vending_machine_accept() {
24 |         assert_eq!(vending_machine_accept(Coin::Penny), false);
25 |         assert_eq!(vending_machine_accept(Coin::Nickel), false);
26 |         assert_eq!(vending_machine_accept(Coin::Dime), true);
27 |         assert_eq!(vending_machine_accept(Coin::Quarter), false);
28 |     }
29 | }
30 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_11_match_or/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_11_match_or/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_10_match_or"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_11_match_or/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | enum Coin {
 2 |     Penny,
 3 |     Nickel,
 4 |     Dime,
 5 |     Quarter,
 6 | }
 7 | 
 8 | // ANCHOR: here
 9 | fn vending_machine_accept(coin: Coin) -> bool {
10 |     match coin {
11 |         Coin::Dime | Coin::Quarter => true,
12 |         _ => false,
13 |     }
14 | }
15 | // ANCHOR_END: here
16 | 
17 | #[cfg(test)]
18 | mod test {
19 |     use super::*;
20 | 
21 |     #[test]
22 |     #[available_gas(2000000)]
23 |     fn test_vending_machine_accept() {
24 |         assert_eq!(vending_machine_accept(Coin::Penny), false);
25 |         assert_eq!(vending_machine_accept(Coin::Nickel), false);
26 |         assert_eq!(vending_machine_accept(Coin::Dime), true);
27 |         assert_eq!(vending_machine_accept(Coin::Quarter), true);
28 |     }
29 | }
30 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_12_match_tuple/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_12_match_tuple/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_11_match_tuple"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_12_match_tuple/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: enum_def
 2 | #[derive(Drop)]
 3 | enum DayType {
 4 |     Week,
 5 |     Weekend,
 6 |     Holiday,
 7 | }
 8 | // ANCHOR_END: enum_def
 9 | 
10 | #[derive(Drop)]
11 | enum Coin {
12 |     Penny,
13 |     Nickel,
14 |     Dime,
15 |     Quarter,
16 | }
17 | 
18 | // ANCHOR: here
19 | fn vending_machine_accept(c: (DayType, Coin)) -> bool {
20 |     match c {
21 |         (DayType::Week, _) => true,
22 |         (_, Coin::Dime) | (_, Coin::Quarter) => true,
23 |         (_, _) => false,
24 |     }
25 | }
26 | // ANCHOR_END: here
27 | 
28 | // ANCHOR: week
29 | fn vending_week_machine(c: (DayType, Coin)) -> bool {
30 |     match c {
31 |         (DayType::Week, Coin::Quarter) => true,
32 |         _ => false,
33 |     }
34 | }
35 | // ANCHOR_END: week
36 | 
37 | #[cfg(test)]
38 | mod test {
39 |     use super::*;
40 | 
41 |     #[test]
42 |     #[available_gas(2000000)]
43 |     fn test_vending_machine_accept_week() {
44 |         assert_eq!(vending_machine_accept((DayType::Week, Coin::Penny)), true);
45 |         assert_eq!(vending_machine_accept((DayType::Week, Coin::Nickel)), true);
46 |         assert_eq!(vending_machine_accept((DayType::Week, Coin::Dime)), true);
47 |         assert_eq!(vending_machine_accept((DayType::Week, Coin::Quarter)), true);
48 |     }
49 | 
50 |     #[test]
51 |     #[available_gas(2000000)]
52 |     fn test_vending_machine_accept_weekend() {
53 |         assert_eq!(vending_machine_accept((DayType::Weekend, Coin::Penny)), false);
54 |         assert_eq!(vending_machine_accept((DayType::Weekend, Coin::Nickel)), false);
55 |         assert_eq!(vending_machine_accept((DayType::Weekend, Coin::Dime)), true);
56 |         assert_eq!(vending_machine_accept((DayType::Weekend, Coin::Quarter)), true);
57 |     }
58 | 
59 |     #[test]
60 |     #[available_gas(2000000)]
61 |     fn test_vending_machine_accept_holiday() {
62 |         assert_eq!(vending_machine_accept((DayType::Holiday, Coin::Penny)), false);
63 |         assert_eq!(vending_machine_accept((DayType::Holiday, Coin::Nickel)), false);
64 |         assert_eq!(vending_machine_accept((DayType::Holiday, Coin::Dime)), true);
65 |         assert_eq!(vending_machine_accept((DayType::Holiday, Coin::Quarter)), true);
66 |     }
67 | }
68 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_13_match_integers/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_13_match_integers/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_12_match_integers"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_13_match_integers/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: here
 2 | fn roll(value: u8) {
 3 |     match value {
 4 |         0 | 1 | 2 => println!("you won!"),
 5 |         3 => println!("you can roll again!"),
 6 |         _ => println!("you lost..."),
 7 |     }
 8 | }
 9 | // ANCHOR_END: here
10 | 
11 | 
12 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_14_if_let_match_one/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     // ANCHOR: match
 3 |     let config_max = Option::Some(5);
 4 |     match config_max {
 5 |         Option::Some(max) => println!("The maximum is configured to be {}", max),
 6 |         _ => (),
 7 |     }
 8 |     // ANCHOR_END: match
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_15_if_let/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     // ANCHOR: here
 3 |     let number = Option::Some(5);
 4 |     if let Option::Some(max) = number {
 5 |         println!("The maximum is configured to be {}", max);
 6 |     }
 7 |     // ANCHOR_END: here
 8 | }
 9 | 
10 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_16_if_let_coiner_match/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | enum Coin {
 3 |     Penny,
 4 |     Nickel,
 5 |     Dime,
 6 |     Quarter,
 7 | }
 8 | 
 9 | fn main() {
10 |     // ANCHOR: here
11 |     let coin = Coin::Quarter;
12 |     let mut count = 0;
13 |     match coin {
14 |         Coin::Quarter => println!("You got a quarter!"),
15 |         _ => count += 1,
16 |     }
17 |     // ANCHOR_END: here
18 | }
19 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_17_if_let_coiner/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | enum Coin {
 3 |     Penny,
 4 |     Nickel,
 5 |     Dime,
 6 |     Quarter,
 7 | }
 8 | 
 9 | fn main() {
10 |     // ANCHOR: here
11 |     let coin = Coin::Quarter;
12 |     let mut count = 0;
13 |     if let Coin::Quarter = coin {
14 |         println!("You got a quarter!");
15 |     } else {
16 |         count += 1;
17 |     }
18 |     // ANCHOR_END: here
19 |     println!("{}", count);
20 | }
21 | 
22 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_18_while_let/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_18_while_let/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_18_while_let"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch06-enums-and-pattern-matching/no_listing_18_while_let/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let mut arr = array![1, 2, 3, 4, 5, 6, 7, 8, 9];
3 |     let mut sum = 0;
4 |     while let Option::Some(value) = arr.pop_front() {
5 |         sum += value;
6 |     };
7 |     println!("{}", sum);
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_01_basic_nested_modules/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_01_basic_nested_modules/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_01"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_01_basic_nested_modules/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: front_of_house
 2 | mod front_of_house {
 3 |     mod hosting {
 4 |         fn add_to_waitlist() {}
 5 | 
 6 |         fn seat_at_table() {}
 7 |     }
 8 | 
 9 |     mod serving {
10 |         fn take_order() {}
11 | 
12 |         fn serve_order() {}
13 | 
14 |         fn take_payment() {}
15 |     }
16 | }
17 | // ANCHOR_END: front_of_house
18 | 
19 | 
20 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_02"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling listing_07_02 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/Scarb.toml)
 3 | error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 4 |  --> listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:28
 5 |     crate::front_of_house::hosting::add_to_waitlist();
 6 |                            ^*****^
 7 | 
 8 | error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 9 |  --> listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:37
10 |     crate::front_of_house::hosting::add_to_waitlist();
11 |                                     ^*************^
12 | 
13 | error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
14 |  --> listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:21
15 |     front_of_house::hosting::add_to_waitlist();
16 |                     ^*****^
17 | 
18 | error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
19 |  --> listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:30
20 |     front_of_house::hosting::add_to_waitlist();
21 |                              ^*************^
22 | 
23 | error: could not compile `listing_07_02` due to previous error
24 | error: `scarb metadata` exited with error
25 | 
26 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR: paths
 3 | mod front_of_house {
 4 |     mod hosting {
 5 |         fn add_to_waitlist() {}
 6 | 
 7 |         fn seat_at_table() {}
 8 |     }
 9 | 
10 |     mod serving {
11 |         fn take_order() {}
12 | 
13 |         fn serve_order() {}
14 | 
15 |         fn take_payment() {}
16 |     }
17 | }
18 | 
19 | 
20 | pub fn eat_at_restaurant() {
21 |     // Absolute path
22 |     crate::front_of_house::hosting::add_to_waitlist();
23 | 
24 |     // Relative path
25 |     front_of_house::hosting::add_to_waitlist();
26 | }
27 | // ANCHOR_END: paths
28 | 
29 | 
30 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_03_pub_keyword/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_03_pub_keyword/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_03_pub"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_03_pub_keyword/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | mod front_of_house {
 3 |     pub mod hosting {
 4 |         fn add_to_waitlist() {}
 5 |     }
 6 | }
 7 | 
 8 | pub fn eat_at_restaurant() {
 9 |     // Absolute path
10 |     crate::front_of_house::hosting::add_to_waitlist();
11 | 
12 |     // Relative path
13 |     front_of_house::hosting::add_to_waitlist();
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_04_pub_compiles/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_04_pub_compiles/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "restaurant"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_04_pub_compiles/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | mod front_of_house {
 2 |     pub mod hosting {
 3 |         pub fn add_to_waitlist() {}
 4 |     }
 5 | }
 6 | 
 7 | pub fn eat_at_restaurant() {
 8 |     // Absolute path
 9 |     crate::front_of_house::hosting::add_to_waitlist(); //  Compiles
10 | 
11 |     // Relative path
12 |     front_of_house::hosting::add_to_waitlist(); //  Compiles
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_05_super/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_05_super/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_03"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_05_super/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn deliver_order() {}
 2 | 
 3 | mod back_of_house {
 4 |     fn fix_incorrect_order() {
 5 |         cook_order();
 6 |         super::deliver_order();
 7 |     }
 8 | 
 9 |     fn cook_order() {}
10 | }
11 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_06_use/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_06_use/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_04"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_06_use/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR: use
 3 | // section "Defining Modules to Control Scope"
 4 | 
 5 | mod front_of_house {
 6 |     pub mod hosting {
 7 |         pub fn add_to_waitlist() {}
 8 |     }
 9 | }
10 | 
11 | use crate::front_of_house::hosting;
12 | 
13 | pub fn eat_at_restaurant() {
14 |     hosting::add_to_waitlist(); //  Shorter path
15 | }
16 | // ANCHOR_END: use
17 | 
18 | 
19 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_05"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb build 
 2 |    Compiling listing_07_05 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/Scarb.toml)
 3 | warn: Unused import: `listing_07_05::hosting`
 4 |  --> listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:10:28
 5 | use crate::front_of_house::hosting;
 6 |                            ^*****^
 7 | 
 8 | error: Identifier not found.
 9 |  --> listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:14:9
10 |         hosting::add_to_waitlist();
11 |         ^*****^
12 | 
13 | error: could not compile `listing_07_05` due to previous error
14 | 
15 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | // ANCHOR: wrong-path
 4 | mod front_of_house {
 5 |     pub mod hosting {
 6 |         pub fn add_to_waitlist() {}
 7 |     }
 8 | }
 9 | 
10 | use crate::front_of_house::hosting;
11 | 
12 | mod customer {
13 |     pub fn eat_at_restaurant() {
14 |         hosting::add_to_waitlist();
15 |     }
16 | }
17 | // ANCHOR_END: wrong-path
18 | 
19 | 
20 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_08_unidiomatic_use/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_08_unidiomatic_use/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_06"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_08_unidiomatic_use/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | // ANCHOR: unidiomatic-path
 4 | mod front_of_house {
 5 |     pub mod hosting {
 6 |         pub fn add_to_waitlist() {}
 7 |     }
 8 | }
 9 | 
10 | use crate::front_of_house::hosting::add_to_waitlist;
11 | 
12 | pub fn eat_at_restaurant() {
13 |     add_to_waitlist();
14 | }
15 | // ANCHOR_END: unidiomatic-path
16 | 
17 | 
18 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_09_idiomatic_import/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_09_idiomatic_import/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_07"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_09_idiomatic_import/src/lib.cairo:
--------------------------------------------------------------------------------
1 | use core::num::traits::BitSize;
2 | 
3 | fn main() {
4 |     let u8_size: usize = BitSize::<u8>::bits();
5 |     println!("A u8 variable has {} bits", u8_size)
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_10_as_keyword/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_10_as_keyword/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_08"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_10_as_keyword/src/lib.cairo:
--------------------------------------------------------------------------------
1 | use core::array::ArrayTrait as Arr;
2 | 
3 | fn main() {
4 |     let mut arr = Arr::new(); // ArrayTrait was renamed to Arr
5 |     arr.append(1);
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_11_multiple_items/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_11_multiple_items/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_09"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_11_multiple_items/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.
 2 | mod shapes {
 3 |     #[derive(Drop)]
 4 |     pub struct Square {
 5 |         pub side: u32,
 6 |     }
 7 | 
 8 |     #[derive(Drop)]
 9 |     pub struct Circle {
10 |         pub radius: u32,
11 |     }
12 | 
13 |     #[derive(Drop)]
14 |     pub struct Triangle {
15 |         pub base: u32,
16 |         pub height: u32,
17 |     }
18 | }
19 | 
20 | // We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like
21 | // this:
22 | use shapes::{Square, Circle, Triangle};
23 | 
24 | // Now we can directly use `Square`, `Circle`, and `Triangle` in our code.
25 | fn main() {
26 |     let sq = Square { side: 5 };
27 |     let cr = Circle { radius: 3 };
28 |     let tr = Triangle { base: 5, height: 2 };
29 |     // ...
30 | }
31 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_12_pub_use/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_12_pub_use/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_10"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_12_pub_use/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR: reexporting
 3 | mod front_of_house {
 4 |     pub mod hosting {
 5 |         pub fn add_to_waitlist() {}
 6 |     }
 7 | }
 8 | 
 9 | pub use crate::front_of_house::hosting;
10 | 
11 | fn eat_at_restaurant() {
12 |     hosting::add_to_waitlist();
13 | }
14 | // ANCHOR_END: reexporting
15 | 
16 | 
17 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_13_front_extraction/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_13_front_extraction/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_11"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_13_front_extraction/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR: front-extraction
 3 | mod front_of_house;
 4 | 
 5 | use crate::front_of_house::hosting;
 6 | 
 7 | fn eat_at_restaurant() {
 8 |     hosting::add_to_waitlist();
 9 | }
10 | // ANCHOR_END: front-extraction
11 | 
12 | 
13 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_14_front_definition/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_14_front_definition/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_12"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_14_front_definition/src/lib.cairo:
--------------------------------------------------------------------------------
1 | pub mod hosting {
2 |     pub fn add_to_waitlist() {}
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_01_lib/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_01_lib/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_lib"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_01_lib/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR: crate
 3 | pub mod garden;
 4 | use crate::garden::vegetables::Asparagus;
 5 | 
 6 | fn main() {
 7 |     let plant = Asparagus {};
 8 |     println!("I'm growing {:?}!", plant);
 9 | }
10 | // ANCHOR_END: crate
11 | 
12 | 
13 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_02_garden/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_02_garden/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_02_garden"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_02_garden/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_garden"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_02_garden/src/lib.cairo:
--------------------------------------------------------------------------------
1 | #[derive(Drop, Debug)]
2 | pub struct Asparagus {}
3 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_01/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_01/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_08_01_extracting_function_01"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_01/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut number_list: Array<u8> = array![34, 50, 25, 100, 65];
 3 | 
 4 |     let mut largest = number_list.pop_front().unwrap();
 5 | 
 6 |     while let Option::Some(number) = number_list.pop_front() {
 7 |         if number > largest {
 8 |             largest = number;
 9 |         }
10 |     };
11 | 
12 |     println!("The largest number is {}", largest);
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_02/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_02/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_08_01_extracting_function_02"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | 
10 | [dev-dependencies]
11 | assert_macros = "2.9.1"
12 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_02/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let mut number_list: Array<u8> = array![34, 50, 25, 100, 65];
 3 | 
 4 |     let mut largest = number_list.pop_front().unwrap();
 5 | 
 6 |     while let Option::Some(number) = number_list.pop_front() {
 7 |         if number > largest {
 8 |             largest = number;
 9 |         }
10 |     };
11 | 
12 |     println!("The largest number is {}", largest);
13 | 
14 |     let mut number_list: Array<u8> = array![102, 34, 255, 89, 54, 2, 43, 8];
15 | 
16 |     let mut largest = number_list.pop_front().unwrap();
17 | 
18 |     while let Option::Some(number) = number_list.pop_front() {
19 |         if number > largest {
20 |             largest = number;
21 |         }
22 |     };
23 | 
24 |     println!("The largest number is {}", largest);
25 | }
26 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_03/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_03/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_08_01_extracting_function_03"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | 
10 | [dev-dependencies]
11 | assert_macros = "2.9.1"
12 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_03/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn largest(ref number_list: Array<u8>) -> u8 {
 2 |     let mut largest = number_list.pop_front().unwrap();
 3 | 
 4 |     while let Option::Some(number) = number_list.pop_front() {
 5 |         if number > largest {
 6 |             largest = number;
 7 |         }
 8 |     };
 9 | 
10 |     largest
11 | }
12 | 
13 | fn main() {
14 |     let mut number_list = array![34, 50, 25, 100, 65];
15 | 
16 |     let result = largest(ref number_list);
17 |     println!("The largest number is {}", result);
18 | 
19 |     let mut number_list = array![102, 34, 255, 89, 54, 2, 43, 8];
20 | 
21 |     let result = largest(ref number_list);
22 |     println!("The largest number is {}", result);
23 | }
24 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_default_impl/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_default_impl/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_default_impl"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_default_impl/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | mod aggregator {
 2 |     //ANCHOR: trait
 3 |     pub trait Summary<T> {
 4 |         fn summarize(self: @T) -> ByteArray {
 5 |             "(Read more...)"
 6 |         }
 7 |     }
 8 |     //ANCHOR_END: trait
 9 | 
10 |     //ANCHOR: impl
11 |     #[derive(Drop)]
12 |     pub struct NewsArticle {
13 |         pub headline: ByteArray,
14 |         pub location: ByteArray,
15 |         pub author: ByteArray,
16 |         pub content: ByteArray,
17 |     }
18 | 
19 |     impl NewsArticleSummary of Summary<NewsArticle> {}
20 | 
21 |     #[derive(Drop)]
22 |     pub struct Tweet {
23 |         pub username: ByteArray,
24 |         pub content: ByteArray,
25 |         pub reply: bool,
26 |         pub retweet: bool,
27 |     }
28 | 
29 |     impl TweetSummary of Summary<Tweet> {
30 |         fn summarize(self: @Tweet) -> ByteArray {
31 |             format!("{}: {}", self.username, self.content)
32 |         }
33 |     }
34 |     //ANCHOR_END: impl
35 | }
36 | 
37 | //ANCHOR: main
38 | use aggregator::{Summary, NewsArticle};
39 | 
40 | fn main() {
41 |     let news = NewsArticle {
42 |         headline: "Cairo has become the most popular language for developers",
43 |         location: "Worldwide",
44 |         author: "Cairo Digger",
45 |         content: "Cairo is a new programming language for zero-knowledge proofs",
46 |     };
47 | 
48 |     println!("New article available! {}", news.summarize());
49 | }
50 | //ANCHOR_END: main
51 | 
52 | 
53 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_impl_aliases/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_impl_aliases/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_impl_aliases"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/listing_impl_aliases/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | trait Two<T> {
 2 |     fn two() -> T;
 3 | }
 4 | 
 5 | mod one_based {
 6 |     pub impl TwoImpl<
 7 |         T, +Copy<T>, +Drop<T>, +Add<T>, impl One: core::num::traits::One<T>,
 8 |     > of super::Two<T> {
 9 |         fn two() -> T {
10 |             One::one() + One::one()
11 |         }
12 |     }
13 | }
14 | 
15 | pub impl U8Two = one_based::TwoImpl<u8>;
16 | pub impl U128Two = one_based::TwoImpl<u128>;
17 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_01_missing_tdrop/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_01_missing_tdrop/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_missing_tdrop"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_01_missing_tdrop/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR: generic
 3 | // Specify generic type T between the angulars
 4 | fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {
 5 |     if l1.len() > l2.len() {
 6 |         l1
 7 |     } else {
 8 |         l2
 9 |     }
10 | }
11 | 
12 | fn main() {
13 |     let mut l1 = array![1, 2];
14 |     let mut l2 = array![3, 4, 5];
15 | 
16 |     // There is no need to specify the concrete type of T because
17 |     // it is inferred by the compiler
18 |     let l3 = largest_list(l1, l2);
19 | }
20 | // ANCHOR_END: generic
21 | 
22 | 
23 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_02_with_tdrop/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_02_with_tdrop/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_02_with_tdrop"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_02_with_tdrop/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_with_tdrop"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_02_with_tdrop/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {
2 |     if l1.len() > l2.len() {
3 |         l1
4 |     } else {
5 |         l2
6 |     }
7 | }
8 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_03_missing_tcopy/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_03_missing_tcopy/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_missing_tcopy"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_03_missing_tcopy/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | //ANCHOR: missing-tcopy
 3 | // Given a list of T get the smallest one
 4 | // The PartialOrd trait implements comparison operations for T
 5 | fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {
 6 |     // This represents the smallest element through the iteration
 7 |     // Notice that we use the desnap (*) operator
 8 |     let mut smallest = *list[0];
 9 | 
10 |     // The index we will use to move through the list
11 |     let mut index = 1;
12 | 
13 |     // Iterate through the whole list storing the smallest
14 |     while index < list.len() {
15 |         if *list[index] < smallest {
16 |             smallest = *list[index];
17 |         }
18 |         index = index + 1;
19 |     };
20 | 
21 |     smallest
22 | }
23 | 
24 | fn main() {
25 |     let list: Array<u8> = array![5, 3, 10];
26 | 
27 |     // We need to specify that we are passing a snapshot of `list` as an argument
28 |     let s = smallest_element(@list);
29 |     assert!(s == 3);
30 | }
31 | //ANCHOR_END: missing-tcopy
32 | 
33 | 
34 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_04_with_tcopy/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_04_with_tcopy/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_04_with_tcopy"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_04_with_tcopy/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_with_tcopy"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_04_with_tcopy/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl TDrop: Drop<T>>(
 2 |     list: @Array<T>,
 3 | ) -> T {
 4 |     let mut smallest = *list[0];
 5 |     let mut index = 1;
 6 | 
 7 |     while index < list.len() {
 8 |         if *list[index] < smallest {
 9 |             smallest = *list[index];
10 |         }
11 |         index = index + 1;
12 |     };
13 | 
14 |     smallest
15 | }
16 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_05_with_anonymous_impl/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_05_with_anonymous_impl/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_05_with_anonymous_impl"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_05_with_anonymous_impl/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_with_anonymous_impl"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_05_with_anonymous_impl/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn smallest_element<T, +PartialOrd<T>, +Copy<T>, +Drop<T>>(list: @Array<T>) -> T {
 2 |     let mut smallest = *list[0];
 3 |     let mut index = 1;
 4 |     loop {
 5 |         if index >= list.len() {
 6 |             break smallest;
 7 |         }
 8 |         if *list[index] < smallest {
 9 |             smallest = *list[index];
10 |         }
11 |         index = index + 1;
12 |     }
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_06_derive_generics/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_06_derive_generics/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_06_derive_generics"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_06_derive_generics/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_06_derive_generics"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_06_derive_generics/src/lib.cairo:
--------------------------------------------------------------------------------
1 | #[derive(Drop)]
2 | struct Wallet<T> {
3 |     balance: T,
4 | }
5 | 
6 | fn main() {
7 |     let w = Wallet { balance: 3 };
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_07_drop_explicit/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_07_drop_explicit/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_07_drop_explicit"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_07_drop_explicit/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_drop_explicit"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_07_drop_explicit/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | struct Wallet<T> {
 2 |     balance: T,
 3 | }
 4 | 
 5 | impl WalletDrop<T, +Drop<T>> of Drop<Wallet<T>>;
 6 | 
 7 | fn main() {
 8 |     let w = Wallet { balance: 3 };
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_08_two_generics/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_08_two_generics/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_08_two_generics"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_08_two_generics/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_two_generics"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_08_two_generics/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct Wallet<T, U> {
 3 |     balance: T,
 4 |     address: U,
 5 | }
 6 | 
 7 | fn main() {
 8 |     let w = Wallet { balance: 3, address: 14 };
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_09_option/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_09_option/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_09_option"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_09_option/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_09_option"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_09_option/src/lib.cairo:
--------------------------------------------------------------------------------
1 | enum Option<T> {
2 |     Some: T,
3 |     None,
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_10_result/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_10_result/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_10_result"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_10_result/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_10_result"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_10_result/src/lib.cairo:
--------------------------------------------------------------------------------
1 | enum Result<T, E> {
2 |     Ok: T,
3 |     Err: E,
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_11_generic_methods/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_11_generic_methods/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_11_generic_methods"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_11_generic_methods/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_11_generic_methods"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_11_generic_methods/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Wallet<T> {
 3 |     balance: T,
 4 | }
 5 | 
 6 | trait WalletTrait<T> {
 7 |     fn balance(self: @Wallet<T>) -> T;
 8 | }
 9 | 
10 | impl WalletImpl<T, +Copy<T>> of WalletTrait<T> {
11 |     fn balance(self: @Wallet<T>) -> T {
12 |         return *self.balance;
13 |     }
14 | }
15 | 
16 | fn main() {
17 |     let w = Wallet { balance: 50 };
18 |     assert!(w.balance() == 50);
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_12_constrained_generics/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_12_constrained_generics/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_12_constrained_generics"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_12_constrained_generics/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_12_constrained_generics"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_12_constrained_generics/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Wallet<T> {
 3 |     balance: T,
 4 | }
 5 | 
 6 | /// Generic trait for wallets
 7 | trait WalletTrait<T> {
 8 |     fn balance(self: @Wallet<T>) -> T;
 9 | }
10 | 
11 | impl WalletImpl<T, +Copy<T>> of WalletTrait<T> {
12 |     fn balance(self: @Wallet<T>) -> T {
13 |         return *self.balance;
14 |     }
15 | }
16 | 
17 | /// Trait for wallets of type u128
18 | trait WalletReceiveTrait {
19 |     fn receive(ref self: Wallet<u128>, value: u128);
20 | }
21 | 
22 | impl WalletReceiveImpl of WalletReceiveTrait {
23 |     fn receive(ref self: Wallet<u128>, value: u128) {
24 |         self.balance += value;
25 |     }
26 | }
27 | 
28 | fn main() {
29 |     let mut w = Wallet { balance: 50 };
30 |     assert!(w.balance() == 50);
31 | 
32 |     w.receive(100);
33 |     assert!(w.balance() == 150);
34 | }
35 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_13_not_compiling/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_13_not_compiling/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_13_not_compiling"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_13_not_compiling/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | //ANCHOR: struct
 3 | struct Wallet<T, U> {
 4 |     balance: T,
 5 |     address: U,
 6 | }
 7 | //ANCHOR_END: struct
 8 | 
 9 | //ANCHOR:trait_impl
10 | // This does not compile!
11 | trait WalletMixTrait<T1, U1> {
12 |     fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2>;
13 | }
14 | 
15 | impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {
16 |     fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> {
17 |         Wallet { balance: self.balance, address: other.address }
18 |     }
19 | }
20 | //ANCHOR_END: trait_impl
21 | 
22 | 
23 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_compiling/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_compiling/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_14_compiling"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_compiling/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_14_compiling"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_compiling/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop, Copy)]
 2 | struct Wallet<T, U> {
 3 |     balance: T,
 4 |     address: U,
 5 | }
 6 | 
 7 | // ANCHOR: trait_impl
 8 | trait WalletMixTrait<T1, U1> {
 9 |     fn mixup<T2, +Drop<T2>, U2, +Drop<U2>>(
10 |         self: Wallet<T1, U1>, other: Wallet<T2, U2>,
11 |     ) -> Wallet<T1, U2>;
12 | }
13 | 
14 | impl WalletMixImpl<T1, +Drop<T1>, U1, +Drop<U1>> of WalletMixTrait<T1, U1> {
15 |     fn mixup<T2, +Drop<T2>, U2, +Drop<U2>>(
16 |         self: Wallet<T1, U1>, other: Wallet<T2, U2>,
17 |     ) -> Wallet<T1, U2> {
18 |         Wallet { balance: self.balance, address: other.address }
19 |     }
20 | }
21 | // ANCHOR_END: trait_impl
22 | 
23 | // ANCHOR: main
24 | fn main() {
25 |     let w1: Wallet<bool, u128> = Wallet { balance: true, address: 10 };
26 |     let w2: Wallet<felt252, u8> = Wallet { balance: 32, address: 100 };
27 | 
28 |     let w3 = w1.mixup(w2);
29 | 
30 |     assert!(w3.balance);
31 |     assert!(w3.address == 100);
32 | }
33 | // ANCHOR_END: main
34 | 
35 | 
36 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_simple_trait/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_14_simple_trait"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_simple_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_14_simple_trait"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_14_simple_trait/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop, Clone)]
 2 | struct NewsArticle {
 3 |     headline: ByteArray,
 4 |     location: ByteArray,
 5 |     author: ByteArray,
 6 |     content: ByteArray,
 7 | }
 8 | 
 9 | //ANCHOR: trait
10 | pub trait Summary {
11 |     fn summarize(self: @NewsArticle) -> ByteArray;
12 | }
13 | //ANCHOR_END: trait
14 | 
15 | //ANCHOR: impl
16 | impl NewsArticleSummary of Summary {
17 |     fn summarize(self: @NewsArticle) -> ByteArray {
18 |         format!("{:?} by {:?} ({:?})", self.headline, self.author, self.location)
19 |     }
20 | }
21 | //ANCHOR_END: impl
22 | 
23 | 
24 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_15_traits/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_15_traits"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_15_traits"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_15_traits/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_15_traits v0.1.0 (listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml)
 3 |     Finished `dev` profile target(s) in 2 seconds
 4 |      Running no_listing_15_traits
 5 | New article available! Cairo has become the most popular language for developers by Cairo Digger (Worldwide)
 6 | New tweet! EliBenSasson: Crypto is full of short-term maximizing projects. 
 7 |  @Starknet and @StarkWareLtd are about long-term vision maximization.
 8 | Run completed successfully, returning []
 9 | 
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_15_traits/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | mod aggregator {
 2 |     //ANCHOR: trait
 3 |     pub trait Summary<T> {
 4 |         fn summarize(self: @T) -> ByteArray;
 5 |     }
 6 |     //ANCHOR_END: trait
 7 | 
 8 |     //ANCHOR: impl
 9 |     #[derive(Drop)]
10 |     pub struct NewsArticle {
11 |         pub headline: ByteArray,
12 |         pub location: ByteArray,
13 |         pub author: ByteArray,
14 |         pub content: ByteArray,
15 |     }
16 | 
17 |     impl NewsArticleSummary of Summary<NewsArticle> {
18 |         fn summarize(self: @NewsArticle) -> ByteArray {
19 |             format!("{} by {} ({})", self.headline, self.author, self.location)
20 |         }
21 |     }
22 | 
23 |     #[derive(Drop)]
24 |     pub struct Tweet {
25 |         pub username: ByteArray,
26 |         pub content: ByteArray,
27 |         pub reply: bool,
28 |         pub retweet: bool,
29 |     }
30 | 
31 |     impl TweetSummary of Summary<Tweet> {
32 |         fn summarize(self: @Tweet) -> ByteArray {
33 |             format!("{}: {}", self.username, self.content)
34 |         }
35 |     }
36 |     //ANCHOR_END: impl
37 | }
38 | 
39 | //ANCHOR: main
40 | use aggregator::{Summary, NewsArticle, Tweet};
41 | 
42 | fn main() {
43 |     let news = NewsArticle {
44 |         headline: "Cairo has become the most popular language for developers",
45 |         location: "Worldwide",
46 |         author: "Cairo Digger",
47 |         content: "Cairo is a new programming language for zero-knowledge proofs",
48 |     };
49 | 
50 |     let tweet = Tweet {
51 |         username: "EliBenSasson",
52 |         content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
53 |         reply: false,
54 |         retweet: false,
55 |     }; // Tweet instantiation
56 | 
57 |     println!("New article available! {}", news.summarize());
58 |     println!("New tweet! {}", tweet.summarize());
59 | }
60 | //ANCHOR_END: main
61 | 
62 | 
63 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_16_generate_trait/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_16_generate_trait/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_16_generate_trait"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_16_generate_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_16_generate_trait"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_16_generate_trait/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | struct Rectangle {
 2 |     height: u64,
 3 |     width: u64,
 4 | }
 5 | 
 6 | #[generate_trait]
 7 | impl RectangleGeometry of RectangleGeometryTrait {
 8 |     fn boundary(self: Rectangle) -> u64 {
 9 |         2 * (self.height + self.width)
10 |     }
11 |     fn area(self: Rectangle) -> u64 {
12 |         self.height * self.width
13 |     }
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_17_generic_traits/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_17_generic_traits/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_17_generic_traits"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_17_generic_traits/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_17_generic_traits"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_17_generic_traits/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // Here T is an alias type which will be provided during implementation
 2 | pub trait ShapeGeometry<T> {
 3 |     fn boundary(self: T) -> u64;
 4 |     fn area(self: T) -> u64;
 5 | }
 6 | 
 7 | mod rectangle {
 8 |     // Importing ShapeGeometry is required to implement this trait for Rectangle
 9 |     use super::ShapeGeometry;
10 | 
11 |     #[derive(Copy, Drop)]
12 |     pub struct Rectangle {
13 |         pub height: u64,
14 |         pub width: u64,
15 |     }
16 | 
17 |     // Implementation RectangleGeometry passes in <Rectangle>
18 |     // to implement the trait for that type
19 |     impl RectangleGeometry of ShapeGeometry<Rectangle> {
20 |         fn boundary(self: Rectangle) -> u64 {
21 |             2 * (self.height + self.width)
22 |         }
23 |         fn area(self: Rectangle) -> u64 {
24 |             self.height * self.width
25 |         }
26 |     }
27 | }
28 | 
29 | mod circle {
30 |     // Importing ShapeGeometry is required to implement this trait for Circle
31 |     use super::ShapeGeometry;
32 | 
33 |     #[derive(Copy, Drop)]
34 |     pub struct Circle {
35 |         pub radius: u64,
36 |     }
37 | 
38 |     // Implementation CircleGeometry passes in <Circle>
39 |     // to implement the imported trait for that type
40 |     impl CircleGeometry of ShapeGeometry<Circle> {
41 |         fn boundary(self: Circle) -> u64 {
42 |             (2 * 314 * self.radius) / 100
43 |         }
44 |         fn area(self: Circle) -> u64 {
45 |             (314 * self.radius * self.radius) / 100
46 |         }
47 |     }
48 | }
49 | 
50 | use rectangle::Rectangle;
51 | use circle::Circle;
52 | 
53 | fn main() {
54 |     let rect = Rectangle { height: 5, width: 7 };
55 |     println!("Rectangle area: {}", ShapeGeometry::area(rect)); //35
56 |     println!("Rectangle boundary: {}", ShapeGeometry::boundary(rect)); //24
57 | 
58 |     let circ = Circle { radius: 5 };
59 |     println!("Circle area: {}", ShapeGeometry::area(circ)); //78
60 |     println!("Circle boundary: {}", ShapeGeometry::boundary(circ)); //31
61 | }
62 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_18_negative_impl/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_18_negative_impl/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_18_negative_impl"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | experimental-features = ["negative_impls"]
 6 | 
 7 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 8 | 
 9 | [dependencies]
10 | # foo = { path = "vendor/foo" }
11 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_18_negative_impl/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct ProducerType {}
 3 | 
 4 | #[derive(Drop, Debug)]
 5 | struct AnotherType {}
 6 | 
 7 | #[derive(Drop, Debug)]
 8 | struct AThirdType {}
 9 | 
10 | trait Producer<T> {
11 |     fn produce(self: T) -> u32;
12 | }
13 | 
14 | trait Consumer<T> {
15 |     fn consume(self: T, input: u32);
16 | }
17 | 
18 | impl ProducerImpl of Producer<ProducerType> {
19 |     fn produce(self: ProducerType) -> u32 {
20 |         42
21 |     }
22 | }
23 | 
24 | impl TConsumerImpl<T, +core::fmt::Debug<T>, +Drop<T>, -Producer<T>> of Consumer<T> {
25 |     fn consume(self: T, input: u32) {
26 |         println!("{:?} consumed value: {}", self, input);
27 |     }
28 | }
29 | 
30 | fn main() {
31 |     let producer = ProducerType {};
32 |     let another_type = AnotherType {};
33 |     let third_type = AThirdType {};
34 |     let production = producer.produce();
35 | 
36 |     // producer.consume(production); Invalid: ProducerType does not implement Consumer
37 |     another_type.consume(production);
38 |     third_type.consume(production);
39 | }
40 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_default_impl_self_call/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_default_impl_self_call/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_default_impl_self_call"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch08-generic-types-and-traits/no_listing_default_impl_self_call/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | mod aggregator {
 2 |     //ANCHOR: trait
 3 |     pub trait Summary<T> {
 4 |         fn summarize(
 5 |             self: @T,
 6 |         ) -> ByteArray {
 7 |             format!("(Read more from {}...)", Self::summarize_author(self))
 8 |         }
 9 |         fn summarize_author(self: @T) -> ByteArray;
10 |     }
11 |     //ANCHOR_END: trait
12 | 
13 |     #[derive(Drop)]
14 |     pub struct Tweet {
15 |         pub username: ByteArray,
16 |         pub content: ByteArray,
17 |         pub reply: bool,
18 |         pub retweet: bool,
19 |     }
20 | 
21 |     //ANCHOR: impl
22 |     impl TweetSummary of Summary<Tweet> {
23 |         fn summarize_author(self: @Tweet) -> ByteArray {
24 |             format!("@{}", self.username)
25 |         }
26 |     }
27 |     //ANCHOR_END: impl
28 | }
29 | 
30 | //ANCHOR: main
31 | use aggregator::{Summary, Tweet};
32 | 
33 | fn main() {
34 |     let tweet = Tweet {
35 |         username: "EliBenSasson",
36 |         content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
37 |         reply: false,
38 |         retweet: false,
39 |     };
40 | 
41 |     println!("1 new tweet: {}", tweet.summarize());
42 | }
43 | //ANCHOR_END: main
44 | 
45 | 
46 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/listing_09_01/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/listing_09_01/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_01"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/listing_09_01/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: function
 2 | fn parse_u8(s: felt252) -> Result<u8, felt252> {
 3 |     match s.try_into() {
 4 |         Option::Some(value) => Result::Ok(value),
 5 |         Option::None => Result::Err('Invalid integer'),
 6 |     }
 7 | }
 8 | //ANCHOR_END: function
 9 | 
10 | //ANCHOR: tests
11 | #[cfg(test)]
12 | mod tests {
13 |     use super::*;
14 | 
15 |     #[test]
16 |     fn test_felt252_to_u8() {
17 |         let number: felt252 = 5;
18 |         // should not panic
19 |         let res = parse_u8(number).unwrap();
20 |     }
21 | 
22 |     #[test]
23 |     #[should_panic]
24 |     fn test_felt252_to_u8_panic() {
25 |         let number: felt252 = 256;
26 |         // should panic
27 |         let res = parse_u8(number).unwrap();
28 |     }
29 | }
30 | //ANCHOR_END: tests
31 | 
32 | 
33 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/listing_09_02/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/listing_09_02/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_02"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/listing_09_02/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn parse_u8(s: felt252) -> Result<u8, felt252> {
 2 |     match s.try_into() {
 3 |         Option::Some(value) => Result::Ok(value),
 4 |         Option::None => Result::Err('Invalid integer'),
 5 |     }
 6 | }
 7 | 
 8 | //ANCHOR: function
 9 | fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
10 |     let input_to_u8: u8 = parse_u8(input)?;
11 |     // DO SOMETHING
12 |     let res = input_to_u8 - 1;
13 |     Result::Ok(res)
14 | }
15 | //ANCHOR_END: function
16 | 
17 | #[cfg(test)]
18 | mod tests {
19 |     use super::*;
20 |     //ANCHOR: tests
21 |     #[test]
22 |     fn test_function_2() {
23 |         let number: felt252 = 258;
24 |         match do_something_with_parse_u8(number) {
25 |             Result::Ok(value) => println!("Result: {}", value),
26 |             Result::Err(e) => println!("Error: {}", e),
27 |         }
28 |     }
29 |     //ANCHOR_END: tests
30 | }
31 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_01_panic/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_01_panic/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_panic"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_01_panic/output.txt:
--------------------------------------------------------------------------------
1 | $ scarb cairo-run 
2 |    Compiling no_listing_01_panic v0.1.0 (listings/ch09-error-handling/no_listing_01_panic/Scarb.toml)
3 |     Finished `dev` profile target(s) in 3 seconds
4 |      Running no_listing_01_panic
5 | Run panicked with [2, ].
6 | 
7 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_01_panic/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let mut data = array![2];
3 | 
4 |     if true {
5 |         panic(data);
6 |     }
7 |     println!("This line isn't reached");
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_02_with_felt252/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_02_with_felt252/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_with_felt252"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_02_with_felt252/src/lib.cairo:
--------------------------------------------------------------------------------
1 | use core::panic_with_felt252;
2 | 
3 | fn main() {
4 |     panic_with_felt252(2);
5 | }
6 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_03_panic_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_03_panic_macro/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_09_panic_macro"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_03_panic_macro/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     if true {
3 |         panic!("2");
4 |     }
5 |     println!("This line isn't reached");
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_04_nopanic/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_04_nopanic/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_nopanic"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_04_nopanic/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn function_never_panic() -> felt252 nopanic {
2 |     42
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_05_nopanic_wrong/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_05_nopanic_wrong/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_nopanic_wrong"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_05_nopanic_wrong/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_04_nopanic_wrong v0.1.0 (listings/ch09-error-handling/no_listing_05_nopanic_wrong/Scarb.toml)
 3 | error: Function is declared as nopanic but calls a function that may panic.
 4 |  --> listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:12
 5 |     assert(1 == 1, 'what');
 6 |            ^****^
 7 | 
 8 | error: Function is declared as nopanic but calls a function that may panic.
 9 |  --> listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:5
10 |     assert(1 == 1, 'what');
11 |     ^********************^
12 | 
13 | error: could not compile `no_listing_04_nopanic_wrong` due to previous error
14 | error: `scarb metadata` exited with error
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:
--------------------------------------------------------------------------------
1 | //TAG: does_not_compile
2 | // ANCHOR: wrong-nopanic
3 | fn function_never_panic() nopanic {
4 |     assert(1 == 1, 'what');
5 | }
6 | // ANCHOR_END: wrong-nopanic
7 | 
8 | 
9 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_06_panic_with/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_06_panic_with/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_panic_with"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_06_panic_with/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[panic_with('value is 0', wrap_not_zero)]
 2 | fn wrap_if_not_zero(value: u128) -> Option<u128> {
 3 |     if value == 0 {
 4 |         Option::None
 5 |     } else {
 6 |         Option::Some(value)
 7 |     }
 8 | }
 9 | 
10 | fn main() {
11 |     wrap_if_not_zero(0); // this returns None
12 |     wrap_not_zero(0); // this panics with 'value is 0'
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_07_result_enum/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_07_result_enum/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_result_enum"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_07_result_enum/src/lib.cairo:
--------------------------------------------------------------------------------
1 | enum Result<T, E> {
2 |     Ok: T,
3 |     Err: E,
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_08_result_trait/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_08_result_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_result_trait"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_08_result_trait/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | trait ResultTrait<T, E> {
 2 |     fn expect<+Drop<E>>(self: Result<T, E>, err: felt252) -> T;
 3 | 
 4 |     fn unwrap<+Drop<E>>(self: Result<T, E>) -> T;
 5 | 
 6 |     fn expect_err<+Drop<T>>(self: Result<T, E>, err: felt252) -> E;
 7 | 
 8 |     fn unwrap_err<+Drop<T>>(self: Result<T, E>) -> E;
 9 | 
10 |     fn is_ok(self: @Result<T, E>) -> bool;
11 | 
12 |     fn is_err(self: @Result<T, E>) -> bool;
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_09_result_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_09_result_example/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_08_result_example"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch09-error-handling/no_listing_09_result_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // TAGS: does_not_compile, ignore_fmt
 2 | // ANCHOR: overflow
 3 | fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;
 4 | // ANCHOR_END: overflow
 5 | 
 6 | // ANCHOR: checked-add
 7 | fn u128_checked_add(a: u128, b: u128) -> Option<u128> {
 8 |     match u128_overflowing_add(a, b) {
 9 |         Result::Ok(r) => Option::Some(r),
10 |         Result::Err(r) => Option::None,
11 |     }
12 | }
13 | // ANCHOR_END: checked-add
14 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_01/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_10_01"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_01/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_10_01 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.90s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 6 seconds
 8 | 
 9 | 
10 | Collected 2 test(s) from listing_10_01 package
11 | Running 2 test(s) from src/
12 | [PASS] listing_10_01::tests::it_works (gas: ~1)
13 | [PASS] listing_10_01::other_tests::exploration (gas: ~1)
14 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_01/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: it_works
 2 | pub fn add(left: usize, right: usize) -> usize {
 3 |     left + right
 4 | }
 5 | 
 6 | #[cfg(test)]
 7 | mod tests {
 8 |     use super::*;
 9 | 
10 |     #[test]
11 |     fn it_works() {
12 |         let result = add(2, 2);
13 |         assert_eq!(result, 4);
14 |     }
15 | }
16 | // ANCHOR_END: it_works
17 | 
18 | #[cfg(test)]
19 | mod other_tests {
20 |     // ANCHOR: exploration
21 |     #[test]
22 |     fn exploration() {
23 |         let result = 2 + 2;
24 |         assert_eq!(result, 4);
25 |     }
26 |     // ANCHOR_END: exploration
27 | }
28 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_02/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_02/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_10_02"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_02/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_10_02 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.33s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_02/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 4 seconds
 7 | 
 8 | 
 9 | Collected 2 test(s) from listing_10_02 package
10 | Running 2 test(s) from src/
11 | [FAIL] listing_10_02::tests::another
12 | 
13 | Failure data:
14 |     "Make this test fail"
15 | 
16 | [PASS] listing_10_02::tests::exploration (gas: ~1)
17 | Tests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out
18 | 
19 | Failures:
20 |     listing_10_02::tests::another
21 | 
22 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_02/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // TAG: tests_fail
 2 | // ANCHOR: exploration-and-another
 3 | #[cfg(test)]
 4 | mod tests {
 5 |     #[test]
 6 |     fn exploration() {
 7 |         let result = 2 + 2;
 8 |         assert_eq!(result, 4);
 9 |     }
10 | 
11 |     #[test]
12 |     fn another() {
13 |         let result = 2 + 2;
14 |         assert!(result == 6, "Make this test fail");
15 |     }
16 | }
17 | // ANCHOR_END: exploration-and-another
18 | 
19 | 
20 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_03/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_10_03"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_03/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_10_03 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 1.04s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 5 seconds
 7 | 
 8 | 
 9 | Collected 2 test(s) from listing_10_03 package
10 | Running 2 test(s) from src/
11 | [PASS] listing_10_03::tests::larger_can_hold_smaller (gas: ~1)
12 | [PASS] listing_10_03::tests2::smaller_cannot_hold_larger (gas: ~1)
13 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
14 | 
15 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_03/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: trait_impl
 2 | #[derive(Drop)]
 3 | struct Rectangle {
 4 |     width: u64,
 5 |     height: u64,
 6 | }
 7 | 
 8 | trait RectangleTrait {
 9 |     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;
10 | }
11 | 
12 | impl RectangleImpl of RectangleTrait {
13 |     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {
14 |         *self.width > *other.width && *self.height > *other.height
15 |     }
16 | }
17 | // ANCHOR_END: trait_impl
18 | 
19 | // ANCHOR: test1
20 | #[cfg(test)]
21 | mod tests {
22 |     use super::*;
23 | 
24 |     #[test]
25 |     fn larger_can_hold_smaller() {
26 |         let larger = Rectangle { height: 7, width: 8 };
27 |         let smaller = Rectangle { height: 1, width: 5 };
28 | 
29 |         assert!(larger.can_hold(@smaller), "rectangle cannot hold");
30 |     }
31 | }
32 | //ANCHOR_END: test1
33 | #[cfg(test)]
34 | mod tests2 {
35 |     use super::*;
36 | 
37 |     // ANCHOR: test2
38 |     #[test]
39 |     fn smaller_cannot_hold_larger() {
40 |         let larger = Rectangle { height: 7, width: 8 };
41 |         let smaller = Rectangle { height: 1, width: 5 };
42 | 
43 |         assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
44 |     }
45 |     // ANCHOR_END: test2
46 | }
47 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_04/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_04/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_10_04"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_04/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_10_04 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 1.00s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_04/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 5 seconds
 8 | 
 9 | 
10 | Collected 2 test(s) from listing_10_04 package
11 | Running 2 test(s) from src/
12 | [PASS] listing_10_04::add_two::tests::it_adds_two (gas: ~1)
13 | [PASS] listing_10_04::add_two::tests::wrong_check (gas: ~1)
14 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_04/src/add_two.cairo:
--------------------------------------------------------------------------------
 1 | pub fn add_two(a: u32) -> u32 {
 2 |     a + 2
 3 | }
 4 | 
 5 | #[cfg(test)]
 6 | mod tests {
 7 |     use super::*;
 8 | 
 9 |     #[test]
10 |     fn it_adds_two() {
11 |         assert_eq!(4, add_two(2));
12 |     }
13 | 
14 |     #[test]
15 |     fn wrong_check() {
16 |         assert_ne!(0, add_two(2));
17 |     }
18 | }
19 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_04/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod add_two;
2 | mod wrong_add_two;
3 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_04/src/wrong_add_two.cairo:
--------------------------------------------------------------------------------
1 | pub fn add_two(a: u32) -> u32 {
2 |     a + 3
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_05/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_09_08"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | [scripts]
15 | test = "snforge test"
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_05/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_09_08 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.21s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 4 seconds
 8 | 
 9 | 
10 | Collected 1 test(s) from listing_09_08 package
11 | Running 1 test(s) from src/
12 | [PASS] listing_09_08::tests::greater_than_100 (gas: ~1)
13 | 
14 | Success data:
15 |     "Guess must be >= 1 and <= 100"
16 | 
17 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
18 | 
19 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_05/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: guess
 2 | #[derive(Drop)]
 3 | struct Guess {
 4 |     value: u64,
 5 | }
 6 | 
 7 | pub trait GuessTrait {
 8 |     fn new(value: u64) -> Guess;
 9 | }
10 | 
11 | impl GuessImpl of GuessTrait {
12 |     fn new(value: u64) -> Guess {
13 |         if value < 1 || value > 100 {
14 |             panic!("Guess must be >= 1 and <= 100");
15 |         }
16 | 
17 |         Guess { value }
18 |     }
19 | }
20 | // ANCHOR_END: guess
21 | 
22 | // ANCHOR: test
23 | #[cfg(test)]
24 | mod tests {
25 |     use super::*;
26 | 
27 |     #[test]
28 |     #[should_panic]
29 |     fn greater_than_100() {
30 |         GuessTrait::new(200);
31 |     }
32 | }
33 | // ANCHOR_END: test
34 | 
35 | 
36 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_06/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_06/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_09_09"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | [scripts]
15 | test = "snforge test"
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_06/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_09_09 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.87s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_06/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 5 seconds
 8 | 
 9 | 
10 | Collected 1 test(s) from listing_09_09 package
11 | Running 1 test(s) from src/
12 | [PASS] listing_09_09::tests::greater_than_100 (gas: ~1)
13 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
14 | 
15 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_06/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct Guess {
 3 |     value: u64,
 4 | }
 5 | 
 6 | trait GuessTrait {
 7 |     fn new(value: u64) -> Guess;
 8 | }
 9 | 
10 | // ANCHOR: here
11 | impl GuessImpl of GuessTrait {
12 |     fn new(value: u64) -> Guess {
13 |         if value < 1 {
14 |             panic!("Guess must be >= 1");
15 |         } else if value > 100 {
16 |             panic!("Guess must be <= 100");
17 |         }
18 | 
19 |         Guess { value }
20 |     }
21 | }
22 | 
23 | #[cfg(test)]
24 | mod tests {
25 |     use super::*;
26 | 
27 |     #[test]
28 |     #[should_panic(expected: "Guess must be <= 100")]
29 |     fn greater_than_100() {
30 |         GuessTrait::new(200);
31 |     }
32 | }
33 | // ANCHOR_END: here
34 | 
35 | 
36 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_07/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_07/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_10_07"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_07/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_10_07 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.71s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_07/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 6 seconds
 8 | 
 9 | 
10 | Collected 2 test(s) from listing_10_07 package
11 | Running 2 test(s) from src/
12 | [PASS] listing_10_07::tests::add_two_and_two (gas: ~1)
13 | [PASS] listing_10_07::tests::add_three_and_two (gas: ~1)
14 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_07/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[cfg(test)]
 2 | mod tests {
 3 |     #[test]
 4 |     fn add_two_and_two() {
 5 |         let result = 2 + 2;
 6 |         assert_eq!(result, 4);
 7 |     }
 8 | 
 9 |     #[test]
10 |     fn add_three_and_two() {
11 |         let result = 3 + 2;
12 |         assert!(result == 5, "result is not 5");
13 |     }
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_08/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_08/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_10_08"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | 
10 | [dev-dependencies]
11 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
12 | assert_macros = "2.9.1"
13 | [scripts]
14 | test = "snforge test"
15 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_08/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_10_08 (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 1.21s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/listing_10_08/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 6 seconds
 8 | 
 9 | 
10 | Collected 1 test(s) from listing_10_08 package
11 | Running 1 test(s) from src/
12 | [PASS] listing_10_08::test_struct_equality (gas: ~1)
13 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
14 | 
15 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/listing_10_08/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop, Copy, Debug, PartialEq)]
 2 | struct Dice {
 3 |     number: u8,
 4 | }
 5 | 
 6 | impl DicePartialOrd of PartialOrd<Dice> {
 7 |     fn lt(lhs: Dice, rhs: Dice) -> bool {
 8 |         lhs.number < rhs.number
 9 |     }
10 | 
11 |     fn le(lhs: Dice, rhs: Dice) -> bool {
12 |         lhs.number <= rhs.number
13 |     }
14 | 
15 |     fn gt(lhs: Dice, rhs: Dice) -> bool {
16 |         lhs.number > rhs.number
17 |     }
18 | 
19 |     fn ge(lhs: Dice, rhs: Dice) -> bool {
20 |         lhs.number >= rhs.number
21 |     }
22 | }
23 | 
24 | #[cfg(test)]
25 | #[test]
26 | fn test_struct_equality() {
27 |     let first_throw = Dice { number: 5 };
28 |     let second_throw = Dice { number: 2 };
29 |     let third_throw = Dice { number: 6 };
30 |     let fourth_throw = Dice { number: 5 };
31 | 
32 |     assert_gt!(first_throw, second_throw);
33 |     assert_ge!(first_throw, fourth_throw);
34 |     assert_lt!(second_throw, third_throw);
35 |     assert_le!(
36 |         first_throw, fourth_throw, "{:?},{:?} should be lower or equal", first_throw, fourth_throw,
37 |     );
38 | }
39 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_wrong_can_hold_impl"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | [scripts]
15 | test = "snforge test"
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_01_wrong_can_hold_impl (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 1.11s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 6 seconds
 8 | 
 9 | 
10 | Collected 0 test(s) from no_listing_01_wrong_can_hold_impl package
11 | Running 0 test(s) from src/
12 | Tests: 0 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
13 | 
14 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Copy, Drop)]
 2 | struct Rectangle {
 3 |     width: u64,
 4 |     height: u64,
 5 | }
 6 | 
 7 | trait RectangleTrait {
 8 |     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;
 9 | }
10 | 
11 | // ANCHOR: wrong_impl
12 | impl RectangleImpl of RectangleTrait {
13 |     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {
14 |         *self.width < *other.width && *self.height > *other.height
15 |     }
16 | }
17 | // ANCHOR_END: wrong_impl
18 | 
19 | 
20 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_02_custom_messages"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_02_custom_messages (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.39s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 4 seconds
 8 | 
 9 | 
10 | Collected 1 test(s) from no_listing_02_custom_messages package
11 | Running 1 test(s) from src/
12 | [FAIL] no_listing_02_custom_messages::tests::it_adds_two
13 | 
14 | Failure data:
15 |     "assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5
16 |     4: 4
17 |     add_two(2): 5"
18 | 
19 | Tests: 0 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out
20 | 
21 | Failures:
22 |     no_listing_02_custom_messages::tests::it_adds_two
23 | 
24 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // TAG: tests_fail
 2 | pub fn add_two(a: u32) -> u32 {
 3 |     a + 3
 4 | }
 5 | 
 6 | #[cfg(test)]
 7 | mod tests {
 8 |     use super::*;
 9 |     // ANCHOR: here
10 |     #[test]
11 |     fn it_adds_two() {
12 |         assert_eq!(4, add_two(2), "Expected {}, got add_two(2)={}", 4, add_two(2));
13 |     }
14 |     // ANCHOR_END: here
15 | }
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_wrong_new_impl"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_03_wrong_new_impl (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.14s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 4 seconds
 7 | 
 8 | 
 9 | Collected 0 test(s) from no_listing_03_wrong_new_impl package
10 | Running 0 test(s) from src/
11 | Tests: 0 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
12 | 
13 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct Guess {
 3 |     value: u64,
 4 | }
 5 | 
 6 | trait GuessTrait {
 7 |     fn new(value: u64) -> Guess;
 8 | }
 9 | 
10 | // ANCHOR:here
11 | impl GuessImpl of GuessTrait {
12 |     fn new(value: u64) -> Guess {
13 |         if value < 1 {
14 |             panic!("Guess must be >= 1 and <= 100");
15 |         }
16 | 
17 |         Guess { value }
18 |     }
19 | }
20 | // ANCHOR_END: here
21 | 
22 | 
23 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_04_new_bug/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_04_new_bug/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_new_bug"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_04_new_bug/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_04_new_bug (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 1.01s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_04_new_bug/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 6 seconds
 8 | 
 9 | 
10 | Collected 1 test(s) from no_listing_04_new_bug package
11 | Running 1 test(s) from src/
12 | [FAIL] no_listing_04_new_bug::tests::greater_than_100
13 | 
14 | Failure data:
15 |     Incorrect panic data
16 |     Actual:    [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203e3d2031, 0x12] (Guess must be >= 1)
17 |     Expected:  [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203c3d20313030, 0x14] (Guess must be <= 100)
18 | 
19 | Tests: 0 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out
20 | 
21 | Failures:
22 |     no_listing_04_new_bug::tests::greater_than_100
23 | 
24 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_04_new_bug/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: tests_fail
 2 | #[derive(Copy, Drop)]
 3 | struct Guess {
 4 |     value: u64,
 5 | }
 6 | 
 7 | trait GuessTrait {
 8 |     fn new(value: u64) -> Guess;
 9 | }
10 | 
11 | // ANCHOR:here
12 | impl GuessImpl of GuessTrait {
13 |     fn new(value: u64) -> Guess {
14 |         if value < 1 {
15 |             panic!("Guess must be <= 100");
16 |         } else if value > 100 {
17 |             panic!("Guess must be >= 1");
18 |         }
19 | 
20 |         Guess { value }
21 |     }
22 | }
23 | 
24 | #[cfg(test)]
25 | mod tests {
26 |     use super::*;
27 | 
28 |     #[test]
29 |     #[should_panic(expected: "Guess must be <= 100")]
30 |     fn greater_than_100() {
31 |         GuessTrait::new(200);
32 |     }
33 | }
34 | // ANCHOR_END:here
35 | 
36 | 
37 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_ignore_tests"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_05_ignore_tests (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.79s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 5 seconds
 8 | 
 9 | 
10 | Collected 2 test(s) from no_listing_05_ignore_tests package
11 | Running 2 test(s) from src/
12 | [IGNORE] no_listing_05_ignore_tests::tests::expensive_test
13 | [PASS] no_listing_05_ignore_tests::tests::it_works (gas: ~1)
14 | Tests: 1 passed, 0 failed, 0 skipped, 1 ignored, 0 filtered out
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | pub fn add(left: usize, right: usize) -> usize {
 2 |     left + right
 3 | }
 4 | 
 5 | #[cfg(test)]
 6 | mod tests {
 7 |     use super::*;
 8 | 
 9 |     #[test]
10 |     fn it_works() {
11 |         let result = add(2, 2);
12 |         assert_eq!(result, 4);
13 |     }
14 | 
15 |     #[test]
16 |     #[ignore]
17 |     fn expensive_test() { // code that takes an hour to run
18 |     }
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_assert/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_assert/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_06_assert"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_assert/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_06_assert (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.24s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_06_assert/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 4 seconds
 7 | 
 8 | 
 9 | Collected 0 test(s) from no_listing_06_assert package
10 | Running 0 test(s) from src/
11 | Tests: 0 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
12 | 
13 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_assert/src/lib.cairo:
--------------------------------------------------------------------------------
1 | //TAG: does_not_run
2 | fn main() {
3 |     let my_number: u8 = 0;
4 | 
5 |     assert(my_number != 0, 'number is zero');
6 | 
7 |     100 / my_number;
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_test_gas/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_test_gas/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_test_gas"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_test_gas/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_08_test_gas (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.13s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_06_test_gas/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 3 seconds
 7 | 
 8 | 
 9 | Collected 1 test(s) from no_listing_08_test_gas package
10 | Running 1 test(s) from src/
11 | [PASS] no_listing_08_test_gas::tests::test_sum_n (gas: ~2)
12 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
13 | 
14 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_06_test_gas/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn sum_n(n: usize) -> usize {
 2 |     let mut i = 0;
 3 |     let mut sum = 0;
 4 |     while i <= n {
 5 |         sum += i;
 6 |         i += 1;
 7 |     };
 8 |     sum
 9 | }
10 | 
11 | #[cfg(test)]
12 | mod tests {
13 |     use super::*;
14 | 
15 |     #[test]
16 |     #[available_gas(2000000)]
17 |     fn test_sum_n() {
18 |         let result = sum_n(10);
19 |         assert!(result == 55, "result is not 55");
20 |     }
21 | }
22 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_07_benchmark_gas/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_09_benchmark_gas (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.44s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_07_benchmark_gas/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 8 seconds
 7 | 
 8 | 
 9 | Collected 1 test(s) from no_listing_09_benchmark_gas package
10 | Running 1 test(s) from src/
11 | consumed gas: 80490
12 | 
13 | [PASS] no_listing_09_benchmark_gas::tests::benchmark_sum_n_gas (gas: ~5)
14 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "adder"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test adder (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.88s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
 7 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
 8 |     Finished `dev` profile target(s) in 9 seconds
 9 | 
10 | 
11 | Collected 2 test(s) from adder package
12 | Running 1 test(s) from tests/
13 | [PASS] adder_integrationtest::integration_tests::it_adds_two (gas: ~1)
14 | Running 1 test(s) from src/
15 | [PASS] adder::tests::internal (gas: ~1)
16 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
17 | 
18 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/output_integration.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test -f integration_tests
 2 |      Running cairo-test adder
 3 |    Compiling test(adder_unittest) adder v0.1.0 (cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
 4 |    Compiling test(adder_integration_tests) adder_integration_tests v0.1.0 (cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
 5 |     Finished release target(s) in 7 seconds
 6 | testing adder ...
 7 | running 1 test
 8 | test adder_integration_tests::integration_tests::internal ... ok (gas usage est.: 23110)
 9 | test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
10 | 
11 | running 0 tests
12 | test result: ok. 0 passed; 0 failed; 0 ignored; 1 filtered out;
13 | 
14 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | pub fn add_two(a: u32) -> u32 {
 2 |     internal_adder(a, 2)
 3 | }
 4 | 
 5 | fn internal_adder(a: u32, b: u32) -> u32 {
 6 |     a + b
 7 | }
 8 | 
 9 | #[cfg(test)]
10 | mod tests {
11 |     use super::*;
12 | 
13 |     #[test]
14 |     fn internal() {
15 |         assert_eq!(4, internal_adder(2, 2));
16 |     }
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/tests/integration_tests.cairo:
--------------------------------------------------------------------------------
1 | use adder::add_two;
2 | 
3 | #[test]
4 | fn it_adds_two() {
5 |     assert_eq!(4, add_two(2));
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_10_assert_eq_ne_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_10_assert_eq_ne_macro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_11_assert_eq_ne_macro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_10_assert_eq_ne_macro/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test no_listing_11_assert_eq_ne_macro (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Blocking waiting for file lock on build directory
 5 |     Finished `release` profile [optimized] target(s) in 0.48s
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_10_assert_eq_ne_macro/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 4 seconds
 8 | 
 9 | 
10 | Collected 1 test(s) from no_listing_11_assert_eq_ne_macro package
11 | Running 1 test(s) from src/
12 | [PASS] no_listing_11_assert_eq_ne_macro::test_struct_equality (gas: ~1)
13 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
14 | 
15 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_10_assert_eq_ne_macro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop, Debug, PartialEq)]
 2 | struct MyStruct {
 3 |     var1: u8,
 4 |     var2: u8,
 5 | }
 6 | 
 7 | #[cfg(test)]
 8 | #[test]
 9 | fn test_struct_equality() {
10 |     let first = MyStruct { var1: 1, var2: 2 };
11 |     let second = MyStruct { var1: 1, var2: 2 };
12 |     let third = MyStruct { var1: 1, var2: 3 };
13 | 
14 |     assert_eq!(first, second);
15 |     assert_eq!(first, second, "{:?},{:?} should be equal", first, second);
16 |     assert_ne!(first, third);
17 |     assert_ne!(first, third, "{:?},{:?} should not be equal", first, third);
18 | }
19 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "test_private_function"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test test_private_function (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.43s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 4 seconds
 7 | 
 8 | 
 9 | Collected 1 test(s) from test_private_function package
10 | Running 1 test(s) from src/
11 | [PASS] test_private_function::tests::add (gas: ~1)
12 | Tests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
13 | 
14 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | pub fn add(a: u32, b: u32) -> u32 {
 2 |     internal_adder(a, 2)
 3 | }
 4 | 
 5 | fn internal_adder(a: u32, b: u32) -> u32 {
 6 |     a + b
 7 | }
 8 | 
 9 | #[cfg(test)]
10 | mod tests {
11 |     use super::*;
12 | 
13 |     #[test]
14 |     fn add() {
15 |         assert_eq!(4, internal_adder(2, 2));
16 |     }
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_12_submodules/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "adder"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_12_submodules/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test adder (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.64s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 8 seconds
 8 | 
 9 | 
10 | Collected 2 test(s) from adder package
11 | Running 1 test(s) from src/
12 | [PASS] adder::tests::add (gas: ~1)
13 | Running 1 test(s) from tests/
14 | [PASS] adder_integrationtest::integration_tests::internal (gas: ~1)
15 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
16 | 
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_12_submodules/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | pub fn it_adds_two(a: u8, b: u8) -> u8 {
 2 |     a + b
 3 | }
 4 | 
 5 | #[cfg(test)]
 6 | mod tests {
 7 |     #[test]
 8 |     fn add() {
 9 |         assert_eq!(4, super::it_adds_two(2, 2));
10 |     }
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_12_submodules/tests/common.cairo:
--------------------------------------------------------------------------------
1 | pub fn setup() {
2 |     println!("Setting up tests...");
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_12_submodules/tests/integration_tests.cairo:
--------------------------------------------------------------------------------
1 | use adder::it_adds_two;
2 | 
3 | #[test]
4 | fn internal() {
5 |     assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "adder"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test adder (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.51s
 5 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
 6 |    Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
 7 |     Finished `dev` profile target(s) in 7 seconds
 8 | 
 9 | 
10 | Collected 2 test(s) from adder package
11 | Running 1 test(s) from tests/
12 | [PASS] adder_tests::integration_tests::internal (gas: ~1)
13 | Running 1 test(s) from src/
14 | [PASS] adder::tests::add (gas: ~1)
15 | Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
16 | 
17 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | pub fn it_adds_two(a: u8, b: u8) -> u8 {
 2 |     a + b
 3 | }
 4 | 
 5 | #[cfg(test)]
 6 | mod tests {
 7 |     #[test]
 8 |     fn add() {
 9 |         assert_eq!(4, super::it_adds_two(2, 2));
10 |     }
11 | }
12 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/tests/common.cairo:
--------------------------------------------------------------------------------
1 | pub fn setup() {
2 |     println!("Setting up tests...");
3 | }
4 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/tests/integration_tests.cairo:
--------------------------------------------------------------------------------
1 | use adder::it_adds_two;
2 | 
3 | #[test]
4 | fn internal() {
5 |     assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/tests/lib.cairo:
--------------------------------------------------------------------------------
1 | mod integration_tests;
2 | mod common;
3 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_01_array_collection/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_01_array_collection/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_01_array_collection"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_01_array_collection/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     //ANCHOR: array_append
3 |     let mut level_players = array![5, 1, 10];
4 |     //ANCHOR_END: array_append
5 | }
6 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_02_inlining/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_02_inlining/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_02_inlining"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_02_inlining/src/inlining.sierra:
--------------------------------------------------------------------------------
 1 | // type declarations
 2 | type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false]
 3 | type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true]
 4 | 
 5 | // libfunc declarations
 6 | libfunc function_call<user@main::main::not_inlined> = function_call<user@main::main::not_inlined>
 7 | libfunc drop<felt252> = drop<felt252>
 8 | libfunc struct_construct<Unit> = struct_construct<Unit>
 9 | libfunc felt252_const<29676284458984804> = felt252_const<29676284458984804>
10 | libfunc store_temp<felt252> = store_temp<felt252>
11 | libfunc felt252_const<133508164995039583817065828> = felt252_const<133508164995039583817065828>
12 | 
13 | // statements
14 | 00 function_call<user@main::main::not_inlined>() -> ([0])
15 | 01 drop<felt252>([0]) -> ()
16 | 02 struct_construct<Unit>() -> ([1])
17 | 03 return([1])
18 | 04 felt252_const<29676284458984804>() -> ([0])
19 | 05 store_temp<felt252>([0]) -> ([0])
20 | 06 return([0])
21 | 07 felt252_const<133508164995039583817065828>() -> ([0])
22 | 08 store_temp<felt252>([0]) -> ([0])
23 | 09 return([0])
24 | 
25 | // funcs
26 | main::main::main@0() -> (Unit)
27 | main::main::inlined@4() -> (felt252)
28 | main::main::not_inlined@7() -> (felt252)


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_02_inlining/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     inlined();
 3 |     not_inlined();
 4 | }
 5 | 
 6 | #[inline(always)]
 7 | fn inlined() -> felt252 {
 8 |     'inlined'
 9 | }
10 | 
11 | #[inline(never)]
12 | fn not_inlined() -> felt252 {
13 |     'not inlined'
14 | }
15 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_03_inlining_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_03_inlining_example/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_03_inlining_example"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_03_inlining_example/src/inlining.sierra:
--------------------------------------------------------------------------------
 1 | // type declarations
 2 | type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false]
 3 | 
 4 | // libfunc declarations
 5 | libfunc function_call<user@main::main::not_inlined> = function_call<user@main::main::not_inlined>
 6 | libfunc felt252_const<1> = felt252_const<1>
 7 | libfunc store_temp<felt252> = store_temp<felt252>
 8 | libfunc felt252_add = felt252_add
 9 | libfunc felt252_const<2> = felt252_const<2>
10 | 
11 | // statements
12 | 00 function_call<user@main::main::not_inlined>() -> ([0])
13 | 01 felt252_const<1>() -> ([1])
14 | 02 store_temp<felt252>([1]) -> ([1])
15 | 03 felt252_add([1], [0]) -> ([2])
16 | 04 store_temp<felt252>([2]) -> ([2])
17 | 05 return([2])
18 | 06 felt252_const<1>() -> ([0])
19 | 07 store_temp<felt252>([0]) -> ([0])
20 | 08 return([0])
21 | 09 felt252_const<2>() -> ([0])
22 | 10 store_temp<felt252>([0]) -> ([0])
23 | 11 return([0])
24 | 
25 | // funcs
26 | main::main::main@0() -> (felt252)
27 | main::main::inlined@6() -> (felt252)
28 | main::main::not_inlined@9() -> (felt252)


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_03_inlining_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() -> felt252 {
 2 |     inlined() + not_inlined()
 3 | }
 4 | 
 5 | #[inline(always)]
 6 | fn inlined() -> felt252 {
 7 |     1
 8 | }
 9 | 
10 | #[inline(never)]
11 | fn not_inlined() -> felt252 {
12 |     2
13 | }
14 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_04_basic_box/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_04_basic_box/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_04_basic_box"
 3 | version = "0.1.0"
 4 | 
 5 | [lib]
 6 | casm = true
 7 | 
 8 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 9 | 
10 | [dependencies]
11 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_04_basic_box/src/lib.cairo:
--------------------------------------------------------------------------------
1 | fn main() {
2 |     let b = BoxTrait::new(5_u128);
3 |     println!("b = {}", b.unbox())
4 | }
5 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_05_box/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_05_box/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_05_box"
 3 | version = "0.1.0"
 4 | 
 5 | [lib]
 6 | casm = true
 7 | 
 8 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 9 | 
10 | [dependencies]
11 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_05_box/box_memory.json:
--------------------------------------------------------------------------------
   1 | {
   2 |   "type": "excalidraw/clipboard",
   3 |   "elements": [
   4 |     {
   5 |       "type": "text",
   6 |       "version": 152,
   7 |       "versionNonce": 953821790,
   8 |       "index": "b5P1",
   9 |       "isDeleted": false,
  10 |       "id": "2utGAh08_lCXe4fuxOrS8",
  11 |       "fillStyle": "solid",
  12 |       "strokeWidth": 1,
  13 |       "strokeStyle": "dashed",
  14 |       "roughness": 0,
  15 |       "opacity": 100,
  16 |       "angle": 0,
  17 |       "x": 2935.7715022862476,
  18 |       "y": -2359.6941648159655,
  19 |       "strokeColor": "#1e1e1e",
  20 |       "backgroundColor": "transparent",
  21 |       "width": 277.055908203125,
  22 |       "height": 45,
  23 |       "seed": 2095591707,
  24 |       "groupIds": [],
  25 |       "frameId": null,
  26 |       "roundness": null,
  27 |       "boundElements": [],
  28 |       "updated": 1715025890319,
  29 |       "link": null,
  30 |       "locked": false,
  31 |       "fontSize": 36,
  32 |       "fontFamily": 1,
  33 |       "text": "CairoVM Memory",
  34 |       "textAlign": "left",
  35 |       "verticalAlign": "top",
  36 |       "containerId": null,
  37 |       "originalText": "CairoVM Memory",
  38 |       "lineHeight": 1.25
  39 |     },
  40 |     {
  41 |       "type": "text",
  42 |       "version": 106,
  43 |       "versionNonce": 790703774,
  44 |       "index": "b5P2",
  45 |       "isDeleted": false,
  46 |       "id": "cVly1DW0kvAXpNUPLddPT",
  47 |       "fillStyle": "solid",
  48 |       "strokeWidth": 1,
  49 |       "strokeStyle": "dashed",
  50 |       "roughness": 0,
  51 |       "opacity": 100,
  52 |       "angle": 0,
  53 |       "x": 2675.7715022862476,
  54 |       "y": -2259.6941648159655,
  55 |       "strokeColor": "#1e1e1e",
  56 |       "backgroundColor": "transparent",
  57 |       "width": 141.34393310546875,
  58 |       "height": 20,
  59 |       "seed": 37267893,
  60 |       "groupIds": [],
  61 |       "frameId": null,
  62 |       "roundness": null,
  63 |       "boundElements": [],
  64 |       "updated": 1715025890319,
  65 |       "link": null,
  66 |       "locked": false,
  67 |       "fontSize": 16,
  68 |       "fontFamily": 1,
  69 |       "text": "execution segment",
  70 |       "textAlign": "left",
  71 |       "verticalAlign": "top",
  72 |       "containerId": null,
  73 |       "originalText": "execution segment",
  74 |       "lineHeight": 1.25
  75 |     },
  76 |     {
  77 |       "type": "text",
  78 |       "version": 274,
  79 |       "versionNonce": 108899038,
  80 |       "index": "b5P3",
  81 |       "isDeleted": false,
  82 |       "id": "0471SyrxtAjM9NZPoxxVY",
  83 |       "fillStyle": "solid",
  84 |       "strokeWidth": 1,
  85 |       "strokeStyle": "dashed",
  86 |       "roughness": 0,
  87 |       "opacity": 100,
  88 |       "angle": 0,
  89 |       "x": 2995.7715022862476,
  90 |       "y": -2279.6941648159655,
  91 |       "strokeColor": "#1e1e1e",
  92 |       "backgroundColor": "transparent",
  93 |       "width": 117.90391540527344,
  94 |       "height": 20,
  95 |       "seed": 537429243,
  96 |       "groupIds": [],
  97 |       "frameId": null,
  98 |       "roundness": null,
  99 |       "boundElements": [],
 100 |       "updated": 1715025890319,
 101 |       "link": null,
 102 |       "locked": false,
 103 |       "fontSize": 16,
 104 |       "fontFamily": 1,
 105 |       "text": "boxed_segment",
 106 |       "textAlign": "left",
 107 |       "verticalAlign": "top",
 108 |       "containerId": null,
 109 |       "originalText": "boxed_segment",
 110 |       "lineHeight": 1.25
 111 |     },
 112 |     {
 113 |       "type": "text",
 114 |       "version": 23,
 115 |       "versionNonce": 1837145886,
 116 |       "index": "b5P4",
 117 |       "isDeleted": false,
 118 |       "id": "CjTU9QS7VKNNPI_S5uoOr",
 119 |       "fillStyle": "solid",
 120 |       "strokeWidth": 2,
 121 |       "strokeStyle": "solid",
 122 |       "roughness": 0,
 123 |       "opacity": 100,
 124 |       "angle": 0,
 125 |       "x": 2855.7715022862476,
 126 |       "y": -2159.6941648159655,
 127 |       "strokeColor": "#1e1e1e",
 128 |       "backgroundColor": "transparent",
 129 |       "width": 89.95193481445312,
 130 |       "height": 20,
 131 |       "seed": 774575067,
 132 |       "groupIds": [],
 133 |       "frameId": null,
 134 |       "roundness": null,
 135 |       "boundElements": [],
 136 |       "updated": 1715025890319,
 137 |       "link": null,
 138 |       "locked": false,
 139 |       "fontSize": 16,
 140 |       "fontFamily": 1,
 141 |       "text": "new_struct",
 142 |       "textAlign": "left",
 143 |       "verticalAlign": "top",
 144 |       "containerId": null,
 145 |       "originalText": "new_struct",
 146 |       "lineHeight": 1.25
 147 |     },
 148 |     {
 149 |       "type": "line",
 150 |       "version": 87,
 151 |       "versionNonce": 412814174,
 152 |       "index": "b5P5",
 153 |       "isDeleted": false,
 154 |       "id": "ZVt9uZlnlESQG2d9htr7u",
 155 |       "fillStyle": "solid",
 156 |       "strokeWidth": 2,
 157 |       "strokeStyle": "solid",
 158 |       "roughness": 0,
 159 |       "opacity": 60,
 160 |       "angle": 0,
 161 |       "x": 2695.7715022862476,
 162 |       "y": -2139.6941648159655,
 163 |       "strokeColor": "#1e1e1e",
 164 |       "backgroundColor": "transparent",
 165 |       "width": 100.00000000000006,
 166 |       "height": 0,
 167 |       "seed": 691555387,
 168 |       "groupIds": [],
 169 |       "frameId": null,
 170 |       "roundness": { "type": 2 },
 171 |       "boundElements": [],
 172 |       "updated": 1715025890319,
 173 |       "link": null,
 174 |       "locked": false,
 175 |       "startBinding": null,
 176 |       "endBinding": null,
 177 |       "lastCommittedPoint": null,
 178 |       "startArrowhead": null,
 179 |       "endArrowhead": null,
 180 |       "points": [
 181 |         [0, 0],
 182 |         [100.00000000000006, 0]
 183 |       ]
 184 |     },
 185 |     {
 186 |       "type": "line",
 187 |       "version": 99,
 188 |       "versionNonce": 102625182,
 189 |       "index": "b5P6",
 190 |       "isDeleted": false,
 191 |       "id": "N6ChMLgvMa0DvRPqYxfnk",
 192 |       "fillStyle": "solid",
 193 |       "strokeWidth": 2,
 194 |       "strokeStyle": "solid",
 195 |       "roughness": 0,
 196 |       "opacity": 60,
 197 |       "angle": 0,
 198 |       "x": 2695.7715022862476,
 199 |       "y": -2099.6941648159655,
 200 |       "strokeColor": "#1e1e1e",
 201 |       "backgroundColor": "transparent",
 202 |       "width": 100.00000000000006,
 203 |       "height": 0,
 204 |       "seed": 435191445,
 205 |       "groupIds": [],
 206 |       "frameId": null,
 207 |       "roundness": { "type": 2 },
 208 |       "boundElements": [],
 209 |       "updated": 1715025890319,
 210 |       "link": null,
 211 |       "locked": false,
 212 |       "startBinding": null,
 213 |       "endBinding": null,
 214 |       "lastCommittedPoint": null,
 215 |       "startArrowhead": null,
 216 |       "endArrowhead": null,
 217 |       "points": [
 218 |         [0, 0],
 219 |         [100.00000000000006, 0]
 220 |       ]
 221 |     },
 222 |     {
 223 |       "type": "line",
 224 |       "version": 104,
 225 |       "versionNonce": 1111116766,
 226 |       "index": "b5P7",
 227 |       "isDeleted": false,
 228 |       "id": "9ufp3ZxsQRKCVUkIQpSue",
 229 |       "fillStyle": "solid",
 230 |       "strokeWidth": 2,
 231 |       "strokeStyle": "solid",
 232 |       "roughness": 0,
 233 |       "opacity": 60,
 234 |       "angle": 0,
 235 |       "x": 2695.7715022862476,
 236 |       "y": -2059.6941648159655,
 237 |       "strokeColor": "#1e1e1e",
 238 |       "backgroundColor": "transparent",
 239 |       "width": 100.00000000000006,
 240 |       "height": 0,
 241 |       "seed": 175830587,
 242 |       "groupIds": [],
 243 |       "frameId": null,
 244 |       "roundness": { "type": 2 },
 245 |       "boundElements": [],
 246 |       "updated": 1715025890319,
 247 |       "link": null,
 248 |       "locked": false,
 249 |       "startBinding": null,
 250 |       "endBinding": null,
 251 |       "lastCommittedPoint": null,
 252 |       "startArrowhead": null,
 253 |       "endArrowhead": null,
 254 |       "points": [
 255 |         [0, 0],
 256 |         [100.00000000000006, 0]
 257 |       ]
 258 |     },
 259 |     {
 260 |       "type": "line",
 261 |       "version": 119,
 262 |       "versionNonce": 721494046,
 263 |       "index": "b5P8",
 264 |       "isDeleted": false,
 265 |       "id": "JgF4kqg54LmYLcOX5tbiy",
 266 |       "fillStyle": "solid",
 267 |       "strokeWidth": 2,
 268 |       "strokeStyle": "solid",
 269 |       "roughness": 0,
 270 |       "opacity": 60,
 271 |       "angle": 0,
 272 |       "x": 2695.7715022862476,
 273 |       "y": -2019.6941648159655,
 274 |       "strokeColor": "#1e1e1e",
 275 |       "backgroundColor": "transparent",
 276 |       "width": 100.00000000000006,
 277 |       "height": 0,
 278 |       "seed": 1697438197,
 279 |       "groupIds": [],
 280 |       "frameId": null,
 281 |       "roundness": { "type": 2 },
 282 |       "boundElements": [],
 283 |       "updated": 1715025890319,
 284 |       "link": null,
 285 |       "locked": false,
 286 |       "startBinding": null,
 287 |       "endBinding": null,
 288 |       "lastCommittedPoint": null,
 289 |       "startArrowhead": null,
 290 |       "endArrowhead": null,
 291 |       "points": [
 292 |         [0, 0],
 293 |         [100.00000000000006, 0]
 294 |       ]
 295 |     },
 296 |     {
 297 |       "type": "line",
 298 |       "version": 128,
 299 |       "versionNonce": 878931038,
 300 |       "index": "b5P8V",
 301 |       "isDeleted": false,
 302 |       "id": "BNiMCidx9Mxpa8vUbl2k_",
 303 |       "fillStyle": "solid",
 304 |       "strokeWidth": 2,
 305 |       "strokeStyle": "solid",
 306 |       "roughness": 0,
 307 |       "opacity": 60,
 308 |       "angle": 0,
 309 |       "x": 2695.7715022862476,
 310 |       "y": -1979.6941648159655,
 311 |       "strokeColor": "#1e1e1e",
 312 |       "backgroundColor": "transparent",
 313 |       "width": 100.00000000000006,
 314 |       "height": 0,
 315 |       "seed": 685124283,
 316 |       "groupIds": [],
 317 |       "frameId": null,
 318 |       "roundness": { "type": 2 },
 319 |       "boundElements": [],
 320 |       "updated": 1715025890319,
 321 |       "link": null,
 322 |       "locked": false,
 323 |       "startBinding": null,
 324 |       "endBinding": null,
 325 |       "lastCommittedPoint": null,
 326 |       "startArrowhead": null,
 327 |       "endArrowhead": null,
 328 |       "points": [
 329 |         [0, 0],
 330 |         [100.00000000000006, 0]
 331 |       ]
 332 |     },
 333 |     {
 334 |       "type": "text",
 335 |       "version": 154,
 336 |       "versionNonce": 741486750,
 337 |       "index": "b5P9",
 338 |       "isDeleted": false,
 339 |       "id": "Cp5-Dfr6z2J2QaXjtj8iI",
 340 |       "fillStyle": "solid",
 341 |       "strokeWidth": 2,
 342 |       "strokeStyle": "solid",
 343 |       "roughness": 0,
 344 |       "opacity": 100,
 345 |       "angle": 0,
 346 |       "x": 2715.7715022862476,
 347 |       "y": -2219.6941648159655,
 348 |       "strokeColor": "#1971c2",
 349 |       "backgroundColor": "transparent",
 350 |       "width": 42.199951171875,
 351 |       "height": 25.000000000000007,
 352 |       "seed": 1795423899,
 353 |       "groupIds": [],
 354 |       "frameId": null,
 355 |       "roundness": null,
 356 |       "boundElements": [],
 357 |       "updated": 1715025890319,
 358 |       "link": null,
 359 |       "locked": false,
 360 |       "fontSize": 20.000000000000007,
 361 |       "fontFamily": 1,
 362 |       "text": "true",
 363 |       "textAlign": "left",
 364 |       "verticalAlign": "top",
 365 |       "containerId": null,
 366 |       "originalText": "true",
 367 |       "lineHeight": 1.25
 368 |     },
 369 |     {
 370 |       "type": "text",
 371 |       "version": 67,
 372 |       "versionNonce": 2115923166,
 373 |       "index": "b5PA",
 374 |       "isDeleted": false,
 375 |       "id": "jOT_PzKIRHv06pd57x6R0",
 376 |       "fillStyle": "solid",
 377 |       "strokeWidth": 2,
 378 |       "strokeStyle": "solid",
 379 |       "roughness": 0,
 380 |       "opacity": 100,
 381 |       "angle": 0,
 382 |       "x": 2735.7715022862476,
 383 |       "y": -2179.6941648159655,
 384 |       "strokeColor": "#1971c2",
 385 |       "backgroundColor": "transparent",
 386 |       "width": 5.4199981689453125,
 387 |       "height": 25.000000000000007,
 388 |       "seed": 1193035835,
 389 |       "groupIds": [],
 390 |       "frameId": null,
 391 |       "roundness": null,
 392 |       "boundElements": [],
 393 |       "updated": 1715025890319,
 394 |       "link": null,
 395 |       "locked": false,
 396 |       "fontSize": 20.000000000000007,
 397 |       "fontFamily": 1,
 398 |       "text": "1",
 399 |       "textAlign": "left",
 400 |       "verticalAlign": "top",
 401 |       "containerId": null,
 402 |       "originalText": "1",
 403 |       "lineHeight": 1.25
 404 |     },
 405 |     {
 406 |       "type": "text",
 407 |       "version": 79,
 408 |       "versionNonce": 1550993118,
 409 |       "index": "b5PB",
 410 |       "isDeleted": false,
 411 |       "id": "5byUTGoDMoO3c53yUsfBc",
 412 |       "fillStyle": "solid",
 413 |       "strokeWidth": 2,
 414 |       "strokeStyle": "solid",
 415 |       "roughness": 0,
 416 |       "opacity": 100,
 417 |       "angle": 0,
 418 |       "x": 2715.7715022862476,
 419 |       "y": -2139.3114203403798,
 420 |       "strokeColor": "#1971c2",
 421 |       "backgroundColor": "transparent",
 422 |       "width": 33.75996398925781,
 423 |       "height": 25.000000000000018,
 424 |       "seed": 1117682773,
 425 |       "groupIds": [],
 426 |       "frameId": null,
 427 |       "roundness": null,
 428 |       "boundElements": [],
 429 |       "updated": 1715025903035,
 430 |       "link": null,
 431 |       "locked": false,
 432 |       "fontSize": 20.000000000000014,
 433 |       "fontFamily": 1,
 434 |       "text": "'Eli'",
 435 |       "textAlign": "left",
 436 |       "verticalAlign": "top",
 437 |       "containerId": null,
 438 |       "originalText": "'Eli'",
 439 |       "lineHeight": 1.25
 440 |     },
 441 |     {
 442 |       "type": "freedraw",
 443 |       "version": 112,
 444 |       "versionNonce": 208883038,
 445 |       "index": "b5PC",
 446 |       "isDeleted": false,
 447 |       "id": "cnVIV7jw4TRlrIWe3I1Qj",
 448 |       "fillStyle": "solid",
 449 |       "strokeWidth": 1,
 450 |       "strokeStyle": "solid",
 451 |       "roughness": 0,
 452 |       "opacity": 100,
 453 |       "angle": 0,
 454 |       "x": 2715.7715022862476,
 455 |       "y": -2079.6941648159655,
 456 |       "strokeColor": "#1e1e1e",
 457 |       "backgroundColor": "transparent",
 458 |       "width": 0.0001,
 459 |       "height": 0.0001,
 460 |       "seed": 272976091,
 461 |       "groupIds": ["K5iVIx0oyenpYGiVUUH9_"],
 462 |       "frameId": null,
 463 |       "roundness": null,
 464 |       "boundElements": [],
 465 |       "updated": 1715025890319,
 466 |       "link": null,
 467 |       "locked": false,
 468 |       "points": [
 469 |         [0, 0],
 470 |         [0.0001, 0.0001]
 471 |       ],
 472 |       "lastCommittedPoint": null,
 473 |       "simulatePressure": true,
 474 |       "pressures": []
 475 |     },
 476 |     {
 477 |       "type": "freedraw",
 478 |       "version": 114,
 479 |       "versionNonce": 429781406,
 480 |       "index": "b5PD",
 481 |       "isDeleted": false,
 482 |       "id": "YlPfccfvYSAKDSmxLL6yB",
 483 |       "fillStyle": "solid",
 484 |       "strokeWidth": 1,
 485 |       "strokeStyle": "solid",
 486 |       "roughness": 0,
 487 |       "opacity": 100,
 488 |       "angle": 0,
 489 |       "x": 2735.7715022862476,
 490 |       "y": -2079.6941648159655,
 491 |       "strokeColor": "#1e1e1e",
 492 |       "backgroundColor": "transparent",
 493 |       "width": 0.0001,
 494 |       "height": 0.0001,
 495 |       "seed": 2086787317,
 496 |       "groupIds": ["K5iVIx0oyenpYGiVUUH9_"],
 497 |       "frameId": null,
 498 |       "roundness": null,
 499 |       "boundElements": [],
 500 |       "updated": 1715025890319,
 501 |       "link": null,
 502 |       "locked": false,
 503 |       "points": [
 504 |         [0, 0],
 505 |         [0.0001, 0.0001]
 506 |       ],
 507 |       "lastCommittedPoint": null,
 508 |       "simulatePressure": true,
 509 |       "pressures": []
 510 |     },
 511 |     {
 512 |       "type": "freedraw",
 513 |       "version": 116,
 514 |       "versionNonce": 711593438,
 515 |       "index": "b5PE",
 516 |       "isDeleted": false,
 517 |       "id": "vmI5h1oRWw4d3-FW1rOsW",
 518 |       "fillStyle": "solid",
 519 |       "strokeWidth": 1,
 520 |       "strokeStyle": "solid",
 521 |       "roughness": 0,
 522 |       "opacity": 100,
 523 |       "angle": 0,
 524 |       "x": 2755.7715022862476,
 525 |       "y": -2079.6941648159655,
 526 |       "strokeColor": "#1e1e1e",
 527 |       "backgroundColor": "transparent",
 528 |       "width": 0.0001,
 529 |       "height": 0.0001,
 530 |       "seed": 1515774491,
 531 |       "groupIds": ["K5iVIx0oyenpYGiVUUH9_"],
 532 |       "frameId": null,
 533 |       "roundness": null,
 534 |       "boundElements": [],
 535 |       "updated": 1715025890319,
 536 |       "link": null,
 537 |       "locked": false,
 538 |       "points": [
 539 |         [0, 0],
 540 |         [0.0001, 0.0001]
 541 |       ],
 542 |       "lastCommittedPoint": null,
 543 |       "simulatePressure": true,
 544 |       "pressures": []
 545 |     },
 546 |     {
 547 |       "type": "text",
 548 |       "version": 89,
 549 |       "versionNonce": 1005101598,
 550 |       "index": "b5PF",
 551 |       "isDeleted": false,
 552 |       "id": "HwrfJOXsdEF14ecQJaxIj",
 553 |       "fillStyle": "solid",
 554 |       "strokeWidth": 2,
 555 |       "strokeStyle": "solid",
 556 |       "roughness": 0,
 557 |       "opacity": 100,
 558 |       "angle": 0,
 559 |       "x": 2715.7715022862476,
 560 |       "y": -2019.6941648159655,
 561 |       "strokeColor": "#2f9e44",
 562 |       "backgroundColor": "transparent",
 563 |       "width": 50.11994934082031,
 564 |       "height": 25.000000000000007,
 565 |       "seed": 596612315,
 566 |       "groupIds": [],
 567 |       "frameId": null,
 568 |       "roundness": null,
 569 |       "boundElements": [],
 570 |       "updated": 1715025890319,
 571 |       "link": null,
 572 |       "locked": false,
 573 |       "fontSize": 20.000000000000007,
 574 |       "fontFamily": 1,
 575 |       "text": "false",
 576 |       "textAlign": "left",
 577 |       "verticalAlign": "top",
 578 |       "containerId": null,
 579 |       "originalText": "false",
 580 |       "lineHeight": 1.25
 581 |     },
 582 |     {
 583 |       "type": "text",
 584 |       "version": 94,
 585 |       "versionNonce": 17477214,
 586 |       "index": "b5PG",
 587 |       "isDeleted": false,
 588 |       "id": "Y-yrHGcxrZEDSzs9UzCJm",
 589 |       "fillStyle": "solid",
 590 |       "strokeWidth": 2,
 591 |       "strokeStyle": "solid",
 592 |       "roughness": 0,
 593 |       "opacity": 100,
 594 |       "angle": 0,
 595 |       "x": 2735.7715022862476,
 596 |       "y": -1979.6941648159655,
 597 |       "strokeColor": "#2f9e44",
 598 |       "backgroundColor": "transparent",
 599 |       "width": 14.239990234375,
 600 |       "height": 25.000000000000007,
 601 |       "seed": 819748277,
 602 |       "groupIds": [],
 603 |       "frameId": null,
 604 |       "roundness": null,
 605 |       "boundElements": [],
 606 |       "updated": 1715025890319,
 607 |       "link": null,
 608 |       "locked": false,
 609 |       "fontSize": 20.000000000000007,
 610 |       "fontFamily": 1,
 611 |       "text": "2",
 612 |       "textAlign": "left",
 613 |       "verticalAlign": "top",
 614 |       "containerId": null,
 615 |       "originalText": "2",
 616 |       "lineHeight": 1.25
 617 |     },
 618 |     {
 619 |       "type": "line",
 620 |       "version": 136,
 621 |       "versionNonce": 648098462,
 622 |       "index": "b5PGV",
 623 |       "isDeleted": false,
 624 |       "id": "Txp47K2nVmMWfNTiOlR_L",
 625 |       "fillStyle": "solid",
 626 |       "strokeWidth": 2,
 627 |       "strokeStyle": "solid",
 628 |       "roughness": 0,
 629 |       "opacity": 60,
 630 |       "angle": 0,
 631 |       "x": 2695.7715022862476,
 632 |       "y": -1939.6941648159655,
 633 |       "strokeColor": "#1e1e1e",
 634 |       "backgroundColor": "transparent",
 635 |       "width": 100.00000000000006,
 636 |       "height": 0,
 637 |       "seed": 405757371,
 638 |       "groupIds": [],
 639 |       "frameId": null,
 640 |       "roundness": { "type": 2 },
 641 |       "boundElements": [],
 642 |       "updated": 1715025890319,
 643 |       "link": null,
 644 |       "locked": false,
 645 |       "startBinding": null,
 646 |       "endBinding": null,
 647 |       "lastCommittedPoint": null,
 648 |       "startArrowhead": null,
 649 |       "endArrowhead": null,
 650 |       "points": [
 651 |         [0, 0],
 652 |         [100.00000000000006, 0]
 653 |       ]
 654 |     },
 655 |     {
 656 |       "type": "line",
 657 |       "version": 184,
 658 |       "versionNonce": 391982814,
 659 |       "index": "b5PH",
 660 |       "isDeleted": false,
 661 |       "id": "03dJlN4BCkCUmBFW6E-Uw",
 662 |       "fillStyle": "solid",
 663 |       "strokeWidth": 2,
 664 |       "strokeStyle": "solid",
 665 |       "roughness": 0,
 666 |       "opacity": 60,
 667 |       "angle": 0,
 668 |       "x": 2695.7715022862476,
 669 |       "y": -1899.6941648159655,
 670 |       "strokeColor": "#1e1e1e",
 671 |       "backgroundColor": "transparent",
 672 |       "width": 100.00000000000006,
 673 |       "height": 0,
 674 |       "seed": 668387483,
 675 |       "groupIds": [],
 676 |       "frameId": null,
 677 |       "roundness": { "type": 2 },
 678 |       "boundElements": [],
 679 |       "updated": 1715025890319,
 680 |       "link": null,
 681 |       "locked": false,
 682 |       "startBinding": null,
 683 |       "endBinding": null,
 684 |       "lastCommittedPoint": null,
 685 |       "startArrowhead": null,
 686 |       "endArrowhead": null,
 687 |       "points": [
 688 |         [0, 0],
 689 |         [40, 0],
 690 |         [100.00000000000006, 0]
 691 |       ]
 692 |     },
 693 |     {
 694 |       "type": "text",
 695 |       "version": 47,
 696 |       "versionNonce": 1060241502,
 697 |       "index": "b5PI",
 698 |       "isDeleted": false,
 699 |       "id": "p8YsYVIfPlSRLil-DqQ9c",
 700 |       "fillStyle": "solid",
 701 |       "strokeWidth": 1,
 702 |       "strokeStyle": "solid",
 703 |       "roughness": 0,
 704 |       "opacity": 100,
 705 |       "angle": 0,
 706 |       "x": 2715.7715022862476,
 707 |       "y": -1940.0829846006873,
 708 |       "strokeColor": "#2f9e44",
 709 |       "backgroundColor": "transparent",
 710 |       "width": 30.319976806640625,
 711 |       "height": 20,
 712 |       "seed": 1331707291,
 713 |       "groupIds": [],
 714 |       "frameId": null,
 715 |       "roundness": null,
 716 |       "boundElements": [],
 717 |       "updated": 1715025895444,
 718 |       "link": null,
 719 |       "locked": false,
 720 |       "fontSize": 16,
 721 |       "fontFamily": 1,
 722 |       "text": "'Uri'",
 723 |       "textAlign": "left",
 724 |       "verticalAlign": "top",
 725 |       "containerId": null,
 726 |       "originalText": "'Uri'",
 727 |       "lineHeight": 1.25
 728 |     },
 729 |     {
 730 |       "type": "freedraw",
 731 |       "version": 18,
 732 |       "versionNonce": 1382649694,
 733 |       "index": "b5PJ",
 734 |       "isDeleted": false,
 735 |       "id": "2reeo7qPdABCwxQ3FPE8g",
 736 |       "fillStyle": "solid",
 737 |       "strokeWidth": 1,
 738 |       "strokeStyle": "solid",
 739 |       "roughness": 0,
 740 |       "opacity": 100,
 741 |       "angle": 0,
 742 |       "x": 2715.8327591672346,
 743 |       "y": -2040.2816791522607,
 744 |       "strokeColor": "#1e1e1e",
 745 |       "backgroundColor": "transparent",
 746 |       "width": 0.0001,
 747 |       "height": 0.0001,
 748 |       "seed": 1858147867,
 749 |       "groupIds": [],
 750 |       "frameId": null,
 751 |       "roundness": null,
 752 |       "boundElements": [],
 753 |       "updated": 1715025890319,
 754 |       "link": null,
 755 |       "locked": false,
 756 |       "points": [
 757 |         [0, 0],
 758 |         [0.0001, 0.0001]
 759 |       ],
 760 |       "lastCommittedPoint": null,
 761 |       "simulatePressure": true,
 762 |       "pressures": []
 763 |     },
 764 |     {
 765 |       "type": "freedraw",
 766 |       "version": 18,
 767 |       "versionNonce": 192672670,
 768 |       "index": "b5PK",
 769 |       "isDeleted": false,
 770 |       "id": "tU3wSE27JEdZjjbK7x_Go",
 771 |       "fillStyle": "solid",
 772 |       "strokeWidth": 1,
 773 |       "strokeStyle": "solid",
 774 |       "roughness": 0,
 775 |       "opacity": 100,
 776 |       "angle": 0,
 777 |       "x": 2735.7797118081717,
 778 |       "y": -2040.2816791522607,
 779 |       "strokeColor": "#1e1e1e",
 780 |       "backgroundColor": "transparent",
 781 |       "width": 0.0001,
 782 |       "height": 0.0001,
 783 |       "seed": 613050677,
 784 |       "groupIds": [],
 785 |       "frameId": null,
 786 |       "roundness": null,
 787 |       "boundElements": [],
 788 |       "updated": 1715025890319,
 789 |       "link": null,
 790 |       "locked": false,
 791 |       "points": [
 792 |         [0, 0],
 793 |         [0.0001, 0.0001]
 794 |       ],
 795 |       "lastCommittedPoint": null,
 796 |       "simulatePressure": true,
 797 |       "pressures": []
 798 |     },
 799 |     {
 800 |       "type": "freedraw",
 801 |       "version": 18,
 802 |       "versionNonce": 1966591966,
 803 |       "index": "b5PL",
 804 |       "isDeleted": false,
 805 |       "id": "jbrVO08dLeufVbnhnyHUh",
 806 |       "fillStyle": "solid",
 807 |       "strokeWidth": 1,
 808 |       "strokeStyle": "solid",
 809 |       "roughness": 0,
 810 |       "opacity": 100,
 811 |       "angle": 0,
 812 |       "x": 2756.3179175876044,
 813 |       "y": -2040.2816791522607,
 814 |       "strokeColor": "#1e1e1e",
 815 |       "backgroundColor": "transparent",
 816 |       "width": 0.0001,
 817 |       "height": 0.0001,
 818 |       "seed": 1190597243,
 819 |       "groupIds": [],
 820 |       "frameId": null,
 821 |       "roundness": null,
 822 |       "boundElements": [],
 823 |       "updated": 1715025890319,
 824 |       "link": null,
 825 |       "locked": false,
 826 |       "points": [
 827 |         [0, 0],
 828 |         [0.0001, 0.0001]
 829 |       ],
 830 |       "lastCommittedPoint": null,
 831 |       "simulatePressure": true,
 832 |       "pressures": []
 833 |     },
 834 |     {
 835 |       "type": "freedraw",
 836 |       "version": 167,
 837 |       "versionNonce": 732832798,
 838 |       "index": "b5PM",
 839 |       "isDeleted": false,
 840 |       "id": "U80Z1-xyQtxcfXSh4bGhN",
 841 |       "fillStyle": "solid",
 842 |       "strokeWidth": 1,
 843 |       "strokeStyle": "solid",
 844 |       "roughness": 0,
 845 |       "opacity": 70,
 846 |       "angle": 0,
 847 |       "x": 2809.205069518923,
 848 |       "y": -2216.5354728314433,
 849 |       "strokeColor": "#1e1e1e",
 850 |       "backgroundColor": "transparent",
 851 |       "width": 26.193049441736548,
 852 |       "height": 118.39330084876565,
 853 |       "seed": 1728088533,
 854 |       "groupIds": [],
 855 |       "frameId": null,
 856 |       "roundness": null,
 857 |       "boundElements": [],
 858 |       "updated": 1715025890319,
 859 |       "link": null,
 860 |       "locked": false,
 861 |       "points": [
 862 |         [0, 0],
 863 |         [-0.09266056518254118, 0],
 864 |         [0.08518793895837007, 0],
 865 |         [0.44088494723928306, 0],
 866 |         [1.3510508213698813, 0],
 867 |         [2.486890007477541, 0],
 868 |         [3.8723149094798828, 0],
 869 |         [6.124564453511084, -0.16290325169211428],
 870 |         [8.399231876215708, 0.4857207045852192],
 871 |         [9.527598436099197, 1.0491567219041826],
 872 |         [10.092528978662813, 1.6140872644682531],
 873 |         [10.657459521226883, 2.03703790876898],
 874 |         [11.08041016552761, 2.6019684513330503],
 875 |         [11.319534204707907, 2.9606545101037227],
 876 |         [12.011499393086524, 4.17271448370002],
 877 |         [12.151984766105215, 4.878130399282327],
 878 |         [12.292470139123907, 5.583546314865089],
 879 |         [12.74680581356688, 6.493712188995687],
 880 |         [12.74680581356688, 7.40387806312674],
 881 |         [12.908214540013432, 8.541211774479052],
 882 |         [13.080084943174825, 9.926636676481394],
 883 |         [13.404396921313037, 11.063970387833706],
 884 |         [13.58672900118836, 12.715420783424179],
 885 |         [13.770555606308335, 14.369860229504411],
 886 |         [13.964843888142696, 16.31423757309085],
 887 |         [14.136714291303633, 17.699662475092737],
 888 |         [14.320540896423609, 19.354101921173424],
 889 |         [14.492411299584546, 20.73952682317531],
 890 |         [14.492411299584546, 22.124951725177652],
 891 |         [14.632896672603238, 22.83036764075996],
 892 |         [14.632896672603238, 23.96770135211227],
 893 |         [14.827184954437143, 25.912078695699165],
 894 |         [14.827184954437143, 27.049412407051477],
 895 |         [14.98859368088415, 28.18674611840379],
 896 |         [15.160464084045088, 29.572171020405676],
 897 |         [15.321872810492096, 30.70950473175799],
 898 |         [15.493743213653033, 33.48035453576267],
 899 |         [15.665613616813971, 34.86577943776456],
 900 |         [15.837484019974909, 36.2512043397669],
 901 |         [16.009354423135846, 37.63662924176879],
 902 |         [16.19318102825582, 39.29106868784902],
 903 |         [16.35458975470283, 40.42840239920133],
 904 |         [16.526460157863767, 41.81382730120367],
 905 |         [16.698330561024704, 43.19925220320556],
 906 |         [17.02264253916337, 44.33658591455787],
 907 |         [17.367877870730354, 45.722010816560214],
 908 |         [17.886478130702926, 47.107435718562556],
 909 |         [18.25413134094333, 48.76187516464233],
 910 |         [18.772731600915904, 50.147300066644675],
 911 |         [19.32421141627583, 51.80173951272491],
 912 |         [19.87569123163621, 53.45617895880514],
 913 |         [20.15815650291779, 54.16159487438745],
 914 |         [20.645371732748117, 55.298928585740214],
 915 |         [21.09970740719109, 56.20909445987081],
 916 |         [21.554043081634063, 57.119260334001865],
 917 |         [21.97699372593479, 57.82467624958417],
 918 |         [22.399944370235517, 58.530092165166934],
 919 |         [22.639068409415813, 58.88877822393761],
 920 |         [23.03063402357384, 59.28034383809563],
 921 |         [23.26975806275459, 59.639029896866305],
 922 |         [23.628444121525263, 59.878153936047056],
 923 |         [23.8466448072777, 60.09635462179904],
 924 |         [24.06484549302968, 60.31455530755147],
 925 |         [24.42353155180035, 60.43411732714185],
 926 |         [24.641732237552787, 60.54321767001784],
 927 |         [24.85993292330477, 60.65231801289383],
 928 |         [25.078133609057204, 60.76141835576982],
 929 |         [25.296334294809185, 60.870518698646265],
 930 |         [25.51453498056162, 60.979619041522255],
 931 |         [25.61317364672368, 61.078257707684315],
 932 |         [25.810450979047346, 61.078257707684315],
 933 |         [25.909089645209406, 61.078257707684315],
 934 |         [26.007728311371466, 61.078257707684315],
 935 |         [26.100388876554007, 61.078257707684315],
 936 |         [26.010717361861225, 61.16643469713199],
 937 |         [25.900122493740128, 61.384635382884426],
 938 |         [25.397962011461004, 62.26341622687278],
 939 |         [25.1573434470356, 62.62210228564345],
 940 |         [24.89580152918188, 63.14369159610578],
 941 |         [24.244188522415243, 64.11812205576643],
 942 |         [23.982646604561523, 64.63971136622922],
 943 |         [23.69868680803438, 65.34512728181153],
 944 |         [23.00522709441111, 66.73055218381387],
 945 |         [22.873708872861698, 67.2521414942762],
 946 |         [22.18024915923843, 68.4642014678725],
 947 |         [22.048730937689015, 68.98579077833529],
 948 |         [21.743847787734012, 69.89595665246588],
 949 |         [21.438964637778554, 70.80612252659694],
 950 |         [21.28652306280128, 71.71628840072754],
 951 |         [20.960716559417506, 72.85362211207985],
 952 |         [20.655833409462502, 73.7637879862109],
 953 |         [20.503391834484773, 74.6739538603415],
 954 |         [20.37187361293536, 75.19554317080429],
 955 |         [20.002725877450757, 76.84998261688452],
 956 |         [19.850284302473028, 77.76014849101512],
 957 |         [19.718766080923615, 78.2817378014779],
 958 |         [19.533444950558987, 79.93617724755813],
 959 |         [19.533444950558987, 80.45776655802047],
 960 |         [19.370541698867328, 81.59510026937278],
 961 |         [19.2181001238896, 82.50526614350383],
 962 |         [19.2181001238896, 83.89069104550572],
 963 |         [19.05519687219794, 85.02802475685803],
 964 |         [19.05519687219794, 85.93819063098908],
 965 |         [19.05519687219794, 86.64360654657139],
 966 |         [18.90275529722021, 87.55377242070244],
 967 |         [18.90275529722021, 89.20821186678268],
 968 |         [18.58741047055082, 91.25571145226604],
 969 |         [18.58741047055082, 92.64113635426793],
 970 |         [18.58741047055082, 93.77847006562024],
 971 |         [18.58741047055082, 95.16389496762258],
 972 |         [18.41404554214523, 96.54931986962447],
 973 |         [18.41404554214523, 97.93474477162681],
 974 |         [18.41404554214523, 99.58918421770704],
 975 |         [18.41404554214523, 100.97460911970938],
 976 |         [18.41404554214523, 102.36003402171127],
 977 |         [18.41404554214523, 103.74545892371361],
 978 |         [18.41404554214523, 104.45087483929592],
 979 |         [18.41404554214523, 105.58820855064823],
 980 |         [18.41404554214523, 106.72554226200054],
 981 |         [18.41404554214523, 108.77304184748391],
 982 |         [18.41404554214523, 109.68320772161496],
 983 |         [18.41404554214523, 110.38862363719727],
 984 |         [18.41404554214523, 111.09403955277958],
 985 |         [18.41404554214523, 111.79945546836234],
 986 |         [18.41404554214523, 112.32104477882467],
 987 |         [18.41404554214523, 112.84263408928746],
 988 |         [18.41404554214523, 113.54805000486976],
 989 |         [18.29298899730975, 113.90673606364089],
 990 |         [18.16147077576079, 114.42832537410322],
 991 |         [17.89992885790707, 114.94991468456556],
 992 |         [17.778872313072043, 115.30860074333668],
 993 |         [17.65781576823656, 115.66728680210736],
 994 |         [17.438120557239472, 115.88548748785934],
 995 |         [17.197501992814068, 116.24417354663001],
 996 |         [16.97780678181698, 116.46237423238244],
 997 |         [16.6176261978012, 116.7014982715632],
 998 |         [16.257445613785876, 116.94062231074349],
 999 |         [15.897265029770097, 117.17974634992424],
1000 |         [15.190354588942682, 117.32023172294248],
1001 |         [14.667270753235243, 117.45025541924679],
1002 |         [13.960360312407829, 117.59074079226548],
1003 |         [13.253449871580415, 117.73122616528417],
1004 |         [12.730366035872976, 117.86124986158848],
1005 |         [12.207282200165537, 117.99127355789278],
1006 |         [11.46450315346101, 118.23039759707353],
1007 |         [11.244807942463922, 118.23039759707353],
1008 |         [11.244807942463922, 118.23039759707353]
1009 |       ],
1010 |       "lastCommittedPoint": null,
1011 |       "simulatePressure": true,
1012 |       "pressures": []
1013 |     },
1014 |     {
1015 |       "type": "text",
1016 |       "version": 130,
1017 |       "versionNonce": 550498398,
1018 |       "index": "b5PN",
1019 |       "isDeleted": false,
1020 |       "id": "NpS170e-J7ojm20UnTk82",
1021 |       "fillStyle": "solid",
1022 |       "strokeWidth": 2,
1023 |       "strokeStyle": "solid",
1024 |       "roughness": 0,
1025 |       "opacity": 100,
1026 |       "angle": 0,
1027 |       "x": 3015.7715022862476,
1028 |       "y": -2219.6941648159655,
1029 |       "strokeColor": "#2f9e44",
1030 |       "backgroundColor": "transparent",
1031 |       "width": 50.11994934082031,
1032 |       "height": 25.000000000000007,
1033 |       "seed": 810363035,
1034 |       "groupIds": [],
1035 |       "frameId": null,
1036 |       "roundness": null,
1037 |       "boundElements": [],
1038 |       "updated": 1715025890319,
1039 |       "link": null,
1040 |       "locked": false,
1041 |       "fontSize": 20.000000000000007,
1042 |       "fontFamily": 1,
1043 |       "text": "false",
1044 |       "textAlign": "left",
1045 |       "verticalAlign": "top",
1046 |       "containerId": null,
1047 |       "originalText": "false",
1048 |       "lineHeight": 1.25
1049 |     },
1050 |     {
1051 |       "type": "text",
1052 |       "version": 133,
1053 |       "versionNonce": 1617835166,
1054 |       "index": "b5PO",
1055 |       "isDeleted": false,
1056 |       "id": "Coz2s0OJQ2R7Kyzr0KeJC",
1057 |       "fillStyle": "solid",
1058 |       "strokeWidth": 2,
1059 |       "strokeStyle": "solid",
1060 |       "roughness": 0,
1061 |       "opacity": 100,
1062 |       "angle": 0,
1063 |       "x": 3035.7715022862476,
1064 |       "y": -2179.6941648159655,
1065 |       "strokeColor": "#2f9e44",
1066 |       "backgroundColor": "transparent",
1067 |       "width": 14.239990234375,
1068 |       "height": 25.000000000000007,
1069 |       "seed": 326327611,
1070 |       "groupIds": [],
1071 |       "frameId": null,
1072 |       "roundness": null,
1073 |       "boundElements": [],
1074 |       "updated": 1715025890319,
1075 |       "link": null,
1076 |       "locked": false,
1077 |       "fontSize": 20.000000000000007,
1078 |       "fontFamily": 1,
1079 |       "text": "2",
1080 |       "textAlign": "left",
1081 |       "verticalAlign": "top",
1082 |       "containerId": null,
1083 |       "originalText": "2",
1084 |       "lineHeight": 1.25
1085 |     },
1086 |     {
1087 |       "type": "line",
1088 |       "version": 224,
1089 |       "versionNonce": 1413083358,
1090 |       "index": "b5PP",
1091 |       "isDeleted": false,
1092 |       "id": "CdesLUJowEIbW32ZFP5bq",
1093 |       "fillStyle": "solid",
1094 |       "strokeWidth": 2,
1095 |       "strokeStyle": "solid",
1096 |       "roughness": 0,
1097 |       "opacity": 60,
1098 |       "angle": 0,
1099 |       "x": 2995.7715022862476,
1100 |       "y": -2179.6941648159655,
1101 |       "strokeColor": "#1e1e1e",
1102 |       "backgroundColor": "transparent",
1103 |       "width": 100.00000000000006,
1104 |       "height": 0,
1105 |       "seed": 1764359643,
1106 |       "groupIds": [],
1107 |       "frameId": null,
1108 |       "roundness": { "type": 2 },
1109 |       "boundElements": [],
1110 |       "updated": 1715025890319,
1111 |       "link": null,
1112 |       "locked": false,
1113 |       "startBinding": null,
1114 |       "endBinding": null,
1115 |       "lastCommittedPoint": null,
1116 |       "startArrowhead": null,
1117 |       "endArrowhead": null,
1118 |       "points": [
1119 |         [0, 0],
1120 |         [40, 0],
1121 |         [100.00000000000006, 0]
1122 |       ]
1123 |     },
1124 |     {
1125 |       "type": "text",
1126 |       "version": 89,
1127 |       "versionNonce": 657350850,
1128 |       "index": "b5PQ",
1129 |       "isDeleted": false,
1130 |       "id": "hpPST94nAkRVke0YakFzw",
1131 |       "fillStyle": "solid",
1132 |       "strokeWidth": 1,
1133 |       "strokeStyle": "solid",
1134 |       "roughness": 0,
1135 |       "opacity": 100,
1136 |       "angle": 0,
1137 |       "x": 3015.7715022862476,
1138 |       "y": -2139.6941648159655,
1139 |       "strokeColor": "#2f9e44",
1140 |       "backgroundColor": "transparent",
1141 |       "width": 30.319976806640625,
1142 |       "height": 20,
1143 |       "seed": 1552124539,
1144 |       "groupIds": [],
1145 |       "frameId": null,
1146 |       "roundness": null,
1147 |       "boundElements": [],
1148 |       "updated": 1715025899723,
1149 |       "link": null,
1150 |       "locked": false,
1151 |       "fontSize": 16,
1152 |       "fontFamily": 1,
1153 |       "text": "'Uri'",
1154 |       "textAlign": "left",
1155 |       "verticalAlign": "top",
1156 |       "containerId": null,
1157 |       "originalText": "'Uri'",
1158 |       "lineHeight": 1.25
1159 |     },
1160 |     {
1161 |       "type": "rectangle",
1162 |       "version": 421,
1163 |       "versionNonce": 1820184926,
1164 |       "index": "b5PR",
1165 |       "isDeleted": false,
1166 |       "id": "Wkbty95JFWxCFF9vvK15A",
1167 |       "fillStyle": "solid",
1168 |       "strokeWidth": 2,
1169 |       "strokeStyle": "solid",
1170 |       "roughness": 0,
1171 |       "opacity": 100,
1172 |       "angle": 0,
1173 |       "x": 2995.7715022862476,
1174 |       "y": -2219.6941648159655,
1175 |       "strokeColor": "#1e1e1e",
1176 |       "backgroundColor": "transparent",
1177 |       "width": 100.00000000000006,
1178 |       "height": 668.7354592734259,
1179 |       "seed": 1775644437,
1180 |       "groupIds": [],
1181 |       "frameId": null,
1182 |       "roundness": { "type": 3 },
1183 |       "boundElements": [
1184 |         { "id": "FOhpTbOthzLLpczb0ljVU", "type": "arrow" },
1185 |         { "id": "jfaDpVcdQxaxghGm5BI4v", "type": "arrow" }
1186 |       ],
1187 |       "updated": 1715025890319,
1188 |       "link": null,
1189 |       "locked": false
1190 |     },
1191 |     {
1192 |       "type": "line",
1193 |       "version": 244,
1194 |       "versionNonce": 1011983902,
1195 |       "index": "b5PS",
1196 |       "isDeleted": false,
1197 |       "id": "kB9dSvvw-w3D1ssExSZ3L",
1198 |       "fillStyle": "solid",
1199 |       "strokeWidth": 2,
1200 |       "strokeStyle": "solid",
1201 |       "roughness": 0,
1202 |       "opacity": 60,
1203 |       "angle": 0,
1204 |       "x": 2995.7715022862476,
1205 |       "y": -2139.6941648159655,
1206 |       "strokeColor": "#1e1e1e",
1207 |       "backgroundColor": "transparent",
1208 |       "width": 100.00000000000006,
1209 |       "height": 0,
1210 |       "seed": 479139707,
1211 |       "groupIds": [],
1212 |       "frameId": null,
1213 |       "roundness": { "type": 2 },
1214 |       "boundElements": [],
1215 |       "updated": 1715025890319,
1216 |       "link": null,
1217 |       "locked": false,
1218 |       "startBinding": null,
1219 |       "endBinding": null,
1220 |       "lastCommittedPoint": null,
1221 |       "startArrowhead": null,
1222 |       "endArrowhead": null,
1223 |       "points": [
1224 |         [0, 0],
1225 |         [40, 0],
1226 |         [100.00000000000006, 0]
1227 |       ]
1228 |     },
1229 |     {
1230 |       "type": "line",
1231 |       "version": 264,
1232 |       "versionNonce": 364065374,
1233 |       "index": "b5PT",
1234 |       "isDeleted": false,
1235 |       "id": "VwHj6f3AkyQOXDwoScQZ0",
1236 |       "fillStyle": "solid",
1237 |       "strokeWidth": 2,
1238 |       "strokeStyle": "solid",
1239 |       "roughness": 0,
1240 |       "opacity": 60,
1241 |       "angle": 0,
1242 |       "x": 2995.7715022862476,
1243 |       "y": -2099.6941648159655,
1244 |       "strokeColor": "#1e1e1e",
1245 |       "backgroundColor": "transparent",
1246 |       "width": 100.00000000000006,
1247 |       "height": 0,
1248 |       "seed": 453873243,
1249 |       "groupIds": [],
1250 |       "frameId": null,
1251 |       "roundness": { "type": 2 },
1252 |       "boundElements": [],
1253 |       "updated": 1715025890319,
1254 |       "link": null,
1255 |       "locked": false,
1256 |       "startBinding": null,
1257 |       "endBinding": null,
1258 |       "lastCommittedPoint": null,
1259 |       "startArrowhead": null,
1260 |       "endArrowhead": null,
1261 |       "points": [
1262 |         [0, 0],
1263 |         [40, 0],
1264 |         [100.00000000000006, 0]
1265 |       ]
1266 |     },
1267 |     {
1268 |       "type": "rectangle",
1269 |       "version": 443,
1270 |       "versionNonce": 463025822,
1271 |       "index": "b5PU",
1272 |       "isDeleted": false,
1273 |       "id": "ZXt4w6jgRpdLcHsKw7MzR",
1274 |       "fillStyle": "solid",
1275 |       "strokeWidth": 2,
1276 |       "strokeStyle": "solid",
1277 |       "roughness": 0,
1278 |       "opacity": 100,
1279 |       "angle": 0,
1280 |       "x": 2695.7715022862476,
1281 |       "y": -2219.6941648159655,
1282 |       "strokeColor": "#1e1e1e",
1283 |       "backgroundColor": "transparent",
1284 |       "width": 100.00000000000006,
1285 |       "height": 668.7354592734259,
1286 |       "seed": 123056872,
1287 |       "groupIds": [],
1288 |       "frameId": null,
1289 |       "roundness": { "type": 3 },
1290 |       "boundElements": [
1291 |         { "id": "Hhh7gN2Ef5uQvPRtEaqJQ", "type": "arrow" },
1292 |         { "id": "jfaDpVcdQxaxghGm5BI4v", "type": "arrow" }
1293 |       ],
1294 |       "updated": 1715025890319,
1295 |       "link": null,
1296 |       "locked": false
1297 |     },
1298 |     {
1299 |       "type": "text",
1300 |       "version": 21,
1301 |       "versionNonce": 1555043166,
1302 |       "index": "b5PUV",
1303 |       "isDeleted": false,
1304 |       "id": "4HyYx83bOoddS99v9Mmrj",
1305 |       "fillStyle": "solid",
1306 |       "strokeWidth": 1,
1307 |       "strokeStyle": "solid",
1308 |       "roughness": 0,
1309 |       "opacity": 100,
1310 |       "angle": 0,
1311 |       "x": 2734.027514249138,
1312 |       "y": -1895.3264351792525,
1313 |       "strokeColor": "#e03131",
1314 |       "backgroundColor": "transparent",
1315 |       "width": 23.48797607421875,
1316 |       "height": 20,
1317 |       "seed": 1956372712,
1318 |       "groupIds": [],
1319 |       "frameId": null,
1320 |       "roundness": null,
1321 |       "boundElements": [],
1322 |       "updated": 1715025890319,
1323 |       "link": null,
1324 |       "locked": false,
1325 |       "fontSize": 16,
1326 |       "fontFamily": 1,
1327 |       "text": "7:0",
1328 |       "textAlign": "center",
1329 |       "verticalAlign": "middle",
1330 |       "containerId": null,
1331 |       "originalText": "7:0",
1332 |       "lineHeight": 1.25
1333 |     },
1334 |     {
1335 |       "type": "line",
1336 |       "version": 253,
1337 |       "versionNonce": 307361694,
1338 |       "index": "b5PV",
1339 |       "isDeleted": false,
1340 |       "id": "IAxLQWX1atS_j-c3ZKXxs",
1341 |       "fillStyle": "solid",
1342 |       "strokeWidth": 2,
1343 |       "strokeStyle": "solid",
1344 |       "roughness": 0,
1345 |       "opacity": 60,
1346 |       "angle": 0,
1347 |       "x": 2695.7715022862476,
1348 |       "y": -1859.6941648159655,
1349 |       "strokeColor": "#1e1e1e",
1350 |       "backgroundColor": "transparent",
1351 |       "width": 100.00000000000006,
1352 |       "height": 0,
1353 |       "seed": 457443067,
1354 |       "groupIds": [],
1355 |       "frameId": null,
1356 |       "roundness": { "type": 2 },
1357 |       "boundElements": [],
1358 |       "updated": 1715025890319,
1359 |       "link": null,
1360 |       "locked": false,
1361 |       "startBinding": null,
1362 |       "endBinding": null,
1363 |       "lastCommittedPoint": null,
1364 |       "startArrowhead": null,
1365 |       "endArrowhead": null,
1366 |       "points": [
1367 |         [0, 0],
1368 |         [40, 0],
1369 |         [100.00000000000006, 0]
1370 |       ]
1371 |     },
1372 |     {
1373 |       "type": "line",
1374 |       "version": 230,
1375 |       "versionNonce": 984437726,
1376 |       "index": "b5PVV",
1377 |       "isDeleted": false,
1378 |       "id": "0mWheoeqsgnilFa7GRvUq",
1379 |       "fillStyle": "solid",
1380 |       "strokeWidth": 2,
1381 |       "strokeStyle": "solid",
1382 |       "roughness": 0,
1383 |       "opacity": 60,
1384 |       "angle": 0,
1385 |       "x": 2695.7715022862476,
1386 |       "y": -1819.6941648159655,
1387 |       "strokeColor": "#1e1e1e",
1388 |       "backgroundColor": "transparent",
1389 |       "width": 100.00000000000006,
1390 |       "height": 0,
1391 |       "seed": 245687704,
1392 |       "groupIds": [],
1393 |       "frameId": null,
1394 |       "roundness": { "type": 2 },
1395 |       "boundElements": [],
1396 |       "updated": 1715025890319,
1397 |       "link": null,
1398 |       "locked": false,
1399 |       "startBinding": null,
1400 |       "endBinding": null,
1401 |       "lastCommittedPoint": null,
1402 |       "startArrowhead": null,
1403 |       "endArrowhead": null,
1404 |       "points": [
1405 |         [0, 0],
1406 |         [40, 0],
1407 |         [100.00000000000006, 0]
1408 |       ]
1409 |     },
1410 |     {
1411 |       "type": "line",
1412 |       "version": 258,
1413 |       "versionNonce": 802367518,
1414 |       "index": "b5PW",
1415 |       "isDeleted": false,
1416 |       "id": "ZZaHNlM4zUAi__ikIh0lz",
1417 |       "fillStyle": "solid",
1418 |       "strokeWidth": 2,
1419 |       "strokeStyle": "solid",
1420 |       "roughness": 0,
1421 |       "opacity": 60,
1422 |       "angle": 0,
1423 |       "x": 2695.7715022862476,
1424 |       "y": -1779.6941648159655,
1425 |       "strokeColor": "#1e1e1e",
1426 |       "backgroundColor": "transparent",
1427 |       "width": 100.00000000000006,
1428 |       "height": 0,
1429 |       "seed": 81135848,
1430 |       "groupIds": [],
1431 |       "frameId": null,
1432 |       "roundness": { "type": 2 },
1433 |       "boundElements": [],
1434 |       "updated": 1715025890319,
1435 |       "link": null,
1436 |       "locked": false,
1437 |       "startBinding": null,
1438 |       "endBinding": null,
1439 |       "lastCommittedPoint": null,
1440 |       "startArrowhead": null,
1441 |       "endArrowhead": null,
1442 |       "points": [
1443 |         [0, 0],
1444 |         [40, 0],
1445 |         [100.00000000000006, 0]
1446 |       ]
1447 |     },
1448 |     {
1449 |       "type": "freedraw",
1450 |       "version": 20,
1451 |       "versionNonce": 1639216222,
1452 |       "index": "b5PX",
1453 |       "isDeleted": false,
1454 |       "id": "6KBvD0PpiSSJ_7xZo-aOp",
1455 |       "fillStyle": "solid",
1456 |       "strokeWidth": 1,
1457 |       "strokeStyle": "solid",
1458 |       "roughness": 0,
1459 |       "opacity": 100,
1460 |       "angle": 0,
1461 |       "x": 2715.7715022862476,
1462 |       "y": -1839.6941648159652,
1463 |       "strokeColor": "#1e1e1e",
1464 |       "backgroundColor": "transparent",
1465 |       "width": 0.0001,
1466 |       "height": 0.0001,
1467 |       "seed": 2051659752,
1468 |       "groupIds": [],
1469 |       "frameId": null,
1470 |       "roundness": null,
1471 |       "boundElements": [],
1472 |       "updated": 1715025890319,
1473 |       "link": null,
1474 |       "locked": false,
1475 |       "points": [
1476 |         [0, 0],
1477 |         [0.0001, 0.0001]
1478 |       ],
1479 |       "lastCommittedPoint": null,
1480 |       "simulatePressure": true,
1481 |       "pressures": []
1482 |     },
1483 |     {
1484 |       "type": "freedraw",
1485 |       "version": 20,
1486 |       "versionNonce": 438450334,
1487 |       "index": "b5PY",
1488 |       "isDeleted": false,
1489 |       "id": "eJzlumdQpv1aIqk6aMrLj",
1490 |       "fillStyle": "solid",
1491 |       "strokeWidth": 1,
1492 |       "strokeStyle": "solid",
1493 |       "roughness": 0,
1494 |       "opacity": 100,
1495 |       "angle": 0,
1496 |       "x": 2736.145667716427,
1497 |       "y": -1839.6941648159655,
1498 |       "strokeColor": "#1e1e1e",
1499 |       "backgroundColor": "transparent",
1500 |       "width": 0.0001,
1501 |       "height": 0.0001,
1502 |       "seed": 1171251608,
1503 |       "groupIds": [],
1504 |       "frameId": null,
1505 |       "roundness": null,
1506 |       "boundElements": [],
1507 |       "updated": 1715025890319,
1508 |       "link": null,
1509 |       "locked": false,
1510 |       "points": [
1511 |         [0, 0],
1512 |         [0.0001, 0.0001]
1513 |       ],
1514 |       "lastCommittedPoint": null,
1515 |       "simulatePressure": true,
1516 |       "pressures": []
1517 |     },
1518 |     {
1519 |       "type": "freedraw",
1520 |       "version": 21,
1521 |       "versionNonce": 1087206622,
1522 |       "index": "b5PZ",
1523 |       "isDeleted": false,
1524 |       "id": "r4g5nfmp-QZbYSMrP3lIV",
1525 |       "fillStyle": "solid",
1526 |       "strokeWidth": 1,
1527 |       "strokeStyle": "solid",
1528 |       "roughness": 0,
1529 |       "opacity": 100,
1530 |       "angle": 0,
1531 |       "x": 2755.973429764961,
1532 |       "y": -1839.6941648159652,
1533 |       "strokeColor": "#1e1e1e",
1534 |       "backgroundColor": "transparent",
1535 |       "width": 0.0001,
1536 |       "height": 0.0001,
1537 |       "seed": 154094824,
1538 |       "groupIds": [],
1539 |       "frameId": null,
1540 |       "roundness": null,
1541 |       "boundElements": [],
1542 |       "updated": 1715025890319,
1543 |       "link": null,
1544 |       "locked": false,
1545 |       "points": [
1546 |         [0, 0],
1547 |         [0.0001, 0.0001]
1548 |       ],
1549 |       "lastCommittedPoint": null,
1550 |       "simulatePressure": true,
1551 |       "pressures": []
1552 |     },
1553 |     {
1554 |       "type": "arrow",
1555 |       "version": 40,
1556 |       "versionNonce": 935061698,
1557 |       "index": "b5Pa",
1558 |       "isDeleted": false,
1559 |       "id": "Hhh7gN2Ef5uQvPRtEaqJQ",
1560 |       "fillStyle": "solid",
1561 |       "strokeWidth": 1,
1562 |       "strokeStyle": "solid",
1563 |       "roughness": 0,
1564 |       "opacity": 100,
1565 |       "angle": 0,
1566 |       "x": 2935.7715022862476,
1567 |       "y": -1799.6941648159655,
1568 |       "strokeColor": "#1e1e1e",
1569 |       "backgroundColor": "transparent",
1570 |       "width": 139,
1571 |       "height": 0,
1572 |       "seed": 463590552,
1573 |       "groupIds": [],
1574 |       "frameId": null,
1575 |       "roundness": { "type": 2 },
1576 |       "boundElements": [],
1577 |       "updated": 1715025890394,
1578 |       "link": null,
1579 |       "locked": false,
1580 |       "startBinding": null,
1581 |       "endBinding": {
1582 |         "elementId": "ZXt4w6jgRpdLcHsKw7MzR",
1583 |         "focus": 0.25610207796166695,
1584 |         "gap": 1
1585 |       },
1586 |       "lastCommittedPoint": null,
1587 |       "startArrowhead": null,
1588 |       "endArrowhead": "arrow",
1589 |       "points": [
1590 |         [0, 0],
1591 |         [-139, 0]
1592 |       ]
1593 |     },
1594 |     {
1595 |       "type": "text",
1596 |       "version": 37,
1597 |       "versionNonce": 620778846,
1598 |       "index": "b5Pb",
1599 |       "isDeleted": false,
1600 |       "id": "yf_m4jeQEGHF9avGR_P4j",
1601 |       "fillStyle": "solid",
1602 |       "strokeWidth": 1,
1603 |       "strokeStyle": "solid",
1604 |       "roughness": 0,
1605 |       "opacity": 100,
1606 |       "angle": 0,
1607 |       "x": 2815.7715022862476,
1608 |       "y": -1819.6941648159655,
1609 |       "strokeColor": "#1e1e1e",
1610 |       "backgroundColor": "transparent",
1611 |       "width": 150.75189208984375,
1612 |       "height": 20,
1613 |       "seed": 161275624,
1614 |       "groupIds": [],
1615 |       "frameId": null,
1616 |       "roundness": null,
1617 |       "boundElements": [],
1618 |       "updated": 1715025890319,
1619 |       "link": null,
1620 |       "locked": false,
1621 |       "fontSize": 16,
1622 |       "fontFamily": 1,
1623 |       "text": "calling pass_data ",
1624 |       "textAlign": "left",
1625 |       "verticalAlign": "top",
1626 |       "containerId": null,
1627 |       "originalText": "calling pass_data ",
1628 |       "lineHeight": 1.25
1629 |     },
1630 |     {
1631 |       "type": "line",
1632 |       "version": 104,
1633 |       "versionNonce": 726268318,
1634 |       "index": "b5Pc",
1635 |       "isDeleted": false,
1636 |       "id": "JgtqUlXtb-E68h1ujYWSp",
1637 |       "fillStyle": "solid",
1638 |       "strokeWidth": 2,
1639 |       "strokeStyle": "solid",
1640 |       "roughness": 0,
1641 |       "opacity": 60,
1642 |       "angle": 0,
1643 |       "x": 2695.7715022862476,
1644 |       "y": -2179.6941648159655,
1645 |       "strokeColor": "#1e1e1e",
1646 |       "backgroundColor": "transparent",
1647 |       "width": 100.00000000000006,
1648 |       "height": 0,
1649 |       "seed": 1976828126,
1650 |       "groupIds": [],
1651 |       "frameId": null,
1652 |       "roundness": { "type": 2 },
1653 |       "boundElements": [],
1654 |       "updated": 1715025890319,
1655 |       "link": null,
1656 |       "locked": false,
1657 |       "startBinding": null,
1658 |       "endBinding": null,
1659 |       "lastCommittedPoint": null,
1660 |       "startArrowhead": null,
1661 |       "endArrowhead": null,
1662 |       "points": [
1663 |         [0, 0],
1664 |         [100.00000000000006, 0]
1665 |       ]
1666 |     },
1667 |     {
1668 |       "type": "line",
1669 |       "version": 119,
1670 |       "versionNonce": 961877470,
1671 |       "index": "b5Pd",
1672 |       "isDeleted": false,
1673 |       "id": "qvq0r52H_LyL9riwxuxFv",
1674 |       "fillStyle": "solid",
1675 |       "strokeWidth": 2,
1676 |       "strokeStyle": "solid",
1677 |       "roughness": 0,
1678 |       "opacity": 60,
1679 |       "angle": 0,
1680 |       "x": 2695.7715022862476,
1681 |       "y": -1739.6941648159655,
1682 |       "strokeColor": "#1e1e1e",
1683 |       "backgroundColor": "transparent",
1684 |       "width": 100.00000000000006,
1685 |       "height": 0,
1686 |       "seed": 173410206,
1687 |       "groupIds": [],
1688 |       "frameId": null,
1689 |       "roundness": { "type": 2 },
1690 |       "boundElements": [],
1691 |       "updated": 1715025890319,
1692 |       "link": null,
1693 |       "locked": false,
1694 |       "startBinding": null,
1695 |       "endBinding": null,
1696 |       "lastCommittedPoint": null,
1697 |       "startArrowhead": null,
1698 |       "endArrowhead": null,
1699 |       "points": [
1700 |         [0, 0],
1701 |         [100.00000000000006, 0]
1702 |       ]
1703 |     },
1704 |     {
1705 |       "type": "line",
1706 |       "version": 131,
1707 |       "versionNonce": 1211279902,
1708 |       "index": "b5Pe",
1709 |       "isDeleted": false,
1710 |       "id": "Q4d951TbkDTK2vR3jNT-3",
1711 |       "fillStyle": "solid",
1712 |       "strokeWidth": 2,
1713 |       "strokeStyle": "solid",
1714 |       "roughness": 0,
1715 |       "opacity": 60,
1716 |       "angle": 0,
1717 |       "x": 2695.7715022862476,
1718 |       "y": -1699.6941648159655,
1719 |       "strokeColor": "#1e1e1e",
1720 |       "backgroundColor": "transparent",
1721 |       "width": 100.00000000000006,
1722 |       "height": 0,
1723 |       "seed": 934241246,
1724 |       "groupIds": [],
1725 |       "frameId": null,
1726 |       "roundness": { "type": 2 },
1727 |       "boundElements": [],
1728 |       "updated": 1715025890319,
1729 |       "link": null,
1730 |       "locked": false,
1731 |       "startBinding": null,
1732 |       "endBinding": null,
1733 |       "lastCommittedPoint": null,
1734 |       "startArrowhead": null,
1735 |       "endArrowhead": null,
1736 |       "points": [
1737 |         [0, 0],
1738 |         [100.00000000000006, 0]
1739 |       ]
1740 |     },
1741 |     {
1742 |       "type": "text",
1743 |       "version": 186,
1744 |       "versionNonce": 114538078,
1745 |       "index": "b5Pf",
1746 |       "isDeleted": false,
1747 |       "id": "_nGOVq2Bj0EvoLzV__MSN",
1748 |       "fillStyle": "solid",
1749 |       "strokeWidth": 2,
1750 |       "strokeStyle": "solid",
1751 |       "roughness": 0,
1752 |       "opacity": 100,
1753 |       "angle": 0,
1754 |       "x": 2715.7715022862476,
1755 |       "y": -1819.6941648159655,
1756 |       "strokeColor": "#1971c2",
1757 |       "backgroundColor": "transparent",
1758 |       "width": 42.199951171875,
1759 |       "height": 25.000000000000007,
1760 |       "seed": 1645426718,
1761 |       "groupIds": [],
1762 |       "frameId": null,
1763 |       "roundness": null,
1764 |       "boundElements": [],
1765 |       "updated": 1715025890319,
1766 |       "link": null,
1767 |       "locked": false,
1768 |       "fontSize": 20.000000000000007,
1769 |       "fontFamily": 1,
1770 |       "text": "true",
1771 |       "textAlign": "left",
1772 |       "verticalAlign": "top",
1773 |       "containerId": null,
1774 |       "originalText": "true",
1775 |       "lineHeight": 1.25
1776 |     },
1777 |     {
1778 |       "type": "text",
1779 |       "version": 99,
1780 |       "versionNonce": 503921310,
1781 |       "index": "b5Pg",
1782 |       "isDeleted": false,
1783 |       "id": "uINNrVOXORVH_XZTZhpEh",
1784 |       "fillStyle": "solid",
1785 |       "strokeWidth": 2,
1786 |       "strokeStyle": "solid",
1787 |       "roughness": 0,
1788 |       "opacity": 100,
1789 |       "angle": 0,
1790 |       "x": 2735.7715022862476,
1791 |       "y": -1779.6941648159655,
1792 |       "strokeColor": "#1971c2",
1793 |       "backgroundColor": "transparent",
1794 |       "width": 5.4199981689453125,
1795 |       "height": 25.000000000000007,
1796 |       "seed": 1903330398,
1797 |       "groupIds": [],
1798 |       "frameId": null,
1799 |       "roundness": null,
1800 |       "boundElements": [],
1801 |       "updated": 1715025890319,
1802 |       "link": null,
1803 |       "locked": false,
1804 |       "fontSize": 20.000000000000007,
1805 |       "fontFamily": 1,
1806 |       "text": "1",
1807 |       "textAlign": "left",
1808 |       "verticalAlign": "top",
1809 |       "containerId": null,
1810 |       "originalText": "1",
1811 |       "lineHeight": 1.25
1812 |     },
1813 |     {
1814 |       "type": "text",
1815 |       "version": 110,
1816 |       "versionNonce": 886979870,
1817 |       "index": "b5Ph",
1818 |       "isDeleted": false,
1819 |       "id": "XNhYh20Be3_FbXiB71QRw",
1820 |       "fillStyle": "solid",
1821 |       "strokeWidth": 2,
1822 |       "strokeStyle": "solid",
1823 |       "roughness": 0,
1824 |       "opacity": 100,
1825 |       "angle": 0,
1826 |       "x": 2715.7715022862476,
1827 |       "y": -1739.6941648159655,
1828 |       "strokeColor": "#1971c2",
1829 |       "backgroundColor": "transparent",
1830 |       "width": 33.75996398925781,
1831 |       "height": 25.000000000000018,
1832 |       "seed": 664684702,
1833 |       "groupIds": [],
1834 |       "frameId": null,
1835 |       "roundness": null,
1836 |       "boundElements": [],
1837 |       "updated": 1715025907121,
1838 |       "link": null,
1839 |       "locked": false,
1840 |       "fontSize": 20.000000000000014,
1841 |       "fontFamily": 1,
1842 |       "text": "'Eli'",
1843 |       "textAlign": "left",
1844 |       "verticalAlign": "top",
1845 |       "containerId": null,
1846 |       "originalText": "'Eli'",
1847 |       "lineHeight": 1.25
1848 |     },
1849 |     {
1850 |       "type": "freedraw",
1851 |       "version": 24,
1852 |       "versionNonce": 1926605598,
1853 |       "index": "b5Pi",
1854 |       "isDeleted": false,
1855 |       "id": "E2362idiguDruXhJdDv5a",
1856 |       "fillStyle": "solid",
1857 |       "strokeWidth": 1,
1858 |       "strokeStyle": "solid",
1859 |       "roughness": 0,
1860 |       "opacity": 100,
1861 |       "angle": 0,
1862 |       "x": 2715.7715022862476,
1863 |       "y": -1679.6941648159657,
1864 |       "strokeColor": "#1e1e1e",
1865 |       "backgroundColor": "transparent",
1866 |       "width": 0.0001,
1867 |       "height": 0.0001,
1868 |       "seed": 459732830,
1869 |       "groupIds": [],
1870 |       "frameId": null,
1871 |       "roundness": null,
1872 |       "boundElements": [],
1873 |       "updated": 1715025890319,
1874 |       "link": null,
1875 |       "locked": false,
1876 |       "points": [
1877 |         [0, 0],
1878 |         [0.0001, 0.0001]
1879 |       ],
1880 |       "lastCommittedPoint": null,
1881 |       "simulatePressure": true,
1882 |       "pressures": []
1883 |     },
1884 |     {
1885 |       "type": "freedraw",
1886 |       "version": 24,
1887 |       "versionNonce": 1198430046,
1888 |       "index": "b5Pj",
1889 |       "isDeleted": false,
1890 |       "id": "dEf_eo21rQx6HAfucMADc",
1891 |       "fillStyle": "solid",
1892 |       "strokeWidth": 1,
1893 |       "strokeStyle": "solid",
1894 |       "roughness": 0,
1895 |       "opacity": 100,
1896 |       "angle": 0,
1897 |       "x": 2735.7715022862476,
1898 |       "y": -1679.6941648159657,
1899 |       "strokeColor": "#1e1e1e",
1900 |       "backgroundColor": "transparent",
1901 |       "width": 0.0001,
1902 |       "height": 0.0001,
1903 |       "seed": 1583037698,
1904 |       "groupIds": [],
1905 |       "frameId": null,
1906 |       "roundness": null,
1907 |       "boundElements": [],
1908 |       "updated": 1715025890319,
1909 |       "link": null,
1910 |       "locked": false,
1911 |       "points": [
1912 |         [0, 0],
1913 |         [0.0001, 0.0001]
1914 |       ],
1915 |       "lastCommittedPoint": null,
1916 |       "simulatePressure": true,
1917 |       "pressures": []
1918 |     },
1919 |     {
1920 |       "type": "freedraw",
1921 |       "version": 24,
1922 |       "versionNonce": 715127710,
1923 |       "index": "b5Pk",
1924 |       "isDeleted": false,
1925 |       "id": "QuRbf7sCcZsbZ8CQHnvja",
1926 |       "fillStyle": "solid",
1927 |       "strokeWidth": 1,
1928 |       "strokeStyle": "solid",
1929 |       "roughness": 0,
1930 |       "opacity": 100,
1931 |       "angle": 0,
1932 |       "x": 2755.7715022862476,
1933 |       "y": -1679.6941648159657,
1934 |       "strokeColor": "#1e1e1e",
1935 |       "backgroundColor": "transparent",
1936 |       "width": 0.0001,
1937 |       "height": 0.0001,
1938 |       "seed": 1443536030,
1939 |       "groupIds": [],
1940 |       "frameId": null,
1941 |       "roundness": null,
1942 |       "boundElements": [],
1943 |       "updated": 1715025890319,
1944 |       "link": null,
1945 |       "locked": false,
1946 |       "points": [
1947 |         [0, 0],
1948 |         [0.0001, 0.0001]
1949 |       ],
1950 |       "lastCommittedPoint": null,
1951 |       "simulatePressure": true,
1952 |       "pressures": []
1953 |     },
1954 |     {
1955 |       "type": "line",
1956 |       "version": 135,
1957 |       "versionNonce": 580573150,
1958 |       "index": "b5Pl",
1959 |       "isDeleted": false,
1960 |       "id": "9r5JTSvEYknT9uA6quKM0",
1961 |       "fillStyle": "solid",
1962 |       "strokeWidth": 2,
1963 |       "strokeStyle": "solid",
1964 |       "roughness": 0,
1965 |       "opacity": 60,
1966 |       "angle": 0,
1967 |       "x": 2695.7715022862476,
1968 |       "y": -1659.6941648159655,
1969 |       "strokeColor": "#1e1e1e",
1970 |       "backgroundColor": "transparent",
1971 |       "width": 100.00000000000006,
1972 |       "height": 0,
1973 |       "seed": 1306549662,
1974 |       "groupIds": [],
1975 |       "frameId": null,
1976 |       "roundness": { "type": 2 },
1977 |       "boundElements": [],
1978 |       "updated": 1715025890319,
1979 |       "link": null,
1980 |       "locked": false,
1981 |       "startBinding": null,
1982 |       "endBinding": null,
1983 |       "lastCommittedPoint": null,
1984 |       "startArrowhead": null,
1985 |       "endArrowhead": null,
1986 |       "points": [
1987 |         [0, 0],
1988 |         [100.00000000000006, 0]
1989 |       ]
1990 |     },
1991 |     {
1992 |       "type": "arrow",
1993 |       "version": 37,
1994 |       "versionNonce": 1198533662,
1995 |       "index": "b5PlV",
1996 |       "isDeleted": false,
1997 |       "id": "Lg6b6ZwhpQaQMz85vlK9W",
1998 |       "fillStyle": "solid",
1999 |       "strokeWidth": 1,
2000 |       "strokeStyle": "solid",
2001 |       "roughness": 0,
2002 |       "opacity": 100,
2003 |       "angle": 0,
2004 |       "x": 2934.7715022862476,
2005 |       "y": -1639.6941648159655,
2006 |       "strokeColor": "#1e1e1e",
2007 |       "backgroundColor": "transparent",
2008 |       "width": 139,
2009 |       "height": 0,
2010 |       "seed": 1239251806,
2011 |       "groupIds": [],
2012 |       "frameId": null,
2013 |       "roundness": { "type": 2 },
2014 |       "boundElements": [],
2015 |       "updated": 1715025890319,
2016 |       "link": null,
2017 |       "locked": false,
2018 |       "startBinding": null,
2019 |       "endBinding": null,
2020 |       "lastCommittedPoint": null,
2021 |       "startArrowhead": null,
2022 |       "endArrowhead": "arrow",
2023 |       "points": [
2024 |         [0, 0],
2025 |         [-139, 0]
2026 |       ]
2027 |     },
2028 |     {
2029 |       "type": "text",
2030 |       "version": 57,
2031 |       "versionNonce": 118552670,
2032 |       "index": "b5Pm",
2033 |       "isDeleted": false,
2034 |       "id": "e9R7CQh1zuIMBMGcpPUuC",
2035 |       "fillStyle": "solid",
2036 |       "strokeWidth": 1,
2037 |       "strokeStyle": "solid",
2038 |       "roughness": 0,
2039 |       "opacity": 100,
2040 |       "angle": 0,
2041 |       "x": 2814.7715022862476,
2042 |       "y": -1659.6941648159655,
2043 |       "strokeColor": "#1e1e1e",
2044 |       "backgroundColor": "transparent",
2045 |       "width": 163.66387939453125,
2046 |       "height": 20,
2047 |       "seed": 1167220638,
2048 |       "groupIds": [],
2049 |       "frameId": null,
2050 |       "roundness": null,
2051 |       "boundElements": [],
2052 |       "updated": 1715025890319,
2053 |       "link": null,
2054 |       "locked": false,
2055 |       "fontSize": 16,
2056 |       "fontFamily": 1,
2057 |       "text": "calling pass_pointer ",
2058 |       "textAlign": "left",
2059 |       "verticalAlign": "top",
2060 |       "containerId": null,
2061 |       "originalText": "calling pass_pointer ",
2062 |       "lineHeight": 1.25
2063 |     },
2064 |     {
2065 |       "type": "text",
2066 |       "version": 33,
2067 |       "versionNonce": 1766735006,
2068 |       "index": "b5Pn",
2069 |       "isDeleted": false,
2070 |       "id": "Ru-RHKSuLhxsRZMrIzcaI",
2071 |       "fillStyle": "solid",
2072 |       "strokeWidth": 1,
2073 |       "strokeStyle": "solid",
2074 |       "roughness": 0,
2075 |       "opacity": 100,
2076 |       "angle": 0,
2077 |       "x": 2735.7715022862476,
2078 |       "y": -1659.6941648159655,
2079 |       "strokeColor": "#e03131",
2080 |       "backgroundColor": "transparent",
2081 |       "width": 23.48797607421875,
2082 |       "height": 20,
2083 |       "seed": 1246753218,
2084 |       "groupIds": [],
2085 |       "frameId": null,
2086 |       "roundness": null,
2087 |       "boundElements": [],
2088 |       "updated": 1715025890319,
2089 |       "link": null,
2090 |       "locked": false,
2091 |       "fontSize": 16,
2092 |       "fontFamily": 1,
2093 |       "text": "7:0",
2094 |       "textAlign": "center",
2095 |       "verticalAlign": "middle",
2096 |       "containerId": null,
2097 |       "originalText": "7:0",
2098 |       "lineHeight": 1.25
2099 |     },
2100 |     {
2101 |       "type": "line",
2102 |       "version": 142,
2103 |       "versionNonce": 1406728414,
2104 |       "index": "b5Po",
2105 |       "isDeleted": false,
2106 |       "id": "UWnTTSByz-YeQCy9e5SrB",
2107 |       "fillStyle": "solid",
2108 |       "strokeWidth": 2,
2109 |       "strokeStyle": "solid",
2110 |       "roughness": 0,
2111 |       "opacity": 60,
2112 |       "angle": 0,
2113 |       "x": 2695.7715022862476,
2114 |       "y": -1619.6941648159655,
2115 |       "strokeColor": "#1e1e1e",
2116 |       "backgroundColor": "transparent",
2117 |       "width": 100.00000000000006,
2118 |       "height": 0,
2119 |       "seed": 719738434,
2120 |       "groupIds": [],
2121 |       "frameId": null,
2122 |       "roundness": { "type": 2 },
2123 |       "boundElements": [],
2124 |       "updated": 1715025890319,
2125 |       "link": null,
2126 |       "locked": false,
2127 |       "startBinding": null,
2128 |       "endBinding": null,
2129 |       "lastCommittedPoint": null,
2130 |       "startArrowhead": null,
2131 |       "endArrowhead": null,
2132 |       "points": [
2133 |         [0, 0],
2134 |         [100.00000000000006, 0]
2135 |       ]
2136 |     },
2137 |     {
2138 |       "type": "line",
2139 |       "version": 139,
2140 |       "versionNonce": 1312959774,
2141 |       "index": "b5Pp",
2142 |       "isDeleted": false,
2143 |       "id": "BHvhXv8F408bRxriMfV1f",
2144 |       "fillStyle": "solid",
2145 |       "strokeWidth": 2,
2146 |       "strokeStyle": "solid",
2147 |       "roughness": 0,
2148 |       "opacity": 60,
2149 |       "angle": 0,
2150 |       "x": 2695.7715022862476,
2151 |       "y": -1579.6941648159655,
2152 |       "strokeColor": "#1e1e1e",
2153 |       "backgroundColor": "transparent",
2154 |       "width": 100.00000000000006,
2155 |       "height": 0,
2156 |       "seed": 1161792258,
2157 |       "groupIds": [],
2158 |       "frameId": null,
2159 |       "roundness": { "type": 2 },
2160 |       "boundElements": [],
2161 |       "updated": 1715025890319,
2162 |       "link": null,
2163 |       "locked": false,
2164 |       "startBinding": null,
2165 |       "endBinding": null,
2166 |       "lastCommittedPoint": null,
2167 |       "startArrowhead": null,
2168 |       "endArrowhead": null,
2169 |       "points": [
2170 |         [0, 0],
2171 |         [100.00000000000006, 0]
2172 |       ]
2173 |     },
2174 |     {
2175 |       "type": "freedraw",
2176 |       "version": 26,
2177 |       "versionNonce": 1174067550,
2178 |       "index": "b5Pq",
2179 |       "isDeleted": false,
2180 |       "id": "GgjsfwI-bVM3FxAPzYU0q",
2181 |       "fillStyle": "solid",
2182 |       "strokeWidth": 1,
2183 |       "strokeStyle": "solid",
2184 |       "roughness": 0,
2185 |       "opacity": 100,
2186 |       "angle": 0,
2187 |       "x": 2715.7715022862476,
2188 |       "y": -1599.6941648159652,
2189 |       "strokeColor": "#1e1e1e",
2190 |       "backgroundColor": "transparent",
2191 |       "width": 0.0001,
2192 |       "height": 0.0001,
2193 |       "seed": 472899970,
2194 |       "groupIds": [],
2195 |       "frameId": null,
2196 |       "roundness": null,
2197 |       "boundElements": [],
2198 |       "updated": 1715025890319,
2199 |       "link": null,
2200 |       "locked": false,
2201 |       "points": [
2202 |         [0, 0],
2203 |         [0.0001, 0.0001]
2204 |       ],
2205 |       "lastCommittedPoint": null,
2206 |       "simulatePressure": true,
2207 |       "pressures": []
2208 |     },
2209 |     {
2210 |       "type": "freedraw",
2211 |       "version": 26,
2212 |       "versionNonce": 1381236126,
2213 |       "index": "b5Pr",
2214 |       "isDeleted": false,
2215 |       "id": "tTB_Up5bKBgkW7MVNJAq4",
2216 |       "fillStyle": "solid",
2217 |       "strokeWidth": 1,
2218 |       "strokeStyle": "solid",
2219 |       "roughness": 0,
2220 |       "opacity": 100,
2221 |       "angle": 0,
2222 |       "x": 2735.7715022862476,
2223 |       "y": -1599.6941648159652,
2224 |       "strokeColor": "#1e1e1e",
2225 |       "backgroundColor": "transparent",
2226 |       "width": 0.0001,
2227 |       "height": 0.0001,
2228 |       "seed": 136159262,
2229 |       "groupIds": [],
2230 |       "frameId": null,
2231 |       "roundness": null,
2232 |       "boundElements": [],
2233 |       "updated": 1715025890319,
2234 |       "link": null,
2235 |       "locked": false,
2236 |       "points": [
2237 |         [0, 0],
2238 |         [0.0001, 0.0001]
2239 |       ],
2240 |       "lastCommittedPoint": null,
2241 |       "simulatePressure": true,
2242 |       "pressures": []
2243 |     },
2244 |     {
2245 |       "type": "freedraw",
2246 |       "version": 26,
2247 |       "versionNonce": 2021562846,
2248 |       "index": "b5Ps",
2249 |       "isDeleted": false,
2250 |       "id": "naBQrCVgFpH9BgEAf7__j",
2251 |       "fillStyle": "solid",
2252 |       "strokeWidth": 1,
2253 |       "strokeStyle": "solid",
2254 |       "roughness": 0,
2255 |       "opacity": 100,
2256 |       "angle": 0,
2257 |       "x": 2755.7715022862476,
2258 |       "y": -1599.6941648159652,
2259 |       "strokeColor": "#1e1e1e",
2260 |       "backgroundColor": "transparent",
2261 |       "width": 0.0001,
2262 |       "height": 0.0001,
2263 |       "seed": 1472770114,
2264 |       "groupIds": [],
2265 |       "frameId": null,
2266 |       "roundness": null,
2267 |       "boundElements": [],
2268 |       "updated": 1715025890319,
2269 |       "link": null,
2270 |       "locked": false,
2271 |       "points": [
2272 |         [0, 0],
2273 |         [0.0001, 0.0001]
2274 |       ],
2275 |       "lastCommittedPoint": null,
2276 |       "simulatePressure": true,
2277 |       "pressures": []
2278 |     },
2279 |     {
2280 |       "type": "rectangle",
2281 |       "version": 424,
2282 |       "versionNonce": 1871425054,
2283 |       "index": "b5Pt",
2284 |       "isDeleted": false,
2285 |       "id": "EVlPwEr92SV7SP1vr7A9C",
2286 |       "fillStyle": "solid",
2287 |       "strokeWidth": 1,
2288 |       "strokeStyle": "dotted",
2289 |       "roughness": 0,
2290 |       "opacity": 60,
2291 |       "angle": 0,
2292 |       "x": 3155.7715022862476,
2293 |       "y": -2219.6941648159655,
2294 |       "strokeColor": "#1e1e1e",
2295 |       "backgroundColor": "transparent",
2296 |       "width": 100,
2297 |       "height": 660.0000000000001,
2298 |       "seed": 120728350,
2299 |       "groupIds": [],
2300 |       "frameId": null,
2301 |       "roundness": { "type": 3 },
2302 |       "boundElements": [],
2303 |       "updated": 1715025890319,
2304 |       "link": null,
2305 |       "locked": false
2306 |     },
2307 |     {
2308 |       "type": "rectangle",
2309 |       "version": 410,
2310 |       "versionNonce": 1684814430,
2311 |       "index": "b5Pu",
2312 |       "isDeleted": false,
2313 |       "id": "n3xDQP4i_-vwCs_rM7HQq",
2314 |       "fillStyle": "solid",
2315 |       "strokeWidth": 1,
2316 |       "strokeStyle": "dotted",
2317 |       "roughness": 0,
2318 |       "opacity": 60,
2319 |       "angle": 0,
2320 |       "x": 3395.7715022862476,
2321 |       "y": -2219.6941648159655,
2322 |       "strokeColor": "#1e1e1e",
2323 |       "backgroundColor": "transparent",
2324 |       "width": 100,
2325 |       "height": 660.0000000000001,
2326 |       "seed": 1432134850,
2327 |       "groupIds": [],
2328 |       "frameId": null,
2329 |       "roundness": { "type": 3 },
2330 |       "boundElements": [],
2331 |       "updated": 1715025890319,
2332 |       "link": null,
2333 |       "locked": false
2334 |     },
2335 |     {
2336 |       "type": "rectangle",
2337 |       "version": 439,
2338 |       "versionNonce": 1039220382,
2339 |       "index": "b5Pv",
2340 |       "isDeleted": false,
2341 |       "id": "S-SOd9l13LI4jUREl8LNh",
2342 |       "fillStyle": "solid",
2343 |       "strokeWidth": 1,
2344 |       "strokeStyle": "dotted",
2345 |       "roughness": 0,
2346 |       "opacity": 60,
2347 |       "angle": 0,
2348 |       "x": 3275.7715022862476,
2349 |       "y": -2219.6941648159655,
2350 |       "strokeColor": "#1e1e1e",
2351 |       "backgroundColor": "transparent",
2352 |       "width": 100,
2353 |       "height": 660.0000000000001,
2354 |       "seed": 1181601410,
2355 |       "groupIds": [],
2356 |       "frameId": null,
2357 |       "roundness": { "type": 3 },
2358 |       "boundElements": [],
2359 |       "updated": 1715025890319,
2360 |       "link": null,
2361 |       "locked": false
2362 |     },
2363 |     {
2364 |       "id": "1dOLcGYb7fsmnwoXYqr9K",
2365 |       "type": "text",
2366 |       "x": 3246.686822123702,
2367 |       "y": -2257.6503835149742,
2368 |       "width": 118.97592163085938,
2369 |       "height": 20,
2370 |       "angle": 0,
2371 |       "strokeColor": "#1e1e1e",
2372 |       "backgroundColor": "transparent",
2373 |       "fillStyle": "solid",
2374 |       "strokeWidth": 1,
2375 |       "strokeStyle": "solid",
2376 |       "roughness": 0,
2377 |       "opacity": 60,
2378 |       "groupIds": [],
2379 |       "frameId": null,
2380 |       "index": "b5Pw",
2381 |       "roundness": null,
2382 |       "seed": 1923012766,
2383 |       "version": 28,
2384 |       "versionNonce": 1623964382,
2385 |       "isDeleted": false,
2386 |       "boundElements": null,
2387 |       "updated": 1715025890319,
2388 |       "link": null,
2389 |       "locked": false,
2390 |       "text": "other segments",
2391 |       "fontSize": 16,
2392 |       "fontFamily": 1,
2393 |       "textAlign": "left",
2394 |       "verticalAlign": "top",
2395 |       "containerId": null,
2396 |       "originalText": "other segments",
2397 |       "lineHeight": 1.25
2398 |     },
2399 |     {
2400 |       "id": "FOhpTbOthzLLpczb0ljVU",
2401 |       "type": "arrow",
2402 |       "x": 2832.962528506419,
2403 |       "y": -1951.198205822514,
2404 |       "width": 161.80897377982865,
2405 |       "height": 185.8481613579729,
2406 |       "angle": 0,
2407 |       "strokeColor": "#1e1e1e",
2408 |       "backgroundColor": "transparent",
2409 |       "fillStyle": "solid",
2410 |       "strokeWidth": 1,
2411 |       "strokeStyle": "solid",
2412 |       "roughness": 0,
2413 |       "opacity": 60,
2414 |       "groupIds": [],
2415 |       "frameId": null,
2416 |       "index": "b5Px",
2417 |       "roundness": { "type": 2 },
2418 |       "seed": 222841566,
2419 |       "version": 357,
2420 |       "versionNonce": 1736802434,
2421 |       "isDeleted": false,
2422 |       "boundElements": [{ "type": "text", "id": "7jK_BGx78S02gc7R0unlx" }],
2423 |       "updated": 1715025890394,
2424 |       "link": null,
2425 |       "locked": false,
2426 |       "points": [
2427 |         [0, 0],
2428 |         [75.30093920015997, -136.61971141094864],
2429 |         [161.80897377982865, -185.8481613579729]
2430 |       ],
2431 |       "lastCommittedPoint": [157.13674617450624, -230.62549515157252],
2432 |       "startBinding": null,
2433 |       "endBinding": {
2434 |         "elementId": "Wkbty95JFWxCFF9vvK15A",
2435 |         "focus": 0.7737761263175824,
2436 |         "gap": 1
2437 |       },
2438 |       "startArrowhead": null,
2439 |       "endArrowhead": "arrow"
2440 |     },
2441 |     {
2442 |       "id": "7jK_BGx78S02gc7R0unlx",
2443 |       "type": "text",
2444 |       "x": 2843.956996208532,
2445 |       "y": -2107.8179172334626,
2446 |       "width": 130.1439208984375,
2447 |       "height": 40,
2448 |       "angle": 0,
2449 |       "strokeColor": "#1e1e1e",
2450 |       "backgroundColor": "transparent",
2451 |       "fillStyle": "solid",
2452 |       "strokeWidth": 1,
2453 |       "strokeStyle": "solid",
2454 |       "roughness": 0,
2455 |       "opacity": 60,
2456 |       "groupIds": [],
2457 |       "frameId": null,
2458 |       "index": "b5Py",
2459 |       "roundness": null,
2460 |       "seed": 1217624670,
2461 |       "version": 33,
2462 |       "versionNonce": 167306178,
2463 |       "isDeleted": false,
2464 |       "boundElements": null,
2465 |       "updated": 1715025511410,
2466 |       "link": null,
2467 |       "locked": false,
2468 |       "text": "stored in boxed \nsegment",
2469 |       "fontSize": 16,
2470 |       "fontFamily": 1,
2471 |       "textAlign": "center",
2472 |       "verticalAlign": "middle",
2473 |       "containerId": "FOhpTbOthzLLpczb0ljVU",
2474 |       "originalText": "stored in boxed segment",
2475 |       "lineHeight": 1.25
2476 |     },
2477 |     {
2478 |       "id": "jfaDpVcdQxaxghGm5BI4v",
2479 |       "type": "arrow",
2480 |       "x": 2993.1268559557398,
2481 |       "y": -2053.238088304672,
2482 |       "width": 196.35535366949216,
2483 |       "height": 173.06327974475607,
2484 |       "angle": 0,
2485 |       "strokeColor": "#1e1e1e",
2486 |       "backgroundColor": "transparent",
2487 |       "fillStyle": "solid",
2488 |       "strokeWidth": 1,
2489 |       "strokeStyle": "solid",
2490 |       "roughness": 0,
2491 |       "opacity": 60,
2492 |       "groupIds": [],
2493 |       "frameId": null,
2494 |       "index": "b5Pz",
2495 |       "roundness": { "type": 2 },
2496 |       "seed": 635998594,
2497 |       "version": 350,
2498 |       "versionNonce": 1381812226,
2499 |       "isDeleted": false,
2500 |       "boundElements": [{ "type": "text", "id": "XYYmeNdcg0XkvmjylXmKp" }],
2501 |       "updated": 1715025890394,
2502 |       "link": null,
2503 |       "locked": false,
2504 |       "points": [
2505 |         [0, 0],
2506 |         [-34.71041273464152, 53.67112678699914],
2507 |         [-114.47635208820475, 152.10811692395237],
2508 |         [-196.35535366949216, 173.06327974475607]
2509 |       ],
2510 |       "lastCommittedPoint": [-199.44653003116537, 307.80621208897423],
2511 |       "startBinding": {
2512 |         "elementId": "Wkbty95JFWxCFF9vvK15A",
2513 |         "focus": 0.6055999703661705,
2514 |         "gap": 2.6446463305078396
2515 |       },
2516 |       "endBinding": {
2517 |         "elementId": "ZXt4w6jgRpdLcHsKw7MzR",
2518 |         "focus": 0.05243621958423575,
2519 |         "gap": 1
2520 |       },
2521 |       "startArrowhead": null,
2522 |       "endArrowhead": "arrow"
2523 |     },
2524 |     {
2525 |       "id": "XYYmeNdcg0XkvmjylXmKp",
2526 |       "type": "text",
2527 |       "x": 2887.8080337129372,
2528 |       "y": -1964.3256408434781,
2529 |       "width": 76.67195129394531,
2530 |       "height": 40,
2531 |       "angle": 0,
2532 |       "strokeColor": "#1e1e1e",
2533 |       "backgroundColor": "transparent",
2534 |       "fillStyle": "solid",
2535 |       "strokeWidth": 1,
2536 |       "strokeStyle": "solid",
2537 |       "roughness": 0,
2538 |       "opacity": 60,
2539 |       "groupIds": [],
2540 |       "frameId": null,
2541 |       "index": "b5PzV",
2542 |       "roundness": null,
2543 |       "seed": 1827400770,
2544 |       "version": 26,
2545 |       "versionNonce": 2120948610,
2546 |       "isDeleted": false,
2547 |       "boundElements": null,
2548 |       "updated": 1715025511410,
2549 |       "link": null,
2550 |       "locked": false,
2551 |       "text": "pointer\nto struct",
2552 |       "fontSize": 16,
2553 |       "fontFamily": 1,
2554 |       "textAlign": "center",
2555 |       "verticalAlign": "middle",
2556 |       "containerId": "jfaDpVcdQxaxghGm5BI4v",
2557 |       "originalText": "pointer\nto struct",
2558 |       "lineHeight": 1.25
2559 |     },
2560 |     {
2561 |       "type": "freedraw",
2562 |       "version": 253,
2563 |       "versionNonce": 1684406174,
2564 |       "index": "b5Q",
2565 |       "isDeleted": false,
2566 |       "id": "V3abPltQ0btsFqRsgJO3V",
2567 |       "fillStyle": "solid",
2568 |       "strokeWidth": 1,
2569 |       "strokeStyle": "solid",
2570 |       "roughness": 0,
2571 |       "opacity": 70,
2572 |       "angle": 0,
2573 |       "x": 2797.383864848666,
2574 |       "y": -2034.6150499361006,
2575 |       "strokeColor": "#1e1e1e",
2576 |       "backgroundColor": "transparent",
2577 |       "width": 26.193049441736548,
2578 |       "height": 118.39330084876565,
2579 |       "seed": 189832862,
2580 |       "groupIds": [],
2581 |       "frameId": null,
2582 |       "roundness": null,
2583 |       "boundElements": [],
2584 |       "updated": 1715025890319,
2585 |       "link": null,
2586 |       "locked": false,
2587 |       "points": [
2588 |         [0, 0],
2589 |         [-0.09266056518254118, 0],
2590 |         [0.08518793895837007, 0],
2591 |         [0.44088494723928306, 0],
2592 |         [1.3510508213698813, 0],
2593 |         [2.486890007477541, 0],
2594 |         [3.8723149094798828, 0],
2595 |         [6.124564453511084, -0.16290325169211428],
2596 |         [8.399231876215708, 0.4857207045852192],
2597 |         [9.527598436099197, 1.0491567219041826],
2598 |         [10.092528978662813, 1.6140872644682531],
2599 |         [10.657459521226883, 2.03703790876898],
2600 |         [11.08041016552761, 2.6019684513330503],
2601 |         [11.319534204707907, 2.9606545101037227],
2602 |         [12.011499393086524, 4.17271448370002],
2603 |         [12.151984766105215, 4.878130399282327],
2604 |         [12.292470139123907, 5.583546314865089],
2605 |         [12.74680581356688, 6.493712188995687],
2606 |         [12.74680581356688, 7.40387806312674],
2607 |         [12.908214540013432, 8.541211774479052],
2608 |         [13.080084943174825, 9.926636676481394],
2609 |         [13.404396921313037, 11.063970387833706],
2610 |         [13.58672900118836, 12.715420783424179],
2611 |         [13.770555606308335, 14.369860229504411],
2612 |         [13.964843888142696, 16.31423757309085],
2613 |         [14.136714291303633, 17.699662475092737],
2614 |         [14.320540896423609, 19.354101921173424],
2615 |         [14.492411299584546, 20.73952682317531],
2616 |         [14.492411299584546, 22.124951725177652],
2617 |         [14.632896672603238, 22.83036764075996],
2618 |         [14.632896672603238, 23.96770135211227],
2619 |         [14.827184954437143, 25.912078695699165],
2620 |         [14.827184954437143, 27.049412407051477],
2621 |         [14.98859368088415, 28.18674611840379],
2622 |         [15.160464084045088, 29.572171020405676],
2623 |         [15.321872810492096, 30.70950473175799],
2624 |         [15.493743213653033, 33.48035453576267],
2625 |         [15.665613616813971, 34.86577943776456],
2626 |         [15.837484019974909, 36.2512043397669],
2627 |         [16.009354423135846, 37.63662924176879],
2628 |         [16.19318102825582, 39.29106868784902],
2629 |         [16.35458975470283, 40.42840239920133],
2630 |         [16.526460157863767, 41.81382730120367],
2631 |         [16.698330561024704, 43.19925220320556],
2632 |         [17.02264253916337, 44.33658591455787],
2633 |         [17.367877870730354, 45.722010816560214],
2634 |         [17.886478130702926, 47.107435718562556],
2635 |         [18.25413134094333, 48.76187516464233],
2636 |         [18.772731600915904, 50.147300066644675],
2637 |         [19.32421141627583, 51.80173951272491],
2638 |         [19.87569123163621, 53.45617895880514],
2639 |         [20.15815650291779, 54.16159487438745],
2640 |         [20.645371732748117, 55.298928585740214],
2641 |         [21.09970740719109, 56.20909445987081],
2642 |         [21.554043081634063, 57.119260334001865],
2643 |         [21.97699372593479, 57.82467624958417],
2644 |         [22.399944370235517, 58.530092165166934],
2645 |         [22.639068409415813, 58.88877822393761],
2646 |         [23.03063402357384, 59.28034383809563],
2647 |         [23.26975806275459, 59.639029896866305],
2648 |         [23.628444121525263, 59.878153936047056],
2649 |         [23.8466448072777, 60.09635462179904],
2650 |         [24.06484549302968, 60.31455530755147],
2651 |         [24.42353155180035, 60.43411732714185],
2652 |         [24.641732237552787, 60.54321767001784],
2653 |         [24.85993292330477, 60.65231801289383],
2654 |         [25.078133609057204, 60.76141835576982],
2655 |         [25.296334294809185, 60.870518698646265],
2656 |         [25.51453498056162, 60.979619041522255],
2657 |         [25.61317364672368, 61.078257707684315],
2658 |         [25.810450979047346, 61.078257707684315],
2659 |         [25.909089645209406, 61.078257707684315],
2660 |         [26.007728311371466, 61.078257707684315],
2661 |         [26.100388876554007, 61.078257707684315],
2662 |         [26.010717361861225, 61.16643469713199],
2663 |         [25.900122493740128, 61.384635382884426],
2664 |         [25.397962011461004, 62.26341622687278],
2665 |         [25.1573434470356, 62.62210228564345],
2666 |         [24.89580152918188, 63.14369159610578],
2667 |         [24.244188522415243, 64.11812205576643],
2668 |         [23.982646604561523, 64.63971136622922],
2669 |         [23.69868680803438, 65.34512728181153],
2670 |         [23.00522709441111, 66.73055218381387],
2671 |         [22.873708872861698, 67.2521414942762],
2672 |         [22.18024915923843, 68.4642014678725],
2673 |         [22.048730937689015, 68.98579077833529],
2674 |         [21.743847787734012, 69.89595665246588],
2675 |         [21.438964637778554, 70.80612252659694],
2676 |         [21.28652306280128, 71.71628840072754],
2677 |         [20.960716559417506, 72.85362211207985],
2678 |         [20.655833409462502, 73.7637879862109],
2679 |         [20.503391834484773, 74.6739538603415],
2680 |         [20.37187361293536, 75.19554317080429],
2681 |         [20.002725877450757, 76.84998261688452],
2682 |         [19.850284302473028, 77.76014849101512],
2683 |         [19.718766080923615, 78.2817378014779],
2684 |         [19.533444950558987, 79.93617724755813],
2685 |         [19.533444950558987, 80.45776655802047],
2686 |         [19.370541698867328, 81.59510026937278],
2687 |         [19.2181001238896, 82.50526614350383],
2688 |         [19.2181001238896, 83.89069104550572],
2689 |         [19.05519687219794, 85.02802475685803],
2690 |         [19.05519687219794, 85.93819063098908],
2691 |         [19.05519687219794, 86.64360654657139],
2692 |         [18.90275529722021, 87.55377242070244],
2693 |         [18.90275529722021, 89.20821186678268],
2694 |         [18.58741047055082, 91.25571145226604],
2695 |         [18.58741047055082, 92.64113635426793],
2696 |         [18.58741047055082, 93.77847006562024],
2697 |         [18.58741047055082, 95.16389496762258],
2698 |         [18.41404554214523, 96.54931986962447],
2699 |         [18.41404554214523, 97.93474477162681],
2700 |         [18.41404554214523, 99.58918421770704],
2701 |         [18.41404554214523, 100.97460911970938],
2702 |         [18.41404554214523, 102.36003402171127],
2703 |         [18.41404554214523, 103.74545892371361],
2704 |         [18.41404554214523, 104.45087483929592],
2705 |         [18.41404554214523, 105.58820855064823],
2706 |         [18.41404554214523, 106.72554226200054],
2707 |         [18.41404554214523, 108.77304184748391],
2708 |         [18.41404554214523, 109.68320772161496],
2709 |         [18.41404554214523, 110.38862363719727],
2710 |         [18.41404554214523, 111.09403955277958],
2711 |         [18.41404554214523, 111.79945546836234],
2712 |         [18.41404554214523, 112.32104477882467],
2713 |         [18.41404554214523, 112.84263408928746],
2714 |         [18.41404554214523, 113.54805000486976],
2715 |         [18.29298899730975, 113.90673606364089],
2716 |         [18.16147077576079, 114.42832537410322],
2717 |         [17.89992885790707, 114.94991468456556],
2718 |         [17.778872313072043, 115.30860074333668],
2719 |         [17.65781576823656, 115.66728680210736],
2720 |         [17.438120557239472, 115.88548748785934],
2721 |         [17.197501992814068, 116.24417354663001],
2722 |         [16.97780678181698, 116.46237423238244],
2723 |         [16.6176261978012, 116.7014982715632],
2724 |         [16.257445613785876, 116.94062231074349],
2725 |         [15.897265029770097, 117.17974634992424],
2726 |         [15.190354588942682, 117.32023172294248],
2727 |         [14.667270753235243, 117.45025541924679],
2728 |         [13.960360312407829, 117.59074079226548],
2729 |         [13.253449871580415, 117.73122616528417],
2730 |         [12.730366035872976, 117.86124986158848],
2731 |         [12.207282200165537, 117.99127355789278],
2732 |         [11.46450315346101, 118.23039759707353],
2733 |         [11.244807942463922, 118.23039759707353],
2734 |         [11.244807942463922, 118.23039759707353]
2735 |       ],
2736 |       "lastCommittedPoint": null,
2737 |       "simulatePressure": true,
2738 |       "pressures": []
2739 |     },
2740 |     {
2741 |       "type": "text",
2742 |       "version": 93,
2743 |       "versionNonce": 1023433694,
2744 |       "index": "b5R",
2745 |       "isDeleted": false,
2746 |       "id": "HXvBNuIu1oVaDkgij8n0j",
2747 |       "fillStyle": "solid",
2748 |       "strokeWidth": 2,
2749 |       "strokeStyle": "solid",
2750 |       "roughness": 0,
2751 |       "opacity": 100,
2752 |       "angle": 0,
2753 |       "x": 2833.3397930498686,
2754 |       "y": -1987.1487325205699,
2755 |       "strokeColor": "#1e1e1e",
2756 |       "backgroundColor": "transparent",
2757 |       "width": 107.82391357421875,
2758 |       "height": 20,
2759 |       "seed": 1753791134,
2760 |       "groupIds": [],
2761 |       "frameId": null,
2762 |       "roundness": null,
2763 |       "boundElements": [],
2764 |       "updated": 1715025890319,
2765 |       "link": null,
2766 |       "locked": false,
2767 |       "fontSize": 16,
2768 |       "fontFamily": 1,
2769 |       "text": "boxed_struct",
2770 |       "textAlign": "left",
2771 |       "verticalAlign": "top",
2772 |       "containerId": null,
2773 |       "originalText": "boxed_struct",
2774 |       "lineHeight": 1.25
2775 |     }
2776 |   ],
2777 |   "files": {}
2778 | }
2779 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_05_box/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[derive(Drop)]
 2 | struct Cart {
 3 |     paid: bool,
 4 |     items: u256,
 5 |     buyer: ByteArray,
 6 | }
 7 | 
 8 | fn pass_data(cart: Cart) {
 9 |     println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
10 | }
11 | 
12 | fn pass_pointer(cart: Box<Cart>) {
13 |     let cart = cart.unbox();
14 |     println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
15 | }
16 | 
17 | fn main() {
18 |     let new_struct = Cart { paid: true, items: 1, buyer: "Eli" };
19 |     pass_data(new_struct);
20 | 
21 |     let new_box = BoxTrait::new(Cart { paid: false, items: 2, buyer: "Uri" });
22 |     pass_pointer(new_box);
23 | }
24 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_09_deref_coercion/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_09_deref_coercion/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_09_deref_coercion"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_09_deref_coercion/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: Deref
 2 | pub trait Deref<T> {
 3 |     type Target;
 4 |     fn deref(self: T) -> Self::Target;
 5 | }
 6 | // ANCHOR_END: Deref
 7 | 
 8 | // ANCHOR: DerefMut
 9 | pub trait DerefMut<T> {
10 |     type Target;
11 |     fn deref_mut(ref self: T) -> Self::Target;
12 | }
13 | // ANCHOR_END: DerefMut
14 | 
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_10_arithmetic_circuits/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_10_arithmetic_circuits/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_10_arithmetic_circuits"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: full
 2 | use core::circuit::{
 3 |     CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
 4 |     CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
 5 | };
 6 | 
 7 | // Circuit: a * (a + b)
 8 | // witness: a = 10, b = 20
 9 | // expected output: 10 * (10 + 20) = 300
10 | fn eval_circuit() -> (u384, u384) {
11 |     // ANCHOR: inputs
12 |     let a = CircuitElement::<CircuitInput<0>> {};
13 |     let b = CircuitElement::<CircuitInput<1>> {};
14 |     // ANCHOR_END: inputs
15 | 
16 |     // ANCHOR: description
17 |     let add = circuit_add(a, b);
18 |     let mul = circuit_mul(a, add);
19 |     // ANCHOR_END: description
20 | 
21 |     // ANCHOR: output
22 |     let output = (mul,);
23 |     // ANCHOR_END: output
24 | 
25 |     // ANCHOR: instance
26 |     let mut inputs = output.new_inputs();
27 |     inputs = inputs.next([10, 0, 0, 0]);
28 |     inputs = inputs.next([20, 0, 0, 0]);
29 | 
30 |     let instance = inputs.done();
31 |     // ANCHOR_END: instance
32 | 
33 |     // ANCHOR: modulus
34 |     let bn254_modulus = TryInto::<
35 |         _, CircuitModulus,
36 |     >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
37 |         .unwrap();
38 |     // ANCHOR_END: modulus
39 | 
40 |     // ANCHOR: eval
41 |     let res = instance.eval(bn254_modulus).unwrap();
42 |     // ANCHOR_END: eval
43 | 
44 |     // ANCHOR: output_values
45 |     let add_output = res.get_output(add);
46 |     let circuit_output = res.get_output(mul);
47 | 
48 |     assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
49 |     assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');
50 |     // ANCHOR_END: output_values
51 | 
52 |     (add_output, circuit_output)
53 | }
54 | // ANCHOR_END: full
55 | 
56 | fn main() {
57 |     eval_circuit();
58 | }
59 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_10_associated_types/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_10_associated_types/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_10_associated_types"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: associated_types
 2 | trait Pack<T> {
 3 |     type Result;
 4 | 
 5 |     fn pack(self: T, other: T) -> Self::Result;
 6 | }
 7 | // ANCHOR_END: associated_types
 8 | 
 9 | // ANCHOR: associated_types_impl
10 | impl PackU32Impl of Pack<u32> {
11 |     type Result = u64;
12 | 
13 |     fn pack(self: u32, other: u32) -> Self::Result {
14 |         let shift: u64 = 0x100000000; // 2^32
15 |         self.into() * shift + other.into()
16 |     }
17 | }
18 | // ANCHOR_END: associated_types_impl
19 | 
20 | // ANCHOR: bar
21 | fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
22 |     PackImpl::pack(self, b)
23 | }
24 | // ANCHOR_END: bar
25 | 
26 | // ANCHOR: generics_usage
27 | trait PackGeneric<T, U> {
28 |     fn pack_generic(self: T, other: T) -> U;
29 | }
30 | 
31 | impl PackGenericU32 of PackGeneric<u32, u64> {
32 |     fn pack_generic(self: u32, other: u32) -> u64 {
33 |         let shift: u64 = 0x100000000; // 2^32
34 |         self.into() * shift + other.into()
35 |     }
36 | }
37 | // ANCHOR_END: generics_usage
38 | 
39 | // ANCHOR: foo
40 | fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
41 |     self.pack_generic(other)
42 | }
43 | // ANCHOR_END: foo
44 | 
45 | // ANCHOR: main
46 | fn main() {
47 |     let a: u32 = 1;
48 |     let b: u32 = 1;
49 | 
50 |     let x = foo(a, b);
51 |     let y = bar(a, b);
52 | 
53 |     // result is 2^32 + 1
54 |     println!("x: {}", x);
55 |     println!("y: {}", y);
56 | }
57 | // ANCHOR_END: main
58 | 
59 | 
60 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_11_associated_consts/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_11_associated_consts/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_11_associated_consts"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_11_associated_consts/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: associated_consts
 2 | trait Shape<T> {
 3 |     const SIDES: u32;
 4 |     fn describe() -> ByteArray;
 5 | }
 6 | 
 7 | struct Triangle {}
 8 | 
 9 | impl TriangleShape of Shape<Triangle> {
10 |     const SIDES: u32 = 3;
11 |     fn describe() -> ByteArray {
12 |         "I am a triangle."
13 |     }
14 | }
15 | 
16 | struct Square {}
17 | 
18 | impl SquareShape of Shape<Square> {
19 |     const SIDES: u32 = 4;
20 |     fn describe() -> ByteArray {
21 |         "I am a square."
22 |     }
23 | }
24 | // ANCHOR_END: associated_consts
25 | 
26 | // ANCHOR: print_info
27 | fn print_shape_info<T, impl ShapeImpl: Shape<T>>() {
28 |     println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
29 | }
30 | // ANCHOR_END: print_info
31 | 
32 | // ANCHOR: main
33 | fn main() {
34 |     print_shape_info::<Triangle>();
35 |     print_shape_info::<Square>();
36 | }
37 | // ANCHOR_END: main
38 | 
39 | 
40 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_12_associated_impls/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_12_associated_impls/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "listing_12_associated_impls"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_12_associated_impls/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: associated_impls
 2 | // Collection type that contains a simple array
 3 | #[derive(Drop)]
 4 | pub struct ArrayIter<T> {
 5 |     array: Array<T>,
 6 | }
 7 | 
 8 | // T is the collection type
 9 | pub trait Iterator<T> {
10 |     type Item;
11 |     fn next(ref self: T) -> Option<Self::Item>;
12 | }
13 | 
14 | impl ArrayIterator<T> of Iterator<ArrayIter<T>> {
15 |     type Item = T;
16 |     fn next(ref self: ArrayIter<T>) -> Option<T> {
17 |         self.array.pop_front()
18 |     }
19 | }
20 | 
21 | /// Turns a collection of values into an iterator
22 | pub trait IntoIterator<T> {
23 |     /// The iterator type that will be created
24 |     type IntoIter;
25 |     impl Iterator: Iterator<Self::IntoIter>;
26 | 
27 |     fn into_iter(self: T) -> Self::IntoIter;
28 | }
29 | 
30 | impl ArrayIntoIterator<T> of IntoIterator<Array<T>> {
31 |     type IntoIter = ArrayIter<T>;
32 |     fn into_iter(self: Array<T>) -> ArrayIter<T> {
33 |         ArrayIter { array: self }
34 |     }
35 | }
36 | // ANCHOR_END: associated_impls
37 | 
38 | // ANCHOR: main
39 | fn main() {
40 |     let mut arr: Array<felt252> = array![1, 2, 3];
41 | 
42 |     // Converts the array into an iterator
43 |     let mut iter = arr.into_iter();
44 | 
45 |     // Uses the iterator to print each element
46 |     loop {
47 |         match iter.next() {
48 |             Option::Some(item) => println!("Item: {}", item),
49 |             Option::None => { break; },
50 |         };
51 |     }
52 | }
53 | // ANCHOR_END: main
54 | 
55 | 
56 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_recursive_types/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_recursive_types"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_recursive_types/src/display.cairo:
--------------------------------------------------------------------------------
 1 | use core::nullable::{NullableTrait};
 2 | use core::fmt::{Debug, Formatter, Error};
 3 | use core::ops::Deref;
 4 | use super::BinaryTree;
 5 | 
 6 | pub(crate) impl DebugBinaryTree of Debug<BinaryTree> {
 7 |     fn fmt(self: @BinaryTree, ref f: Formatter) -> Result<(), Error> {
 8 |         fmt_helper(self, ref f, 0, true)
 9 |     }
10 | }
11 | 
12 | fn fmt_helper(
13 |     self: @BinaryTree, ref f: Formatter, depth: usize, is_last: bool,
14 | ) -> Result<(), Error> {
15 |     let mut indent: ByteArray = "";
16 |     let mut i = 0;
17 |     loop {
18 |         if i == depth {
19 |             break;
20 |         }
21 |         indent += if i == depth - 1 && is_last {
22 |             "    "
23 |         } else {
24 |             "|   "
25 |         };
26 |         i += 1;
27 |     };
28 | 
29 |     let branch: ByteArray = if is_last {
30 |         "`-- "
31 |     } else {
32 |         "|-- "
33 |     };
34 | 
35 |     match self {
36 |         BinaryTree::Leaf(value) => { writeln!(f, "{}{}{:?}", indent, branch, *value) },
37 |         BinaryTree::Node(node) => {
38 |             let (value, left, right) = node;
39 |             let left_node = (*left).deref();
40 |             let right_node = (*right).deref();
41 |             writeln!(f, "{}{}{:?}", indent, branch, *value)?;
42 |             fmt_helper(@left_node, ref f, depth + 1, false)?;
43 |             fmt_helper(@right_node, ref f, depth + 1, true)
44 |         },
45 |     }
46 | }
47 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_recursive_types/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::box::{BoxTrait};
 2 | 
 3 | mod display;
 4 | use display::DebugBinaryTree;
 5 | 
 6 | #[derive(Copy, Drop)]
 7 | enum BinaryTree {
 8 |     Leaf: u32,
 9 |     Node: (u32, Box<BinaryTree>, Box<BinaryTree>),
10 | }
11 | 
12 | 
13 | fn main() {
14 |     let leaf1 = BinaryTree::Leaf(1);
15 |     let leaf2 = BinaryTree::Leaf(2);
16 |     let leaf3 = BinaryTree::Leaf(3);
17 |     let node = BinaryTree::Node((4, BoxTrait::new(leaf2), BoxTrait::new(leaf3)));
18 |     let root = BinaryTree::Node((5, BoxTrait::new(leaf1), BoxTrait::new(node)));
19 | 
20 |     println!("{:?}", root);
21 | }
22 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_recursive_types_wrong/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_recursive_types_wrong"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_recursive_types_wrong/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb build 
 2 |    Compiling listing_recursive_types_wrong v0.1.0 (listings/ch11-advanced-features/listing_recursive_types_wrong/Scarb.toml)
 3 | error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 4 |  --> listings/ch11-advanced-features/listing_recursive_types_wrong/src/lib.cairo:6:5
 5 |     Node: (u32, BinaryTree, BinaryTree),
 6 |     ^*********************************^
 7 | 
 8 | error: Recursive type "listing_recursive_types_wrong::BinaryTree" has infinite size.
 9 |  --> listings/ch11-advanced-features/listing_recursive_types_wrong/src/lib.cairo:10:17
10 |     let leaf1 = BinaryTree::Leaf(1);
11 |                 ^*****************^
12 | 
13 | error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
14 |  --> listings/ch11-advanced-features/listing_recursive_types_wrong/src/lib.cairo:13:33
15 |     let node = BinaryTree::Node((4, leaf2, leaf3));
16 |                                 ^***************^
17 | 
18 | error: could not compile `listing_recursive_types_wrong` due to previous error
19 | 
20 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/listing_recursive_types_wrong/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | #[derive(Copy, Drop)]
 4 | enum BinaryTree {
 5 |     Leaf: u32,
 6 |     Node: (u32, BinaryTree, BinaryTree),
 7 | }
 8 | 
 9 | fn main() {
10 |     let leaf1 = BinaryTree::Leaf(1);
11 |     let leaf2 = BinaryTree::Leaf(2);
12 |     let leaf3 = BinaryTree::Leaf(3);
13 |     let node = BinaryTree::Node((4, leaf2, leaf3));
14 |     let _root = BinaryTree::Node((5, leaf1, node));
15 | }
16 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_01_potions/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_01_potions/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_01_potions"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_01_potions/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_potions"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_01_potions/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | struct Potion {
 2 |     health: felt252,
 3 |     mana: felt252,
 4 | }
 5 | 
 6 | impl PotionAdd of Add<Potion> {
 7 |     fn add(lhs: Potion, rhs: Potion) -> Potion {
 8 |         Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana }
 9 |     }
10 | }
11 | 
12 | fn main() {
13 |     let health_potion: Potion = Potion { health: 100, mana: 0 };
14 |     let mana_potion: Potion = Potion { health: 0, mana: 100 };
15 |     let super_potion: Potion = health_potion + mana_potion;
16 |     // Both potions were combined with the `+` operator.
17 |     assert(super_potion.health == 100, '');
18 |     assert(super_potion.mana == 100, '');
19 | }
20 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_03_hash_trait/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_03_hash_trait/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_03_hash_trait"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_03_hash_trait/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_hash_trait"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_03_hash_trait/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: hashtrait
 2 | /// A trait for hash state accumulators.
 3 | trait HashStateTrait<S> {
 4 |     fn update(self: S, value: felt252) -> S;
 5 |     fn finalize(self: S) -> felt252;
 6 | }
 7 | 
 8 | /// Extension trait for hash state accumulators.
 9 | trait HashStateExTrait<S, T> {
10 |     /// Updates the hash state with the given value.
11 |     fn update_with(self: S, value: T) -> S;
12 | }
13 | 
14 | /// A trait for values that can be hashed.
15 | trait Hash<T, S, +HashStateTrait<S>> {
16 |     /// Updates the hash state with the given value.
17 |     fn update_state(state: S, value: T) -> S;
18 | }
19 | //ANCHOR_END: hashtrait
20 | 
21 | 
22 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_pedersen/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_pedersen/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_04_hash_pedersen"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_pedersen/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_hash_pedersen"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_pedersen/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: import
 2 | use core::pedersen::PedersenTrait;
 3 | use core::hash::{HashStateTrait, HashStateExTrait};
 4 | //ANCHOR_END: import
 5 | 
 6 | //ANCHOR: structure
 7 | #[derive(Drop, Hash, Serde, Copy)]
 8 | struct StructForHash {
 9 |     first: felt252,
10 |     second: felt252,
11 |     third: (u32, u32),
12 |     last: bool,
13 | }
14 | //ANCHOR_END: structure
15 | 
16 | //ANCHOR: main
17 | fn main() -> (felt252, felt252) {
18 |     let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };
19 | 
20 |     // hash1 is the result of hashing a struct with a base state of 0
21 |     let hash1 = PedersenTrait::new(0).update_with(struct_to_hash).finalize();
22 | 
23 |     let mut serialized_struct: Array<felt252> = ArrayTrait::new();
24 |     Serde::serialize(@struct_to_hash, ref serialized_struct);
25 |     let first_element = serialized_struct.pop_front().unwrap();
26 |     let mut state = PedersenTrait::new(first_element);
27 | 
28 |     while let Option::Some(value) = serialized_struct.pop_front() {
29 |         state = state.update(value);
30 |     };
31 | 
32 |     // hash2 is the result of hashing only the fields of the struct
33 |     let hash2 = state.finalize();
34 | 
35 |     (hash1, hash2)
36 | }
37 | //ANCHOR_END: main
38 | 
39 | 
40 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_poseidon/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_poseidon/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_04_hash_poseidon"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_poseidon/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_04_hash_poseidon"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_04_hash_poseidon/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::poseidon::PoseidonTrait;
 2 | use core::hash::{HashStateTrait, HashStateExTrait};
 3 | 
 4 | #[derive(Drop, Hash)]
 5 | struct StructForHash {
 6 |     first: felt252,
 7 |     second: felt252,
 8 |     third: (u32, u32),
 9 |     last: bool,
10 | }
11 | 
12 | fn main() -> felt252 {
13 |     let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };
14 | 
15 |     let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();
16 |     hash
17 | }
18 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_05_advanced_hash/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_05_advanced_hash/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_05_advanced_hash"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_05_advanced_hash/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_05_advanced_hash"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: import
 2 | use core::poseidon::PoseidonTrait;
 3 | use core::poseidon::poseidon_hash_span;
 4 | use core::hash::{HashStateTrait, HashStateExTrait};
 5 | //ANCHOR_END: import
 6 | 
 7 | //ANCHOR: structure
 8 | #[derive(Drop)]
 9 | struct StructForHashArray {
10 |     first: felt252,
11 |     second: felt252,
12 |     third: Array<felt252>,
13 | }
14 | //ANCHOR_END: structure
15 | 
16 | //ANCHOR: main
17 | fn main() {
18 |     let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };
19 | 
20 |     let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);
21 |     let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();
22 | }
23 | // ANCHOR_END: main
24 | 
25 | 
26 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_06_format_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_06_format_macro/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_06_format_macro"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_06_format_macro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_06_format_macro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_06_format_macro/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling no_listing_06_format_macro v0.1.0 (listings/ch11-advanced-features/no_listing_06_format_macro/Scarb.toml)
 3 | warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 4 |  --> listings/ch11-advanced-features/no_listing_06_format_macro/src/lib.cairo:5:9
 5 |     let s = s1 + "-" + s2 + "-" + s3;
 6 |         ^
 7 | 
 8 | warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 9 |  --> listings/ch11-advanced-features/no_listing_06_format_macro/src/lib.cairo:11:9
10 |     let s = format!("{s1}-{s2}-{s3}"); // s1, s2, s3 are not consumed by format!
11 |         ^
12 | 
13 |     Finished `dev` profile target(s) in 2 seconds
14 |      Running no_listing_06_format_macro
15 | tic-tac-toe
16 | Run completed successfully, returning []
17 | 
18 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_06_format_macro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let s1: ByteArray = "tic";
 3 |     let s2: ByteArray = "tac";
 4 |     let s3: ByteArray = "toe";
 5 |     let s = s1 + "-" + s2 + "-" + s3;
 6 |     // using + operator consumes the strings, so they can't be used again!
 7 | 
 8 |     let s1: ByteArray = "tic";
 9 |     let s2: ByteArray = "tac";
10 |     let s3: ByteArray = "toe";
11 |     let s = format!("{s1}-{s2}-{s3}"); // s1, s2, s3 are not consumed by format!
12 |     // or
13 |     let s = format!("{}-{}-{}", s1, s2, s3);
14 | 
15 |     println!("{}", s);
16 | }
17 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_07_write_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_07_write_macro/Scarb.lock:
--------------------------------------------------------------------------------
1 | # Code generated by scarb DO NOT EDIT.
2 | version = 1
3 | 
4 | [[package]]
5 | name = "no_listing_07_write_macro"
6 | version = "0.1.0"
7 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_07_write_macro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_07_write_macro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_07_write_macro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::fmt::Formatter;
 2 | 
 3 | fn main() {
 4 |     let mut formatter: Formatter = Default::default();
 5 |     let a = 10;
 6 |     let b = 20;
 7 |     write!(formatter, "hello");
 8 |     write!(formatter, "world");
 9 |     write!(formatter, " {a} {b}");
10 | 
11 |     println!("{}", formatter.buffer); // helloworld 10 20
12 | }
13 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_08_print_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_08_print_macro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_08_print_macro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_08_print_macro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | fn main() {
 2 |     let a = 10;
 3 |     let b = 20;
 4 |     let c = 30;
 5 | 
 6 |     println!("Hello world!");
 7 |     println!("{} {} {}", a, b, c); // 10 20 30
 8 |     println!("{c} {a} {}", b); // 30 10 20
 9 | }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_example/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_09_deref_coercion_example"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: Wrapper
 2 | #[derive(Drop, Copy)]
 3 | struct UserProfile {
 4 |     username: felt252,
 5 |     email: felt252,
 6 |     age: u16,
 7 | }
 8 | 
 9 | #[derive(Drop, Copy)]
10 | struct Wrapper<T> {
11 |     value: T,
12 | }
13 | // ANCHOR_END: Wrapper
14 | 
15 | // ANCHOR: deref
16 | impl DerefWrapper<T> of Deref<Wrapper<T>> {
17 |     type Target = T;
18 |     fn deref(self: Wrapper<T>) -> T {
19 |         self.value
20 |     }
21 | }
22 | // ANCHOR_END: deref
23 | 
24 | // ANCHOR: main
25 | fn main() {
26 |     let wrapped_profile = Wrapper {
27 |         value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
28 |     };
29 |     // Access fields directly via deref coercion
30 |     println!("Username: {}", wrapped_profile.username);
31 |     println!("Current age: {}", wrapped_profile.age);
32 | }
33 | // ANCHOR_END: main
34 | 
35 | 
36 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_mut_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_mut_example/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_09_deref_coercion_example"
3 | version = "0.1.0"
4 | edition = "2024_07"
5 | 
6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
7 | 
8 | [dependencies]
9 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_mut_example/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb build 
 2 |    Compiling no_listing_09_deref_coercion_example v0.1.0 (listings/ch11-advanced-features/no_listing_09_deref_mut_example/Scarb.toml)
 3 | error: Type "no_listing_09_deref_coercion_example::Wrapper::<no_listing_09_deref_coercion_example::UserProfile>" has no member "username"
 4 |  --> listings/ch11-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:32:46
 5 |     println!("Username: {}", wrapped_profile.username);
 6 |                                              ^******^
 7 | 
 8 | error: could not compile `no_listing_09_deref_coercion_example` due to previous error
 9 | 
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | 
 3 | use core::ops::DerefMut;
 4 | 
 5 | #[derive(Drop, Copy)]
 6 | struct UserProfile {
 7 |     username: felt252,
 8 |     email: felt252,
 9 |     age: u16,
10 | }
11 | 
12 | #[derive(Drop, Copy)]
13 | struct Wrapper<T> {
14 |     value: T,
15 | }
16 | 
17 | // ANCHOR: derefMut
18 | impl DerefMutWrapper<T, +Copy<T>> of DerefMut<Wrapper<T>> {
19 |     type Target = T;
20 |     fn deref_mut(ref self: Wrapper<T>) -> T {
21 |         self.value
22 |     }
23 | }
24 | //ANCHOR_END: derefMut
25 | 
26 | // ANCHOR: error
27 | fn error() {
28 |     let wrapped_profile = Wrapper {
29 |         value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
30 |     };
31 |     // Uncommenting the next line will cause a compilation error
32 |     println!("Username: {}", wrapped_profile.username);
33 | }
34 | // ANCHOR_END: error
35 | 
36 | // ANCHOR: example
37 | fn main() {
38 |     let mut wrapped_profile = Wrapper {
39 |         value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
40 |     };
41 | 
42 |     println!("Username: {}", wrapped_profile.username);
43 |     println!("Current age: {}", wrapped_profile.age);
44 | }
45 | // ANCHOR_END: example
46 | 
47 | 
48 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_display_trait_with_format/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_display_trait_with_format/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_09_display_trait_with_format"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_09_display_trait_with_format/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::fmt::{Display, Formatter, Error};
 2 | 
 3 | #[derive(Copy, Drop)]
 4 | struct Point {
 5 |     x: u8,
 6 |     y: u8,
 7 | }
 8 | 
 9 | impl PointDisplay of Display<Point> {
10 |     fn fmt(self: @Point, ref f: Formatter) -> Result<(), Error> {
11 |         let str: ByteArray = format!("Point ({}, {})", *self.x, *self.y);
12 |         f.buffer.append(@str);
13 |         Result::Ok(())
14 |     }
15 | }
16 | 
17 | fn main() {
18 |     let p = Point { x: 1, y: 3 };
19 |     println!("{}", p); // Point: (1, 3)
20 | }
21 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_10_display_trait_with_write/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_10_display_trait_with_write/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_10_display_trait_with_write"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_10_display_trait_with_write/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::fmt::{Display, Formatter, Error};
 2 | 
 3 | #[derive(Copy, Drop)]
 4 | struct Point {
 5 |     x: u8,
 6 |     y: u8,
 7 | }
 8 | 
 9 | impl PointDisplay of Display<Point> {
10 |     fn fmt(self: @Point, ref f: Formatter) -> Result<(), Error> {
11 |         let x = *self.x;
12 |         let y = *self.y;
13 | 
14 |         writeln!(f, "Point ({x}, {y})")
15 |     }
16 | }
17 | 
18 | fn main() {
19 |     let p = Point { x: 1, y: 3 };
20 |     println!("{}", p); // Point: (1, 3)
21 | }
22 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_12_dict_struct_member/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_12_dict_struct_member/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_12_dict_struct_member"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::dict::Felt252Dict;
 2 | 
 3 | // ANCHOR: struct
 4 | struct UserDatabase<T> {
 5 |     users_updates: u64,
 6 |     balances: Felt252Dict<T>,
 7 | }
 8 | // ANCHOR_END: struct
 9 | 
10 | // ANCHOR: trait
11 | trait UserDatabaseTrait<T> {
12 |     fn new() -> UserDatabase<T>;
13 |     fn update_user<+Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);
14 |     fn get_balance<+Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;
15 | }
16 | // ANCHOR_END: trait
17 | 
18 | // ANCHOR: impl
19 | impl UserDatabaseImpl<T, +Felt252DictValue<T>> of UserDatabaseTrait<T> {
20 |     // Creates a database
21 |     fn new() -> UserDatabase<T> {
22 |         UserDatabase { users_updates: 0, balances: Default::default() }
23 |     }
24 | 
25 |     // Get the user's balance
26 |     fn get_balance<+Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {
27 |         self.balances.get(name)
28 |     }
29 | 
30 |     // Add a user
31 |     fn update_user<+Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {
32 |         self.balances.insert(name, balance);
33 |         self.users_updates += 1;
34 |     }
35 | }
36 | // ANCHOR_END: impl
37 | 
38 | // ANCHOR: destruct
39 | impl UserDatabaseDestruct<T, +Drop<T>, +Felt252DictValue<T>> of Destruct<UserDatabase<T>> {
40 |     fn destruct(self: UserDatabase<T>) nopanic {
41 |         self.balances.squash();
42 |     }
43 | }
44 | // ANCHOR_END: destruct
45 | 
46 | // ANCHOR: main
47 | fn main() {
48 |     let mut db = UserDatabaseTrait::<u64>::new();
49 | 
50 |     db.update_user('Alex', 100);
51 |     db.update_user('Maria', 80);
52 | 
53 |     db.update_user('Alex', 40);
54 |     db.update_user('Maria', 0);
55 | 
56 |     let alex_latest_balance = db.get_balance('Alex');
57 |     let maria_latest_balance = db.get_balance('Maria');
58 | 
59 |     assert!(alex_latest_balance == 40, "Expected 40");
60 |     assert!(maria_latest_balance == 0, "Expected 0");
61 | }
62 | // ANCHOR_END: main
63 | 
64 | 
65 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_13_cust_struct_vect/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_13_cust_struct_stack"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | 
 3 | // ANCHOR: imports
 4 | use core::dict::Felt252Dict;
 5 | use core::nullable::NullableTrait;
 6 | use core::num::traits::WrappingAdd;
 7 | // ANCHOR_END: imports
 8 | 
 9 | // ANCHOR: trait
10 | trait MemoryVecTrait<V, T> {
11 |     fn new() -> V;
12 |     fn get(ref self: V, index: usize) -> Option<T>;
13 |     fn at(ref self: V, index: usize) -> T;
14 |     fn push(ref self: V, value: T) -> ();
15 |     fn set(ref self: V, index: usize, value: T);
16 |     fn len(self: @V) -> usize;
17 | }
18 | // ANCHOR_END: trait
19 | 
20 | // ANCHOR: struct
21 | struct MemoryVec<T> {
22 |     data: Felt252Dict<Nullable<T>>,
23 |     len: usize,
24 | }
25 | // ANCHOR_END: struct
26 | 
27 | // ANCHOR: destruct
28 | impl DestructMemoryVec<T, +Drop<T>> of Destruct<MemoryVec<T>> {
29 |     fn destruct(self: MemoryVec<T>) nopanic {
30 |         self.data.squash();
31 |     }
32 | }
33 | // ANCHOR_END: destruct
34 | 
35 | // ANCHOR: implem
36 | impl MemoryVecImpl<T, +Drop<T>, +Copy<T>> of MemoryVecTrait<MemoryVec<T>, T> {
37 |     fn new() -> MemoryVec<T> {
38 |         MemoryVec { data: Default::default(), len: 0 }
39 |     }
40 | 
41 |     fn get(ref self: MemoryVec<T>, index: usize) -> Option<T> {
42 |         if index < self.len() {
43 |             Option::Some(self.data.get(index.into()).deref())
44 |         } else {
45 |             Option::None
46 |         }
47 |     }
48 | 
49 |     fn at(ref self: MemoryVec<T>, index: usize) -> T {
50 |         assert!(index < self.len(), "Index out of bounds");
51 |         self.data.get(index.into()).deref()
52 |     }
53 | 
54 |     fn push(ref self: MemoryVec<T>, value: T) -> () {
55 |         self.data.insert(self.len.into(), NullableTrait::new(value));
56 |         self.len.wrapping_add(1_usize);
57 |     }
58 |     // ANCHOR: set
59 |     fn set(ref self: MemoryVec<T>, index: usize, value: T) {
60 |         assert!(index < self.len(), "Index out of bounds");
61 |         self.data.insert(index.into(), NullableTrait::new(value));
62 |     }
63 |     // ANCHOR_END: set
64 |     fn len(self: @MemoryVec<T>) -> usize {
65 |         *self.len
66 |     }
67 | }
68 | // ANCHOR_END: implem
69 | 
70 | 
71 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_14_cust_struct_stack/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_14_cust_struct_stack"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR: all
 2 | 
 3 | // ANCHOR: imports
 4 | use core::dict::Felt252Dict;
 5 | use core::nullable::{match_nullable, FromNullableResult, NullableTrait};
 6 | // ANCHOR_END: imports
 7 | 
 8 | // ANCHOR: trait
 9 | trait StackTrait<S, T> {
10 |     fn push(ref self: S, value: T);
11 |     fn pop(ref self: S) -> Option<T>;
12 |     fn is_empty(self: @S) -> bool;
13 | }
14 | // ANCHOR_END: trait
15 | 
16 | // ANCHOR: struct
17 | struct NullableStack<T> {
18 |     data: Felt252Dict<Nullable<T>>,
19 |     len: usize,
20 | }
21 | // ANCHOR_END: struct
22 | 
23 | impl DestructNullableStack<T, +Drop<T>> of Destruct<NullableStack<T>> {
24 |     fn destruct(self: NullableStack<T>) nopanic {
25 |         self.data.squash();
26 |     }
27 | }
28 | 
29 | 
30 | // ANCHOR: implem
31 | impl NullableStackImpl<T, +Drop<T>, +Copy<T>> of StackTrait<NullableStack<T>, T> {
32 |     fn push(ref self: NullableStack<T>, value: T) {
33 |         self.data.insert(self.len.into(), NullableTrait::new(value));
34 |         self.len += 1;
35 |     }
36 | 
37 |     fn pop(ref self: NullableStack<T>) -> Option<T> {
38 |         if self.is_empty() {
39 |             return Option::None;
40 |         }
41 |         self.len -= 1;
42 |         Option::Some(self.data.get(self.len.into()).deref())
43 |     }
44 | 
45 |     fn is_empty(self: @NullableStack<T>) -> bool {
46 |         *self.len == 0
47 |     }
48 | }
49 | // ANCHOR_END: implem
50 | 
51 | 
52 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/Cargo.lock:
--------------------------------------------------------------------------------
  1 | # This file is automatically @generated by Cargo.
  2 | # It is not intended for manual editing.
  3 | version = 4
  4 | 
  5 | [[package]]
  6 | name = "ahash"
  7 | version = "0.8.11"
  8 | source = "registry+https://github.com/rust-lang/crates.io-index"
  9 | checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
 10 | dependencies = [
 11 |  "cfg-if",
 12 |  "once_cell",
 13 |  "version_check",
 14 |  "zerocopy",
 15 | ]
 16 | 
 17 | [[package]]
 18 | name = "allocator-api2"
 19 | version = "0.2.18"
 20 | source = "registry+https://github.com/rust-lang/crates.io-index"
 21 | checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"
 22 | 
 23 | [[package]]
 24 | name = "autocfg"
 25 | version = "1.3.0"
 26 | source = "registry+https://github.com/rust-lang/crates.io-index"
 27 | checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"
 28 | 
 29 | [[package]]
 30 | name = "bigdecimal"
 31 | version = "0.4.5"
 32 | source = "registry+https://github.com/rust-lang/crates.io-index"
 33 | checksum = "51d712318a27c7150326677b321a5fa91b55f6d9034ffd67f20319e147d40cee"
 34 | dependencies = [
 35 |  "autocfg",
 36 |  "libm",
 37 |  "num-bigint",
 38 |  "num-integer",
 39 |  "num-traits",
 40 | ]
 41 | 
 42 | [[package]]
 43 | name = "bitflags"
 44 | version = "2.6.0"
 45 | source = "registry+https://github.com/rust-lang/crates.io-index"
 46 | checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"
 47 | 
 48 | [[package]]
 49 | name = "cairo-lang-debug"
 50 | version = "2.9.1"
 51 | source = "registry+https://github.com/rust-lang/crates.io-index"
 52 | checksum = "6be5007f324a01655e3cb68f364ca2ec1b7572680466db87c9a3b79a21719787"
 53 | dependencies = [
 54 |  "cairo-lang-utils",
 55 | ]
 56 | 
 57 | [[package]]
 58 | name = "cairo-lang-diagnostics"
 59 | version = "2.9.1"
 60 | source = "registry+https://github.com/rust-lang/crates.io-index"
 61 | checksum = "9106d4a80140aa57452d89ffd876f7ee02a106e1a217d6cbb2dbd8c6c47e60d0"
 62 | dependencies = [
 63 |  "cairo-lang-debug",
 64 |  "cairo-lang-filesystem",
 65 |  "cairo-lang-utils",
 66 |  "itertools",
 67 | ]
 68 | 
 69 | [[package]]
 70 | name = "cairo-lang-filesystem"
 71 | version = "2.9.1"
 72 | source = "registry+https://github.com/rust-lang/crates.io-index"
 73 | checksum = "d5a197bb16c9a90f480abbe47046297e715c1db3a1c682f8b1d17d609675278c"
 74 | dependencies = [
 75 |  "cairo-lang-debug",
 76 |  "cairo-lang-utils",
 77 |  "path-clean",
 78 |  "rust-analyzer-salsa",
 79 |  "semver",
 80 |  "serde",
 81 |  "smol_str",
 82 |  "toml",
 83 | ]
 84 | 
 85 | [[package]]
 86 | name = "cairo-lang-macro"
 87 | version = "0.1.1"
 88 | source = "registry+https://github.com/rust-lang/crates.io-index"
 89 | checksum = "dda77fe9404e438edaa80c9acaf0d72260aa883ba433812d0a745f5a72f31881"
 90 | dependencies = [
 91 |  "cairo-lang-macro-attributes",
 92 |  "cairo-lang-macro-stable",
 93 |  "linkme",
 94 | ]
 95 | 
 96 | [[package]]
 97 | name = "cairo-lang-macro-attributes"
 98 | version = "0.1.0"
 99 | source = "registry+https://github.com/rust-lang/crates.io-index"
100 | checksum = "e32e958decd95ae122ee64daa26721da2f76e83231047f947fd9cdc5d3c90cc6"
101 | dependencies = [
102 |  "quote",
103 |  "scarb-stable-hash",
104 |  "syn",
105 | ]
106 | 
107 | [[package]]
108 | name = "cairo-lang-macro-stable"
109 | version = "1.0.0"
110 | source = "registry+https://github.com/rust-lang/crates.io-index"
111 | checksum = "c49906d6b1c215e5814be7c5c65ecf2328898b335bee8c2409ec07cfb5530daf"
112 | 
113 | [[package]]
114 | name = "cairo-lang-parser"
115 | version = "2.9.1"
116 | source = "registry+https://github.com/rust-lang/crates.io-index"
117 | checksum = "f1579124d1e0f0a3cf3d29de7ae690ba86abb3531d75763c9431d4597ed27b3e"
118 | dependencies = [
119 |  "cairo-lang-diagnostics",
120 |  "cairo-lang-filesystem",
121 |  "cairo-lang-syntax",
122 |  "cairo-lang-syntax-codegen",
123 |  "cairo-lang-utils",
124 |  "colored",
125 |  "itertools",
126 |  "num-bigint",
127 |  "num-traits",
128 |  "rust-analyzer-salsa",
129 |  "smol_str",
130 |  "unescaper",
131 | ]
132 | 
133 | [[package]]
134 | name = "cairo-lang-primitive-token"
135 | version = "1.0.0"
136 | source = "registry+https://github.com/rust-lang/crates.io-index"
137 | checksum = "123ac0ecadf31bacae77436d72b88fa9caef2b8e92c89ce63a125ae911a12fae"
138 | 
139 | [[package]]
140 | name = "cairo-lang-syntax"
141 | version = "2.9.1"
142 | source = "registry+https://github.com/rust-lang/crates.io-index"
143 | checksum = "cc64c19279354975d45cf325e5618287c7fe01dbcbd0341db0f5429375e3a854"
144 | dependencies = [
145 |  "cairo-lang-debug",
146 |  "cairo-lang-filesystem",
147 |  "cairo-lang-primitive-token",
148 |  "cairo-lang-utils",
149 |  "num-bigint",
150 |  "num-traits",
151 |  "rust-analyzer-salsa",
152 |  "smol_str",
153 |  "unescaper",
154 | ]
155 | 
156 | [[package]]
157 | name = "cairo-lang-syntax-codegen"
158 | version = "2.9.1"
159 | source = "registry+https://github.com/rust-lang/crates.io-index"
160 | checksum = "80bede54808f2e5d26a8702711009eefe4a12e5a8f3a427ba9b081073c8e9d36"
161 | dependencies = [
162 |  "genco",
163 |  "xshell",
164 | ]
165 | 
166 | [[package]]
167 | name = "cairo-lang-utils"
168 | version = "2.9.1"
169 | source = "registry+https://github.com/rust-lang/crates.io-index"
170 | checksum = "3e89f1a4669e07f30a56a20d4bcc4eb43d78675e5bcb9af3bdbcf7f245330114"
171 | dependencies = [
172 |  "hashbrown",
173 |  "indexmap",
174 |  "itertools",
175 |  "num-bigint",
176 |  "num-traits",
177 |  "serde",
178 | ]
179 | 
180 | [[package]]
181 | name = "cfg-if"
182 | version = "1.0.0"
183 | source = "registry+https://github.com/rust-lang/crates.io-index"
184 | checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
185 | 
186 | [[package]]
187 | name = "colored"
188 | version = "2.1.0"
189 | source = "registry+https://github.com/rust-lang/crates.io-index"
190 | checksum = "cbf2150cce219b664a8a70df7a1f933836724b503f8a413af9365b4dcc4d90b8"
191 | dependencies = [
192 |  "lazy_static",
193 |  "windows-sys",
194 | ]
195 | 
196 | [[package]]
197 | name = "data-encoding"
198 | version = "2.6.0"
199 | source = "registry+https://github.com/rust-lang/crates.io-index"
200 | checksum = "e8566979429cf69b49a5c740c60791108e86440e8be149bbea4fe54d2c32d6e2"
201 | 
202 | [[package]]
203 | name = "either"
204 | version = "1.13.0"
205 | source = "registry+https://github.com/rust-lang/crates.io-index"
206 | checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"
207 | 
208 | [[package]]
209 | name = "equivalent"
210 | version = "1.0.1"
211 | source = "registry+https://github.com/rust-lang/crates.io-index"
212 | checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
213 | 
214 | [[package]]
215 | name = "genco"
216 | version = "0.17.9"
217 | source = "registry+https://github.com/rust-lang/crates.io-index"
218 | checksum = "afac3cbb14db69ac9fef9cdb60d8a87e39a7a527f85a81a923436efa40ad42c6"
219 | dependencies = [
220 |  "genco-macros",
221 |  "relative-path",
222 |  "smallvec",
223 | ]
224 | 
225 | [[package]]
226 | name = "genco-macros"
227 | version = "0.17.9"
228 | source = "registry+https://github.com/rust-lang/crates.io-index"
229 | checksum = "553630feadf7b76442b0849fd25fdf89b860d933623aec9693fed19af0400c78"
230 | dependencies = [
231 |  "proc-macro2",
232 |  "quote",
233 |  "syn",
234 | ]
235 | 
236 | [[package]]
237 | name = "hashbrown"
238 | version = "0.14.5"
239 | source = "registry+https://github.com/rust-lang/crates.io-index"
240 | checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
241 | dependencies = [
242 |  "ahash",
243 |  "allocator-api2",
244 |  "serde",
245 | ]
246 | 
247 | [[package]]
248 | name = "heck"
249 | version = "0.4.1"
250 | source = "registry+https://github.com/rust-lang/crates.io-index"
251 | checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"
252 | 
253 | [[package]]
254 | name = "indexmap"
255 | version = "2.4.0"
256 | source = "registry+https://github.com/rust-lang/crates.io-index"
257 | checksum = "93ead53efc7ea8ed3cfb0c79fc8023fbb782a5432b52830b6518941cebe6505c"
258 | dependencies = [
259 |  "equivalent",
260 |  "hashbrown",
261 |  "serde",
262 | ]
263 | 
264 | [[package]]
265 | name = "itertools"
266 | version = "0.12.1"
267 | source = "registry+https://github.com/rust-lang/crates.io-index"
268 | checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
269 | dependencies = [
270 |  "either",
271 | ]
272 | 
273 | [[package]]
274 | name = "lazy_static"
275 | version = "1.5.0"
276 | source = "registry+https://github.com/rust-lang/crates.io-index"
277 | checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
278 | 
279 | [[package]]
280 | name = "libc"
281 | version = "0.2.158"
282 | source = "registry+https://github.com/rust-lang/crates.io-index"
283 | checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"
284 | 
285 | [[package]]
286 | name = "libm"
287 | version = "0.2.8"
288 | source = "registry+https://github.com/rust-lang/crates.io-index"
289 | checksum = "4ec2a862134d2a7d32d7983ddcdd1c4923530833c9f2ea1a44fc5fa473989058"
290 | 
291 | [[package]]
292 | name = "linkme"
293 | version = "0.3.28"
294 | source = "registry+https://github.com/rust-lang/crates.io-index"
295 | checksum = "3c943daedff228392b791b33bba32e75737756e80a613e32e246c6ce9cbab20a"
296 | dependencies = [
297 |  "linkme-impl",
298 | ]
299 | 
300 | [[package]]
301 | name = "linkme-impl"
302 | version = "0.3.28"
303 | source = "registry+https://github.com/rust-lang/crates.io-index"
304 | checksum = "cb26336e6dc7cc76e7927d2c9e7e3bb376d7af65a6f56a0b16c47d18a9b1abc5"
305 | dependencies = [
306 |  "proc-macro2",
307 |  "quote",
308 |  "syn",
309 | ]
310 | 
311 | [[package]]
312 | name = "lock_api"
313 | version = "0.4.12"
314 | source = "registry+https://github.com/rust-lang/crates.io-index"
315 | checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
316 | dependencies = [
317 |  "autocfg",
318 |  "scopeguard",
319 | ]
320 | 
321 | [[package]]
322 | name = "memchr"
323 | version = "2.7.4"
324 | source = "registry+https://github.com/rust-lang/crates.io-index"
325 | checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
326 | 
327 | [[package]]
328 | name = "no_listing_15_macro"
329 | version = "0.1.0"
330 | dependencies = [
331 |  "bigdecimal",
332 |  "cairo-lang-macro",
333 |  "cairo-lang-parser",
334 |  "cairo-lang-syntax",
335 | ]
336 | 
337 | [[package]]
338 | name = "num-bigint"
339 | version = "0.4.6"
340 | source = "registry+https://github.com/rust-lang/crates.io-index"
341 | checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
342 | dependencies = [
343 |  "num-integer",
344 |  "num-traits",
345 |  "serde",
346 | ]
347 | 
348 | [[package]]
349 | name = "num-integer"
350 | version = "0.1.46"
351 | source = "registry+https://github.com/rust-lang/crates.io-index"
352 | checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
353 | dependencies = [
354 |  "num-traits",
355 | ]
356 | 
357 | [[package]]
358 | name = "num-traits"
359 | version = "0.2.19"
360 | source = "registry+https://github.com/rust-lang/crates.io-index"
361 | checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
362 | dependencies = [
363 |  "autocfg",
364 | ]
365 | 
366 | [[package]]
367 | name = "once_cell"
368 | version = "1.19.0"
369 | source = "registry+https://github.com/rust-lang/crates.io-index"
370 | checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"
371 | 
372 | [[package]]
373 | name = "oorandom"
374 | version = "11.1.4"
375 | source = "registry+https://github.com/rust-lang/crates.io-index"
376 | checksum = "b410bbe7e14ab526a0e86877eb47c6996a2bd7746f027ba551028c925390e4e9"
377 | 
378 | [[package]]
379 | name = "parking_lot"
380 | version = "0.12.3"
381 | source = "registry+https://github.com/rust-lang/crates.io-index"
382 | checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
383 | dependencies = [
384 |  "lock_api",
385 |  "parking_lot_core",
386 | ]
387 | 
388 | [[package]]
389 | name = "parking_lot_core"
390 | version = "0.9.10"
391 | source = "registry+https://github.com/rust-lang/crates.io-index"
392 | checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
393 | dependencies = [
394 |  "cfg-if",
395 |  "libc",
396 |  "redox_syscall",
397 |  "smallvec",
398 |  "windows-targets 0.52.6",
399 | ]
400 | 
401 | [[package]]
402 | name = "path-clean"
403 | version = "1.0.1"
404 | source = "registry+https://github.com/rust-lang/crates.io-index"
405 | checksum = "17359afc20d7ab31fdb42bb844c8b3bb1dabd7dcf7e68428492da7f16966fcef"
406 | 
407 | [[package]]
408 | name = "pin-project-lite"
409 | version = "0.2.15"
410 | source = "registry+https://github.com/rust-lang/crates.io-index"
411 | checksum = "915a1e146535de9163f3987b8944ed8cf49a18bb0056bcebcdcece385cece4ff"
412 | 
413 | [[package]]
414 | name = "proc-macro2"
415 | version = "1.0.86"
416 | source = "registry+https://github.com/rust-lang/crates.io-index"
417 | checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
418 | dependencies = [
419 |  "unicode-ident",
420 | ]
421 | 
422 | [[package]]
423 | name = "quote"
424 | version = "1.0.37"
425 | source = "registry+https://github.com/rust-lang/crates.io-index"
426 | checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
427 | dependencies = [
428 |  "proc-macro2",
429 | ]
430 | 
431 | [[package]]
432 | name = "redox_syscall"
433 | version = "0.5.7"
434 | source = "registry+https://github.com/rust-lang/crates.io-index"
435 | checksum = "9b6dfecf2c74bce2466cabf93f6664d6998a69eb21e39f4207930065b27b771f"
436 | dependencies = [
437 |  "bitflags",
438 | ]
439 | 
440 | [[package]]
441 | name = "relative-path"
442 | version = "1.9.3"
443 | source = "registry+https://github.com/rust-lang/crates.io-index"
444 | checksum = "ba39f3699c378cd8970968dcbff9c43159ea4cfbd88d43c00b22f2ef10a435d2"
445 | 
446 | [[package]]
447 | name = "rust-analyzer-salsa"
448 | version = "0.17.0-pre.6"
449 | source = "registry+https://github.com/rust-lang/crates.io-index"
450 | checksum = "719825638c59fd26a55412a24561c7c5bcf54364c88b9a7a04ba08a6eafaba8d"
451 | dependencies = [
452 |  "indexmap",
453 |  "lock_api",
454 |  "oorandom",
455 |  "parking_lot",
456 |  "rust-analyzer-salsa-macros",
457 |  "rustc-hash",
458 |  "smallvec",
459 |  "tracing",
460 |  "triomphe",
461 | ]
462 | 
463 | [[package]]
464 | name = "rust-analyzer-salsa-macros"
465 | version = "0.17.0-pre.6"
466 | source = "registry+https://github.com/rust-lang/crates.io-index"
467 | checksum = "4d96498e9684848c6676c399032ebc37c52da95ecbefa83d71ccc53b9f8a4a8e"
468 | dependencies = [
469 |  "heck",
470 |  "proc-macro2",
471 |  "quote",
472 |  "syn",
473 | ]
474 | 
475 | [[package]]
476 | name = "rustc-hash"
477 | version = "1.1.0"
478 | source = "registry+https://github.com/rust-lang/crates.io-index"
479 | checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
480 | 
481 | [[package]]
482 | name = "scarb-stable-hash"
483 | version = "1.0.0"
484 | source = "registry+https://github.com/rust-lang/crates.io-index"
485 | checksum = "1902536b23a05dd165d3992865870aaf1b0650317767cbf171ed2ca5903732a9"
486 | dependencies = [
487 |  "data-encoding",
488 |  "xxhash-rust",
489 | ]
490 | 
491 | [[package]]
492 | name = "scopeguard"
493 | version = "1.2.0"
494 | source = "registry+https://github.com/rust-lang/crates.io-index"
495 | checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
496 | 
497 | [[package]]
498 | name = "semver"
499 | version = "1.0.23"
500 | source = "registry+https://github.com/rust-lang/crates.io-index"
501 | checksum = "61697e0a1c7e512e84a621326239844a24d8207b4669b41bc18b32ea5cbf988b"
502 | dependencies = [
503 |  "serde",
504 | ]
505 | 
506 | [[package]]
507 | name = "serde"
508 | version = "1.0.209"
509 | source = "registry+https://github.com/rust-lang/crates.io-index"
510 | checksum = "99fce0ffe7310761ca6bf9faf5115afbc19688edd00171d81b1bb1b116c63e09"
511 | dependencies = [
512 |  "serde_derive",
513 | ]
514 | 
515 | [[package]]
516 | name = "serde_derive"
517 | version = "1.0.209"
518 | source = "registry+https://github.com/rust-lang/crates.io-index"
519 | checksum = "a5831b979fd7b5439637af1752d535ff49f4860c0f341d1baeb6faf0f4242170"
520 | dependencies = [
521 |  "proc-macro2",
522 |  "quote",
523 |  "syn",
524 | ]
525 | 
526 | [[package]]
527 | name = "serde_spanned"
528 | version = "0.6.8"
529 | source = "registry+https://github.com/rust-lang/crates.io-index"
530 | checksum = "87607cb1398ed59d48732e575a4c28a7a8ebf2454b964fe3f224f2afc07909e1"
531 | dependencies = [
532 |  "serde",
533 | ]
534 | 
535 | [[package]]
536 | name = "smallvec"
537 | version = "1.13.2"
538 | source = "registry+https://github.com/rust-lang/crates.io-index"
539 | checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"
540 | 
541 | [[package]]
542 | name = "smol_str"
543 | version = "0.2.2"
544 | source = "registry+https://github.com/rust-lang/crates.io-index"
545 | checksum = "dd538fb6910ac1099850255cf94a94df6551fbdd602454387d0adb2d1ca6dead"
546 | dependencies = [
547 |  "serde",
548 | ]
549 | 
550 | [[package]]
551 | name = "stable_deref_trait"
552 | version = "1.2.0"
553 | source = "registry+https://github.com/rust-lang/crates.io-index"
554 | checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
555 | 
556 | [[package]]
557 | name = "syn"
558 | version = "2.0.76"
559 | source = "registry+https://github.com/rust-lang/crates.io-index"
560 | checksum = "578e081a14e0cefc3279b0472138c513f37b41a08d5a3cca9b6e4e8ceb6cd525"
561 | dependencies = [
562 |  "proc-macro2",
563 |  "quote",
564 |  "unicode-ident",
565 | ]
566 | 
567 | [[package]]
568 | name = "thiserror"
569 | version = "1.0.63"
570 | source = "registry+https://github.com/rust-lang/crates.io-index"
571 | checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
572 | dependencies = [
573 |  "thiserror-impl",
574 | ]
575 | 
576 | [[package]]
577 | name = "thiserror-impl"
578 | version = "1.0.63"
579 | source = "registry+https://github.com/rust-lang/crates.io-index"
580 | checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
581 | dependencies = [
582 |  "proc-macro2",
583 |  "quote",
584 |  "syn",
585 | ]
586 | 
587 | [[package]]
588 | name = "toml"
589 | version = "0.8.19"
590 | source = "registry+https://github.com/rust-lang/crates.io-index"
591 | checksum = "a1ed1f98e3fdc28d6d910e6737ae6ab1a93bf1985935a1193e68f93eeb68d24e"
592 | dependencies = [
593 |  "serde",
594 |  "serde_spanned",
595 |  "toml_datetime",
596 |  "toml_edit",
597 | ]
598 | 
599 | [[package]]
600 | name = "toml_datetime"
601 | version = "0.6.8"
602 | source = "registry+https://github.com/rust-lang/crates.io-index"
603 | checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"
604 | dependencies = [
605 |  "serde",
606 | ]
607 | 
608 | [[package]]
609 | name = "toml_edit"
610 | version = "0.22.22"
611 | source = "registry+https://github.com/rust-lang/crates.io-index"
612 | checksum = "4ae48d6208a266e853d946088ed816055e556cc6028c5e8e2b84d9fa5dd7c7f5"
613 | dependencies = [
614 |  "indexmap",
615 |  "serde",
616 |  "serde_spanned",
617 |  "toml_datetime",
618 |  "winnow",
619 | ]
620 | 
621 | [[package]]
622 | name = "tracing"
623 | version = "0.1.41"
624 | source = "registry+https://github.com/rust-lang/crates.io-index"
625 | checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
626 | dependencies = [
627 |  "pin-project-lite",
628 |  "tracing-attributes",
629 |  "tracing-core",
630 | ]
631 | 
632 | [[package]]
633 | name = "tracing-attributes"
634 | version = "0.1.28"
635 | source = "registry+https://github.com/rust-lang/crates.io-index"
636 | checksum = "395ae124c09f9e6918a2310af6038fba074bcf474ac352496d5910dd59a2226d"
637 | dependencies = [
638 |  "proc-macro2",
639 |  "quote",
640 |  "syn",
641 | ]
642 | 
643 | [[package]]
644 | name = "tracing-core"
645 | version = "0.1.33"
646 | source = "registry+https://github.com/rust-lang/crates.io-index"
647 | checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"
648 | dependencies = [
649 |  "once_cell",
650 | ]
651 | 
652 | [[package]]
653 | name = "triomphe"
654 | version = "0.1.14"
655 | source = "registry+https://github.com/rust-lang/crates.io-index"
656 | checksum = "ef8f7726da4807b58ea5c96fdc122f80702030edc33b35aff9190a51148ccc85"
657 | dependencies = [
658 |  "serde",
659 |  "stable_deref_trait",
660 | ]
661 | 
662 | [[package]]
663 | name = "unescaper"
664 | version = "0.1.5"
665 | source = "registry+https://github.com/rust-lang/crates.io-index"
666 | checksum = "c878a167baa8afd137494101a688ef8c67125089ff2249284bd2b5f9bfedb815"
667 | dependencies = [
668 |  "thiserror",
669 | ]
670 | 
671 | [[package]]
672 | name = "unicode-ident"
673 | version = "1.0.12"
674 | source = "registry+https://github.com/rust-lang/crates.io-index"
675 | checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
676 | 
677 | [[package]]
678 | name = "version_check"
679 | version = "0.9.5"
680 | source = "registry+https://github.com/rust-lang/crates.io-index"
681 | checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
682 | 
683 | [[package]]
684 | name = "windows-sys"
685 | version = "0.48.0"
686 | source = "registry+https://github.com/rust-lang/crates.io-index"
687 | checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
688 | dependencies = [
689 |  "windows-targets 0.48.5",
690 | ]
691 | 
692 | [[package]]
693 | name = "windows-targets"
694 | version = "0.48.5"
695 | source = "registry+https://github.com/rust-lang/crates.io-index"
696 | checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
697 | dependencies = [
698 |  "windows_aarch64_gnullvm 0.48.5",
699 |  "windows_aarch64_msvc 0.48.5",
700 |  "windows_i686_gnu 0.48.5",
701 |  "windows_i686_msvc 0.48.5",
702 |  "windows_x86_64_gnu 0.48.5",
703 |  "windows_x86_64_gnullvm 0.48.5",
704 |  "windows_x86_64_msvc 0.48.5",
705 | ]
706 | 
707 | [[package]]
708 | name = "windows-targets"
709 | version = "0.52.6"
710 | source = "registry+https://github.com/rust-lang/crates.io-index"
711 | checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
712 | dependencies = [
713 |  "windows_aarch64_gnullvm 0.52.6",
714 |  "windows_aarch64_msvc 0.52.6",
715 |  "windows_i686_gnu 0.52.6",
716 |  "windows_i686_gnullvm",
717 |  "windows_i686_msvc 0.52.6",
718 |  "windows_x86_64_gnu 0.52.6",
719 |  "windows_x86_64_gnullvm 0.52.6",
720 |  "windows_x86_64_msvc 0.52.6",
721 | ]
722 | 
723 | [[package]]
724 | name = "windows_aarch64_gnullvm"
725 | version = "0.48.5"
726 | source = "registry+https://github.com/rust-lang/crates.io-index"
727 | checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
728 | 
729 | [[package]]
730 | name = "windows_aarch64_gnullvm"
731 | version = "0.52.6"
732 | source = "registry+https://github.com/rust-lang/crates.io-index"
733 | checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
734 | 
735 | [[package]]
736 | name = "windows_aarch64_msvc"
737 | version = "0.48.5"
738 | source = "registry+https://github.com/rust-lang/crates.io-index"
739 | checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
740 | 
741 | [[package]]
742 | name = "windows_aarch64_msvc"
743 | version = "0.52.6"
744 | source = "registry+https://github.com/rust-lang/crates.io-index"
745 | checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
746 | 
747 | [[package]]
748 | name = "windows_i686_gnu"
749 | version = "0.48.5"
750 | source = "registry+https://github.com/rust-lang/crates.io-index"
751 | checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
752 | 
753 | [[package]]
754 | name = "windows_i686_gnu"
755 | version = "0.52.6"
756 | source = "registry+https://github.com/rust-lang/crates.io-index"
757 | checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
758 | 
759 | [[package]]
760 | name = "windows_i686_gnullvm"
761 | version = "0.52.6"
762 | source = "registry+https://github.com/rust-lang/crates.io-index"
763 | checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
764 | 
765 | [[package]]
766 | name = "windows_i686_msvc"
767 | version = "0.48.5"
768 | source = "registry+https://github.com/rust-lang/crates.io-index"
769 | checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
770 | 
771 | [[package]]
772 | name = "windows_i686_msvc"
773 | version = "0.52.6"
774 | source = "registry+https://github.com/rust-lang/crates.io-index"
775 | checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
776 | 
777 | [[package]]
778 | name = "windows_x86_64_gnu"
779 | version = "0.48.5"
780 | source = "registry+https://github.com/rust-lang/crates.io-index"
781 | checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
782 | 
783 | [[package]]
784 | name = "windows_x86_64_gnu"
785 | version = "0.52.6"
786 | source = "registry+https://github.com/rust-lang/crates.io-index"
787 | checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
788 | 
789 | [[package]]
790 | name = "windows_x86_64_gnullvm"
791 | version = "0.48.5"
792 | source = "registry+https://github.com/rust-lang/crates.io-index"
793 | checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
794 | 
795 | [[package]]
796 | name = "windows_x86_64_gnullvm"
797 | version = "0.52.6"
798 | source = "registry+https://github.com/rust-lang/crates.io-index"
799 | checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
800 | 
801 | [[package]]
802 | name = "windows_x86_64_msvc"
803 | version = "0.48.5"
804 | source = "registry+https://github.com/rust-lang/crates.io-index"
805 | checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
806 | 
807 | [[package]]
808 | name = "windows_x86_64_msvc"
809 | version = "0.52.6"
810 | source = "registry+https://github.com/rust-lang/crates.io-index"
811 | checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
812 | 
813 | [[package]]
814 | name = "winnow"
815 | version = "0.6.20"
816 | source = "registry+https://github.com/rust-lang/crates.io-index"
817 | checksum = "36c1fec1a2bb5866f07c25f68c26e565c4c200aebb96d7e55710c19d3e8ac49b"
818 | dependencies = [
819 |  "memchr",
820 | ]
821 | 
822 | [[package]]
823 | name = "xshell"
824 | version = "0.2.6"
825 | source = "registry+https://github.com/rust-lang/crates.io-index"
826 | checksum = "6db0ab86eae739efd1b054a8d3d16041914030ac4e01cd1dca0cf252fd8b6437"
827 | dependencies = [
828 |  "xshell-macros",
829 | ]
830 | 
831 | [[package]]
832 | name = "xshell-macros"
833 | version = "0.2.6"
834 | source = "registry+https://github.com/rust-lang/crates.io-index"
835 | checksum = "9d422e8e38ec76e2f06ee439ccc765e9c6a9638b9e7c9f2e8255e4d41e8bd852"
836 | 
837 | [[package]]
838 | name = "xxhash-rust"
839 | version = "0.8.12"
840 | source = "registry+https://github.com/rust-lang/crates.io-index"
841 | checksum = "6a5cbf750400958819fb6178eaa83bee5cd9c29a26a40cc241df8c70fdd46984"
842 | 
843 | [[package]]
844 | name = "zerocopy"
845 | version = "0.7.35"
846 | source = "registry+https://github.com/rust-lang/crates.io-index"
847 | checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
848 | dependencies = [
849 |  "zerocopy-derive",
850 | ]
851 | 
852 | [[package]]
853 | name = "zerocopy-derive"
854 | version = "0.7.35"
855 | source = "registry+https://github.com/rust-lang/crates.io-index"
856 | checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
857 | dependencies = [
858 |  "proc-macro2",
859 |  "quote",
860 |  "syn",
861 | ]
862 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/Cargo.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_15_macro"
 3 | version = "0.1.0"
 4 | edition = "2021"
 5 | publish = false
 6 | 
 7 | [lib]
 8 | crate-type = ["cdylib"]
 9 | 
10 | [dependencies]
11 | bigdecimal = "0.4.5"
12 | cairo-lang-macro = "0.1"
13 | cairo-lang-parser = "2.9.1"
14 | cairo-lang-syntax = "2.9.1"
15 | 
16 | [workspace]
17 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/Scarb.toml:
--------------------------------------------------------------------------------
1 | [package]
2 | name = "no_listing_15_macro"
3 | version = "0.1.0"
4 | 
5 | [cairo-plugin]
6 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/src/lib.rs:
--------------------------------------------------------------------------------
1 | mod num_traits;
2 | mod parse;
3 | mod pow;
4 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/src/num_traits.rs:
--------------------------------------------------------------------------------
  1 | use cairo_lang_macro::{derive_macro, ProcMacroResult, TokenStream};
  2 | 
  3 | use crate::parse::{parse_struct_info, StructInfo};
  4 | 
  5 | struct OpInfo {
  6 |     trait_name: String,
  7 |     fn_name: String,
  8 |     operator: String,
  9 | }
 10 | 
 11 | fn generate_op_trait_impl(op_info: &OpInfo, s: &StructInfo) -> String {
 12 |     let generic_params = s
 13 |         .generic_params
 14 |         .as_ref()
 15 |         .map_or(String::new(), |params| format!("<{}>", params.join(", ")));
 16 | 
 17 |     let trait_bounds = s
 18 |         .generic_params
 19 |         .as_ref()
 20 |         .map_or_else(String::new, |params| {
 21 |             let bounds = params
 22 |                 .iter()
 23 |                 .flat_map(|param| {
 24 |                     vec![
 25 |                         format!("+core::traits::{}<{}>", op_info.trait_name, param),
 26 |                         format!("+core::traits::Drop<{}>", param),
 27 |                     ]
 28 |                 })
 29 |                 .collect::<Vec<_>>()
 30 |                 .join(",\n");
 31 |             format!("<{},\n{}>", params.join(", "), bounds)
 32 |         });
 33 | 
 34 |     let members_op = s
 35 |         .members
 36 |         .iter()
 37 |         .map(|member| format!("{0}: lhs.{0} {1} rhs.{0}", member, op_info.operator))
 38 |         .collect::<Vec<_>>()
 39 |         .join(", ");
 40 | 
 41 |     format!(
 42 |         "\n
 43 | impl {0}{1}{2}
 44 | of core::traits::{1}<{0}{3}> {{
 45 |     fn {4}(lhs: {0}{3}, rhs: {0}{3}) -> {0}{3} {{
 46 |         {0} {{ {5} }}
 47 |     }}
 48 | }}\n",
 49 |         s.name, op_info.trait_name, trait_bounds, generic_params, op_info.fn_name, members_op
 50 |     )
 51 | }
 52 | 
 53 | fn generate_op_assign_trait_impl(op_info: &OpInfo, s: &StructInfo) -> String {
 54 |     let generic_params = s
 55 |         .generic_params
 56 |         .as_ref()
 57 |         .map_or(String::new(), |params| format!("<{}>", params.join(", ")));
 58 | 
 59 |     let trait_bounds = s
 60 |         .generic_params
 61 |         .as_ref()
 62 |         .map_or_else(String::new, |params| {
 63 |             let bounds = params
 64 |                 .iter()
 65 |                 .flat_map(|param| {
 66 |                     vec![
 67 |                         format!("+core::ops::{0}Assign<{1}, {1}>", op_info.trait_name, param),
 68 |                         format!("+core::traits::Drop<{}>", param),
 69 |                     ]
 70 |                 })
 71 |                 .collect::<Vec<_>>()
 72 |                 .join(",\n");
 73 |             format!("<{},\n{}>", params.join(", "), bounds)
 74 |         });
 75 | 
 76 |     let members_op = s
 77 |         .members
 78 |         .iter()
 79 |         .map(|member| format!("self.{0} {1}= rhs.{0}", member, op_info.operator))
 80 |         .collect::<Vec<_>>()
 81 |         .join(";\n        ");
 82 | 
 83 |     format!(
 84 |         "\n
 85 | impl {0}{1}Assign{2}
 86 | of core::ops::{1}Assign<{0}{3}, {0}{3}> {{
 87 |     fn {4}_assign(ref self: {0}{3}, rhs: {0}{3}) {{
 88 |         {5};
 89 |     }}
 90 | }}\n",
 91 |         s.name, op_info.trait_name, trait_bounds, generic_params, op_info.fn_name, members_op
 92 |     )
 93 | }
 94 | 
 95 | /// Adds implementation for the `core::traits::Add` trait.
 96 | ///
 97 | /// Allows you to use the `+` operator on a type. All members of
 98 | /// the struct must already implement the `Add` trait.
 99 | #[derive_macro]
100 | pub fn add(token_stream: TokenStream) -> ProcMacroResult {
101 |     let op = OpInfo {
102 |         trait_name: "Add".to_string(),
103 |         fn_name: "add".to_string(),
104 |         operator: "+".to_string(),
105 |     };
106 | 
107 |     let s = parse_struct_info(token_stream);
108 | 
109 |     ProcMacroResult::new(TokenStream::new(generate_op_trait_impl(&op, &s)))
110 | }
111 | 
112 | /// Adds implementation for the `core::traits::Sub` trait.
113 | ///
114 | /// Allows you to use the `-` operator on a type. All members of
115 | /// the struct must already implement the `Sub` trait.
116 | #[derive_macro]
117 | pub fn sub(token_stream: TokenStream) -> ProcMacroResult {
118 |     let op = OpInfo {
119 |         trait_name: "Sub".to_string(),
120 |         fn_name: "sub".to_string(),
121 |         operator: "-".to_string(),
122 |     };
123 |     let s = parse_struct_info(token_stream);
124 | 
125 |     ProcMacroResult::new(TokenStream::new(generate_op_trait_impl(&op, &s)))
126 | }
127 | 
128 | /// Adds implementation for the `core::traits::Mul` trait.
129 | ///
130 | /// Allows you to use the `*` operator on a type. All members of
131 | /// the struct must already implement the `Mul` trait.
132 | #[derive_macro]
133 | pub fn mul(token_stream: TokenStream) -> ProcMacroResult {
134 |     let op = OpInfo {
135 |         trait_name: "Mul".to_string(),
136 |         fn_name: "mul".to_string(),
137 |         operator: "*".to_string(),
138 |     };
139 |     let s = parse_struct_info(token_stream);
140 | 
141 |     ProcMacroResult::new(TokenStream::new(generate_op_trait_impl(&op, &s)))
142 | }
143 | 
144 | /// Adds implementation for the `core::traits::Div` trait.
145 | ///
146 | /// Allows you to use the `/` operator on a type. All members of
147 | /// the struct must already implement the `Div` trait.
148 | #[derive_macro]
149 | pub fn div(token_stream: TokenStream) -> ProcMacroResult {
150 |     let op = OpInfo {
151 |         trait_name: "Div".to_string(),
152 |         fn_name: "div".to_string(),
153 |         operator: "/".to_string(),
154 |     };
155 |     let s = parse_struct_info(token_stream);
156 | 
157 |     ProcMacroResult::new(TokenStream::new(generate_op_trait_impl(&op, &s)))
158 | }
159 | 
160 | /// Adds implementation for the `core::ops::AddAssign` trait.
161 | ///
162 | /// Allows you to use the `+=` operator on a type. All members of
163 | /// the struct must already implement the `AddAssign` trait.
164 | #[derive_macro]
165 | fn add_assign(token_stream: TokenStream) -> ProcMacroResult {
166 |     let op = OpInfo {
167 |         trait_name: "Add".to_string(),
168 |         fn_name: "add".to_string(),
169 |         operator: "+".to_string(),
170 |     };
171 |     let s = parse_struct_info(token_stream);
172 | 
173 |     ProcMacroResult::new(TokenStream::new(generate_op_assign_trait_impl(&op, &s)))
174 | }
175 | 
176 | /// Adds implementation for the `core::ops::SubAssign` trait.
177 | ///
178 | /// Allows you to use the `-=` operator on a type. All members of
179 | /// the struct must already implement the `SubAssign` trait.
180 | #[derive_macro]
181 | fn sub_assign(token_stream: TokenStream) -> ProcMacroResult {
182 |     let op = OpInfo {
183 |         trait_name: "Sub".to_string(),
184 |         fn_name: "sub".to_string(),
185 |         operator: "-".to_string(),
186 |     };
187 |     let s = parse_struct_info(token_stream);
188 | 
189 |     ProcMacroResult::new(TokenStream::new(generate_op_assign_trait_impl(&op, &s)))
190 | }
191 | 
192 | /// Adds implementation for the `core::ops::MulAssign` trait.
193 | ///
194 | /// Allows you to use the `*=` operator on a type. All members of
195 | /// the struct must already implement the `MulAssign` trait.
196 | #[derive_macro]
197 | fn mul_assign(token_stream: TokenStream) -> ProcMacroResult {
198 |     let op = OpInfo {
199 |         trait_name: "Mul".to_string(),
200 |         fn_name: "mul".to_string(),
201 |         operator: "*".to_string(),
202 |     };
203 |     let s = parse_struct_info(token_stream);
204 | 
205 |     ProcMacroResult::new(TokenStream::new(generate_op_assign_trait_impl(&op, &s)))
206 | }
207 | 
208 | /// Adds implementation for the `core::ops::DivAssign` trait.
209 | ///
210 | /// Allows you to use the `/=` operator on a type. All members of
211 | /// the struct must already implement the `DivAssign` trait.
212 | #[derive_macro]
213 | fn div_assign(token_stream: TokenStream) -> ProcMacroResult {
214 |     let op = OpInfo {
215 |         trait_name: "Div".to_string(),
216 |         fn_name: "div".to_string(),
217 |         operator: "/".to_string(),
218 |     };
219 |     let s = parse_struct_info(token_stream);
220 | 
221 |     ProcMacroResult::new(TokenStream::new(generate_op_assign_trait_impl(&op, &s)))
222 | }
223 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/src/parse.rs:
--------------------------------------------------------------------------------
 1 | use cairo_lang_macro::TokenStream;
 2 | use cairo_lang_parser::utils::SimpleParserDatabase;
 3 | use cairo_lang_syntax::node::kind::SyntaxKind::{
 4 |     Member, OptionWrappedGenericParamListEmpty, TerminalStruct, TokenIdentifier,
 5 |     WrappedGenericParamList,
 6 | };
 7 | 
 8 | pub(crate) struct StructInfo {
 9 |     pub(crate) name: String,
10 |     pub(crate) generic_params: Option<Vec<String>>,
11 |     pub(crate) members: Vec<String>,
12 | }
13 | 
14 | pub(crate) fn parse_struct_info(token_stream: TokenStream) -> StructInfo {
15 |     let db = SimpleParserDatabase::default();
16 |     let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);
17 |     let mut nodes = parsed.descendants(&db);
18 | 
19 |     // find struct name - the next TokenIdentifier after TerminalStruct
20 |     let mut struct_name = String::new();
21 |     for node in nodes.by_ref() {
22 |         if node.kind(&db) == TerminalStruct {
23 |             struct_name = nodes
24 |                 .find(|node| node.kind(&db) == TokenIdentifier)
25 |                 .unwrap()
26 |                 .get_text(&db);
27 |             break;
28 |         }
29 |     }
30 | 
31 |     // collect generic params or skip if there aren't any
32 |     let mut generic_params: Option<Vec<String>> = None;
33 |     for node in nodes.by_ref() {
34 |         match node.kind(&db) {
35 |             WrappedGenericParamList => {
36 |                 let params = node
37 |                     .descendants(&db)
38 |                     .filter(|node| node.kind(&db) == TokenIdentifier)
39 |                     .map(|node| node.get_text(&db))
40 |                     .collect();
41 |                 generic_params = Some(params);
42 |                 break;
43 |             }
44 |             OptionWrappedGenericParamListEmpty => {
45 |                 break;
46 |             }
47 |             _ => {}
48 |         }
49 |     }
50 | 
51 |     // collect struct members - all TokenIdentifier nodes after each Member
52 |     let mut members = Vec::new();
53 |     for node in nodes {
54 |         if node.kind(&db) == Member {
55 |             let member = node
56 |                 .descendants(&db)
57 |                 .find(|node| node.kind(&db) == TokenIdentifier)
58 |                 .map(|node| node.get_text(&db))
59 |                 .unwrap();
60 |             members.push(member);
61 |         }
62 |     }
63 | 
64 |     StructInfo {
65 |         name: struct_name,
66 |         generic_params,
67 |         members,
68 |     }
69 | }
70 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_15_macro/src/pow.rs:
--------------------------------------------------------------------------------
 1 | // ANCHOR: main
 2 | use bigdecimal::{num_traits::pow, BigDecimal};
 3 | use cairo_lang_macro::{inline_macro, Diagnostic, ProcMacroResult, TokenStream};
 4 | use cairo_lang_parser::utils::SimpleParserDatabase;
 5 | 
 6 | /// Compile-time power function.
 7 | ///
 8 | /// Takes two arguments, `x, y`, calculates the value of `x` raised to the power of `y`.
 9 | ///
10 | /// ```
11 | /// const MEGABYTE: u64 = pow!(2, 20);
12 | /// assert_eq!(MEGABYTE, 1048576);
13 | /// ```
14 | #[inline_macro]
15 | pub fn pow(token_stream: TokenStream) -> ProcMacroResult {
16 |     let db = SimpleParserDatabase::default();
17 |     let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);
18 | 
19 |     let macro_args: Vec<String> = parsed
20 |         .descendants(&db)
21 |         .next()
22 |         .unwrap()
23 |         .get_text(&db)
24 |         .trim_matches(|c| c == '(' || c == ')')
25 |         .split(',')
26 |         .map(|s| s.trim().to_string())
27 |         .collect();
28 | 
29 |     if macro_args.len() != 2 {
30 |         return ProcMacroResult::new(TokenStream::empty()).with_diagnostics(
31 |             Diagnostic::error(format!("Expected two arguments, got {:?}", macro_args)).into(),
32 |         );
33 |     }
34 | 
35 |     let base: BigDecimal = match macro_args[0].parse() {
36 |         Ok(val) => val,
37 |         Err(_) => {
38 |             return ProcMacroResult::new(TokenStream::empty())
39 |                 .with_diagnostics(Diagnostic::error("Invalid base value").into());
40 |         }
41 |     };
42 | 
43 |     let exp: usize = match macro_args[1].parse() {
44 |         Ok(val) => val,
45 |         Err(_) => {
46 |             return ProcMacroResult::new(TokenStream::empty())
47 |                 .with_diagnostics(Diagnostic::error("Invalid exponent value").into());
48 |         }
49 |     };
50 | 
51 |     let result: BigDecimal = pow(base, exp);
52 | 
53 |     ProcMacroResult::new(TokenStream::new(result.to_string()))
54 | }
55 | // ANCHOR_END: main
56 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_16_procedural_macro/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_16_procedural_macro/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_16_procedural_macro"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | no_listing_15_macro = { path = "../no_listing_15_macro" }
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch11-advanced-features/no_listing_16_procedural_macro/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | const TWO_TEN: u128 = pow!(12, 2);
 2 | 
 3 | // ANCHOR: derive_macro
 4 | #[derive(Add, AddAssign, Sub, SubAssign, Mul, MulAssign, Div, DivAssign, Debug, Drop, PartialEq)]
 5 | pub struct B {
 6 |     pub a: u8,
 7 |     pub b: u16,
 8 | }
 9 | // ANCHOR_END: derive_macro
10 | 
11 | fn main() {
12 |     println!("{}", TWO_TEN);
13 | 
14 |     // ANCHOR: b_struct
15 |     let b1 = B { a: 1, b: 2 };
16 |     let b2 = B { a: 3, b: 4 };
17 |     let b3 = b1 + b2;
18 |     // ANCHOR_END: b_struct
19 | 
20 |     println!("{:?}", b3);
21 | }
22 | 
23 | #[cfg(test)]
24 | mod tests {
25 |     use super::*;
26 | 
27 |     // ANCHOR: pow_macro
28 |     #[test]
29 |     fn test_pow_macro() {
30 |         assert_eq!(super::TWO_TEN, 144);
31 |         assert_eq!(pow!(10, 2), 100);
32 |         assert_eq!(pow!(20, 30), 1073741824000000000000000000000000000000_felt252);
33 |         assert_eq!(
34 |             pow!(2, 255),
35 |             57896044618658097711785492504343953926634992332820282019728792003956564819968_u256,
36 |         );
37 |     }
38 |     // ANCHOR_END: pow_macro
39 | 
40 |     #[test]
41 |     fn test_add_derive() {
42 |         let b1 = B { a: 1, b: 2 };
43 |         let b2 = B { a: 3, b: 4 };
44 |         let b3 = b1 + b2;
45 |         assert_eq!(b3, B { a: 4, b: 6 });
46 |     }
47 | }
48 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_01"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | // ANCHOR:all
 2 | // ANCHOR: interface
 3 | #[starknet::interface]
 4 | trait ISimpleStorage<TContractState> {
 5 |     fn set(ref self: TContractState, x: u128);
 6 |     fn get(self: @TContractState) -> u128;
 7 | }
 8 | //ANCHOR_END: interface
 9 | 
10 | #[starknet::contract]
11 | mod SimpleStorage {
12 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
13 | 
14 |     #[storage]
15 |     struct Storage {
16 |         stored_data: u128,
17 |     }
18 | 
19 |     //ANCHOR: impl
20 |     #[abi(embed_v0)]
21 |     impl SimpleStorage of super::ISimpleStorage<ContractState> {
22 |         fn set(ref self: ContractState, x: u128) {
23 |             //ANCHOR: write_state
24 |             self.stored_data.write(x);
25 |             //ANCHOR_END: write_state
26 |         }
27 | 
28 |         fn get(self: @ContractState) -> u128 {
29 |             //ANCHOR: read_state
30 |             self.stored_data.read()
31 |             //ANCHOR_END: read_state
32 |         }
33 |     }
34 |     //ANCHOR_END: impl
35 | }
36 | //ANCHOR_END: all
37 | 
38 | 
39 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_02"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb cairo-run 
 2 |    Compiling listing_99_02 v0.1.0 (listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/Scarb.toml)
 3 | error: The number of parameters in the impl function `SimpleStorage::set` is incompatible with `ISimpleStorage::set`. Expected: 2, actual: 1.
 4 |  --> listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/src/lib.cairo:23:16
 5 |         fn set(ref self: ContractState) {}
 6 |                ^*********************^
 7 | 
 8 | error: Wrong number of arguments. Expected 2, found: 1
 9 |  --> listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/src/lib.cairo:23:9
10 |         fn set(ref self: ContractState) {}
11 |         ^********************************^
12 | 
13 | error: could not compile `listing_99_02` due to previous error
14 | error: `scarb metadata` exited with error
15 | 
16 | 


--------------------------------------------------------------------------------
/listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | // ANCHOR:all
 3 | // ANCHOR: interface
 4 | #[starknet::interface]
 5 | trait ISimpleStorage<TContractState> {
 6 |     fn set(ref self: TContractState, x: u128);
 7 |     fn get(self: @TContractState) -> u128;
 8 | }
 9 | //ANCHOR_END: interface
10 | 
11 | #[starknet::contract]
12 | mod SimpleStorage {
13 |     use core::starknet::storage::StoragePointerReadAccess;
14 | 
15 |     #[storage]
16 |     struct Storage {
17 |         stored_data: u128,
18 |     }
19 | 
20 |     //ANCHOR: impl
21 |     #[abi(embed_v0)]
22 |     impl SimpleStorage of super::ISimpleStorage<ContractState> {
23 |         fn set(ref self: ContractState) {}
24 |         fn get(self: @ContractState) -> u128 {
25 |             self.stored_data.read()
26 |         }
27 |     }
28 |     //ANCHOR_END: impl
29 | }
30 | //ANCHOR_END: all
31 | 
32 | 
33 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_01_reference_contract"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:
--------------------------------------------------------------------------------
  1 | //ANCHOR: all
  2 | use core::starknet::ContractAddress;
  3 | 
  4 | #[starknet::interface]
  5 | pub trait INameRegistry<TContractState> {
  6 |     fn store_name(
  7 |         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType,
  8 |     );
  9 |     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
 10 |     fn get_owner(self: @TContractState) -> NameRegistry::Person;
 11 |     fn get_owner_name(self: @TContractState) -> felt252;
 12 |     fn get_registration_info(
 13 |         self: @TContractState, address: ContractAddress,
 14 |     ) -> NameRegistry::RegistrationInfo;
 15 | }
 16 | 
 17 | #[starknet::contract]
 18 | mod NameRegistry {
 19 |     use core::starknet::{ContractAddress, get_caller_address};
 20 |     use core::starknet::storage::{
 21 |         Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
 22 |     };
 23 | 
 24 |     //ANCHOR: storage
 25 |     #[storage]
 26 |     struct Storage {
 27 |         names: Map::<ContractAddress, felt252>,
 28 |         owner: Person,
 29 |         registrations: Map<ContractAddress, RegistrationNode>,
 30 |         total_names: u128,
 31 |     }
 32 |     //ANCHOR_END: storage
 33 | 
 34 |     //ANCHOR: event
 35 |     #[event]
 36 |     #[derive(Drop, starknet::Event)]
 37 |     enum Event {
 38 |         StoredName: StoredName,
 39 |     }
 40 |     //ANCHOR_END: event
 41 |     //ANCHOR: stored_name
 42 |     #[derive(Drop, starknet::Event)]
 43 |     struct StoredName {
 44 |         #[key]
 45 |         user: ContractAddress,
 46 |         name: felt252,
 47 |     }
 48 |     //ANCHOR_END: stored_name
 49 | 
 50 |     //ANCHOR: person
 51 |     #[derive(Drop, Serde, starknet::Store)]
 52 |     pub struct Person {
 53 |         address: ContractAddress,
 54 |         name: felt252,
 55 |     }
 56 |     //ANCHOR_END: person
 57 | 
 58 |     //ANCHOR: enum_store
 59 |     #[derive(Copy, Drop, Serde, starknet::Store)]
 60 |     pub enum RegistrationType {
 61 |         Finite: u64,
 62 |         #[default]
 63 |         Infinite,
 64 |     }
 65 |     //ANCHOR_END: enum_store
 66 | 
 67 |     //ANCHOR: storage_node_def
 68 |     #[starknet::storage_node]
 69 |     struct RegistrationNode {
 70 |         count: u64,
 71 |         info: RegistrationInfo,
 72 |         history: Map<u64, RegistrationInfo>,
 73 |     }
 74 |     //ANCHOR_END: storage_node_def
 75 | 
 76 |     #[derive(Copy, Drop, Serde, starknet::Store)]
 77 |     pub struct RegistrationInfo {
 78 |         name: felt252,
 79 |         registration_type: RegistrationType,
 80 |         registration_date: u64,
 81 |     }
 82 | 
 83 |     //ANCHOR: constructor
 84 |     #[constructor]
 85 |     fn constructor(ref self: ContractState, owner: Person) {
 86 |         self.names.entry(owner.address).write(owner.name);
 87 |         self.total_names.write(1);
 88 |         //ANCHOR: write_owner
 89 |         self.owner.write(owner);
 90 |         //ANCHOR_END: write_owner
 91 |     }
 92 |     //ANCHOR_END: constructor
 93 | 
 94 |     //ANCHOR: impl_public
 95 |     // Public functions inside an impl block
 96 |     #[abi(embed_v0)]
 97 |     impl NameRegistry of super::INameRegistry<ContractState> {
 98 |         //ANCHOR: external
 99 |         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {
100 |             let caller = get_caller_address();
101 |             self._store_name(caller, name, registration_type);
102 |         }
103 |         //ANCHOR_END: external
104 | 
105 |         //ANCHOR: view
106 |         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
107 |             //ANCHOR: read
108 |             self.names.entry(address).read()
109 |             //ANCHOR_END: read
110 |         }
111 | 
112 |         //ANCHOR_END: view
113 |         fn get_owner(self: @ContractState) -> Person {
114 |             //ANCHOR: read_owner
115 |             self.owner.read()
116 |             //ANCHOR_END: read_owner
117 |         }
118 | 
119 |         fn get_owner_name(self: @ContractState) -> felt252 {
120 |             //ANCHOR: read_owner_name
121 |             self.owner.name.read()
122 |             //ANCHOR_END: read_owner_name
123 |         }
124 | 
125 |         fn get_registration_info(
126 |             self: @ContractState, address: ContractAddress,
127 |         ) -> RegistrationInfo {
128 |             self.registrations.entry(address).info.read()
129 |         }
130 |     }
131 |     //ANCHOR_END: impl_public
132 | 
133 |     //ANCHOR: standalone
134 |     // Standalone public function
135 |     #[external(v0)]
136 |     fn get_contract_name(self: @ContractState) -> felt252 {
137 |         'Name Registry'
138 |     }
139 |     //ANCHOR_END: standalone
140 | 
141 |     // ANCHOR: state_internal
142 |     // ANCHOR: generate_trait
143 |     // Could be a group of functions about a same topic
144 |     #[generate_trait]
145 |     impl InternalFunctions of InternalFunctionsTrait {
146 |         fn _store_name(
147 |             ref self: ContractState,
148 |             user: ContractAddress,
149 |             name: felt252,
150 |             registration_type: RegistrationType,
151 |         ) {
152 |             let total_names = self.total_names.read();
153 | 
154 |             //ANCHOR: write
155 |             self.names.entry(user).write(name);
156 |             //ANCHOR_END: write
157 | 
158 |             //ANCHOR: storage_node
159 |             let registration_info = RegistrationInfo {
160 |                 name: name,
161 |                 registration_type: registration_type,
162 |                 registration_date: starknet::get_block_timestamp(),
163 |             };
164 |             let mut registration_node = self.registrations.entry(user);
165 |             registration_node.info.write(registration_info);
166 | 
167 |             let count = registration_node.count.read();
168 |             registration_node.history.entry(count).write(registration_info);
169 |             registration_node.count.write(count + 1);
170 |             //ANCHOR_END: storage_node
171 | 
172 |             self.total_names.write(total_names + 1);
173 | 
174 |             //ANCHOR: emit_event
175 |             self.emit(StoredName { user: user, name: name });
176 |             //ANCHOR_END: emit_event
177 |         }
178 |     }
179 |     // ANCHOR_END: generate_trait
180 | 
181 |     // Free function
182 |     fn get_owner_storage_address(self: @ContractState) -> felt252 {
183 |         //ANCHOR: owner_address
184 |         self.owner.__base_address__
185 |         //ANCHOR_END: owner_address
186 |     }
187 |     // ANCHOR_END: state_internal
188 | }
189 | //ANCHOR_END: all
190 | 
191 | 
192 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_02_storage_mapping/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_02_storage_mapping/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_02_storage_mapping"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_02_storage_mapping/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait IUserValues<TState> {
 5 |     fn set(ref self: TState, amount: u64);
 6 |     fn get(self: @TState, address: ContractAddress) -> u64;
 7 | }
 8 | 
 9 | //ANCHOR: contract
10 | #[starknet::contract]
11 | mod UserValues {
12 |     use starknet::storage::{
13 |         StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map,
14 |     };
15 |     use core::starknet::{ContractAddress, get_caller_address};
16 | 
17 |     #[storage]
18 |     struct Storage {
19 |         user_values: Map<ContractAddress, u64>,
20 |     }
21 | 
22 |     impl UserValuesImpl of super::IUserValues<ContractState> {
23 |         // ANCHOR: write
24 |         fn set(ref self: ContractState, amount: u64) {
25 |             let caller = get_caller_address();
26 |             self.user_values.entry(caller).write(amount);
27 |         }
28 |         // ANCHOR_END: write
29 | 
30 |         // ANCHOR: read
31 |         fn get(self: @ContractState, address: ContractAddress) -> u64 {
32 |             self.user_values.entry(address).read()
33 |         }
34 |         // ANCHOR_END: read
35 |     }
36 | }
37 | //ANCHOR_END: contract
38 | 
39 | 
40 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_events_example/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_events_example/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_events_example"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait IEventExample<TContractState> {
 3 |     fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
 4 |     fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
 5 |     fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
 6 |     fn remove_book(ref self: TContractState, id: u32);
 7 | }
 8 | 
 9 | //ANCHOR: all
10 | #[starknet::contract]
11 | mod EventExample {
12 |     #[storage]
13 |     struct Storage {}
14 | 
15 |     //ANCHOR: event
16 |     //ANCHOR: full_events
17 |     #[event]
18 |     #[derive(Drop, starknet::Event)]
19 |     pub enum Event {
20 |         BookAdded: BookAdded,
21 |         #[flat]
22 |         FieldUpdated: FieldUpdated,
23 |         BookRemoved: BookRemoved,
24 |     }
25 |     //ANCHOR_END: event
26 | 
27 |     #[derive(Drop, starknet::Event)]
28 |     pub struct BookAdded {
29 |         pub id: u32,
30 |         pub title: felt252,
31 |         #[key]
32 |         pub author: felt252,
33 |     }
34 | 
35 |     #[derive(Drop, starknet::Event)]
36 |     pub enum FieldUpdated {
37 |         Title: UpdatedTitleData,
38 |         Author: UpdatedAuthorData,
39 |     }
40 | 
41 |     #[derive(Drop, starknet::Event)]
42 |     pub struct UpdatedTitleData {
43 |         #[key]
44 |         pub id: u32,
45 |         pub new_title: felt252,
46 |     }
47 | 
48 |     #[derive(Drop, starknet::Event)]
49 |     pub struct UpdatedAuthorData {
50 |         #[key]
51 |         pub id: u32,
52 |         pub new_author: felt252,
53 |     }
54 | 
55 |     #[derive(Drop, starknet::Event)]
56 |     pub struct BookRemoved {
57 |         pub id: u32,
58 |     }
59 |     //ANCHOR_END: full_events
60 | 
61 |     #[abi(embed_v0)]
62 |     impl EventExampleImpl of super::IEventExample<ContractState> {
63 |         //ANCHOR: emit_event
64 |         fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
65 |             // ... logic to add a book in the contract storage ...
66 |             self.emit(BookAdded { id, title, author });
67 |         }
68 | 
69 |         fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
70 |             self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
71 |         }
72 | 
73 |         fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
74 |             self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
75 |         }
76 | 
77 |         fn remove_book(ref self: ContractState, id: u32) {
78 |             self.emit(BookRemoved { id });
79 |         }
80 |         //ANCHOR_END: emit_event
81 | 
82 |     }
83 | }
84 | //ANCHOR_END: all
85 | 
86 | 
87 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_nested_storage_mapping/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_nested_storage_mapping/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_nested_storage_mapping"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | [dev-dependencies]
12 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
13 | assert_macros = "2.9.1"
14 | 
15 | [scripts]
16 | test = "snforge test"
17 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_nested_storage_mapping/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait IWarehouseContract<TState> {
 5 |     fn set_quantity(ref self: TState, item_id: u64, quantity: u64);
 6 |     fn get_item_quantity(self: @TState, address: ContractAddress, item_id: u64) -> u64;
 7 | }
 8 | 
 9 | // ANCHOR: contract
10 | #[starknet::contract]
11 | mod WarehouseContract {
12 |     use starknet::storage::{
13 |         StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map,
14 |     };
15 |     use core::starknet::{ContractAddress, get_caller_address};
16 | 
17 |     // ANCHOR: storage
18 |     #[storage]
19 |     struct Storage {
20 |         user_warehouse: Map<ContractAddress, Map<u64, u64>>,
21 |     }
22 |     // ANCHOR_END: storage
23 | 
24 |     impl WarehouseContractImpl of super::IWarehouseContract<ContractState> {
25 |         // ANCHOR: accesses
26 |         fn set_quantity(ref self: ContractState, item_id: u64, quantity: u64) {
27 |             let caller = get_caller_address();
28 |             self.user_warehouse.entry(caller).entry(item_id).write(quantity);
29 |         }
30 | 
31 |         fn get_item_quantity(self: @ContractState, address: ContractAddress, item_id: u64) -> u64 {
32 |             self.user_warehouse.entry(address).entry(item_id).read()
33 |         }
34 |         // ANCHOR_END: accesses
35 |     }
36 | }
37 | // ANCHOR_END: contract
38 | 
39 | 
40 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_simple_storage/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_simple_storage/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_nested_storage_mapping"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | pub trait ISimpleStorage<TContractState> {
 3 |     fn get_owner(self: @TContractState) -> SimpleStorage::Person;
 4 |     fn get_owner_name(self: @TContractState) -> felt252;
 5 |     fn get_expiration(self: @TContractState) -> SimpleStorage::Expiration;
 6 |     fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
 7 | }
 8 | 
 9 | //ANCHOR: all
10 | #[starknet::contract]
11 | mod SimpleStorage {
12 |     use core::starknet::{ContractAddress, get_caller_address};
13 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
14 | 
15 |     //ANCHOR: storage
16 |     #[storage]
17 |     struct Storage {
18 |         owner: Person,
19 |         expiration: Expiration,
20 |     }
21 |     //ANCHOR_END: storage
22 | 
23 |     //ANCHOR: person
24 |     #[derive(Drop, Serde, starknet::Store)]
25 |     pub struct Person {
26 |         address: ContractAddress,
27 |         name: felt252,
28 |     }
29 |     //ANCHOR_END: person
30 | 
31 |     //ANCHOR: enum
32 |     #[derive(Copy, Drop, Serde, starknet::Store)]
33 |     pub enum Expiration {
34 |         Finite: u64,
35 |         #[default]
36 |         Infinite,
37 |     }
38 |     //ANCHOR_END: enum
39 | 
40 |     //ANCHOR: write_owner
41 |     #[constructor]
42 |     fn constructor(ref self: ContractState, owner: Person) {
43 |         self.owner.write(owner);
44 |     }
45 |     //ANCHOR_END: write_owner
46 | 
47 |     //ANCHOR: impl_public
48 |     #[abi(embed_v0)]
49 |     impl SimpleCounterImpl of super::ISimpleStorage<ContractState> {
50 |         //ANCHOR: read_owner
51 |         fn get_owner(self: @ContractState) -> Person {
52 |             self.owner.read()
53 |         }
54 |         //ANCHOR_END: read_owner
55 | 
56 |         //ANCHOR: read_owner_name
57 |         fn get_owner_name(self: @ContractState) -> felt252 {
58 |             self.owner.name.read()
59 |         }
60 |         //ANCHOR_END: read_owner_name
61 | 
62 |         //ANCHOR: enum_read
63 |         fn get_expiration(self: @ContractState) -> Expiration {
64 |             self.expiration.read()
65 |         }
66 |         //ANCHOR_END: enum_read
67 | 
68 |         //ANCHOR: enum_store
69 |         fn change_expiration(ref self: ContractState, expiration: Expiration) {
70 |             if get_caller_address() != self.owner.address.read() {
71 |                 panic!("Only the owner can change the expiration");
72 |             }
73 |             self.expiration.write(expiration);
74 |         }
75 |         //ANCHOR_END: enum_store
76 |     }
77 | 
78 |     //ANCHOR: owner_address
79 |     fn get_owner_storage_address(self: @ContractState) -> felt252 {
80 |         self.owner.__base_address__
81 |     }
82 | 
83 |     fn get_owner_name_storage_address(self: @ContractState) -> felt252 {
84 |         self.owner.name.__storage_pointer_address__.into()
85 |     }
86 |     //ANCHOR_END: owner_address
87 | 
88 | }
89 | //ANCHOR_END: all
90 | 
91 | 
92 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_storage_node/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_storage_node/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_storage_node"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | mod VotingSystem {
 3 |     use starknet::{ContractAddress, get_caller_address};
 4 |     use core::starknet::storage::{
 5 |         Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
 6 |     };
 7 | 
 8 |     #[storage]
 9 |     struct Storage {
10 |         proposals: Map<u32, ProposalNode>,
11 |         proposal_count: u32,
12 |     }
13 | 
14 |     //ANCHOR: storage_node
15 |     #[starknet::storage_node]
16 |     struct ProposalNode {
17 |         title: felt252,
18 |         description: felt252,
19 |         yes_votes: u32,
20 |         no_votes: u32,
21 |         voters: Map<ContractAddress, bool>,
22 |     }
23 |     //ANCHOR_END: storage_node
24 | 
25 |     //ANCHOR: create_proposal
26 |     #[external(v0)]
27 |     fn create_proposal(ref self: ContractState, title: felt252, description: felt252) -> u32 {
28 |         let mut proposal_count = self.proposal_count.read();
29 |         let new_proposal_id = proposal_count + 1;
30 | 
31 |         let mut proposal = self.proposals.entry(new_proposal_id);
32 |         proposal.title.write(title);
33 |         proposal.description.write(description);
34 |         proposal.yes_votes.write(0);
35 |         proposal.no_votes.write(0);
36 | 
37 |         self.proposal_count.write(new_proposal_id);
38 | 
39 |         new_proposal_id
40 |     }
41 |     //ANCHOR_END: create_proposal
42 | 
43 |     //ANCHOR: vote
44 |     #[external(v0)]
45 |     fn vote(ref self: ContractState, proposal_id: u32, vote: bool) {
46 |         let mut proposal = self.proposals.entry(proposal_id);
47 |         let caller = get_caller_address();
48 |         let has_voted = proposal.voters.entry(caller).read();
49 |         if has_voted {
50 |             return;
51 |         }
52 |         proposal.voters.entry(caller).write(true);
53 |     }
54 |     //ANCHOR_END: vote
55 | }
56 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_nested_storage_mapping"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait IAddressList<TState> {
 5 |     fn register_caller(ref self: TState);
 6 |     fn get_n_th_registered_address(self: @TState, index: u64) -> Option<ContractAddress>;
 7 |     fn get_all_addresses(self: @TState) -> Array<ContractAddress>;
 8 |     fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
 9 | }
10 | 
11 | //ANCHOR: contract
12 | #[starknet::contract]
13 | mod AddressList {
14 |     use starknet::storage::{
15 |         StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait, MutableVecTrait,
16 |     };
17 |     use core::starknet::{get_caller_address, ContractAddress};
18 | 
19 |     //ANCHOR: storage_vecs
20 |     #[storage]
21 |     struct Storage {
22 |         addresses: Vec<ContractAddress>,
23 |     }
24 |     //ANCHOR_END: storage_vecs
25 | 
26 |     impl AddressListImpl of super::IAddressList<ContractState> {
27 |         //ANCHOR: append
28 |         fn register_caller(ref self: ContractState) {
29 |             let caller = get_caller_address();
30 |             self.addresses.append().write(caller);
31 |         }
32 |         //ANCHOR_END: append
33 | 
34 |         //ANCHOR: read
35 |         fn get_n_th_registered_address(
36 |             self: @ContractState, index: u64,
37 |         ) -> Option<ContractAddress> {
38 |             if let Option::Some(storage_ptr) = self.addresses.get(index) {
39 |                 return Option::Some(storage_ptr.read());
40 |             }
41 |             return Option::None;
42 |         }
43 | 
44 |         fn get_all_addresses(self: @ContractState) -> Array<ContractAddress> {
45 |             let mut addresses = array![];
46 |             for i in 0..self.addresses.len() {
47 |                 addresses.append(self.addresses.at(i).read());
48 |             };
49 |             addresses
50 |         }
51 |         //ANCHOR_END: read
52 | 
53 |         //ANCHOR: modify
54 |         fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
55 |             let mut storage_ptr = self.addresses.at(index);
56 |             storage_ptr.write(new_address);
57 |         }
58 |         //ANCHOR_END: modify
59 |     }
60 | }
61 | //ANCHOR_END: contract
62 | 
63 | 
64 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/no_listing_01_abi_per_item_attribute/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/no_listing_01_abi_per_item_attribute/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_abi_per_item_attribute"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/no_listing_01_abi_per_item_attribute/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | mod ContractExample {
 3 |     #[storage]
 4 |     struct Storage {}
 5 | 
 6 |     #[abi(per_item)]
 7 |     #[generate_trait]
 8 |     impl SomeImpl of SomeTrait {
 9 |         #[constructor]
10 |         // this is a constructor function
11 |         fn constructor(ref self: ContractState) {}
12 | 
13 |         #[external(v0)]
14 |         // this is a public function
15 |         fn external_function(ref self: ContractState, arg1: felt252) {}
16 | 
17 |         #[l1_handler]
18 |         // this is a l1_handler function
19 |         fn handle_message(ref self: ContractState, from_address: felt252, arg: felt252) {}
20 | 
21 |         // this is an internal function
22 |         fn internal_function(self: @ContractState) {}
23 |     }
24 | }
25 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/no_listing_03_explicit_internal_fn/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/no_listing_03_explicit_internal_fn/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_03_explicit_internal_fn"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch14-building-starknet-smart-contracts/no_listing_03_explicit_internal_fn/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: all
 2 | use core::starknet::ContractAddress;
 3 | 
 4 | #[starknet::contract]
 5 | mod NameRegistry {
 6 |     use core::starknet::{ContractAddress, get_caller_address};
 7 |     use core::starknet::storage::{
 8 |         StoragePointerReadAccess, StoragePointerWriteAccess, StorageMapReadAccess,
 9 |         StorageMapWriteAccess, Map,
10 |     };
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         names: Map::<ContractAddress, felt252>,
15 |         total_names: u128,
16 |         owner: Person,
17 |     }
18 | 
19 |     //ANCHOR: person
20 |     #[derive(Copy, Drop, Serde, starknet::Store)]
21 |     struct Person {
22 |         name: felt252,
23 |         address: ContractAddress,
24 |     }
25 |     //ANCHOR_END: person
26 | 
27 |     //ANCHOR: event
28 |     #[event]
29 |     #[derive(Drop, starknet::Event)]
30 |     enum Event {
31 |         StoredName: StoredName,
32 |     }
33 | 
34 |     #[derive(Drop, starknet::Event)]
35 |     struct StoredName {
36 |         #[key]
37 |         user: ContractAddress,
38 |         name: felt252,
39 |     }
40 | 
41 |     // ANCHOR: state_internal
42 |     trait InternalFunctionsTrait<TContractState> {
43 |         fn _store_name(ref self: TContractState, user: ContractAddress, name: felt252);
44 |     }
45 | 
46 |     impl InternalFunctions of InternalFunctionsTrait<ContractState> {
47 |         fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
48 |             let mut total_names = self.total_names.read();
49 |             self.names.write(user, name);
50 |             self.total_names.write(total_names + 1);
51 |             //ANCHOR: emit_event
52 |             self.emit(Event::StoredName(StoredName { user: user, name: name }));
53 |             //ANCHOR_END: emit_event
54 |         }
55 |     }
56 |     // ANCHOR_END: state_internal
57 | }
58 | //ANCHOR_END: all
59 | 
60 | 
61 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_01_simple_erc20_interface/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_01_simple_erc20_interface/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_05"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_01_simple_erc20_interface/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait IERC20<TContractState> {
 5 |     fn name(self: @TContractState) -> felt252;
 6 | 
 7 |     fn symbol(self: @TContractState) -> felt252;
 8 | 
 9 |     fn decimals(self: @TContractState) -> u8;
10 | 
11 |     fn total_supply(self: @TContractState) -> u256;
12 | 
13 |     fn balance_of(self: @TContractState, account: ContractAddress) -> u256;
14 | 
15 |     fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;
16 | 
17 |     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;
18 | 
19 |     fn transfer_from(
20 |         ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256,
21 |     ) -> bool;
22 | 
23 |     fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;
24 | }
25 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_06"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | trait IERC20DispatcherTrait<T> {
 4 |     fn name(self: T) -> felt252;
 5 |     fn transfer(self: T, recipient: ContractAddress, amount: u256);
 6 | }
 7 | 
 8 | #[derive(Copy, Drop, starknet::Store, Serde)]
 9 | struct IERC20Dispatcher {
10 |     pub contract_address: starknet::ContractAddress,
11 | }
12 | 
13 | impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {
14 |     fn name(self: IERC20Dispatcher) -> felt252 {
15 |         let mut __calldata__ = core::traits::Default::default();
16 | 
17 |         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
18 |             self.contract_address, selector!("name"), core::array::ArrayTrait::span(@__calldata__),
19 |         );
20 |         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
21 |             __dispatcher_return_data__,
22 |         );
23 |         core::option::OptionTrait::expect(
24 |             core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
25 |             'Returned data too short',
26 |         )
27 |     }
28 |     fn transfer(self: IERC20Dispatcher, recipient: ContractAddress, amount: u256) {
29 |         let mut __calldata__ = core::traits::Default::default();
30 |         core::serde::Serde::<ContractAddress>::serialize(@recipient, ref __calldata__);
31 |         core::serde::Serde::<u256>::serialize(@amount, ref __calldata__);
32 | 
33 |         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
34 |             self.contract_address,
35 |             selector!("transfer"),
36 |             core::array::ArrayTrait::span(@__calldata__),
37 |         );
38 |         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
39 |             __dispatcher_return_data__,
40 |         );
41 |         ()
42 |     }
43 | }
44 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_07"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait IERC20<TContractState> {
 5 |     fn name(self: @TContractState) -> felt252;
 6 | 
 7 |     fn symbol(self: @TContractState) -> felt252;
 8 | 
 9 |     fn decimals(self: @TContractState) -> u8;
10 | 
11 |     fn total_supply(self: @TContractState) -> u256;
12 | 
13 |     fn balance_of(self: @TContractState, account: ContractAddress) -> u256;
14 | 
15 |     fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;
16 | 
17 |     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;
18 | 
19 |     fn transfer_from(
20 |         ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256,
21 |     ) -> bool;
22 | 
23 |     fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;
24 | }
25 | 
26 | #[starknet::interface]
27 | trait ITokenWrapper<TContractState> {
28 |     fn token_name(self: @TContractState, contract_address: ContractAddress) -> felt252;
29 | 
30 |     fn transfer_token(
31 |         ref self: TContractState,
32 |         address: ContractAddress,
33 |         recipient: ContractAddress,
34 |         amount: u256,
35 |     ) -> bool;
36 | }
37 | 
38 | //ANCHOR: here
39 | //**** Specify interface here ****//
40 | #[starknet::contract]
41 | mod TokenWrapper {
42 |     //ANCHOR: import
43 |     use super::{IERC20Dispatcher, IERC20DispatcherTrait};
44 |     //ANCHOR_END: import
45 |     use super::ITokenWrapper;
46 |     use core::starknet::{get_caller_address, ContractAddress};
47 | 
48 |     #[storage]
49 |     struct Storage {}
50 | 
51 |     impl TokenWrapper of ITokenWrapper<ContractState> {
52 |         fn token_name(self: @ContractState, contract_address: ContractAddress) -> felt252 {
53 |             IERC20Dispatcher { contract_address }.name()
54 |         }
55 | 
56 |         fn transfer_token(
57 |             ref self: ContractState,
58 |             address: ContractAddress,
59 |             recipient: ContractAddress,
60 |             amount: u256,
61 |         ) -> bool {
62 |             let erc20_dispatcher = IERC20Dispatcher { contract_address: address };
63 |             erc20_dispatcher.transfer_from(get_caller_address(), recipient, amount)
64 |         }
65 |     }
66 | }
67 | // ANCHOR_END: here
68 | 
69 | 
70 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_04_expanded_ierc20_library/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_04_expanded_ierc20_library/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_08"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_04_expanded_ierc20_library/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | use core::starknet::ContractAddress;
 3 | 
 4 | trait IERC20DispatcherTrait<T> {
 5 |     fn name(self: T) -> felt252;
 6 |     fn transfer(self: T, recipient: ContractAddress, amount: u256);
 7 | }
 8 | 
 9 | #[derive(Copy, Drop, starknet::Store, Serde)]
10 | struct IERC20LibraryDispatcher {
11 |     class_hash: starknet::ClassHash,
12 | }
13 | 
14 | impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait<IERC20LibraryDispatcher> {
15 |     fn name(
16 |         self: IERC20LibraryDispatcher,
17 |     ) -> felt252 { // starknet::syscalls::library_call_syscall  is called in here
18 |     }
19 |     fn transfer(
20 |         self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: u256,
21 |     ) { // starknet::syscalls::library_call_syscall  is called in here
22 |     }
23 | }
24 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_05_library_dispatcher/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_05_library_dispatcher/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_09"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_05_library_dispatcher/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | trait IValueStore<TContractState> {
 3 |     fn set_value(ref self: TContractState, value: u128);
 4 |     fn get_value(self: @TContractState) -> u128;
 5 | }
 6 | 
 7 | #[starknet::contract]
 8 | mod ValueStoreLogic {
 9 |     use core::starknet::{ContractAddress};
10 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
11 | 
12 |     #[storage]
13 |     struct Storage {
14 |         value: u128,
15 |     }
16 | 
17 |     #[abi(embed_v0)]
18 |     impl ValueStore of super::IValueStore<ContractState> {
19 |         fn set_value(ref self: ContractState, value: u128) {
20 |             self.value.write(value);
21 |         }
22 | 
23 |         fn get_value(self: @ContractState) -> u128 {
24 |             self.value.read()
25 |         }
26 |     }
27 | }
28 | 
29 | #[starknet::contract]
30 | mod ValueStoreExecutor {
31 |     use super::{IValueStoreDispatcherTrait, IValueStoreLibraryDispatcher};
32 |     use core::starknet::{ContractAddress, ClassHash};
33 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
34 | 
35 |     #[storage]
36 |     struct Storage {
37 |         logic_library: ClassHash,
38 |         value: u128,
39 |     }
40 | 
41 |     #[constructor]
42 |     fn constructor(ref self: ContractState, logic_library: ClassHash) {
43 |         self.logic_library.write(logic_library);
44 |     }
45 | 
46 |     #[abi(embed_v0)]
47 |     impl ValueStoreExecutor of super::IValueStore<ContractState> {
48 |         fn set_value(ref self: ContractState, value: u128) {
49 |             IValueStoreLibraryDispatcher { class_hash: self.logic_library.read() }
50 |                 .set_value((value));
51 |         }
52 | 
53 |         fn get_value(self: @ContractState) -> u128 {
54 |             IValueStoreLibraryDispatcher { class_hash: self.logic_library.read() }.get_value()
55 |         }
56 |     }
57 | 
58 |     #[external(v0)]
59 |     fn get_value_local(self: @ContractState) -> u128 {
60 |         self.value.read()
61 |     }
62 | }
63 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_06_syscalls/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_06_syscalls/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_10"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_06_syscalls/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | trait ITokenWrapper<TContractState> {
 5 |     fn transfer_token(
 6 |         ref self: TContractState,
 7 |         address: ContractAddress,
 8 |         recipient: ContractAddress,
 9 |         amount: u256,
10 |     ) -> bool;
11 | }
12 | 
13 | #[starknet::contract]
14 | mod TokenWrapper {
15 |     use super::ITokenWrapper;
16 |     use core::starknet::{ContractAddress, syscalls, SyscallResultTrait, get_caller_address};
17 | 
18 |     #[storage]
19 |     struct Storage {}
20 | 
21 |     impl TokenWrapper of ITokenWrapper<ContractState> {
22 |         fn transfer_token(
23 |             ref self: ContractState,
24 |             address: ContractAddress,
25 |             recipient: ContractAddress,
26 |             amount: u256,
27 |         ) -> bool {
28 |             let mut call_data: Array<felt252> = array![];
29 |             Serde::serialize(@get_caller_address(), ref call_data);
30 |             Serde::serialize(@recipient, ref call_data);
31 |             Serde::serialize(@amount, ref call_data);
32 | 
33 |             let mut res = syscalls::call_contract_syscall(
34 |                 address, selector!("transfer_from"), call_data.span(),
35 |             )
36 |                 .unwrap_syscall();
37 | 
38 |             Serde::<bool>::deserialize(ref res).unwrap()
39 |         }
40 |     }
41 | }
42 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_07_library_syscall/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_07_library_syscall/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_library_syscall"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 


--------------------------------------------------------------------------------
/listings/ch15-starknet-cross-contract-interactions/listing_07_library_syscall/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | mod ValueStore {
 3 |     use core::starknet::{ClassHash, syscalls, SyscallResultTrait};
 4 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 5 | 
 6 |     #[storage]
 7 |     struct Storage {
 8 |         logic_library: ClassHash,
 9 |         value: u128,
10 |     }
11 | 
12 |     #[constructor]
13 |     fn constructor(ref self: ContractState, logic_library: ClassHash) {
14 |         self.logic_library.write(logic_library);
15 |     }
16 | 
17 |     #[external(v0)]
18 |     fn set_value(ref self: ContractState, value: u128) -> bool {
19 |         let mut call_data: Array<felt252> = array![];
20 |         Serde::serialize(@value, ref call_data);
21 | 
22 |         let mut res = syscalls::library_call_syscall(
23 |             self.logic_library.read(), selector!("set_value"), call_data.span(),
24 |         )
25 |             .unwrap_syscall();
26 | 
27 |         Serde::<bool>::deserialize(ref res).unwrap()
28 |     }
29 | 
30 |     #[external(v0)]
31 |     fn get_value(self: @ContractState) -> u128 {
32 |         self.value.read()
33 |     }
34 | }
35 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_01_storage_packing/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_01_storage_packing/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_13_storage_packing"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 
12 | [dev-dependencies]
13 | cairo_test = "2.9.1"
14 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_01_storage_packing/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR:here
 2 | use core::starknet::storage_access::StorePacking;
 3 | 
 4 | #[derive(Drop, Serde)]
 5 | //ANCHOR:struct
 6 | struct Sizes {
 7 |     tiny: u8,
 8 |     small: u32,
 9 |     medium: u64,
10 | }
11 | //ANCHOR_END:struct
12 | 
13 | const TWO_POW_8: u128 = 0x100;
14 | const TWO_POW_40: u128 = 0x10000000000;
15 | 
16 | const MASK_8: u128 = 0xff;
17 | const MASK_32: u128 = 0xffffffff;
18 | 
19 | impl SizesStorePacking of StorePacking<Sizes, u128> {
20 |     fn pack(value: Sizes) -> u128 {
21 |         value.tiny.into() + (value.small.into() * TWO_POW_8) + (value.medium.into() * TWO_POW_40)
22 |     }
23 | 
24 |     fn unpack(value: u128) -> Sizes {
25 |         let tiny = value & MASK_8;
26 |         let small = (value / TWO_POW_8) & MASK_32;
27 |         let medium = (value / TWO_POW_40);
28 | 
29 |         Sizes {
30 |             tiny: tiny.try_into().unwrap(),
31 |             small: small.try_into().unwrap(),
32 |             medium: medium.try_into().unwrap(),
33 |         }
34 |     }
35 | }
36 | 
37 | #[starknet::contract]
38 | mod SizeFactory {
39 |     use super::Sizes;
40 |     use super::SizesStorePacking; //don't forget to import it!
41 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
42 | 
43 |     #[storage]
44 |     struct Storage {
45 |         remaining_sizes: Sizes,
46 |     }
47 | 
48 |     #[abi(embed_v0)]
49 |     fn update_sizes(ref self: ContractState, sizes: Sizes) {
50 |         // This will automatically pack the
51 |         // struct into a single u128
52 |         self.remaining_sizes.write(sizes);
53 |     }
54 | 
55 | 
56 |     #[abi(embed_v0)]
57 |     fn get_sizes(ref self: ContractState) -> Sizes {
58 |         // this will automatically unpack the
59 |         // packed-representation into the Sizes struct
60 |         self.remaining_sizes.read()
61 |     }
62 | }
63 | //ANCHOR_END:here
64 | 
65 | #[cfg(test)]
66 | mod tests {
67 |     use super::*;
68 |     use core::starknet::storage_access::StorePacking;
69 | 
70 |     #[test]
71 |     fn test_pack_unpack() {
72 |         let value = Sizes { tiny: 0x12, small: 0x12345678, medium: 0x1234567890 };
73 | 
74 |         let packed = SizesStorePacking::pack(value);
75 |         assert(packed == 0x12345678901234567812, 'wrong packed value');
76 | 
77 |         let unpacked = SizesStorePacking::unpack(packed);
78 |         assert(unpacked.tiny == 0x12, 'wrong unpacked tiny');
79 |         assert(unpacked.small == 0x12345678, 'wrong unpacked small');
80 |         assert(unpacked.medium == 0x1234567890, 'wrong unpacked medium');
81 |     }
82 | }
83 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_01_ownable"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | [[target.starknet-contract]]
12 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:
--------------------------------------------------------------------------------
  1 | // This implementation of an Ownable is inspired by Openzeppelin's work on
  2 | // OpenZeppelin Contracts for Cairo available here: https://github.com/OpenZeppelin/cairo-contracts
  3 | 
  4 | use core::starknet::ContractAddress;
  5 | mod Errors {
  6 |     pub const NOT_OWNER: felt252 = 'Caller is not the owner';
  7 |     pub const ZERO_ADDRESS_CALLER: felt252 = 'Caller is the zero address';
  8 |     pub const ZERO_ADDRESS_OWNER: felt252 = 'New owner is the zero address';
  9 | }
 10 | 
 11 | // ANCHOR: interface
 12 | #[starknet::interface]
 13 | trait IOwnable<TContractState> {
 14 |     //ANCHOR: trait_def
 15 |     fn owner(self: @TContractState) -> ContractAddress;
 16 |     fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
 17 |     fn renounce_ownership(ref self: TContractState);
 18 |     //ANCHOR_END: trait_def
 19 | }
 20 | //ANCHOR_END: interface
 21 | 
 22 | //ANCHOR: component
 23 | #[starknet::component]
 24 | pub mod ownable_component {
 25 |     use core::starknet::{ContractAddress, get_caller_address};
 26 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 27 |     use super::Errors;
 28 |     use core::num::traits::Zero;
 29 | 
 30 |     #[storage]
 31 |     pub struct Storage {
 32 |         owner: ContractAddress,
 33 |     }
 34 | 
 35 |     #[event]
 36 |     #[derive(Drop, starknet::Event)]
 37 |     pub enum Event {
 38 |         OwnershipTransferred: OwnershipTransferred,
 39 |     }
 40 | 
 41 |     #[derive(Drop, starknet::Event)]
 42 |     struct OwnershipTransferred {
 43 |         previous_owner: ContractAddress,
 44 |         new_owner: ContractAddress,
 45 |     }
 46 | 
 47 |     //ANCHOR: impl_signature
 48 |     #[embeddable_as(Ownable)]
 49 |     impl OwnableImpl<
 50 |         TContractState, +HasComponent<TContractState>,
 51 |     > of super::IOwnable<ComponentState<TContractState>> {
 52 |         //ANCHOR_END: impl_signature
 53 |         fn owner(self: @ComponentState<TContractState>) -> ContractAddress {
 54 |             self.owner.read()
 55 |         }
 56 | 
 57 |         fn transfer_ownership(
 58 |             ref self: ComponentState<TContractState>, new_owner: ContractAddress,
 59 |         ) {
 60 |             assert(!new_owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);
 61 |             self.assert_only_owner();
 62 |             self._transfer_ownership(new_owner);
 63 |         }
 64 | 
 65 |         fn renounce_ownership(ref self: ComponentState<TContractState>) {
 66 |             self.assert_only_owner();
 67 |             self._transfer_ownership(Zero::zero());
 68 |         }
 69 |     }
 70 | 
 71 |     #[generate_trait]
 72 |     pub impl InternalImpl<
 73 |         TContractState, +HasComponent<TContractState>,
 74 |     > of InternalTrait<TContractState> {
 75 |         fn initializer(ref self: ComponentState<TContractState>, owner: ContractAddress) {
 76 |             self._transfer_ownership(owner);
 77 |         }
 78 | 
 79 |         fn assert_only_owner(self: @ComponentState<TContractState>) {
 80 |             let owner: ContractAddress = self.owner.read();
 81 |             let caller: ContractAddress = get_caller_address();
 82 |             assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);
 83 |             assert(caller == owner, Errors::NOT_OWNER);
 84 |         }
 85 | 
 86 |         fn _transfer_ownership(
 87 |             ref self: ComponentState<TContractState>, new_owner: ContractAddress,
 88 |         ) {
 89 |             let previous_owner: ContractAddress = self.owner.read();
 90 |             self.owner.write(new_owner);
 91 |             self
 92 |                 .emit(
 93 |                     OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner },
 94 |                 );
 95 |         }
 96 |     }
 97 | }
 98 | //ANCHOR_END: component
 99 | 
100 | 
101 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: all
 2 | #[starknet::contract]
 3 | mod OwnableCounter {
 4 |     use listing_01_ownable::component::ownable_component;
 5 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 6 | 
 7 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
 8 | 
 9 |     //ANCHOR:  embedded_impl
10 |     #[abi(embed_v0)]
11 |     impl OwnableImpl = ownable_component::Ownable<ContractState>;
12 | 
13 |     impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;
14 |     //ANCHOR_END: embedded_impl
15 | 
16 |     #[storage]
17 |     struct Storage {
18 |         counter: u128,
19 |         #[substorage(v0)]
20 |         ownable: ownable_component::Storage,
21 |     }
22 | 
23 | 
24 |     #[event]
25 |     #[derive(Drop, starknet::Event)]
26 |     enum Event {
27 |         OwnableEvent: ownable_component::Event,
28 |     }
29 | 
30 | 
31 |     #[abi(embed_v0)]
32 |     fn foo(ref self: ContractState) {
33 |         self.ownable.assert_only_owner();
34 |         self.counter.write(self.counter.read() + 1);
35 |     }
36 | }
37 | //ANCHOR_END: all
38 | 
39 | 
40 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod component;
2 | mod contract;
3 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_03_component_dep"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | [[target.starknet-contract]]
12 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/contract.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: all
 2 | #[starknet::contract]
 3 | mod OwnableCounter {
 4 |     use listing_03_component_dep::owner::ownable_component;
 5 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 6 | 
 7 |     component!(path: ownable_component, storage: ownable, event: OwnableEvent);
 8 | 
 9 |     //ANCHOR:  embedded_impl
10 |     #[abi(embed_v0)]
11 |     impl OwnableImpl = ownable_component::Ownable<ContractState>;
12 | 
13 |     impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;
14 |     //ANCHOR_END: embedded_impl
15 | 
16 |     #[storage]
17 |     struct Storage {
18 |         counter: u128,
19 |         #[substorage(v0)]
20 |         ownable: ownable_component::Storage,
21 |     }
22 | 
23 |     #[event]
24 |     #[derive(Drop, starknet::Event)]
25 |     enum Event {
26 |         OwnableEvent: ownable_component::Event,
27 |     }
28 | 
29 |     #[abi(embed_v0)]
30 |     fn foo(ref self: ContractState) {
31 |         self.ownable.assert_only_owner();
32 |         self.counter.write(self.counter.read() + 1);
33 |     }
34 | }
35 | //ANCHOR_END: all
36 | 
37 | 
38 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: full
 2 | //ANCHOR: interface
 3 | use core::starknet::ContractAddress;
 4 | 
 5 | #[starknet::interface]
 6 | trait IOwnableCounter<TContractState> {
 7 |     fn get_counter(self: @TContractState) -> u32;
 8 |     fn increment(ref self: TContractState);
 9 |     fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
10 | }
11 | //ANCHOR_END: interface
12 | 
13 | //ANCHOR: component
14 | #[starknet::component]
15 | mod OwnableCounterComponent {
16 |     use listing_03_component_dep::owner::{ownable_component, ownable_component::InternalImpl};
17 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
18 |     use core::starknet::ContractAddress;
19 | 
20 |     #[storage]
21 |     pub struct Storage {
22 |         value: u32,
23 |     }
24 | 
25 |     //ANCHOR: component_impl
26 |     #[embeddable_as(OwnableCounterImpl)]
27 |     //ANCHOR: component_signature
28 |     impl OwnableCounter<
29 |         TContractState,
30 |         +HasComponent<TContractState>,
31 |         +Drop<TContractState>,
32 |         impl Owner: ownable_component::HasComponent<TContractState>,
33 |     > of super::IOwnableCounter<ComponentState<TContractState>> {
34 |         //ANCHOR_END: component_signature
35 |         //ANCHOR: get_counter
36 |         fn get_counter(self: @ComponentState<TContractState>) -> u32 {
37 |             self.value.read()
38 |         }
39 |         //ANCHOR_END: get_counter
40 | 
41 |         //ANCHOR: increment
42 |         fn increment(ref self: ComponentState<TContractState>) {
43 |             let ownable_comp = get_dep_component!(@self, Owner);
44 |             ownable_comp.assert_only_owner();
45 |             self.value.write(self.value.read() + 1);
46 |         }
47 |         //ANCHOR_END: increment
48 | 
49 |         //ANCHOR: transfer_ownership
50 |         fn transfer_ownership(
51 |             ref self: ComponentState<TContractState>, new_owner: ContractAddress,
52 |         ) {
53 |             let mut ownable_comp = get_dep_component_mut!(ref self, Owner);
54 |             ownable_comp._transfer_ownership(new_owner);
55 |         }
56 |         //ANCHOR_END: transfer_ownership
57 |     }
58 |     //ANCHOR_END: component_impl
59 | }
60 | //ANCHOR_END: component
61 | //ANCHOR_END: full
62 | 
63 | 
64 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod owner;
2 | mod counter;
3 | mod contract;
4 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/owner.cairo:
--------------------------------------------------------------------------------
  1 | // This implementation of an Ownable is inspired by Openzeppelin's work on
  2 | // OpenZeppelin Contracts for Cairo available here: https://github.com/OpenZeppelin/cairo-contracts
  3 | 
  4 | use core::starknet::ContractAddress;
  5 | 
  6 | pub mod Errors {
  7 |     pub const NOT_OWNER: felt252 = 'Caller is not the owner';
  8 |     pub const ZERO_ADDRESS_CALLER: felt252 = 'Caller is the zero address';
  9 |     pub const ZERO_ADDRESS_OWNER: felt252 = 'New owner is the zero address';
 10 | }
 11 | 
 12 | // ANCHOR: interface
 13 | #[starknet::interface]
 14 | trait IOwnable<TContractState> {
 15 |     //ANCHOR: trait_def
 16 |     fn owner(self: @TContractState) -> ContractAddress;
 17 |     fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
 18 |     fn renounce_ownership(ref self: TContractState);
 19 |     //ANCHOR_END: trait_def
 20 | }
 21 | //ANCHOR_END: interface
 22 | 
 23 | //ANCHOR: component
 24 | #[starknet::component]
 25 | pub mod ownable_component {
 26 |     use core::starknet::{ContractAddress, get_caller_address};
 27 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
 28 |     use super::Errors;
 29 |     use core::num::traits::Zero;
 30 | 
 31 |     #[storage]
 32 |     pub struct Storage {
 33 |         owner: ContractAddress,
 34 |     }
 35 | 
 36 |     #[event]
 37 |     #[derive(Drop, starknet::Event)]
 38 |     pub enum Event {
 39 |         OwnershipTransferred: OwnershipTransferred,
 40 |     }
 41 | 
 42 |     #[derive(Drop, starknet::Event)]
 43 |     struct OwnershipTransferred {
 44 |         previous_owner: ContractAddress,
 45 |         new_owner: ContractAddress,
 46 |     }
 47 | 
 48 |     //ANCHOR: impl_signature
 49 |     #[embeddable_as(Ownable)]
 50 |     pub impl OwnableImpl<
 51 |         TContractState, +HasComponent<TContractState>,
 52 |     > of super::IOwnable<ComponentState<TContractState>> {
 53 |         //ANCHOR_END: impl_signature
 54 |         fn owner(self: @ComponentState<TContractState>) -> ContractAddress {
 55 |             self.owner.read()
 56 |         }
 57 | 
 58 |         fn transfer_ownership(
 59 |             ref self: ComponentState<TContractState>, new_owner: ContractAddress,
 60 |         ) {
 61 |             assert(!new_owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);
 62 |             self.assert_only_owner();
 63 |             self._transfer_ownership(new_owner);
 64 |         }
 65 | 
 66 |         fn renounce_ownership(ref self: ComponentState<TContractState>) {
 67 |             self.assert_only_owner();
 68 |             self._transfer_ownership(Zero::zero());
 69 |         }
 70 |     }
 71 | 
 72 |     #[generate_trait]
 73 |     pub impl InternalImpl<
 74 |         TContractState, +HasComponent<TContractState>,
 75 |     > of InternalTrait<TContractState> {
 76 |         fn initializer(ref self: ComponentState<TContractState>, owner: ContractAddress) {
 77 |             self._transfer_ownership(owner);
 78 |         }
 79 | 
 80 |         fn assert_only_owner(self: @ComponentState<TContractState>) {
 81 |             let owner: ContractAddress = self.owner.read();
 82 |             let caller: ContractAddress = get_caller_address();
 83 |             assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);
 84 |             assert(caller == owner, Errors::NOT_OWNER);
 85 |         }
 86 | 
 87 |         fn _transfer_ownership(
 88 |             ref self: ComponentState<TContractState>, new_owner: ContractAddress,
 89 |         ) {
 90 |             let previous_owner: ContractAddress = self.owner.read();
 91 |             self.owner.write(new_owner);
 92 |             self
 93 |                 .emit(
 94 |                     OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner },
 95 |                 );
 96 |         }
 97 |     }
 98 | }
 99 | //ANCHOR_END: component
100 | 
101 | 
102 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_03_test_component"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | [dev-dependencies]
12 | cairo_test = "2.9.1"
13 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/counter.cairo:
--------------------------------------------------------------------------------
 1 | //ANCHOR: interface
 2 | #[starknet::interface]
 3 | pub trait ICounter<TContractState> {
 4 |     fn get_counter(self: @TContractState) -> u32;
 5 |     fn increment(ref self: TContractState);
 6 | }
 7 | //ANCHOR_END: interface
 8 | 
 9 | //ANCHOR: component
10 | #[starknet::component]
11 | pub mod CounterComponent {
12 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
13 | 
14 |     #[storage]
15 |     pub struct Storage {
16 |         value: u32,
17 |     }
18 | 
19 |     #[embeddable_as(CounterImpl)]
20 |     impl Counter<
21 |         TContractState, +HasComponent<TContractState>,
22 |     > of super::ICounter<ComponentState<TContractState>> {
23 |         //ANCHOR: get_counter
24 |         fn get_counter(self: @ComponentState<TContractState>) -> u32 {
25 |             self.value.read()
26 |         }
27 |         //ANCHOR_END: get_counter
28 | 
29 |         //ANCHOR: increment
30 |         fn increment(ref self: ComponentState<TContractState>) {
31 |             self.value.write(self.value.read() + 1);
32 |         }
33 |         //ANCHOR_END: increment
34 |     }
35 | }
36 | //ANCHOR_END: component
37 | 
38 | 
39 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | mod counter;
 2 | #[cfg(test)]
 3 | mod tests_deployed;
 4 | #[cfg(test)]
 5 | mod tests_direct;
 6 | 
 7 | // ANCHOR: mock_contract
 8 | #[starknet::contract]
 9 | mod MockContract {
10 |     use super::counter::CounterComponent;
11 | 
12 |     component!(path: CounterComponent, storage: counter, event: CounterEvent);
13 | 
14 |     #[storage]
15 |     struct Storage {
16 |         #[substorage(v0)]
17 |         counter: CounterComponent::Storage,
18 |     }
19 | 
20 |     #[event]
21 |     #[derive(Drop, starknet::Event)]
22 |     enum Event {
23 |         CounterEvent: CounterComponent::Event,
24 |     }
25 | 
26 |     #[abi(embed_v0)]
27 |     impl CounterImpl = CounterComponent::CounterImpl<ContractState>;
28 | }
29 | //ANCHOR_END: mock_contract
30 | 
31 | 
32 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_deployed.cairo:
--------------------------------------------------------------------------------
 1 | use super::MockContract;
 2 | use super::counter::{ICounterDispatcher, ICounterDispatcherTrait};
 3 | use core::starknet::syscalls::deploy_syscall;
 4 | use core::starknet::SyscallResultTrait;
 5 | 
 6 | fn setup_counter() -> ICounterDispatcher {
 7 |     let (address, _) = deploy_syscall(
 8 |         MockContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false,
 9 |     )
10 |         .unwrap_syscall();
11 |     ICounterDispatcher { contract_address: address }
12 | }
13 | 
14 | #[test]
15 | fn test_constructor() {
16 |     let counter = setup_counter();
17 |     assert_eq!(counter.get_counter(), 0);
18 | }
19 | 
20 | #[test]
21 | fn test_increment() {
22 |     let counter = setup_counter();
23 |     counter.increment();
24 |     assert_eq!(counter.get_counter(), 1);
25 | }
26 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_direct.cairo:
--------------------------------------------------------------------------------
 1 | use super::counter::{CounterComponent};
 2 | use super::MockContract;
 3 | use CounterComponent::{CounterImpl};
 4 | 
 5 | //ANCHOR: type_alias
 6 | type TestingState = CounterComponent::ComponentState<MockContract::ContractState>;
 7 | 
 8 | // You can derive even `Default` on this type alias
 9 | impl TestingStateDefault of Default<TestingState> {
10 |     fn default() -> TestingState {
11 |         CounterComponent::component_state_for_testing()
12 |     }
13 | }
14 | //ANCHOR_END: type_alias
15 | 
16 | //ANCHOR: test
17 | #[test]
18 | fn test_increment() {
19 |     let mut counter: TestingState = Default::default();
20 | 
21 |     counter.increment();
22 |     counter.increment();
23 | 
24 |     assert_eq!(counter.get_counter(), 2);
25 | }
26 | //ANCHOR_END: test
27 | 
28 | 
29 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_05_vote_contract/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_05_vote_contract/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_12_vote_contract"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_05_vote_contract/src/lib.cairo:
--------------------------------------------------------------------------------
  1 | /// @dev Core Library Imports for the Traits outside the Starknet Contract
  2 | use core::starknet::ContractAddress;
  3 | 
  4 | /// @dev Trait defining the functions that can be implemented or called by the Starknet Contract
  5 | #[starknet::interface]
  6 | trait VoteTrait<T> {
  7 |     /// @dev Function that returns the current vote status
  8 |     fn get_vote_status(self: @T) -> (u8, u8, u8, u8);
  9 |     /// @dev Function that checks if the user at the specified address is allowed to vote
 10 |     fn voter_can_vote(self: @T, user_address: ContractAddress) -> bool;
 11 |     /// @dev Function that checks if the specified address is registered as a voter
 12 |     fn is_voter_registered(self: @T, address: ContractAddress) -> bool;
 13 |     /// @dev Function that allows a user to vote
 14 |     fn vote(ref self: T, vote: u8);
 15 | }
 16 | 
 17 | /// @dev Starknet Contract allowing three registered voters to vote on a proposal
 18 | #[starknet::contract]
 19 | mod Vote {
 20 |     use core::starknet::ContractAddress;
 21 |     use core::starknet::get_caller_address;
 22 |     use core::starknet::storage::{
 23 |         StoragePointerReadAccess, StoragePointerWriteAccess, StorageMapReadAccess,
 24 |         StorageMapWriteAccess, Map,
 25 |     };
 26 | 
 27 |     const YES: u8 = 1_u8;
 28 |     const NO: u8 = 0_u8;
 29 | 
 30 |     /// @dev Structure that stores vote counts and voter states
 31 |     #[storage]
 32 |     struct Storage {
 33 |         yes_votes: u8,
 34 |         no_votes: u8,
 35 |         can_vote: Map::<ContractAddress, bool>,
 36 |         registered_voter: Map::<ContractAddress, bool>,
 37 |     }
 38 | 
 39 |     /// @dev Contract constructor initializing the contract with a list of registered voters and 0
 40 |     /// vote count
 41 |     #[constructor]
 42 |     fn constructor(
 43 |         ref self: ContractState,
 44 |         voter_1: ContractAddress,
 45 |         voter_2: ContractAddress,
 46 |         voter_3: ContractAddress,
 47 |     ) {
 48 |         // Register all voters by calling the _register_voters function
 49 |         self._register_voters(voter_1, voter_2, voter_3);
 50 | 
 51 |         // Initialize the vote count to 0
 52 |         self.yes_votes.write(0_u8);
 53 |         self.no_votes.write(0_u8);
 54 |     }
 55 | 
 56 |     /// @dev Event that gets emitted when a vote is cast
 57 |     #[event]
 58 |     #[derive(Drop, starknet::Event)]
 59 |     enum Event {
 60 |         VoteCast: VoteCast,
 61 |         UnauthorizedAttempt: UnauthorizedAttempt,
 62 |     }
 63 | 
 64 |     /// @dev Represents a vote that was cast
 65 |     #[derive(Drop, starknet::Event)]
 66 |     struct VoteCast {
 67 |         voter: ContractAddress,
 68 |         vote: u8,
 69 |     }
 70 | 
 71 |     /// @dev Represents an unauthorized attempt to vote
 72 |     #[derive(Drop, starknet::Event)]
 73 |     struct UnauthorizedAttempt {
 74 |         unauthorized_address: ContractAddress,
 75 |     }
 76 | 
 77 |     /// @dev Implementation of VoteTrait for ContractState
 78 |     #[abi(embed_v0)]
 79 |     impl VoteImpl of super::VoteTrait<ContractState> {
 80 |         /// @dev Returns the voting results
 81 |         fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) {
 82 |             let (n_yes, n_no) = self._get_voting_result();
 83 |             let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage();
 84 |             (n_yes, n_no, yes_percentage, no_percentage)
 85 |         }
 86 | 
 87 |         /// @dev Check whether a voter is allowed to vote
 88 |         fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -> bool {
 89 |             self.can_vote.read(user_address)
 90 |         }
 91 | 
 92 |         /// @dev Check whether an address is registered as a voter
 93 |         fn is_voter_registered(self: @ContractState, address: ContractAddress) -> bool {
 94 |             self.registered_voter.read(address)
 95 |         }
 96 | 
 97 |         /// @dev Submit a vote
 98 |         fn vote(ref self: ContractState, vote: u8) {
 99 |             assert!(vote == NO || vote == YES, "VOTE_0_OR_1");
100 |             let caller: ContractAddress = get_caller_address();
101 |             self._assert_allowed(caller);
102 |             self.can_vote.write(caller, false);
103 | 
104 |             if (vote == NO) {
105 |                 self.no_votes.write(self.no_votes.read() + 1_u8);
106 |             }
107 |             if (vote == YES) {
108 |                 self.yes_votes.write(self.yes_votes.read() + 1_u8);
109 |             }
110 | 
111 |             self.emit(VoteCast { voter: caller, vote: vote });
112 |         }
113 |     }
114 | 
115 |     /// @dev Internal Functions implementation for the Vote contract
116 |     #[generate_trait]
117 |     impl InternalFunctions of InternalFunctionsTrait {
118 |         /// @dev Registers the voters and initializes their voting status to true (can vote)
119 |         fn _register_voters(
120 |             ref self: ContractState,
121 |             voter_1: ContractAddress,
122 |             voter_2: ContractAddress,
123 |             voter_3: ContractAddress,
124 |         ) {
125 |             self.registered_voter.write(voter_1, true);
126 |             self.can_vote.write(voter_1, true);
127 | 
128 |             self.registered_voter.write(voter_2, true);
129 |             self.can_vote.write(voter_2, true);
130 | 
131 |             self.registered_voter.write(voter_3, true);
132 |             self.can_vote.write(voter_3, true);
133 |         }
134 |     }
135 | 
136 |     /// @dev Asserts implementation for the Vote contract
137 |     #[generate_trait]
138 |     impl AssertsImpl of AssertsTrait {
139 |         // @dev Internal function that checks if an address is allowed to vote
140 |         fn _assert_allowed(ref self: ContractState, address: ContractAddress) {
141 |             let is_voter: bool = self.registered_voter.read((address));
142 |             let can_vote: bool = self.can_vote.read((address));
143 | 
144 |             if (!can_vote) {
145 |                 self.emit(UnauthorizedAttempt { unauthorized_address: address });
146 |             }
147 | 
148 |             assert!(is_voter, "USER_NOT_REGISTERED");
149 |             assert!(can_vote, "USER_ALREADY_VOTED");
150 |         }
151 |     }
152 | 
153 |     /// @dev Implement the VotingResultTrait for the Vote contract
154 |     #[generate_trait]
155 |     impl VoteResultFunctionsImpl of VoteResultFunctionsTrait {
156 |         // @dev Internal function to get the voting results (yes and no vote counts)
157 |         fn _get_voting_result(self: @ContractState) -> (u8, u8) {
158 |             let n_yes: u8 = self.yes_votes.read();
159 |             let n_no: u8 = self.no_votes.read();
160 | 
161 |             (n_yes, n_no)
162 |         }
163 | 
164 |         // @dev Internal function to calculate the voting results in percentage
165 |         fn _get_voting_result_in_percentage(self: @ContractState) -> (u8, u8) {
166 |             let n_yes: u8 = self.yes_votes.read();
167 |             let n_no: u8 = self.no_votes.read();
168 | 
169 |             let total_votes: u8 = n_yes + n_no;
170 | 
171 |             if (total_votes == 0_u8) {
172 |                 return (0, 0);
173 |             }
174 |             let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes);
175 |             let no_percentage: u8 = (n_no * 100_u8) / (total_votes);
176 | 
177 |             (yes_percentage, no_percentage)
178 |         }
179 |     }
180 | }
181 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_06_dice_game_vrf/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_06_dice_game_vrf/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_06_dice_game_vrf"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib", rev = "c4cdeaafbec19d99d740df61afc0301d78975204" }
10 | openzeppelin = { git = "https://github.com/OpenZeppelin/cairo-contracts.git", tag = "v0.19.0" }
11 | starknet = ">=2.9.1"
12 | 
13 | [[target.starknet-contract]]
14 | casm = true
15 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_06_dice_game_vrf/src/lib.cairo:
--------------------------------------------------------------------------------
  1 | //ANCHOR: interfaces
  2 | use core::starknet::ContractAddress;
  3 | 
  4 | #[starknet::interface]
  5 | pub trait IPragmaVRF<TContractState> {
  6 |     fn get_last_random_number(self: @TContractState) -> felt252;
  7 |     fn request_randomness_from_pragma(
  8 |         ref self: TContractState,
  9 |         seed: u64,
 10 |         callback_address: ContractAddress,
 11 |         callback_fee_limit: u128,
 12 |         publish_delay: u64,
 13 |         num_words: u64,
 14 |         calldata: Array<felt252>,
 15 |     );
 16 |     fn receive_random_words(
 17 |         ref self: TContractState,
 18 |         requester_address: ContractAddress,
 19 |         request_id: u64,
 20 |         random_words: Span<felt252>,
 21 |         calldata: Array<felt252>,
 22 |     );
 23 |     fn withdraw_extra_fee_fund(ref self: TContractState, receiver: ContractAddress);
 24 | }
 25 | 
 26 | #[starknet::interface]
 27 | pub trait IDiceGame<TContractState> {
 28 |     fn guess(ref self: TContractState, guess: u8);
 29 |     fn toggle_play_window(ref self: TContractState);
 30 |     fn get_game_window(self: @TContractState) -> bool;
 31 |     fn process_game_winners(ref self: TContractState);
 32 | }
 33 | //ANCHOR_END: interfaces
 34 | 
 35 | //ANCHOR: dice_game
 36 | #[starknet::contract]
 37 | mod DiceGame {
 38 |     use core::starknet::storage::{
 39 |         Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
 40 |     };
 41 |     use core::starknet::{
 42 |         ContractAddress, contract_address_const, get_block_number, get_caller_address,
 43 |         get_contract_address,
 44 |     };
 45 |     use pragma_lib::abi::{IRandomnessDispatcher, IRandomnessDispatcherTrait};
 46 |     use openzeppelin::token::erc20::interface::{ERC20ABIDispatcher, ERC20ABIDispatcherTrait};
 47 |     use openzeppelin::access::ownable::OwnableComponent;
 48 | 
 49 |     component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
 50 | 
 51 |     #[abi(embed_v0)]
 52 |     impl OwnableImpl = OwnableComponent::OwnableImpl<ContractState>;
 53 |     impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;
 54 | 
 55 |     #[storage]
 56 |     struct Storage {
 57 |         user_guesses: Map<ContractAddress, u8>,
 58 |         pragma_vrf_contract_address: ContractAddress,
 59 |         game_window: bool,
 60 |         min_block_number_storage: u64,
 61 |         last_random_number: felt252,
 62 |         #[substorage(v0)]
 63 |         ownable: OwnableComponent::Storage,
 64 |     }
 65 | 
 66 |     #[event]
 67 |     #[derive(Drop, starknet::Event)]
 68 |     enum Event {
 69 |         GameWinner: ResultAnnouncement,
 70 |         GameLost: ResultAnnouncement,
 71 |         #[flat]
 72 |         OwnableEvent: OwnableComponent::Event,
 73 |     }
 74 | 
 75 |     #[derive(Drop, starknet::Event)]
 76 |     struct ResultAnnouncement {
 77 |         caller: ContractAddress,
 78 |         guess: u8,
 79 |         random_number: u256,
 80 |     }
 81 | 
 82 |     #[constructor]
 83 |     fn constructor(
 84 |         ref self: ContractState,
 85 |         pragma_vrf_contract_address: ContractAddress,
 86 |         owner: ContractAddress,
 87 |     ) {
 88 |         self.ownable.initializer(owner);
 89 |         self.pragma_vrf_contract_address.write(pragma_vrf_contract_address);
 90 |         self.game_window.write(true);
 91 |     }
 92 | 
 93 |     #[abi(embed_v0)]
 94 |     impl DiceGame of super::IDiceGame<ContractState> {
 95 |         fn guess(ref self: ContractState, guess: u8) {
 96 |             assert(self.game_window.read(), 'GAME_INACTIVE');
 97 |             assert(guess >= 1 && guess <= 6, 'INVALID_GUESS');
 98 | 
 99 |             let caller = get_caller_address();
100 |             self.user_guesses.entry(caller).write(guess);
101 |         }
102 | 
103 |         fn toggle_play_window(ref self: ContractState) {
104 |             self.ownable.assert_only_owner();
105 | 
106 |             let current: bool = self.game_window.read();
107 |             self.game_window.write(!current);
108 |         }
109 | 
110 |         fn get_game_window(self: @ContractState) -> bool {
111 |             self.game_window.read()
112 |         }
113 | 
114 |         fn process_game_winners(ref self: ContractState) {
115 |             assert(!self.game_window.read(), 'GAME_ACTIVE');
116 |             assert(self.last_random_number.read() != 0, 'NO_RANDOM_NUMBER_YET');
117 | 
118 |             let caller = get_caller_address();
119 |             let user_guess: u8 = self.user_guesses.entry(caller).read();
120 |             let reduced_random_number: u256 = self.last_random_number.read().into() % 6 + 1;
121 | 
122 |             if user_guess == reduced_random_number.try_into().unwrap() {
123 |                 self
124 |                     .emit(
125 |                         Event::GameWinner(
126 |                             ResultAnnouncement {
127 |                                 caller: caller,
128 |                                 guess: user_guess,
129 |                                 random_number: reduced_random_number,
130 |                             },
131 |                         ),
132 |                     );
133 |             } else {
134 |                 self
135 |                     .emit(
136 |                         Event::GameLost(
137 |                             ResultAnnouncement {
138 |                                 caller: caller,
139 |                                 guess: user_guess,
140 |                                 random_number: reduced_random_number,
141 |                             },
142 |                         ),
143 |                     );
144 |             }
145 |         }
146 |     }
147 | 
148 |     #[abi(embed_v0)]
149 |     impl PragmaVRFOracle of super::IPragmaVRF<ContractState> {
150 |         fn get_last_random_number(self: @ContractState) -> felt252 {
151 |             let last_random = self.last_random_number.read();
152 |             last_random
153 |         }
154 | 
155 |         fn request_randomness_from_pragma(
156 |             ref self: ContractState,
157 |             seed: u64,
158 |             callback_address: ContractAddress,
159 |             callback_fee_limit: u128,
160 |             publish_delay: u64,
161 |             num_words: u64,
162 |             calldata: Array<felt252>,
163 |         ) {
164 |             self.ownable.assert_only_owner();
165 | 
166 |             let randomness_contract_address = self.pragma_vrf_contract_address.read();
167 |             let randomness_dispatcher = IRandomnessDispatcher {
168 |                 contract_address: randomness_contract_address,
169 |             };
170 | 
171 |             // Approve the randomness contract to transfer the callback fee
172 |             // You would need to send some ETH to this contract first to cover the fees
173 |             let eth_dispatcher = ERC20ABIDispatcher {
174 |                 contract_address: contract_address_const::<
175 |                     0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
176 |                 >() // ETH Contract Address
177 |             };
178 |             eth_dispatcher
179 |                 .approve(
180 |                     randomness_contract_address,
181 |                     (callback_fee_limit + callback_fee_limit / 5).into(),
182 |                 );
183 | 
184 |             // Request the randomness
185 |             randomness_dispatcher
186 |                 .request_random(
187 |                     seed, callback_address, callback_fee_limit, publish_delay, num_words, calldata,
188 |                 );
189 | 
190 |             let current_block_number = get_block_number();
191 |             self.min_block_number_storage.write(current_block_number + publish_delay);
192 |         }
193 | 
194 |         fn receive_random_words(
195 |             ref self: ContractState,
196 |             requester_address: ContractAddress,
197 |             request_id: u64,
198 |             random_words: Span<felt252>,
199 |             calldata: Array<felt252>,
200 |         ) {
201 |             // Have to make sure that the caller is the Pragma Randomness Oracle contract
202 |             let caller_address = get_caller_address();
203 |             assert(
204 |                 caller_address == self.pragma_vrf_contract_address.read(),
205 |                 'caller not randomness contract',
206 |             );
207 |             // and that the current block is within publish_delay of the request block
208 |             let current_block_number = get_block_number();
209 |             let min_block_number = self.min_block_number_storage.read();
210 |             assert(min_block_number <= current_block_number, 'block number issue');
211 | 
212 |             let random_word = *random_words.at(0);
213 |             self.last_random_number.write(random_word);
214 |         }
215 | 
216 |         fn withdraw_extra_fee_fund(ref self: ContractState, receiver: ContractAddress) {
217 |             self.ownable.assert_only_owner();
218 |             let eth_dispatcher = ERC20ABIDispatcher {
219 |                 contract_address: contract_address_const::<
220 |                     0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
221 |                 >() // ETH Contract Address
222 |             };
223 |             let balance = eth_dispatcher.balance_of(get_contract_address());
224 |             eth_dispatcher.transfer(receiver, balance);
225 |         }
226 |     }
227 | }
228 | //ANCHOR_END: dice_game
229 | 
230 | 
231 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_06_upgrade_with_syscall/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_06_upgrade_with_syscall/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_06_upgrade_with_syscall"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | [[target.starknet-contract]]
12 | casm = true
13 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_06_upgrade_with_syscall/src/lib.cairo:
--------------------------------------------------------------------------------
1 | use core::starknet::{ClassHash, syscalls};
2 | use core::starknet::class_hash::class_hash_const;
3 | use core::num::traits::Zero;
4 | 
5 | fn _upgrade(new_class_hash: ClassHash) {
6 |     assert(!new_class_hash.is_zero(), 'Class hash cannot be zero');
7 |     syscalls::replace_class_syscall(new_class_hash).unwrap();
8 | }
9 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_07_oz_upgrade/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_07_oz_upgrade/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_07_oz_upgrade"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | openzeppelin = { git = "https://github.com/OpenZeppelin/cairo-contracts.git", tag = "v0.19.0" }
10 | starknet = ">=2.9.1"
11 | 
12 | [[target.starknet-contract]]
13 | casm = true
14 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_07_oz_upgrade/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | mod UpgradeableContract {
 3 |     use openzeppelin::access::ownable::OwnableComponent;
 4 |     use openzeppelin::upgrades::UpgradeableComponent;
 5 |     use openzeppelin::upgrades::interface::IUpgradeable;
 6 |     use core::starknet::{ContractAddress, ClassHash};
 7 | 
 8 |     component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
 9 |     component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);
10 | 
11 |     /// Ownable
12 |     #[abi(embed_v0)]
13 |     impl OwnableImpl = OwnableComponent::OwnableImpl<ContractState>;
14 |     impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;
15 | 
16 |     /// Upgradeable
17 |     impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;
18 | 
19 |     #[storage]
20 |     struct Storage {
21 |         #[substorage(v0)]
22 |         ownable: OwnableComponent::Storage,
23 |         #[substorage(v0)]
24 |         upgradeable: UpgradeableComponent::Storage,
25 |     }
26 | 
27 |     #[event]
28 |     #[derive(Drop, starknet::Event)]
29 |     enum Event {
30 |         #[flat]
31 |         OwnableEvent: OwnableComponent::Event,
32 |         #[flat]
33 |         UpgradeableEvent: UpgradeableComponent::Event,
34 |     }
35 | 
36 |     #[constructor]
37 |     fn constructor(ref self: ContractState, owner: ContractAddress) {
38 |         self.ownable.initializer(owner);
39 |     }
40 | 
41 |     #[abi(embed_v0)]
42 |     impl UpgradeableImpl of IUpgradeable<ContractState> {
43 |         fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
44 |             // This function can only be called by the owner
45 |             self.ownable.assert_only_owner();
46 | 
47 |             // Replace the class hash upgrading the contract
48 |             self.upgradeable.upgrade(new_class_hash);
49 |         }
50 |     }
51 | }
52 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | .snfoundry_cache/
3 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_08_price_feed"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib", rev = "c4cdeaafbec19d99d740df61afc0301d78975204" }
10 | openzeppelin = { git = "https://github.com/OpenZeppelin/cairo-contracts.git", tag = "v0.19.0" }
11 | starknet = ">=2.9.1"
12 | 
13 | [[target.starknet-contract]]
14 | casm = true
15 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | //ANCHOR:price_interface
 4 | #[starknet::interface]
 5 | pub trait IPriceFeedExample<TContractState> {
 6 |     fn buy_item(ref self: TContractState);
 7 |     fn get_asset_price(self: @TContractState, asset_id: felt252) -> u128;
 8 | }
 9 | //ANCHOR_END:price_interface
10 | 
11 | //ANCHOR: here
12 | #[starknet::contract]
13 | mod PriceFeedExample {
14 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
15 |     use super::{ContractAddress, IPriceFeedExample};
16 |     //ANCHOR: pragma_lib
17 |     use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
18 |     use pragma_lib::types::{DataType, PragmaPricesResponse};
19 |     //ANCHOR_END: pragma_lib
20 |     use openzeppelin::token::erc20::interface::{ERC20ABIDispatcher, ERC20ABIDispatcherTrait};
21 |     use core::starknet::contract_address::contract_address_const;
22 |     use core::starknet::get_caller_address;
23 | 
24 |     const ETH_USD: felt252 = 19514442401534788;
25 |     const EIGHT_DECIMAL_FACTOR: u256 = 100000000;
26 | 
27 |     #[storage]
28 |     struct Storage {
29 |         pragma_contract: ContractAddress,
30 |         product_price_in_usd: u256,
31 |     }
32 | 
33 |     #[constructor]
34 |     fn constructor(ref self: ContractState, pragma_contract: ContractAddress) {
35 |         self.pragma_contract.write(pragma_contract);
36 |         self.product_price_in_usd.write(100);
37 |     }
38 | 
39 |     #[abi(embed_v0)]
40 |     impl PriceFeedExampleImpl of IPriceFeedExample<ContractState> {
41 |         fn buy_item(ref self: ContractState) {
42 |             let caller_address = get_caller_address();
43 |             let eth_price = self.get_asset_price(ETH_USD).into();
44 |             let product_price = self.product_price_in_usd.read();
45 | 
46 |             // Calculate the amount of ETH needed
47 |             let eth_needed = product_price * EIGHT_DECIMAL_FACTOR / eth_price;
48 | 
49 |             let eth_dispatcher = ERC20ABIDispatcher {
50 |                 contract_address: contract_address_const::<
51 |                     0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
52 |                 >() // ETH Contract Address
53 |             };
54 | 
55 |             // Transfer the ETH to the caller
56 |             eth_dispatcher
57 |                 .transfer_from(
58 |                     caller_address,
59 |                     contract_address_const::<
60 |                         0x0237726d12d3c7581156e141c1b132f2db9acf788296a0e6e4e9d0ef27d092a2,
61 |                     >(),
62 |                     eth_needed,
63 |                 );
64 |         }
65 | 
66 |         //ANCHOR: price_feed_impl
67 |         fn get_asset_price(self: @ContractState, asset_id: felt252) -> u128 {
68 |             // Retrieve the oracle dispatcher
69 |             let oracle_dispatcher = IPragmaABIDispatcher {
70 |                 contract_address: self.pragma_contract.read(),
71 |             };
72 | 
73 |             // Call the Oracle contract, for a spot entry
74 |             let output: PragmaPricesResponse = oracle_dispatcher
75 |                 .get_data_median(DataType::SpotEntry(asset_id));
76 | 
77 |             return output.price;
78 |         }
79 |         //ANCHOR_END: price_feed_impl
80 |     }
81 | }
82 | //ANCHOR_END: here
83 | 
84 | 
85 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_01_embeddable/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_01_embeddable/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "no_listing_01_embeddable"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | [[target.starknet-contract]]
12 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_01_embeddable/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | trait SimpleTrait<TContractState> {
 3 |     fn ret_4(self: @TContractState) -> u8;
 4 | }
 5 | 
 6 | #[starknet::embeddable]
 7 | impl SimpleImpl<TContractState> of SimpleTrait<TContractState> {
 8 |     fn ret_4(self: @TContractState) -> u8 {
 9 |         4
10 |     }
11 | }
12 | 
13 | #[starknet::contract]
14 | mod simple_contract {
15 |     #[storage]
16 |     struct Storage {}
17 | 
18 |     #[abi(embed_v0)]
19 |     impl MySimpleImpl = super::SimpleImpl<ContractState>;
20 | }
21 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_02_embeddable_as_output/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_02_embeddable_as_output/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "embeddable"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_02_embeddable_as_output/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //TAG: does_not_compile
 2 | #[starknet::embeddable]
 3 | impl Ownable<
 4 |     TContractState, +HasComponent<TContractState>, impl TContractStateDrop: Drop<TContractState>,
 5 | > of super::IOwnable<TContractState> {
 6 |     fn owner(self: @TContractState) -> ContractAddress {
 7 |         let component = HasComponent::get_component(self);
 8 |         OwnableImpl::owner(component)
 9 |     }
10 | 
11 |     fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress) {
12 |         let mut component = HasComponent::get_component_mut(ref self);
13 |         OwnableImpl::transfer_ownership(ref component, new_owner)
14 |     }
15 | 
16 |     fn renounce_ownership(ref self: TContractState) {
17 |         let mut component = HasComponent::get_component_mut(ref self);
18 |         OwnableImpl::renounce_ownership(ref component)
19 |     }
20 | }
21 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_03_L1_L2_messaging/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_03_L1_L2_messaging/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_04_l1_l2_messaging"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch16-building-advanced-starknet-smart-contracts/no_listing_03_L1_L2_messaging/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | //! A simple contract that sends and receives messages from/to
 2 | //! the L1 (Ethereum).
 3 | //!
 4 | //! The reception of the messages is done using the `l1_handler` functions.
 5 | //! The messages are sent by using the `send_message_to_l1_syscall` syscall.
 6 | 
 7 | /// A custom struct, which is already
 8 | /// serializable as `felt252` is serializable.
 9 | #[derive(Drop, Serde)]
10 | struct MyData {
11 |     a: felt252,
12 |     b: felt252,
13 | }
14 | 
15 | #[starknet::interface]
16 | trait IContractL1<T> {
17 |     /// Sends a message to L1 contract with a single felt252 value.
18 |     ///
19 |     /// # Arguments
20 |     ///
21 |     /// * `to_address` - Contract address on L1.
22 |     /// * `my_felt` - Felt value to be sent in the payload.
23 |     fn send_message_felt(ref self: T, to_address: starknet::EthAddress, my_felt: felt252);
24 | 
25 |     /// Sends a message to L1 contract with a serialized struct.
26 |     /// To send a struct in a payload of a message, you only have to ensure that
27 |     /// your structure is serializable implementing the `Serde` trait. Which
28 |     /// can be derived automatically if your struct only contains serializable members.
29 |     ///
30 |     /// # Arguments
31 |     ///
32 |     /// * `to_address` - Contract address on L1.
33 |     /// * `data` - Data to be sent in the payload.
34 |     fn send_message_struct(ref self: T, to_address: starknet::EthAddress, data: MyData);
35 | }
36 | 
37 | #[starknet::contract]
38 | mod contract_msg {
39 |     use super::{IContractL1, MyData};
40 |     use core::starknet::{EthAddress, SyscallResultTrait, syscalls};
41 |     use core::num::traits::Zero;
42 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
43 | 
44 |     #[storage]
45 |     struct Storage {
46 |         allowed_message_sender: felt252,
47 |     }
48 | 
49 |     //ANCHOR: felt_msg_handler
50 |     #[l1_handler]
51 |     fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {
52 |         assert(from_address == self.allowed_message_sender.read(), 'Invalid message sender');
53 | 
54 |         // You can now use the data, automatically deserialized from the message payload.
55 |         assert(my_felt == 123, 'Invalid value');
56 |     }
57 |     //ANCHOR_END: felt_msg_handler
58 | 
59 |     #[l1_handler]
60 |     fn msg_handler_struct(ref self: ContractState, from_address: felt252, data: MyData) {
61 |         // assert(from_address == ...);
62 | 
63 |         assert(!data.a.is_zero(), 'data.a is invalid');
64 |         assert(!data.b.is_zero(), 'data.b is invalid');
65 |     }
66 | 
67 |     #[abi(embed_v0)]
68 |     impl ContractL1Impl of IContractL1<ContractState> {
69 |         //ANCHOR: felt_msg_send
70 |         fn send_message_felt(ref self: ContractState, to_address: EthAddress, my_felt: felt252) {
71 |             // Note here, we "serialize" my_felt, as the payload must be
72 |             // a `Span<felt252>`.
73 |             syscalls::send_message_to_l1_syscall(to_address.into(), array![my_felt].span())
74 |                 .unwrap();
75 |         }
76 |         //ANCHOR_END: felt_msg_send
77 | 
78 |         fn send_message_struct(ref self: ContractState, to_address: EthAddress, data: MyData) {
79 |             // Explicit serialization of our structure `MyData`.
80 |             let mut buf: Array<felt252> = array![];
81 |             data.serialize(ref buf);
82 |             syscalls::send_message_to_l1_syscall(to_address.into(), buf.span()).unwrap();
83 |         }
84 |     }
85 | }
86 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_02_pizza_factory_snfoundry"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | starknet = ">=2.9.1"
10 | 
11 | 
12 | [dev-dependencies]
13 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
14 | assert_macros = "2.9.1"
15 | 
16 | 
17 | [[target.starknet-contract]]
18 | 
19 | [scripts]
20 | test = "snforge test"
21 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/output.txt:
--------------------------------------------------------------------------------
 1 | $ scarb test 
 2 |      Running test listing_02_pizza_factory_snfoundry (snforge test)
 3 |    Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
 4 |     Finished `release` profile [optimized] target(s) in 0.99s
 5 |    Compiling test(listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/Scarb.toml)
 6 |     Finished `dev` profile target(s) in 7 seconds
 7 | 
 8 | 
 9 | Collected 6 test(s) from listing_02_pizza_factory_snfoundry package
10 | Running 6 test(s) from src/
11 | [PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_set_as_new_owner_direct (gas: ~130)
12 | [PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_panic_when_not_owner (gas: ~298)
13 | [PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_constructor (gas: ~297)
14 | [PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_panic_when_not_owner (gas: ~298)
15 | [PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_increment_pizza_counter (gas: ~368)
16 | [PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_change_owner (gas: ~303)
17 | Tests: 6 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out
18 | 
19 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/lib.cairo:
--------------------------------------------------------------------------------
1 | mod pizza;
2 | 
3 | #[cfg(test)]
4 | mod tests {
5 |     mod foundry_test;
6 | }
7 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/pizza.cairo:
--------------------------------------------------------------------------------
 1 | use core::starknet::ContractAddress;
 2 | 
 3 | #[starknet::interface]
 4 | pub trait IPizzaFactory<TContractState> {
 5 |     fn increase_pepperoni(ref self: TContractState, amount: u32);
 6 |     fn increase_pineapple(ref self: TContractState, amount: u32);
 7 |     fn get_owner(self: @TContractState) -> ContractAddress;
 8 |     fn change_owner(ref self: TContractState, new_owner: ContractAddress);
 9 |     fn make_pizza(ref self: TContractState);
10 |     fn count_pizza(self: @TContractState) -> u32;
11 | }
12 | 
13 | #[starknet::contract]
14 | pub mod PizzaFactory {
15 |     use super::IPizzaFactory;
16 |     use core::starknet::{ContractAddress, get_caller_address};
17 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
18 | 
19 |     #[storage]
20 |     pub struct Storage {
21 |         pepperoni: u32,
22 |         pineapple: u32,
23 |         pub owner: ContractAddress,
24 |         pizzas: u32,
25 |     }
26 | 
27 |     #[constructor]
28 |     fn constructor(ref self: ContractState, owner: ContractAddress) {
29 |         self.pepperoni.write(10);
30 |         self.pineapple.write(10);
31 |         self.owner.write(owner);
32 |     }
33 | 
34 |     #[event]
35 |     #[derive(Drop, starknet::Event)]
36 |     pub enum Event {
37 |         PizzaEmission: PizzaEmission,
38 |     }
39 | 
40 |     #[derive(Drop, starknet::Event)]
41 |     pub struct PizzaEmission {
42 |         pub counter: u32,
43 |     }
44 | 
45 |     #[abi(embed_v0)]
46 |     impl PizzaFactoryimpl of super::IPizzaFactory<ContractState> {
47 |         fn increase_pepperoni(ref self: ContractState, amount: u32) {
48 |             assert!(amount != 0, "Amount cannot be 0");
49 |             self.pepperoni.write(self.pepperoni.read() + amount);
50 |         }
51 | 
52 |         fn increase_pineapple(ref self: ContractState, amount: u32) {
53 |             assert!(amount != 0, "Amount cannot be 0");
54 |             self.pineapple.write(self.pineapple.read() + amount);
55 |         }
56 | 
57 |         fn make_pizza(ref self: ContractState) {
58 |             assert!(self.pepperoni.read() > 0, "Not enough pepperoni");
59 |             assert!(self.pineapple.read() > 0, "Not enough pineapple");
60 | 
61 |             let caller: ContractAddress = get_caller_address();
62 |             let owner: ContractAddress = self.get_owner();
63 | 
64 |             assert!(caller == owner, "Only the owner can make pizza");
65 | 
66 |             self.pepperoni.write(self.pepperoni.read() - 1);
67 |             self.pineapple.write(self.pineapple.read() - 1);
68 |             self.pizzas.write(self.pizzas.read() + 1);
69 | 
70 |             self.emit(PizzaEmission { counter: self.pizzas.read() });
71 |         }
72 | 
73 |         fn get_owner(self: @ContractState) -> ContractAddress {
74 |             self.owner.read()
75 |         }
76 | 
77 |         fn change_owner(ref self: ContractState, new_owner: ContractAddress) {
78 |             self.set_owner(new_owner);
79 |         }
80 | 
81 |         fn count_pizza(self: @ContractState) -> u32 {
82 |             self.pizzas.read()
83 |         }
84 |     }
85 | 
86 |     #[generate_trait]
87 |     pub impl InternalImpl of InternalTrait {
88 |         fn set_owner(ref self: ContractState, new_owner: ContractAddress) {
89 |             let caller: ContractAddress = get_caller_address();
90 |             assert!(caller == self.get_owner(), "Only the owner can set ownership");
91 | 
92 |             self.owner.write(new_owner);
93 |         }
94 |     }
95 | }
96 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:
--------------------------------------------------------------------------------
  1 | use crate::pizza::{
  2 |     IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
  3 |     PizzaFactory::{Event as PizzaEvents, PizzaEmission},
  4 | };
  5 | //ANCHOR: import_internal
  6 | use crate::pizza::PizzaFactory::{InternalTrait};
  7 | //ANCHOR_END: import_internal
  8 | 
  9 | use core::starknet::{ContractAddress, contract_address_const};
 10 | use core::starknet::storage::StoragePointerReadAccess;
 11 | 
 12 | use snforge_std::{
 13 |     declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
 14 |     stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
 15 | };
 16 | 
 17 | fn owner() -> ContractAddress {
 18 |     contract_address_const::<'owner'>()
 19 | }
 20 | 
 21 | //ANCHOR: deployment
 22 | fn deploy_pizza_factory() -> (IPizzaFactoryDispatcher, ContractAddress) {
 23 |     let contract = declare("PizzaFactory").unwrap().contract_class();
 24 | 
 25 |     let owner: ContractAddress = contract_address_const::<'owner'>();
 26 |     let constructor_calldata = array![owner.into()];
 27 | 
 28 |     let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
 29 | 
 30 |     let dispatcher = IPizzaFactoryDispatcher { contract_address };
 31 | 
 32 |     (dispatcher, contract_address)
 33 | }
 34 | //ANCHOR_END: deployment
 35 | 
 36 | //ANCHOR: test_constructor
 37 | #[test]
 38 | fn test_constructor() {
 39 |     let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
 40 | 
 41 |     let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
 42 |     let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
 43 |     assert_eq!(pepperoni_count, array![10]);
 44 |     assert_eq!(pineapple_count, array![10]);
 45 |     assert_eq!(pizza_factory.get_owner(), owner());
 46 | }
 47 | //ANCHOR_END: test_constructor
 48 | 
 49 | //ANCHOR: test_owner
 50 | #[test]
 51 | fn test_change_owner_should_change_owner() {
 52 |     let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
 53 | 
 54 |     let new_owner: ContractAddress = contract_address_const::<'new_owner'>();
 55 |     assert_eq!(pizza_factory.get_owner(), owner());
 56 | 
 57 |     start_cheat_caller_address(pizza_factory_address, owner());
 58 | 
 59 |     pizza_factory.change_owner(new_owner);
 60 | 
 61 |     assert_eq!(pizza_factory.get_owner(), new_owner);
 62 | }
 63 | 
 64 | #[test]
 65 | #[should_panic(expected: "Only the owner can set ownership")]
 66 | fn test_change_owner_should_panic_when_not_owner() {
 67 |     let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
 68 |     let not_owner = contract_address_const::<'not_owner'>();
 69 |     start_cheat_caller_address(pizza_factory_address, not_owner);
 70 |     pizza_factory.change_owner(not_owner);
 71 |     stop_cheat_caller_address(pizza_factory_address);
 72 | }
 73 | //ANCHOR_END: test_owner
 74 | 
 75 | //ANCHOR: test_make_pizza
 76 | #[test]
 77 | #[should_panic(expected: "Only the owner can make pizza")]
 78 | fn test_make_pizza_should_panic_when_not_owner() {
 79 |     let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
 80 |     let not_owner = contract_address_const::<'not_owner'>();
 81 |     start_cheat_caller_address(pizza_factory_address, not_owner);
 82 | 
 83 |     pizza_factory.make_pizza();
 84 | }
 85 | 
 86 | #[test]
 87 | fn test_make_pizza_should_increment_pizza_counter() {
 88 |     // Setup
 89 |     let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
 90 |     start_cheat_caller_address(pizza_factory_address, owner());
 91 |     let mut spy = spy_events();
 92 | 
 93 |     // When
 94 |     pizza_factory.make_pizza();
 95 | 
 96 |     // Then
 97 |     let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
 98 |     assert_eq!(pizza_factory.count_pizza(), 1);
 99 |     spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
100 | }
101 | //ANCHOR_END: test_make_pizza
102 | 
103 | //ANCHOR: test_internals
104 | #[test]
105 | fn test_set_as_new_owner_direct() {
106 |     let mut state = PizzaFactory::contract_state_for_testing();
107 |     let owner: ContractAddress = contract_address_const::<'owner'>();
108 |     state.set_owner(owner);
109 |     assert_eq!(state.owner.read(), owner);
110 | }
111 | //ANCHOR_END: test_internals
112 | 
113 | 
114 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/no_listing_01_assert_balance/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/no_listing_01_assert_balance/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_10_assert_balance"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/no_listing_01_assert_balance/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::interface]
 2 | trait IContract<TContractState> {
 3 |     fn withdraw(ref self: TContractState, amount: u256);
 4 | }
 5 | 
 6 | #[starknet::contract]
 7 | mod contract {
 8 |     use super::IContract;
 9 |     use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
10 | 
11 |     #[storage]
12 |     struct Storage {
13 |         balance: u256,
14 |     }
15 | 
16 |     //ANCHOR: withdraw
17 |     impl Contract of IContract<ContractState> {
18 |         fn withdraw(ref self: ContractState, amount: u256) {
19 |             let current_balance = self.balance.read();
20 | 
21 |             assert!(self.balance.read() >= amount, "Insufficient funds");
22 | 
23 |             self.balance.write(current_balance - amount);
24 |         }
25 |         //ANCHOR_END: withdraw
26 | 
27 |     }
28 | }
29 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/no_listing_02_simple_access_control/.gitignore:
--------------------------------------------------------------------------------
1 | target
2 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/no_listing_02_simple_access_control/Scarb.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "listing_99_11_simple_access_control"
 3 | version = "0.1.0"
 4 | edition = "2024_07"
 5 | 
 6 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest
 7 | 
 8 | [dependencies]
 9 | # foo = { path = "vendor/foo" }
10 | starknet = ">=2.9.1"
11 | 


--------------------------------------------------------------------------------
/listings/ch17-starknet-smart-contracts-security/no_listing_02_simple_access_control/src/lib.cairo:
--------------------------------------------------------------------------------
 1 | #[starknet::contract]
 2 | mod access_control_contract {
 3 |     use core::starknet::storage::{
 4 |         StoragePointerReadAccess, StoragePointerWriteAccess, StorageMapReadAccess,
 5 |         StorageMapWriteAccess, Map,
 6 |     };
 7 |     use core::starknet::ContractAddress;
 8 |     use core::starknet::get_caller_address;
 9 | 
10 |     trait IContract<TContractState> {
11 |         fn is_owner(self: @TContractState) -> bool;
12 |         fn is_role_a(self: @TContractState) -> bool;
13 |         fn only_owner(self: @TContractState);
14 |         fn only_role_a(self: @TContractState);
15 |         fn only_allowed(self: @TContractState);
16 |         fn set_role_a(ref self: TContractState, _target: ContractAddress, _active: bool);
17 |         fn role_a_action(ref self: ContractState);
18 |         fn allowed_action(ref self: ContractState);
19 |     }
20 | 
21 |     #[storage]
22 |     struct Storage {
23 |         // Role 'owner': only one address
24 |         owner: ContractAddress,
25 |         // Role 'role_a': a set of addresses
26 |         role_a: Map::<ContractAddress, bool>,
27 |     }
28 | 
29 |     #[constructor]
30 |     fn constructor(ref self: ContractState) {
31 |         self.owner.write(get_caller_address());
32 |     }
33 | 
34 |     // Guard functions to check roles
35 | 
36 |     impl Contract of IContract<ContractState> {
37 |         #[inline(always)]
38 |         fn is_owner(self: @ContractState) -> bool {
39 |             self.owner.read() == get_caller_address()
40 |         }
41 | 
42 |         #[inline(always)]
43 |         fn is_role_a(self: @ContractState) -> bool {
44 |             self.role_a.read(get_caller_address())
45 |         }
46 | 
47 |         #[inline(always)]
48 |         fn only_owner(self: @ContractState) {
49 |             assert!(Self::is_owner(self), "Not owner");
50 |         }
51 | 
52 |         #[inline(always)]
53 |         fn only_role_a(self: @ContractState) {
54 |             assert!(Self::is_role_a(self), "Not role A");
55 |         }
56 | 
57 |         // You can easily combine guards to perform complex checks
58 |         fn only_allowed(self: @ContractState) {
59 |             assert!(Self::is_owner(self) || Contract::is_role_a(self), "Not allowed");
60 |         }
61 | 
62 |         // Functions to manage roles
63 | 
64 |         fn set_role_a(ref self: ContractState, _target: ContractAddress, _active: bool) {
65 |             Self::only_owner(@self);
66 |             self.role_a.write(_target, _active);
67 |         }
68 | 
69 |         // You can now focus on the business logic of your contract
70 |         // and reduce the complexity of your code by using guard functions
71 | 
72 |         fn role_a_action(ref self: ContractState) {
73 |             Self::only_role_a(@self);
74 |             // ...
75 |         }
76 | 
77 |         fn allowed_action(ref self: ContractState) {
78 |             Self::only_allowed(@self);
79 |             // ...
80 |         }
81 |     }
82 | }
83 | 


/src/SUMMARY.md:
--------------------------------------------------------------------------------
  1 | # The Cairo Book
  2 | 
  3 | [The Cairo Book](title-page.md)
  4 | [Foreword](ch00-01-foreword.md)
  5 | [Introduction](ch00-00-introduction.md)
  6 | 
  7 | # The Cairo Programming Language
  8 | 
  9 | ## Getting Started
 10 | 
 11 | - [Getting Started](ch01-00-getting-started.md)
 12 | 
 13 |   - [Installation](ch01-01-installation.md)
 14 |   - [Hello, World!](ch01-02-hello-world.md)
 15 | 
 16 | ## Common Programming Concepts
 17 | 
 18 | - [Common Programming Concepts](ch02-00-common-programming-concepts.md)
 19 |   - [Variables and Mutability](ch02-01-variables-and-mutability.md)
 20 |   - [Data Types](ch02-02-data-types.md)
 21 |   - [Functions](ch02-03-functions.md)
 22 |   - [Comments](ch02-04-comments.md)
 23 |   - [Control Flow](ch02-05-control-flow.md)
 24 | 
 25 | ## Common Collections
 26 | 
 27 | - [Common Collections](ch03-00-common-collections.md)
 28 |   - [Arrays](ch03-01-arrays.md)
 29 |   - [Dictionaries](ch03-02-dictionaries.md)
 30 | 
 31 | ## Understanding Ownership
 32 | 
 33 | - [Understanding Ownership](ch04-00-understanding-ownership.md)
 34 |   - [What is Ownership?](ch04-01-what-is-ownership.md)
 35 |   - [References and Snapshots](ch04-02-references-and-snapshots.md)
 36 | 
 37 | ## Using Structs to Structure Related Data
 38 | 
 39 | - [Using Structs to Structure Related Data](ch05-00-using-structs-to-structure-related-data.md)
 40 |   - [Defining and Instantiating Structs](ch05-01-defining-and-instantiating-structs.md)
 41 |   - [An Example Program Using Structs](ch05-02-an-example-program-using-structs.md)
 42 |   - [Method Syntax](ch05-03-method-syntax.md)
 43 | 
 44 | ## Enums and Pattern Matching
 45 | 
 46 | - [Enums and Pattern Matching](ch06-00-enums-and-pattern-matching.md)
 47 |   - [Enums](ch06-01-enums.md)
 48 |   - [The Match Control Flow Construct](ch06-02-the-match-control-flow-construct.md)
 49 |   - [Concise Control Flow with `if let` and `while let`](ch06-03-concise-control-flow-with-if-let-and-while-let.md)
 50 | 
 51 | ## Managing Cairo Projects with Packages, Crates and Modules
 52 | 
 53 | - [Managing Cairo Projects with Packages, Crates and Modules](ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md)
 54 | 
 55 |   - [Packages and Crates](ch07-01-packages-and-crates.md)
 56 |   - [Defining Modules to Control Scope](ch07-02-defining-modules-to-control-scope.md)
 57 |   - [Paths for Referring to an Item in the Module Tree](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md)
 58 |   - [Bringing Paths into Scope with the `use` Keyword](ch07-04-bringing-paths-into-scope-with-the-use-keyword.md)
 59 |   - [Separating Modules into Different Files](ch07-05-separating-modules-into-different-files.md)
 60 | 
 61 | ## Generic Data Types
 62 | 
 63 | - [Generic Types and Traits](ch08-00-generic-types-and-traits.md)
 64 | 
 65 |   - [Generic Data Types](ch08-01-generic-data-types.md)
 66 |   - [Traits in Cairo](ch08-02-traits-in-cairo.md)
 67 | 
 68 | ## Error Handling
 69 | 
 70 | - [Error Handling](ch09-00-error-handling.md)
 71 | 
 72 |   - [Unrecoverable Errors with panic](ch09-01-unrecoverable-errors-with-panic.md)
 73 |   - [Recoverable Errors with Result](ch09-02-recoverable-errors.md)
 74 | 
 75 | ## Testing Cairo Programs
 76 | 
 77 | - [Testing Cairo Programs](ch10-00-testing-cairo-programs.md)
 78 | 
 79 |   - [How To Write Tests](ch10-01-how-to-write-tests.md)
 80 |   - [Test Organization](ch10-02-test-organization.md)
 81 | 
 82 | ## Advanced Cairo Features
 83 | 
 84 | - [Advanced Cairo Features](ch11-00-advanced-features.md)
 85 | 
 86 |   - [Custom Data Structures](ch11-01-custom-data-structures.md)
 87 |   - [Smart Pointers](ch11-02-smart-pointers.md)
 88 |   - [Deref Coercion](ch11-09-deref-coercion.md)
 89 |   - [Associated Items](ch11-10-associated-items.md)
 90 |   - [Operator Overloading](ch11-03-operator-overloading.md)
 91 |   - [Working with Hashes](ch11-04-hash.md)
 92 |   - [Macros](ch11-05-macros.md)
 93 |   - [Procedural Macros](ch11-10-procedural-macros.md)
 94 |   - [Inlining in Cairo](ch11-06-inlining-in-cairo.md)
 95 |   - [Printing](ch11-08-printing.md)
 96 |   - [Arithmetic Circuits](ch11-10-arithmetic-circuits.md)
 97 | 
 98 | - [Appendix (Cairo)](appendix-00.md)
 99 | 
100 |   - [A - Keywords](appendix-01-keywords.md)
101 |   - [B - Operators and Symbols](appendix-02-operators-and-symbols.md)
102 |   - [C - Derivable Traits](appendix-03-derivable-traits.md)
103 |   - [D - The Cairo Prelude](appendix-04-cairo-prelude.md)
104 |   - [E - Common Error Messages](appendix-05-common-error-messages.md)
105 |   - [F - Useful Development Tools](appendix-06-useful-development-tools.md)
106 | 
107 | ---
108 | 
109 | # Smart Contracts in Cairo
110 | 
111 | ## Introduction to Starknet Smart Contracts
112 | 
113 | - [Introduction to Starknet Smart Contracts](./ch13-00-introduction-to-starknet-smart-contracts.md)
114 | 
115 |   - [General Introduction to Smart Contracts](./ch13-01-general-introduction-to-smart-contracts.md)
116 |   - [Anatomy of a Simple Contract](./ch13-02-anatomy-of-a-simple-contract.md)
117 | 
118 | ## Building Starknet Smart Contracts
119 | 
120 | - [Building Starknet Smart Contracts](./ch14-00-building-starknet-smart-contracts.md)
121 | 
122 |   - [Contract Storage](./ch14-01-00-contract-storage.md)
123 |     - [Storage Mappings](./ch14-01-01-storage-mappings.md)
124 |     - [Storage Vecs](./ch14-01-02-storage-vecs.md)
125 |   - [Contract Functions](./ch14-02-contract-functions.md)
126 |   - [Contract Events](./ch14-03-contract-events.md)
127 | 
128 | ## Starknet Cross-Contract Interactions
129 | 
130 | - [Starknet Contract Interactions](./ch15-00-starknet-contract-interactions.md)
131 | 
132 |   - [Contract Class ABI](./ch15-01-contract-class-abi.md)
133 |   - [Interacting with Another Contract](./ch15-02-interacting-with-another-contract.md)
134 |   - [Executing Code from Another Class](./ch15-03-executing-code-from-another-class.md)
135 | 
136 | ## Building Advanced Starknet Smart Contracts
137 | 
138 | - [Building Advanced Starknet Smart Contracts](./ch16-00-building-advanced-starknet-smart-contracts.md)
139 | 
140 |   - [Optimizing Storage Costs](./ch16-01-optimizing-storage-costs.md)
141 |   - [Composability and Components](./ch16-02-00-composability-and-components.md)
142 |     - [Under the Hood](./ch16-02-01-under-the-hood.md)
143 |     - [Component Dependencies](./ch16-02-02-component-dependencies.md)
144 |     - [Testing Components](./ch16-02-03-testing-components.md)
145 |   - [Upgradeability](./ch16-03-upgradeability.md)
146 |   - [L1 <> L2 Messaging](./ch16-04-L1-L2-messaging.md)
147 |   - [Oracle Interactions](./ch16-05-oracle-interactions.md)
148 |     - [Price Feeds](./ch16-05-01-price-feeds.md)
149 |     - [Randomness](./ch16-05-02-randomness.md)
150 |   - [Other Examples](./ch16-06-00-other-examples.md)
151 |     - [Deploying and Interacting with a Voting Contract](./ch16-06-01-deploying-and-interacting-with-a-voting-contract.md)
152 | 
153 | ## Starknet Smart Contracts Security
154 | 
155 | - [Starknet Smart Contracts Security](./ch17-00-starknet-smart-contracts-security.md)
156 | 
157 |   - [General Recommendations](./ch17-01-general-recommendations.md)
158 |   - [Testing Smart Contracts](./ch17-02-testing-smart-contracts.md)
159 |   - [Static Analysis Tools](./ch17-03-static-analysis-tools.md)
160 | 
161 | ## Appendix
162 | 
163 | - [Appendix (Starknet)](appendix-000.md)
164 |   - [A - System Calls](appendix-08-system-calls.md)
165 | 
166 | ---
167 | 
168 | # Cairo VM
169 | 
170 | - [Introduction](ch200-introduction.md)
171 | 
172 | - [Architecture](ch201-architecture.md)
173 | 
174 | ## Memory
175 | 
176 | - [Memory]()
177 | 
178 |   - [Non-Deterministic Read-only Memory]()
179 |   - [Segments]()
180 |   - [Segment Value]()
181 |   - [Relocation]()
182 |   - [Layout]()
183 | 
184 | ## Execution Model
185 | 
186 | - [Execution Model]()
187 | 
188 |   - [Registers]()
189 |   - [Instructions]()
190 |   - [Cairo Assembly (CASM)]()
191 |   - [State transition]()
192 | 
193 | ## Builtins
194 | 
195 | - [Builtins](ch204-00-builtins.md)
196 |   - [How Builtins Work](ch204-01-how-builtins-work.md)
197 |   - [Builtins List](ch204-02-builtins-list.md)
198 |     - [Output]()
199 |     - [Pedersen](ch204-02-01-pedersen.md)
200 |     - [Range Check]()
201 |     - [ECDSA]()
202 |     - [Bitwise]()
203 |     - [EC OP]()
204 |     - [Keccak]()
205 |     - [Poseidon]()
206 |     - [Range Check96]()
207 |     - [AddMod]()
208 |     - [MulMod]()
209 |     - [Segment Arena]()
210 |     - [Gas]()
211 |     - [System]()
212 | 
213 | ## Hints
214 | 
215 | - [Hints]()
216 |   - [Structure]()
217 |   - [Hint runner]()
218 |   - [List of hints]()
219 | 
220 | ## Runner
221 | 
222 | - [Runner]()
223 | 
224 |   - [Program]()
225 |     - [Program Artifacts]()
226 |     - [Program Parsing]()
227 |   - [Runner Mode]()
228 |     - [Execution Mode]()
229 |     - [Proof Mode]()
230 |   - [Output]()
231 |     - [Cairo PIE]()
232 |     - [Memory File]()
233 |     - [Trace file]()
234 |     - [AIR public input]()
235 |     - [AIR private input]()
236 | 
237 | - [Tracer]()
238 | 
239 | - [Implementations]()
240 | 
241 | - [Resources]()
242 | 


--------------------------------------------------------------------------------
/src/appendix-00.md:
--------------------------------------------------------------------------------
1 | # Appendix
2 | 
3 | The following sections contain reference material you may find useful in your
4 | Cairo journey.
5 | 


--------------------------------------------------------------------------------
/src/appendix-000.md:
--------------------------------------------------------------------------------
1 | # Appendix
2 | 
3 | The following sections contain reference material you may find useful in your
4 | Starknet journey.


--------------------------------------------------------------------------------
/src/appendix-01-keywords.md:
--------------------------------------------------------------------------------
 1 | # Appendix A - Keywords
 2 | 
 3 | The following list contains keywords that are reserved for current or future use by the Cairo language.
 4 | 
 5 | There are three keyword categories:
 6 | 
 7 | - strict
 8 | - loose
 9 | - reserved
10 | 
11 | There is a fourth category, which are functions from the core library. While their names are not reserved,
12 | they are not recommended to be used as names of any items to follow good practices.
13 | 
14 | ---
15 | 
16 | ## Strict keywords
17 | 
18 | These keywords can only be used in their correct contexts.
19 | They cannot be used as names of any items.
20 | 
21 | - `as` - Rename import
22 | - `break` - Exit a loop immediately
23 | - `const` - Define constant items
24 | - `continue` - Continue to the next loop iteration
25 | - `else` - Fallback for `if` and `if let` control flow constructs
26 | - `enum` - Define an enumeration
27 | - `extern` - Function defined at the compiler level that can be compiled to CASM
28 | - `false` - Boolean false literal
29 | - `fn` - Define a function
30 | - `if` - Branch based on the result of a conditional expression
31 | - `impl` - Implement inherent or trait functionality
32 | - `implicits` - Special kind of function parameters that are required to perform certain actions
33 | - `let` - Bind a variable
34 | - `loop` - Loop unconditionally
35 | - `match` - Match a value to patterns
36 | - `mod` - Define a module
37 | - `mut` - Denote variable mutability
38 | - `nopanic` - Functions marked with this notation mean that the function will never panic.
39 | - `of` - Implement a trait
40 | - `pub` - Denote public visibility in items, such as struct and struct fields, enums, consts, traits and impl blocks, or modules
41 | - `ref` - Parameter passed implicitly returned at the end of a function
42 | - `return` - Return from function
43 | - `struct` - Define a structure
44 | - `trait` - Define a trait
45 | - `true` - Boolean true literal
46 | - `type` - Define a type alias
47 | - `use` - Bring symbols into scope
48 | - `while` - loop conditionally based on the result of an expression
49 | 
50 | ---
51 | 
52 | ## Loose Keywords
53 | 
54 | These keywords are associated with a specific behaviour, but can also be used to define items.
55 | 
56 | - `self` - Method subject
57 | - `super` - Parent module of the current module
58 | 
59 | ---
60 | 
61 | ## Reserved Keywords
62 | 
63 | These keywords aren't used yet, but they are reserved for future use.
64 | For now, it is possible to use them to define items, although it is highly recommended not to do so.
65 | The reasoning behind this recommendation is to make current programs forward compatible with future versions of
66 | Cairo by forbidding them to use these keywords.
67 | 
68 | - `Self`
69 | - `do`
70 | - `dyn`
71 | - `for`
72 | - `hint`
73 | - `in`
74 | - `macro`
75 | - `move`
76 | - `static_assert`
77 | - `static`
78 | - `try`
79 | - `typeof`
80 | - `unsafe`
81 | - `where`
82 | - `with`
83 | - `yield`
84 | 
85 | ---
86 | 
87 | ## Built-in Functions
88 | 
89 | The Cairo programming language provides several specific functions that serve a special purpose. We will not cover all of them in this book, but using the names of these functions as names of other items is not recommended.
90 | 
91 | - `assert` - This function checks a boolean expression, and if it evaluates to false, it triggers the panic function.
92 | - `panic` - This function acknowledges the occurrence of an error and terminates the program.
93 | 


--------------------------------------------------------------------------------
/src/appendix-02-operators-and-symbols.md:
--------------------------------------------------------------------------------
  1 | # Appendix B - Operators and Symbols
  2 | 
  3 | This appendix contains a glossary of Cairo's syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, macros, attributes, comments, tuples, and brackets.
  4 | 
  5 | ## Operators
  6 | 
  7 | Table B-1 contains the operators in Cairo, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed.
  8 | 
  9 | | Operator                  | Example                                                 | Explanation                              | Overloadable? |
 10 | | ------------------------- | ------------------------------------------------------- | ---------------------------------------- | ------------- |
 11 | | `!`                       | `!expr`                                                 | Logical complement                       | `Not`         |
 12 | | `~`                       | `~expr`                                                 | Bitwise NOT                              | `BitNot`      |
 13 | | `!=`                      | `expr != expr`                                          | Non-equality comparison                  | `PartialEq`   |
 14 | | `%`                       | `expr % expr`                                           | Arithmetic remainder                     | `Rem`         |
 15 | | `%=`                      | `var %= expr`                                           | Arithmetic remainder and assignment      | `RemEq`       |
 16 | | `&`                       | `expr & expr`                                           | Bitwise AND                              | `BitAnd`      |
 17 | | `&&`                      | `expr && expr`                                          | Short-circuiting logical AND             |               |
 18 | | `*`                       | `expr * expr`                                           | Arithmetic multiplication                | `Mul`         |
 19 | | `*=`                      | `var *= expr`                                           | Arithmetic multiplication and assignment | `MulEq`       |
 20 | | `@`                       | `@var`                                                  | Snapshot                                 |               |
 21 | | `*`                       | `*var`                                                  | Desnap                                   |               |
 22 | | `+`                       | `expr + expr`                                           | Arithmetic addition                      | `Add`         |
 23 | | `+=`                      | `var += expr`                                           | Arithmetic addition and assignment       | `AddEq`       |
 24 | | `,`                       | `expr, expr`                                            | Argument and element separator           |               |
 25 | | `-`                       | `-expr`                                                 | Arithmetic negation                      | `Neg`         |
 26 | | `-`                       | `expr - expr`                                           | Arithmetic subtraction                   | `Sub`         |
 27 | | `-=`                      | `var -= expr`                                           | Arithmetic subtraction and assignment    | `SubEq`       |
 28 | | `->`                      | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type         |               |
 29 | | `.`                       | `expr.ident`                                            | Member access                            |               |
 30 | | `/`                       | `expr / expr`                                           | Arithmetic division                      | `Div`         |
 31 | | `/=`                      | `var /= expr`                                           | Arithmetic division and assignment       | `DivEq`       |
 32 | | `:`                       | `pat: type`, `ident: type`                              | Constraints                              |               |
 33 | | `:`                       | `ident: expr`                                           | Struct field initializer                 |               |
 34 | | `;`                       | `expr;`                                                 | Statement and item terminator            |               |
 35 | | `<`                       | `expr < expr`                                           | Less than comparison                     | `PartialOrd`  |
 36 | | `<=`                      | `expr <= expr`                                          | Less than or equal to comparison         | `PartialOrd`  |
 37 | | `=`                       | `var = expr`                                            | Assignment                               |               |
 38 | | `==`                      | `expr == expr`                                          | Equality comparison                      | `PartialEq`   |
 39 | | `=>`                      | `pat => expr`                                           | Part of match arm syntax                 |               |
 40 | | `>`                       | `expr > expr`                                           | Greater than comparison                  | `PartialOrd`  |
 41 | | `>=`                      | `expr >= expr`                                          | Greater than or equal to comparison      | `PartialOrd`  |
 42 | | `^`                       | `expr ^ expr`                                           | Bitwise exclusive OR                     | `BitXor`      |
 43 | | <code>&vert;</code>       | <code>expr &vert; expr</code>                           | Bitwise OR                               | `BitOr`       |
 44 | | <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code>                     | Short-circuiting logical OR              |               |
 45 | | `?`                       | expr?                                                   | Error propagation                        |
 46 | 
 47 | <span class="caption">Table B-1: Operators</span>
 48 | 
 49 | ## Non Operator Symbols
 50 | 
 51 | The following list contains all symbols that are not used as operators; that is, they do not have the same behavior as a function or method call.
 52 | 
 53 | Table B-2 shows symbols that appear on their own and are valid in a variety of locations.
 54 | 
 55 | | Symbol                                  | Explanation                               |
 56 | | --------------------------------------- | ----------------------------------------- |
 57 | | `..._u8`, `..._usize`, `..._bool`, etc. | Numeric literal of specific type          |
 58 | | `"..."`                                 | String literal                            |
 59 | | `'...'`                                 | Short string, 31 ASCII characters maximum |
 60 | | `_`                                     | Ignored pattern binding                 |
 61 | 
 62 | <span class="caption">Table B-2: Stand-Alone Syntax</span>
 63 | 
 64 | Table B-3 shows symbols that are used within the context of a module hierarchy path to access an item.
 65 | 
 66 | | Symbol               | Explanation                                                      |
 67 | | -------------------- | ---------------------------------------------------------------- |
 68 | | `ident::ident`       | Namespace path                                                   |
 69 | | `super::path`        | Path relative to the parent of the current module                |
 70 | | `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
 71 | 
 72 | <span class="caption">Table B-3: Path-Related Syntax</span>
 73 | 
 74 | Table B-4 shows symbols that appear in the context of using generic type parameters.
 75 | 
 76 | | Symbol                         | Explanation                                                                                                  |
 77 | | ------------------------------ | ------------------------------------------------------------------------------------------------------------ |
 78 | | `path<...>`                    | Specifies parameters to generic type in a type (e.g., `Array<u8>`)                                           |
 79 | | `path::<...>`, `method::<...>` | Specifies parameters to a generic type, function, or method in an expression; often referred to as turbofish |
 80 | | `fn ident<...> ...`            | Define generic function                                                                                      |
 81 | | `struct ident<...> ...`        | Define generic structure                                                                                     |
 82 | | `enum ident<...> ...`          | Define generic enumeration                                                                                   |
 83 | | `impl<...> ...`                | Define generic implementation                                                                                |
 84 | 
 85 | <span class="caption">Table B-4: Generics</span>
 86 | 
 87 | Table B-5 shows symbols that appear in the context of specifying attributes on an item.
 88 | 
 89 | | Symbol                               | Explanation                                                                                                                                   |
 90 | | ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |
 91 | | `#[derive(...)]`                     | Automatically implements a trait for a type                                                                                                   |
 92 | | `#[inline]`                          | Hint to the compiler to allow inlining of annotated function                                                                                  |
 93 | | `#[inline(always)]`                  | Hint to the compiler to systematically inline annotated function                                                                              |
 94 | | `#[inline(never)]`                   | Hint to the compiler to never inline annotated function                                                                                       |
 95 | | `#[must_use]`                        | Hint to the compiler that the return value of a function or a specific returned type must be used                                             |
 96 | | `#[generate_trait]`                  | Automatically generates a trait for an impl                                                                                                   |
 97 | | `#[available_gas(...)]`              | Set the maximum amount of gas available to execute a function                                                                                 |
 98 | | `#[panic_with('...', wrapper_name)]` | Creates a wrapper for the annotated function which will panic if the function returns `None` or `Err`, with the given data as the panic error |
 99 | | `#[test]`                            | Describe a function as a test function                                                                                                        |
100 | | `#[cfg(...)]`                        | Configuration attribute, especially used to configure a `tests` module with `#[cfg(test)]`                                                    |
101 | | `#[should_panic]`                    | Specifies that a test function should necessarily panic                                                                                       |
102 | | `#[starknet::contract]`              | Defines a Starknet smart contract                                                                                                             |
103 | | `#[starknet::interface]`             | Defines a Starknet interface                                                                                                                  |
104 | | `#[starknet::component]`             | Defines a Starknet component                                                                                                                  |
105 | | `#[starknet::embeddable]`            | Defines an isolated embeddable implementation that can be injected in any smart contract                                                      |
106 | | `#[embeddable_as(...)]`              | Defines an embeddable implementation inside a component                                                                                       |
107 | | `#[storage]`                         | Defines the storage of a smart contract                                                                                                       |
108 | | `#[event]`                           | Defines an event in a smart contract                                                                                                          |
109 | | `#[constructor]`                     | Defines the constructor in a smart contract                                                                                                   |
110 | | `#[abi(embed_v0)]`                   | Defines an implementation of a trait, exposing the functions of the impl as entrypoints of a contract                                         |
111 | | `#[abi(per_item)]`                   | Allows individual definition of the entrypoint type of functions inside an impl                                                               |
112 | | `#[external(v0)]`                    | Defines an external function when `#[abi(per_item)]` is used                                                                                  |
113 | | `#[flat]`                            | Defines a enum variant of the `Event` enum that is not nested, ignoring the variant name in the serialization process, very useful for composability when using Starknet components      |
114 | | `#[key]`                             | Defines an indexed `Event` enum field, allowing for more efficient queries and filtering of events                    |
115 | 
116 | <span class="caption">Table B-5: Attributes</span>
117 | 
118 | Table B-6 shows symbols that appear in the context of calling or defining macros.
119 | 
120 | | Symbol                   | Explanation                                                                            |
121 | | ------------------------ | -------------------------------------------------------------------------------------- |
122 | | `print!`                 | Inline printing                                                                        |
123 | | `println!`               | Print on a new line                                                                    |
124 | | `consteval_int!`         | Declare a constant that is the result of a computation of integers                     |
125 | | `array!`                 | Instantiate and fill arrays                                                            |
126 | | `panic!`                 | Calls `panic` function and allows to provide a message error longer than 31 characters |
127 | | `assert!`                | Evaluates a Boolean and panics if `false`                                              |
128 | | `assert_eq!`             | Evaluates an equality, and panics if not equal                                         |
129 | | `assert_ne!`             | Evaluates an equality, and panics if equal                                             |
130 | | `assert_lt!`             | Evaluates a comparison, and panics if greater or equal                                             |
131 | | `assert_le!`             | Evaluates a comparison, and panics if greater                                             |
132 | | `assert_gt!`             | Evaluates a comparison, and panics if lower or equal                                             |
133 | | `assert_ge!`             | Evaluates a comparison, and panics if lower                                             |
134 | | `format!`                | Format a string and returns a `ByteArray` with the contents                            |
135 | | `write!`                 | Write formatted strings in a formatter                                                 |
136 | | `writeln!`               | Write formatted strings in a formatter on a new line                                   |
137 | | `get_dep_component!`     | Returns the requested component state from a snapshot of the state inside a component  |
138 | | `get_dep_component_mut!` | Returns the requested component state from a reference of the state inside a component |
139 | | `component!`             | Macro used in Starknet contracts to embed a component inside a contract                |
140 | 
141 | 
142 | <span class="caption">Table B-6: Macros</span>
143 | 
144 | Table B-7 shows symbols that create comments.
145 | 
146 | | Symbol | Explanation  |
147 | | ------ | ------------ |
148 | | `//`   | Line comment |
149 | 
150 | <span class="caption">Table B-7: Comments</span>
151 | 
152 | Table B-8 shows symbols that appear in the context of using tuples.
153 | 
154 | | Symbol            | Explanation                                                                                 |
155 | | ----------------- | ------------------------------------------------------------------------------------------- |
156 | | `()`              | Empty tuple (aka unit), both literal and type                                               |
157 | | `(expr)`          | Parenthesized expression                                                                    |
158 | | `(expr,)`         | Single-element tuple expression                                                             |
159 | | `(type,)`         | Single-element tuple type                                                                   |
160 | | `(expr, ...)`     | Tuple expression                                                                            |
161 | | `(type, ...)`     | Tuple type                                                                                  |
162 | | `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
163 | 
164 | <span class="caption">Table B-8: Tuples</span>
165 | 
166 | Table B-9 shows the contexts in which curly braces are used.
167 | 
168 | | Context      | Explanation      |
169 | | ------------ | ---------------- |
170 | | `{...}`      | Block expression |
171 | | `Type {...}` | `struct` literal |
172 | 
173 | <span class="caption">Table B-9: Curly Braces</span>
174 | 


--------------------------------------------------------------------------------
/src/appendix-03-derivable-traits.md:
--------------------------------------------------------------------------------
  1 | # Appendix C - Derivable Traits
  2 | 
  3 | In various places in the book, weve discussed the `derive` attribute, which you can apply to a struct or enum definition. The `derive` attribute generates code to implement a default trait on the type youve annotated with the `derive` syntax.
  4 | 
  5 | In this appendix, we provide a comprehensive reference detailing all the traits in the standard library compatible with the `derive` attribute.
  6 | 
  7 | These traits listed here are the only ones defined by the core library that can be implemented on your types using `derive`. Other traits defined in the standard library dont have sensible default behavior, so its up to you to implement them in a way that makes sense for what youre trying to accomplish.
  8 | 
  9 | ## Drop and Destruct
 10 | 
 11 | When moving out of scope, variables need to be moved first. This is where the `Drop` trait intervenes. You can find more details about its usage [here](ch04-01-what-is-ownership.md#no-op-destruction-the-drop-trait).
 12 | 
 13 | Moreover, Dictionaries need to be squashed before going out of scope. Calling the `squash` method on each of them manually can quickly become redundant. `Destruct` trait allows Dictionaries to be automatically squashed when they get out of scope. You can also find more information about `Destruct` [here](ch04-01-what-is-ownership.md#destruction-with-a-side-effect-the-destruct-trait).
 14 | 
 15 | ## `Clone` and `Copy` for Duplicating Values
 16 | 
 17 | The `Clone` trait provides the functionality to explicitly create a deep copy of a value.
 18 | 
 19 | Deriving `Clone` implements the `clone` method, which, in turn, calls clone on each of the type's components. This means all the fields or values in the type must also implement `Clone` to derive `Clone`.
 20 | 
 21 | Here is a simple example:
 22 | 
 23 | ```cairo
 24 | {{#include ../listings/appendix/listing_01_clone/src/lib.cairo}}
 25 | ```
 26 | 
 27 | The `Copy` trait allows for the duplication of values. You can derive `Copy` on any type whose parts all implement `Copy`.
 28 | 
 29 | Example:
 30 | 
 31 | ```cairo
 32 | {{#include ../listings/appendix/listing_02_copy/src/lib.cairo}}
 33 | ```
 34 | 
 35 | ## `Debug` for Printing and Debugging
 36 | 
 37 | The `Debug` trait enables debug formatting in format strings, which you indicate by adding `:?` within `{}` placeholders.
 38 | 
 39 | It allows you to print instances of a type for debugging purposes, so you and other programmers using this type can inspect an instance at a particular point in a programs execution.
 40 | 
 41 | For example, if you want to print the value of a variable of type `Point`, you can do it as follows:
 42 | 
 43 | ```cairo
 44 | {{#include ../listings/appendix/listing_03_debug/src/lib.cairo}}
 45 | ```
 46 | 
 47 | ```shell
 48 | scarb cairo-run
 49 | Point { x: 1, y: 3 }
 50 | ```
 51 | 
 52 | The `Debug` trait is required, for example, when using the `assert_xx!` macros in tests. Theses macros print the values of instances given as arguments if the equality or comparison assertion fails so programmers can see why the two instances werent equal.
 53 | 
 54 | ## `Default` for Default Values
 55 | 
 56 | The `Default` trait allows creation of a default value of a type. The most common default value is zero. All primitive types in the standard library implement `Default`.
 57 | 
 58 | If you want to derive `Default` on a composite type, each of its elements must already implement `Default`. If you have an [`enum`](ch06-01-enums.md) type, you must declare its default value by using the `#[default]` attribute on one of its variants.
 59 | 
 60 | An example:
 61 | 
 62 | ```cairo
 63 | {{#include ../listings/appendix/listing_07_default/src/lib.cairo}}
 64 | ```
 65 | 
 66 | ## `PartialEq` for Equality Comparisons
 67 | 
 68 | The `PartialEq` trait allows for comparison between instances of a type for equality, thereby enabling the `==` and `!=` operators.
 69 | 
 70 | When `PartialEq` is derived on structs, two instances are equal only if all their fields are equal; they are not equal if any field is different. When derived for enums, each variant is equal to itself and not equal to the other variants.
 71 | 
 72 | You can write your own implementation of the `PartialEq` trait for your type, if you can't derive it or if you want to implement your custom rules. In the following example, we write an implementation for `PartialEq` in which we consider that two rectangles are equal if they have the same area:
 73 | 
 74 | ```cairo
 75 | {{#include ../listings/appendix/listing_04_implpartialeq/src/lib.cairo}}
 76 | ```
 77 | 
 78 | The `PartialEq` trait is required when using the `assert_eq!` macro in tests, which needs to be able to compare two instances of a type for equality.
 79 | 
 80 | Here is an example:
 81 | 
 82 | ```cairo
 83 | {{#include ../listings/appendix/listing_05_partialeq/src/lib.cairo}}
 84 | ```
 85 | 
 86 | ## Serializing with `Serde`
 87 | 
 88 | `Serde` provides trait implementations for `serialize` and `deserialize` functions for data structures defined in your crate. It allows you to transform your structure into an array (or the opposite).
 89 | 
 90 | > **[Serialization](https://en.wikipedia.org/wiki/Serialization)** is a process of transforming data structures into a format that can be easily stored or transmitted. Let's say you are running a program and would like to persist its state to be able to resume it later. To do this, you could take each of the objects your program is using and save their information, for example in a file. This is a simplified version of serialization. Now if you want to resume your program with this saved state, you would perform **deserialization**, which means loading the state of the objects from the saved source.
 91 | 
 92 | For example:
 93 | 
 94 | ```cairo
 95 | {{#include ../listings/appendix/listing_06_serialize/src/lib.cairo}}
 96 | 
 97 | ```
 98 | 
 99 | If you run the `main` function, the output will be:
100 | 
101 | ```shell
102 | Run panicked with [2, 99 ('c'), ].
103 | ```
104 | 
105 | We can see here that our struct `A` has been serialized into the output array. Note that the `serialize` function takes as argument a snapshot of the type you want to convert into an array. This is why deriving `Drop` for `A` is required here, as the `main` function keeps ownership of the `first_struct` struct.
106 | 
107 | Also, we can use the `deserialize` function to convert the serialized array back into our `A` struct.
108 | 
109 | Here is an example:
110 | 
111 | ```cairo
112 | {{#include ../listings/appendix/listing_07_deserialize/src/lib.cairo}}
113 | ```
114 | 
115 | Here we are converting a serialized array span back to the struct `A`. `deserialize` returns an `Option` so we need to unwrap it. When using `deserialize` we also need to specify the type we want to deserialize into.
116 | 
117 | ## Hashing with `Hash`
118 | 
119 | It is possible to derive the `Hash` trait on structs and enums. This allows them to be hashed easily using any available hash function. For a struct or an enum to derive the `Hash` attribute, all fields or variants need to be hashable themselves.
120 | 
121 | You can refer to the [Hashes section](ch11-04-hash.md) to get more information about how to hash complex data types.
122 | 
123 | ## Starknet Storage with `starknet::Store`
124 | 
125 | The `starknet::Store` trait is relevant only when building on [Starknet](ch13-00-introduction-to-starknet-smart-contracts.md). It allows for a type to be used in smart contract storage by automatically implementing the necessary read and write functions.
126 | 
127 | You can find detailed information about the inner workings of Starknet storage in the [Contract storage section](ch14-01-00-contract-storage.md).
128 | 


--------------------------------------------------------------------------------
/src/appendix-04-cairo-prelude.md:
--------------------------------------------------------------------------------
 1 | # Appendix D - The Cairo Prelude
 2 | 
 3 | ## Prelude
 4 | 
 5 | The Cairo prelude is a collection of commonly used modules, functions, data
 6 | types, and traits that are automatically brought into scope of every module in a
 7 | Cairo crate without needing explicit import statements. Cairo's prelude provides
 8 | the basic building blocks developers need to start Cairo programs and writing
 9 | smart contracts.
10 | 
11 | The core library prelude is defined in the _[lib.cairo](https://github.com/starkware-libs/cairo/blob/main/corelib/src/lib.cairo)_
12 | file of the corelib crate and contains Cairo's primitive data types, traits,
13 | operators, and utility functions. This includes:
14 | 
15 | - Data types: integers, bools, arrays, dicts, etc.
16 | - Traits: behaviors for arithmetic, comparison, and serialization operations
17 | - Operators: arithmetic, logical, bitwise
18 | - Utility functions - helpers for arrays, maps, boxing, etc.
19 | 
20 | The core library prelude delivers the fundamental programming
21 | constructs and operations needed for basic Cairo programs, without requiring the
22 | explicit import of elements. Since the core library prelude is automatically
23 | imported, its contents are available for use in any Cairo crate without explicit
24 | imports. This prevents repetition and provides a better devX. This is what
25 | allows you to use `ArrayTrait::append()` or the `Default` trait without bringing
26 | them explicitly into scope.
27 | 
28 | You can choose which prelude to use. For example, adding `edition = "2024_07"` in the _Scarb.toml_ configuration file will load the prelude from July 2024. Note that when you create a new project using `scarb new` command, the _Scarb.toml_ file will automatically include `edition = "2024_07"`.
29 | Different prelude versions will expose different functions and traits, so it is important to specify the correct edition in the _Scarb.toml_ file. Generally, you want to start a new project using the latest edition, and migrate to newer editions as they are released.
30 | 


--------------------------------------------------------------------------------
/src/appendix-05-common-error-messages.md:
--------------------------------------------------------------------------------
 1 | # Appendix E - Common Error Messages
 2 | 
 3 | You might encounter error messages when writing Cairo code. Some of them occur very frequently, which is why we will be listing the most common error messages in this appendix to help you resolve common issues.
 4 | 
 5 | - `Variable not dropped.`: this error message means that you are trying to make a variable with a type that do not implement the `Drop` trait go out of scope, without destroying it. Make sure that variables that need to be dropped at the end of the execution of a function implement the `Drop` trait or the `Destruct` trait. See [Ownership](ch04-01-what-is-ownership.md#destroying-values---example-with-feltdict) section.
 6 | 
 7 | - `Variable was previously moved.`: this error message means that you are trying to use a variable whose ownership has already been transferred to another function. When a variable doesn't implement the `Copy` trait, it is passed by value to functions, and ownership of the variable is transferred to the function. Such a variable cannot be used anymore in the current context after its ownership has been transferred. It is often useful to use the `clone` method in this situation.
 8 | 
 9 | - `error: Trait has no implementation in context: core::fmt::Display::<package_name::struct_name>`: this error message is encountered if you try to print an instance of a custom data type with `{}` placeholders in a `print!` or `println!` macro. To mitigate this issue, you need to either manually implement the `Display` trait for your type, or use the `Debug` trait by applying `derive(Debug)` to your type, allowing to print your instance by adding `:?` in `{}` placeholders.
10 | 
11 | - `Got an exception while executing a hint: Hint Error: Failed to deserialize param #x.`: this error means that the execution failed because an entrypoint was called without the expected arguments. Make sure that the arguments you provide when calling an entrypoint are correct. There is a classic issue with `u256` variables, which are actually structs of 2 `u128`. Therefore, when calling a function that takes a `u256` as argument, you need to pass 2 values.
12 | 
13 | - `Item path::item is not visible in this context.`: this error message lets us know that the path to bring an item into scope is correct, but there is a vibility issue. In cairo, all items are private to parent modules by default. To resolve this issue, make sure that all the modules on the path to items and items themselves are declared with `pub(crate)` or `pub` to have access to them.
14 | 
15 | - `Identifier not found.`: this error message is a bit aspecific but might indicate that:
16 |   - A variable is being used before it has been declared. Make sure to declare variables with the `let` keyword.
17 |   - The path to bring an item into scope is wrongly defined. Make sure to use valid paths.
18 | 
19 | ## Starknet Components Related Error Messages
20 | 
21 | You might encounter some errors when trying to implement components.
22 | Unfortunately, some of them lack meaningful error messages to help debug. This
23 | section aims to provide you with some pointers to help you debug your code.
24 | 
25 | - `Trait not found. Not a trait.`: this error can occur when you're not importing the component's impl block
26 |   correctly in your contract. Make sure to respect the following syntax:
27 | 
28 |   ```cairo,noplayground
29 |   #[abi(embed_v0)]
30 |   impl IMPL_NAME = PATH_TO_COMPONENT::EMBEDDED_NAME<ContractState>
31 |   ```
32 | 
33 | - `Plugin diagnostic: name is not a substorage member in the contract's Storage. Consider adding to Storage: (...)`: the compiler helps you a lot debugging this by giving you recommendation on the action to take. Basically, you forgot to add the component's storage to your contract's storage. Make sure to add the path to the component's storage annotated with the `#[substorage(v0)]` attribute to your contract's storage.
34 | 
35 | - `Plugin diagnostic: name is not a nested event in the contract's Event enum. Consider adding to the Event enum:` similar to the previous error, the compiler tells you that you forgot to add the component's events to your contract's events. Make sure to add the path to the component's events to your contract's events.
36 | 


--------------------------------------------------------------------------------
/src/appendix-06-useful-development-tools.md:
--------------------------------------------------------------------------------
 1 | # Appendix F - Useful Development Tools
 2 | 
 3 | In this appendix, we talk about some useful development tools that the Cairo
 4 | project provides. Well look at automatic formatting, quick ways to apply
 5 | warning fixes, a linter, and integrating with IDEs.
 6 | 
 7 | ## Automatic Formatting with `scarb fmt`
 8 | 
 9 | Scarb projects can be formatted using the `scarb fmt` command.
10 | If you're using the Cairo binaries directly, you can run `cairo-format` instead.
11 | Many collaborative projects use `scarb fmt` to prevent arguments about which
12 | style to use when writing Cairo: everyone formats their code using the tool.
13 | 
14 | To format any Cairo project, enter the following inside the project directory:
15 | 
16 | ```bash
17 | scarb fmt
18 | ```
19 | 
20 | For things you do not want `scarb fmt` to mangle, use `#[cairofmt::skip]`:
21 | 
22 | ```cairo, noplayground
23 | #[cairofmt::skip]
24 | let table: Array<ByteArray> = array![
25 |     "oxo",
26 |     "xox",
27 |     "oxo",
28 | ];
29 | ```
30 | 
31 | ## IDE Integration Using `cairo-language-server`
32 | 
33 | To help IDE integration, the Cairo community recommends using the
34 | [`cairo-language-server`][cairo-language-server]<!-- ignore -->. This tool is a set of
35 | compiler-centric utilities that speaks the [Language Server Protocol][lsp]<!--
36 | ignore -->, which is a specification for IDEs and programming languages to
37 | communicate with each other. Different clients can use `cairo-language-server`, such as
38 | [the Cairo extension for Visual Studio Code][vscode-cairo].
39 | 
40 | [lsp]: http://langserver.org/
41 | [vscode-cairo]: https://marketplace.visualstudio.com/items?itemName=starkware.cairo1
42 | 
43 | Visit the `vscode-cairo` [page][vscode-cairo]<!-- ignore -->
44 | to install it on VSCode. You will get abilities such as autocompletion, jump to
45 | definition, and inline errors.
46 | 
47 | [cairo-language-server]: https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server
48 | 
49 | > Note: If you have Scarb installed, it should work out of the box with the Cairo VSCode extension, without a manual installation of the language server.
50 | 


--------------------------------------------------------------------------------
/src/appendix-08-system-calls.md:
--------------------------------------------------------------------------------
  1 | # Appendix A - System Calls
  2 | 
  3 | This chapter is based on the Starknet documentation available at [Starknet Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/).
  4 | 
  5 | Writing smart contracts requires various associated operations, such as calling another contract or accessing the contracts storage, that standalone programs do not require.
  6 | 
  7 | The Starknet contract language supports these operations by using system calls. System calls enable a contract to require services from the Starknet OS. You can use system calls in a function to get information that depends on the broader state of Starknet, which would otherwise be inaccessible, rather than local variables that appear in the functions scope.
  8 | 
  9 | Here is a list of the system calls available in Cairo 1.0:
 10 | 
 11 | - [get_block_hash](#get_block_hash)
 12 | - [get_execution_info](#get_execution_info)
 13 | - [call_contract](#call_contract)
 14 | - [deploy](#deploy)
 15 | - [emit_event](#emit_event)
 16 | - [library_call](#library_call)
 17 | - [send_message_to_L1](#send_message_to_l1)
 18 | - [get_class_hash_at](#get_class_hash_at)
 19 | - [replace_class](#replace_class)
 20 | - [storage_read](#storage_read)
 21 | - [storage_write](#storage_write)
 22 | - [keccak](#keccak)
 23 | - [sha256_process_block](#sha256_process_block)
 24 | 
 25 | ## `get_block_hash`
 26 | 
 27 | #### Syntax
 28 | 
 29 | ```cairo,noplayground
 30 | pub extern fn get_block_hash_syscall(
 31 |     block_number: u64,
 32 | ) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;
 33 | ```
 34 | 
 35 | #### Description
 36 | 
 37 | Gets the hash of a specific Starknet block within the range of `[first_v0_12_0_block, current_block - 10]`.
 38 | 
 39 | #### Return Values
 40 | 
 41 | Returns the hash of the given block.
 42 | 
 43 | #### Error Messages
 44 | 
 45 | - `Block number out of range`: `block_number` is greater than _`current_block`_`- 10`.
 46 | - `0`: `block_number` is less than the first block number of v0.12.0.
 47 | 
 48 | #### Common Library
 49 | 
 50 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)
 51 | 
 52 | ## `get_execution_info`
 53 | 
 54 | #### Syntax
 55 | 
 56 | ```cairo,noplayground
 57 | pub extern fn get_execution_info_syscall() -> SyscallResult<
 58 |     Box<starknet::info::ExecutionInfo>,
 59 | > implicits(GasBuiltin, System) nopanic;
 60 | ```
 61 | 
 62 | #### Description
 63 | 
 64 | Gets information about the original transaction.
 65 | 
 66 | In Cairo 1.0, all block/transaction/execution context getters are batched into this single system call.
 67 | 
 68 | #### Arguments
 69 | 
 70 | None.
 71 | 
 72 | #### Return Values
 73 | 
 74 | Returns a [struct](https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8) containing the execution info.
 75 | 
 76 | #### Common Library
 77 | 
 78 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)
 79 | 
 80 | ## `call_contract`
 81 | 
 82 | #### Syntax
 83 | 
 84 | ```cairo,noplayground
 85 | pub extern fn call_contract_syscall(
 86 |     address: ContractAddress, entry_point_selector: felt252, calldata: Span<felt252>,
 87 | ) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;
 88 | ```
 89 | 
 90 | #### Description
 91 | 
 92 | Calls a given contract. This system call expects the address of the called contract, a selector for a function within that contract, and call arguments.
 93 | 
 94 | > **Note:**
 95 | >
 96 | > An internal call cant return Err(\_) as this is not handled by the sequencer and the Starknet OS.
 97 | >
 98 | > If call_contract_syscall fails, this cant be caught and will therefore result in the entire transaction being reverted.
 99 | 
100 | #### Arguments
101 | 
102 | - _`address`_: The address of the contract you want to call.
103 | - _`entry_point_selector`_: A selector for a function within that contract, can be computed with the `selector!` macro.
104 | - _`calldata`_: The calldata array.
105 | 
106 | #### Return Values
107 | 
108 | The call response, of type `SyscallResult<Span<felt252>>`.
109 | 
110 | #### Common Library
111 | 
112 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)
113 | 
114 | > **Note:**
115 | > This is considered a lower-level syntax for calling contracts.
116 | > If the interface of the called contract is available, then you can use a more straightforward syntax.
117 | 
118 | ## `deploy`
119 | 
120 | #### Syntax
121 | 
122 | ```cairo,noplayground
123 | pub extern fn deploy_syscall(
124 |     class_hash: ClassHash,
125 |     contract_address_salt: felt252,
126 |     calldata: Span<felt252>,
127 |     deploy_from_zero: bool,
128 | ) -> SyscallResult<(ContractAddress, Span<felt252>)> implicits(GasBuiltin, System) nopanic;
129 | ```
130 | 
131 | #### Description
132 | 
133 | Deploys a new instance of a previously declared class.
134 | 
135 | #### Arguments
136 | 
137 | - _`class_hash`_: The class hash of the contract to be deployed.
138 | - _`contract_address_salt`_: The salt, an arbitrary value provided by the sender. It is used in the computation of the contracts address.
139 | - _`calldata`_: The constructors calldata. An array of felts.
140 | - _`deploy_from_zero`_: A flag used for the contract address computation. If not set, the caller address will be used as the new contracts deployer address, otherwise 0 is used.
141 | 
142 | #### Return Values
143 | 
144 | A tuple wrapped with SyscallResult where:
145 | 
146 | - The first element is the address of the deployed contract, of type `ContractAddress`.
147 | 
148 | - The second element is the response array from the contracts constructor, of type `Span::<felt252>`.
149 | 
150 | #### Common Library
151 | 
152 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)
153 | 
154 | ## `emit_event`
155 | 
156 | #### Syntax
157 | 
158 | ```cairo,noplayground
159 | pub extern fn emit_event_syscall(
160 |     keys: Span<felt252>, data: Span<felt252>,
161 | ) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;
162 | ```
163 | 
164 | #### Description
165 | 
166 | Emits an event with a given set of keys and data.
167 | 
168 | For more information and a higher-level syntax for emitting events, see [Starknet events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-events/).
169 | 
170 | #### Arguments
171 | 
172 | - _`keys`_: The events keys. These are analogous to Ethereums event topics, you can use the starknet_getEvents method to filter by these keys.
173 | 
174 | - _`data`_: The events data.
175 | 
176 | #### Return Values
177 | 
178 | None.
179 | 
180 | #### Example
181 | 
182 | The following example emits an event with two keys, the strings `status` and `deposit` and three data elements: `1`, `2`, and `3`.
183 | 
184 | ```cairo,noplayground
185 | let keys = ArrayTrait::new();
186 | keys.append('key');
187 | keys.append('deposit');
188 | let values = ArrayTrait::new();
189 | values.append(1);
190 | values.append(2);
191 | values.append(3);
192 | emit_event_syscall(keys, values).unwrap_syscall();
193 | ```
194 | 
195 | #### Common Library
196 | 
197 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)
198 | 
199 | ## `library_call`
200 | 
201 | #### Syntax
202 | 
203 | ```cairo,noplayground
204 | pub extern fn library_call_syscall(
205 |     class_hash: ClassHash, function_selector: felt252, calldata: Span<felt252>,
206 | ) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;
207 | ```
208 | 
209 | #### Description
210 | 
211 | Calls the requested function in any previously declared class. The class is only used for its logic.
212 | 
213 | This system call replaces the known delegate call functionality from Ethereum, with the important difference that there is only one contract involved.
214 | 
215 | #### Arguments
216 | 
217 | - _`class_hash`_: The hash of the class you want to use.
218 | 
219 | - _`function_selector`_: A selector for a function within that class, can be computed with the `selector!` macro.
220 | 
221 | - _`calldata`_: The calldata.
222 | 
223 | #### Return Values
224 | 
225 | The call response, of type `SyscallResult<Span<felt252>>`.
226 | 
227 | #### Common Library
228 | 
229 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)
230 | 
231 | ## `send_message_to_L1`
232 | 
233 | #### Syntax
234 | 
235 | ```cairo,noplayground
236 | pub extern fn send_message_to_l1_syscall(
237 |     to_address: felt252, payload: Span<felt252>,
238 | ) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;
239 | ```
240 | 
241 | #### Description
242 | 
243 | Sends a message to L1.
244 | 
245 | This system call includes the message parameters as part of the proofs output and exposes these parameters to the `StarknetCore` contract on L1 once the state update, including the transaction, is received.
246 | 
247 | For more information, see Starknets [messaging mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/).
248 | 
249 | #### Arguments
250 | 
251 | - _`to_address`_: The recipients L1 address.
252 | 
253 | - _`payload`_: The array containing the message payload.
254 | 
255 | #### Return Values
256 | 
257 | None.
258 | 
259 | #### Example
260 | 
261 | The following example sends a message whose content is `(1,2)` to the L1 contract whose address is `3423542542364363`.
262 | 
263 | ```cairo,noplayground
264 | let payload = ArrayTrait::new();
265 | payload.append(1);
266 | payload.append(2);
267 | send_message_to_l1_syscall(payload).unwrap_syscall();
268 | ```
269 | 
270 | #### Common Library
271 | 
272 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)
273 | 
274 | ## `get_class_hash_at`
275 | 
276 | #### Syntax
277 | 
278 | ```cairo,noplayground
279 | pub extern fn get_class_hash_at_syscall(
280 |     contract_address: ContractAddress,
281 | ) -> SyscallResult<ClassHash> implicits(GasBuiltin, System) nopanic;
282 | ```
283 | 
284 | #### Description
285 | 
286 | Gets the class hash of the contract at the given address.
287 | 
288 | #### Arguments
289 | 
290 | - _`contract_address`_: The address of the deployed contract.
291 | 
292 | #### Return Values
293 | 
294 | The class hash of the contract's originating code.
295 | 
296 | #### Common Library
297 | 
298 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L99)
299 | 
300 | ## `replace_class`
301 | 
302 | #### Syntax
303 | 
304 | ```cairo,noplayground
305 | pub extern fn replace_class_syscall(
306 |     class_hash: ClassHash,
307 | ) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;
308 | ```
309 | 
310 | #### Description
311 | 
312 | Once `replace_class` is called, the class of the calling contract (i.e. the contract whose address is returned by `get_contract_address` at the time the syscall is called) will be replaced by the class whose hash is given by the class_hash argument.
313 | 
314 | > **Note:**
315 | >
316 | > After calling `replace_class`, the code currently executing from the old class will finish running.
317 | >
318 | > The new class will be used from the next transaction onwards or if the contract is called via the `call_contract` syscall in the same transaction (after the replacement).
319 | 
320 | #### Arguments
321 | 
322 | - _`class_hash`_: The hash of the class you want to use as a replacement.
323 | 
324 | #### Return Values
325 | 
326 | None.
327 | 
328 | #### Common Library
329 | 
330 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)
331 | 
332 | ## `storage_read`
333 | 
334 | #### Syntax
335 | 
336 | ```cairo,noplayground
337 | pub extern fn storage_read_syscall(
338 |     address_domain: u32, address: StorageAddress,
339 | ) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;
340 | ```
341 | 
342 | #### Description
343 | 
344 | Gets the value of a key in the storage of the calling contract.
345 | 
346 | This system call provides direct access to any possible key in storage, in contrast with `var.read()`, which enables you to read storage variables that are defined explicitly in the contract.
347 | 
348 | For information on accessing storage by using the storage variables, see [storage variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables).
349 | 
350 | #### Arguments
351 | 
352 | - _`address_domain`_: The domain of the key, used to separate between different data availability modes. This separation is used in Starknet to offer different data availability modes. Currently, only the onchain mode (where all updates go to L1), indicated by domain `0`, is supported. Other address domains which will be introduced in the future will behave differently in terms of publication (in particular, they will not be posted on L1, creating a tradeoff between cost and security).
353 | 
354 | - _`address`_: The requested storage address.
355 | 
356 | #### Return Values
357 | 
358 | The value of the key, of type `SyscallResult<felt252>`.
359 | 
360 | #### Example
361 | 
362 | ```cairo,noplayground
363 | use starknet::storage_access::storage_base_address_from_felt252;
364 | 
365 | ...
366 | 
367 | let storage_address = storage_base_address_from_felt252(3534535754756246375475423547453)
368 | storage_read_syscall(0, storage_address).unwrap_syscall()
369 | ```
370 | 
371 | #### Common Library
372 | 
373 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)
374 | 
375 | ## `storage_write`
376 | 
377 | #### Syntax
378 | 
379 | ```cairo,noplayground
380 | pub extern fn storage_write_syscall(
381 |     address_domain: u32, address: StorageAddress, value: felt252,
382 | ) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;
383 | ```
384 | 
385 | #### Description
386 | 
387 | Sets the value of a key in the storage of the calling contract.
388 | 
389 | This system call provides direct access to any possible key in storage, in contrast with `var.write()`, which enables you to write to storage variables that are defined explicitly in the contract.
390 | 
391 | For information on accessing storage by using the storage variables, see [storage variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables).
392 | 
393 | #### Arguments
394 | 
395 | - _`address_domain`_: The domain of the key, used to separate between different data availability modes. This separation is used in Starknet to offer different data availability modes. Currently, only the onchain mode (where all updates go to L1), indicated by domain `0`, is supported. Other address domains which will be introduced in the future will behave differently in terms of publication (in particular, they will not be posted on L1, creating a tradeoff between cost and security).
396 | 
397 | - _`address`_: The requested storage address.
398 | 
399 | - _`value`_: The value to write to the key.
400 | 
401 | #### Return Values
402 | 
403 | None.
404 | 
405 | #### Common Library
406 | 
407 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)
408 | 
409 | ## `keccak`
410 | 
411 | #### Syntax
412 | 
413 | ```cairo,noplayground
414 | pub extern fn keccak_syscall(
415 |     input: Span<u64>,
416 | ) -> SyscallResult<u256> implicits(GasBuiltin, System) nopanic;
417 | ```
418 | 
419 | #### Description
420 | 
421 | Computes the Keccak-256 hash of a given input.
422 | 
423 | #### Arguments
424 | 
425 | - _`input`_: A `Span<u64>` Keccak-256 input.
426 | 
427 | #### Return Values
428 | 
429 | Returns the hash result as a `u256`.
430 | 
431 | #### Common Library
432 | 
433 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L107)
434 | 
435 | 
436 | ## `sha256_process_block`
437 | 
438 | #### Syntax
439 | 
440 | ```cairo,noplayground
441 | pub extern fn sha256_process_block_syscall(
442 |     state: core::sha256::Sha256StateHandle, input: Box<[u32; 16]>
443 | ) -> SyscallResult<core::sha256::Sha256StateHandle> implicits(GasBuiltin, System) nopanic;
444 | ```
445 | 
446 | #### Description
447 | 
448 | Computes the next SHA-256 state of the input with the given state.
449 | 
450 | This syscall computes the next SHA-256 state by combining the current `state` with a 512-bit block of `input` data.
451 | 
452 | #### Arguments
453 | 
454 | - _`state`_: The current SHA-256 state.
455 | - _`input`_: The value to be processed into SHA-256.
456 | 
457 | #### Return Values
458 | 
459 | Returns a new SHA-256 state of the `input` data.
460 | 
461 | #### Common Library
462 | 
463 | - [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/3540731e5b0e78f2f5b1a51d3611418121c19e54/corelib/src/starknet/syscalls.cairo#L106)
464 | 


--------------------------------------------------------------------------------
/src/box_memory.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/box_memory.png


--------------------------------------------------------------------------------
/src/cairo-vm-architecture.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/cairo-vm-architecture.png


--------------------------------------------------------------------------------
/src/ch00-00-introduction.md:
--------------------------------------------------------------------------------
 1 | # Introduction
 2 | 
 3 | ## What is Cairo?
 4 | 
 5 | Cairo is a programming language designed to leverage the power of mathematical proofs for computational integrity. Just as C.S. Lewis defined integrity as "doing the right thing, even when no one is watching," Cairo enables programs to prove they've done the right computation, even when executed on untrusted machines.
 6 | 
 7 | The language is built on STARK technology, a modern evolution of PCP (Probabilistically Checkable Proofs) that transforms computational claims into constraint systems. While Cairo's ultimate purpose is to generate these mathematical proofs that can be verified efficiently and with absolute certainty.
 8 | 
 9 | ## What Can You Do with It?
10 | 
11 | Cairo enables a paradigm shift in how we think about trusted computation. Its primary application today is Starknet, a Layer 2 scaling solution for Ethereum that addresses one of blockchain's fundamental challenges: scalability without sacrificing security.
12 | 
13 | In the traditional blockchain model, every participant must verify every computation. Starknet changes this by using Cairo's proof system: computations are executed off-chain by a prover who generates a STARK proof, which is then verified by an Ethereum smart contract. This verification requires significantly less computational power than re-executing the computations, enabling massive scalability while maintaining security.
14 | 
15 | However, Cairo's potential extends beyond blockchain. Any scenario where computational integrity needs to be verified efficiently can benefit from Cairo's verifiable computation capabilities.
16 | 
17 | ## Who Is This Book For?
18 | 
19 | This book caters to three main audiences, each with their own learning path:
20 | 
21 | 1. **General-Purpose Developers**: If you're interested in Cairo for its verifiable computation capabilities outside of blockchain, you'll want to focus on chapters {{#chap getting-started}}-{{#chap advanced-cairo-features}}. These chapters cover the core language features and programming concepts without diving deep into smart contract specifics.
22 | 
23 | 2. **New Smart Contract Developers**: If you're new to both Cairo and smart contracts, we recommend reading the book front to back. This will give you a solid foundation in both the language fundamentals and smart contract development principles.
24 | 
25 | 3. **Experienced Smart Contract Developers**: If you're already familiar with smart contract development in other languages, or Rust, you might want to follow this focused path:
26 |    - Chapters {{#chap getting-started}}-{{#chap common-collections}} for Cairo basics
27 |    - Chapter {{#chap generic-types-and-traits}} for Cairo's trait and generics system
28 |    - Skip to Chapter {{#chap building-starknet-smart-contracts}} for smart contract development
29 |    - Reference other chapters as needed
30 | 
31 | Regardless of your background, this book assumes basic programming knowledge such as variables, functions, and common data structures. While prior experience with Rust can be helpful (as Cairo shares many similarities), it's not required.
32 | 
33 | ## References
34 | 
35 | - Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>
36 | - Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>
37 | - State of non determinism: <https://twitter.com/PapiniShahar/status/1638203716535713798>
38 | 


--------------------------------------------------------------------------------
/src/ch00-01-foreword.md:
--------------------------------------------------------------------------------
 1 | # Foreword
 2 | 
 3 | Zero-knowledge proofs have emerged as a transformative technology in the blockchain space, offering solutions for both privacy and scalability challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge) stand out as a particularly powerful innovation. Unlike traditional proof systems, STARKs rely solely on collision-resistant hash functions, making them post-quantum secure and eliminating the need for trusted setups.
 4 | 
 5 | However, writing general-purpose programs that can generate cryptographic proofs has historically been a significant challenge. Developers needed deep expertise in cryptography and complex mathematical concepts to create verifiable computations, making it impractical for mainstream adoption.
 6 | 
 7 | This is where Cairo comes in. As a general-purpose programming language designed specifically for creating provable programs, Cairo abstracts away the underlying cryptographic complexities while maintaining the full power of STARKs. Strongly inspired by Rust, Cairo has been built to help you create provable programs without requiring specific knowledge of its underlying architecture, allowing you to focus on the program logic itself.
 8 | 
 9 | Blockchain developers that want to deploy contracts on Starknet will use the Cairo programming language to code their smart contracts. This allows the Starknet OS to generate execution traces for transactions to be proved by a prover, which is then verified on Ethereum L1 prior to updating the state root of Starknet.
10 | 
11 | However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines. Powered by a Rust VM, and a next-generation prover, the execution and proof generation of Cairo programs is blazingly fast - making Cairo the best tool for building provable applications.
12 | 
13 | This book is designed for developers with a basic understanding of programming concepts. It is a friendly and approachable text intended to help you level up your knowledge of Cairo, but also help you develop your programming skills in general. So, dive in and get ready to learn all there is to know about Cairo!
14 | 
15 | ## Acknowledgements
16 | 
17 | This book would not have been possible without the help of the Cairo community. We would like to thank every contributor for their contributions to this book!
18 | 
19 | We would like to thank the Rust community for the [Rust Book][doc rust], which has been a great source of inspiration for this book. Many examples and explanations have been adapted from the Rust Book to fit the Cairo programming language, as the two languages share many similarities.
20 | 
21 | [doc rust]: https://doc.rust-lang.org/book/
22 | 


--------------------------------------------------------------------------------
/src/ch01-00-getting-started.md:
--------------------------------------------------------------------------------
 1 | # Getting Started
 2 | 
 3 | Lets start your Cairo journey! Theres a lot to learn, but every journey starts somewhere. In this chapter, well discuss:
 4 | 
 5 | - Installing Scarb, which is Cairo's build toolchain and package manager, on Linux, macOS, and Windows.
 6 | - Installing Starknet Foundry, which is the default test runnner when creating a Cairo project.
 7 | - Writing a program that prints `Hello, world!`.
 8 | - Using basic Scarb commands to create a project and execute a program.
 9 | 
10 | ## Getting Help
11 | 
12 | If you have any questions about Starknet or Cairo, you can ask them in the [Starknet Discord server][discord]. The community is friendly and always willing to help.
13 | 
14 | [discord]: https://discord.gg/starknet-community
15 | 
16 | ## Interacting with the Starknet AI Agent
17 | 
18 | Starknet proposes its own AI agent designed to assist with Cairo and Starknet-related questions. This AI agent is trained on the Cairo book and the Starknet documentation, using Retrieval-Augmented Generation (RAG) to efficiently retrieve information and provide accurate assistance.
19 | 
20 | You can find the Starknet Agent on the [Starknet Agent][agent gpt] website.
21 | 
22 | [agent gpt]: https://agent.starknet.id/
23 | 


--------------------------------------------------------------------------------
/src/ch01-01-installation.md:
--------------------------------------------------------------------------------
 1 | # Installation
 2 | 
 3 | Cairo can be installed by simply downloading [Scarb][scarb doc]. Scarb bundles the Cairo compiler and the Cairo language server together in an easy-to-install package so that you can start writing Cairo code right away.
 4 | 
 5 | Scarb is also Cairo's package manager and is heavily inspired by [Cargo][cargo doc], Rusts build system and package manager.
 6 | 
 7 | Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, building those libraries, and provides LSP support for the VSCode Cairo 1 extension.
 8 | 
 9 | As you write more complex Cairo programs, you might add dependencies, and if you start a project using Scarb, managing external code and dependencies will be a lot easier to do.
10 | 
11 | [Starknet Foundry][sn foundry] is a toolchain for Cairo programs and Starknet smart contract development. It supports many features, including writing and running tests with advanced features, deploying contracts, interacting with the Starknet network, and more.
12 | 
13 | Let's start by installing Scarb and Starknet Foundry.
14 | 
15 | [scarb doc]: https://docs.swmansion.com/scarb/docs
16 | [cargo doc]: https://doc.rust-lang.org/cargo/
17 | [sn foundry]: https://foundry-rs.github.io/starknet-foundry/index.html
18 | 
19 | ## Installing Scarb
20 | 
21 | ### Requirements
22 | 
23 | Scarb requires a Git executable to be available in the `PATH` environment variable.
24 | 
25 | ### Installation
26 | 
27 | To install Scarb, please refer to the [installation instructions][scarb download]. We strongly recommend that you install Scarb [via asdf][scarb asdf], a CLI tool that can manage multiple language runtime versions on a per-project basis. This will ensure that the version of Scarb you use to work on a project always matches the one defined in the project settings, avoiding problems related to version mismatches.
28 | 
29 | Please refer to the [asdf documentation][asdf doc] to install all prerequisites.
30 | 
31 | Once you have asdf installed locally, you can download Scarb plugin with the following command:
32 | 
33 | ```bash
34 | asdf plugin add scarb
35 | ```
36 | 
37 | This will allow you to download specific versions:
38 | 
39 | ```bash
40 | asdf install scarb 2.9.1
41 | ```
42 | 
43 | and set a global version:
44 | 
45 | ```bash
46 | asdf global scarb 2.9.1
47 | ```
48 | 
49 | Otherwise, you can simply run the following command in your terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb.
50 | 
51 | ```bash
52 | curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh
53 | ```
54 | 
55 | <br>
56 | In both cases, you can verify installation by running the following command in a new terminal session, it should print both Scarb and Cairo language versions, e.g:
57 | 
58 | ```bash
59 | $ scarb --version
60 | scarb 2.9.1 (aba4f604a 2024-11-29)
61 | cairo: 2.9.1 (https://crates.io/crates/cairo-lang-compiler/2.9.1)
62 | sierra: 1.6.0
63 | ```
64 | 
65 | [scarb download]: https://docs.swmansion.com/scarb/download
66 | [scarb asdf]: https://docs.swmansion.com/scarb/download.html#install-via-asdf
67 | [asdf doc]: https://asdf-vm.com/guide/getting-started.html
68 | 
69 | ## Installing Starknet Foundry
70 | 
71 | To install Starknet Foundry, please refer to the [installation instructions][snfoundry download]. We also recommend that you install it via asdf.
72 | 
73 | Once installed, you can run the following command to see the version:
74 | 
75 | ```bash
76 | $ snforge --version
77 | snforge 0.33.0
78 | ```
79 | 
80 | We'll describe Starknet Foundry in more detail in [Chapter {{#chap testing-cairo-programs}}][writing tests] for Cairo programs testing and in [Chapter {{#chap starknet-smart-contracts-security}}][testing with snfoundry] when discussing Starknet smart contract testing and security in the second part of the book.
81 | 
82 | [snfoundry download]: https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html
83 | [writing tests]: ./ch10-01-how-to-write-tests.md
84 | [testing with snfoundry]: ./ch17-02-testing-smart-contracts.md#testing-smart-contracts-with-starknet-foundry
85 | 
86 | ## Installing the VSCode Extension
87 | 
88 | Cairo has a VSCode extension that provides syntax highlighting, code completion, and other useful features. You can install it from the [VSCode Marketplace][vsc extension].
89 | Once installed, go into the extension settings, and make sure to tick the `Enable Language Server` and `Enable Scarb` options.
90 | 
91 | [vsc extension]: https://marketplace.visualstudio.com/items?itemName=starkware.cairo1
92 | 
93 | {{#quiz ../quizzes/ch01-01-installation.toml}}
94 | 


--------------------------------------------------------------------------------
/src/ch01-02-hello-world.md:
--------------------------------------------------------------------------------
  1 | # Hello, World
  2 | 
  3 | Now that youve installed Cairo through Scarb, its time to write your first Cairo program.
  4 | Its traditional when learning a new language to write a little program that
  5 | prints the text `Hello, world!` to the screen, so well do the same here!
  6 | 
  7 | > Note: This book assumes basic familiarity with the command line. Cairo makes
  8 | > no specific demands about your editing or tooling or where your code lives, so
  9 | > if you prefer to use an integrated development environment (IDE) instead of
 10 | > the command line, feel free to use your favorite IDE. The Cairo team has developed
 11 | > a VSCode extension for the Cairo language that you can use to get the features from
 12 | > the language server and code highlighting. See [Appendix F][devtools]
 13 | > for more details.
 14 | 
 15 | [devtools]: ./appendix-06-useful-development-tools.md
 16 | 
 17 | ## Creating a Project Directory
 18 | 
 19 | Youll start by making a directory to store your Cairo code. It doesnt matter
 20 | to Cairo where your code lives, but for the exercises and projects in this book,
 21 | we suggest making a _cairo_projects_ directory in your home directory and keeping all
 22 | your projects there.
 23 | 
 24 | Open a terminal and enter the following commands to make a _cairo_projects_ directory.
 25 | 
 26 | For Linux, macOS, and PowerShell on Windows, enter this:
 27 | 
 28 | ```shell
 29 | mkdir ~/cairo_projects
 30 | cd ~/cairo_projects
 31 | ```
 32 | 
 33 | For Windows CMD, enter this:
 34 | 
 35 | ```cmd
 36 | > mkdir "%USERPROFILE%\cairo_projects"
 37 | > cd /d "%USERPROFILE%\cairo_projects"
 38 | ```
 39 | 
 40 | > Note: From now on, for each example shown in the book, we assume that
 41 | > you will be working from a Scarb project directory. If you are not using Scarb, and try to run the examples from a different directory, you might need to adjust the commands accordingly or create a Scarb project.
 42 | 
 43 | ## Creating a Project with Scarb
 44 | 
 45 | Lets create a new project using Scarb.
 46 | 
 47 | Navigate to your _cairo_projects_ directory (or wherever you decided to store your code). Then run the following:
 48 | 
 49 | ```bash
 50 | scarb new hello_world
 51 | ```
 52 | 
 53 | Scarb will ask you about the dependencies you want to add.
 54 | You will be given two options :
 55 | 
 56 | ```text
 57 | ? Which test runner do you want to set up? 
 58 |  Starknet Foundry (default)
 59 |   Cairo Test
 60 | ```
 61 | 
 62 | In general, we'll prefer using the first one ` Starknet Foundry (default)`.
 63 | 
 64 | This creates a new directory and project called _hello_world_. Weve named our project _hello_world_, and Scarb creates its files in a directory of the same name.
 65 | 
 66 | Go into the _hello_world_ directory with the command `cd hello_world`. Youll see that Scarb has generated three files and two directory for us: a _Scarb.toml_ file, a _src_ directory with a _lib.cairo_ file inside and a _tests_ directory containing a _test_contract.cairo_ file. For now, we can remove this _tests_ directory.
 67 | 
 68 | It has also initialized a new Git repository along with a `.gitignore` file
 69 | 
 70 | > Note: Git is a common version control system. You can stop using version control system by using the `--no-vcs` flag.
 71 | > Run `scarb new --help` to see the available options.
 72 | 
 73 | Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing {{#ref scarb-content}}.
 74 | 
 75 | <span class="filename">Filename: Scarb.toml</span>
 76 | 
 77 | ```toml
 78 | [package]
 79 | name = "hello_world"
 80 | version = "0.1.0"
 81 | edition = "2024_07"
 82 | 
 83 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 84 | 
 85 | [dependencies]
 86 | starknet = "2.8.2"
 87 | 
 88 | [dev-dependencies]
 89 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry", tag = "v0.33.0" }
 90 | 
 91 | [[target.starknet-contract]]
 92 | sierra = true
 93 | 
 94 | [scripts]
 95 | test = "snforge test"
 96 | ```
 97 | 
 98 | {{#label scarb-content}}
 99 | <span class="caption">Listing {{#ref scarb-content}}: Contents of _Scarb.toml_ generated by `scarb new`</span>
100 | 
101 | This file is in the [TOML][toml doc] (Toms Obvious, Minimal Language) format, which is Scarbs configuration format.
102 | 
103 | The first line, `[package]`, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, well add other sections.
104 | 
105 | The next three lines set the configuration information Scarb needs to compile your program: the name of the package and the version of Scarb to use, and the edition of the prelude to use. The prelude is the collection of the most commonly used items that are automatically imported into every Cairo program. You can learn more about the prelude in [Appendix D][prelude].
106 | 
107 | The `[dependencies]` section, is the start of a section for you to list any of your projects dependencies. In Cairo, packages of code are referred to as crates. We wont need any other crates for this project.
108 | 
109 | > Note: By default, using Starknet Foundry adds the `starknet` dependency, so that you can also build contracts for Starknet.
110 | 
111 | The `[dev-dependencies]` section is about dependencies that are required for development, but are not needed for the actual production build of the project.
112 | 
113 | The `[[target.starknet-contract]]` section allows to build Starknet smart contracts. We can remove it for now.
114 | 
115 | The `[script]` section allows to define custom scripts. By default, there is one script for running tests using `snforge` with the `scarb test` command. We can also remove it for now.
116 | 
117 | The other file created by Scarb is _src/lib.cairo_, let's delete all the content and put in the following content, we will explain the reason later.
118 | 
119 | ```cairo,noplayground
120 | mod hello_world;
121 | ```
122 | 
123 | Then create a new file called _src/hello_world.cairo_ and put the following code in it:
124 | 
125 | <span class="filename">Filename: src/hello_world.cairo</span>
126 | 
127 | ```cairo,file=hello_world.cairo
128 | fn main() {
129 |     println!("Hello, World!");
130 | }
131 | ```
132 | 
133 | We have just created a file called _lib.cairo_, which contains a module declaration referencing another module named `hello_world`, as well as the file _hello_world.cairo_, containing the implementation details of the `hello_world` module.
134 | 
135 | Scarb requires your source files to be located within the _src_ directory.
136 | 
137 | The top-level project directory is reserved for README files, license information, configuration files, and any other non-code-related content.
138 | Scarb ensures a designated location for all project components, maintaining a structured organization.
139 | 
140 | If you started a project that doesnt use Scarb, you can convert it to a project that does use Scarb. Move the project code into the _src_ directory and create an appropriate _Scarb.toml_ file. You can also use `scarb init` command to generate the _src_ folder and the _Scarb.toml_ it contains.
141 | 
142 | ```txt
143 |  Scarb.toml
144 |  src
145 |     lib.cairo
146 |     hello_world.cairo
147 | ```
148 | 
149 | <span class="caption"> A sample Scarb project structure</span>
150 | 
151 | [toml doc]: https://toml.io/
152 | [prelude]: ./appendix-04-cairo-prelude.md
153 | [starknet package]: https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-package.html
154 | 
155 | ## Building a Scarb Project
156 | 
157 | From your _hello_world_ directory, build your project by entering the following command:
158 | 
159 | ```bash
160 | $ scarb build
161 |    Compiling hello_world v0.1.0 (file:///projects/Scarb.toml)
162 |     Finished release target(s) in 0 seconds
163 | ```
164 | 
165 | This command creates a `sierra` file in _target/dev_, let's ignore the `sierra` file for now.
166 | 
167 | If you have installed Cairo correctly, you should be able to run the `main` function of your program with the `scarb cairo-run` command and see the following output:
168 | 
169 | ```shell
170 | $ scarb cairo-run
171 | Running hello_world
172 | Hello, World!
173 | Run completed successfully, returning []
174 | ```
175 | 
176 | Regardless of your operating system, the string `Hello, world!` should be printed to
177 | the terminal.
178 | 
179 | If `Hello, world!` did print, congratulations! Youve officially written a Cairo
180 | program. That makes you a Cairo programmer  welcome!
181 | 
182 | ## Anatomy of a Cairo Program
183 | 
184 | Lets review this Hello, world! program in detail. Heres the first piece of
185 | the puzzle:
186 | 
187 | ```cairo,noplayground
188 | fn main() {
189 | 
190 | }
191 | ```
192 | 
193 | These lines define a function named `main`. The `main` function is special: it
194 | is always the first code that runs in every executable Cairo program. Here, the
195 | first line declares a function named `main` that has no parameters and returns
196 | nothing. If there were parameters, they would go inside the parentheses `()`.
197 | 
198 | The function body is wrapped in `{}`. Cairo requires curly brackets around all
199 | function bodies. Its good style to place the opening curly bracket on the same
200 | line as the function declaration, adding one space in between.
201 | 
202 | > Note: If you want to stick to a standard style across Cairo projects, you can
203 | > use the automatic formatter tool available with `scarb fmt` to format your code in a
204 | > particular style (more on `scarb fmt` in
205 | > [Appendix F][devtools]). The Cairo team has included this tool
206 | > with the standard Cairo distribution, as `cairo-run` is, so it should already be
207 | > installed on your computer!
208 | 
209 | The body of the `main` function holds the following code:
210 | 
211 | ```cairo,noplayground
212 |     println!("Hello, World!");
213 | ```
214 | 
215 | This line does all the work in this little program: it prints text to the
216 | screen. There are four important details to notice here.
217 | 
218 | First, Cairo style is to indent with four spaces, not a tab.
219 | 
220 | Second, `println!` calls a Cairo macro. If it had called a function instead, it would be entered as `println` (without the `!`).
221 | Well discuss Cairo macros in more detail in the ["Macros"][macros] chapter. For now, you just need to know that using a `!` means that youre calling a macro instead of a normal function and that macros dont always follow the same rules as functions.
222 | 
223 | Third, you see the `"Hello, world!"` string. We pass this string as an argument to `println!`, and the string is printed to the screen.
224 | 
225 | Fourth, we end the line with a semicolon (`;`), which indicates that this
226 | expression is over and the next one is ready to begin. Most lines of Cairo code
227 | end with a semicolon.
228 | 
229 | [devtools]: ./appendix-06-useful-development-tools.md
230 | [macros]: ./ch11-05-macros.md
231 | 
232 | {{#quiz ../quizzes/ch01-02-hello-world.toml}}
233 | 
234 | # Summary
235 | 
236 | Lets recap what weve learned so far about Scarb:
237 | 
238 | - We can install one or multiple Scarb versions, either the latest stable or a specific one, using asdf.
239 | - We can create a project using `scarb new`.
240 | - We can build a project using `scarb build` to generate the compiled Sierra code.
241 | - We can execute a Cairo program using the `scarb cairo-run` command.
242 | 
243 | An additional advantage of using Scarb is that the commands are the same no matter which operating system youre working on. So, at this point, well no longer provide specific instructions for Linux and macOS versus Windows.
244 | 
245 | Youre already off to a great start on your Cairo journey! This is a great time to build a more substantial program to get used to reading and writing Cairo code.
246 | 


--------------------------------------------------------------------------------
/src/ch02-00-common-programming-concepts.md:
--------------------------------------------------------------------------------
1 | # Common Programming Concepts
2 | 
3 | This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Cairo, but well discuss them in the context of Cairo and explain the conventions around using these concepts.
4 | 
5 | Specifically, youll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Cairo program, and learning them early will give you a strong core to start from.
6 | 


--------------------------------------------------------------------------------
/src/ch02-01-variables-and-mutability.md:
--------------------------------------------------------------------------------
  1 | # Variables and Mutability
  2 | 
  3 | Cairo uses an immutable memory model, meaning that once a memory cell is written to,
  4 | it can't be overwritten but only read from. To reflect this immutable memory model,
  5 | variables in Cairo are immutable by default.
  6 | However, the language abstracts this model and gives you the option to make your
  7 | variables mutable. Lets explore how and why Cairo enforces immutability, and how
  8 | you can make your variables mutable.
  9 | 
 10 | When a variable is immutable, once a value is bound to a name, you cant change
 11 | that value. To illustrate this, generate a new project called _variables_ in
 12 | your _cairo_projects_ directory by using `scarb new variables`.
 13 | 
 14 | Then, in your new _variables_ directory, open _src/lib.cairo_ and replace its
 15 | code with the following code, which wont compile just yet:
 16 | 
 17 | <span class="filename">Filename: src/lib.cairo</span>
 18 | 
 19 | ```cairo,does_not_compile
 20 | {{#include ../listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo}}
 21 | 
 22 | ```
 23 | 
 24 | Save and run the program using `scarb cairo-run`. You should receive an error message
 25 | regarding an immutability error, as shown in this output:
 26 | 
 27 | ```shell
 28 | {{#include ../listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/output.txt}}
 29 | ```
 30 | 
 31 | This example shows how the compiler helps you find errors in your programs.
 32 | Compiler errors can be frustrating, but they only mean your program
 33 | isnt safely doing what you want it to do yet; they do _not_ mean that youre
 34 | not a good programmer! Experienced Caironautes still get compiler errors.
 35 | 
 36 | You received the error message `Cannot assign to an immutable variable.`
 37 | because you tried to assign a second value to the immutable `x` variable.
 38 | 
 39 | Its important that we get compile-time errors when we attempt to change a
 40 | value thats designated as immutable because this specific situation can lead to
 41 | bugs. If one part of our code operates on the assumption that a value will
 42 | never change and another part of our code changes that value, its possible
 43 | that the first part of the code wont do what it was designed to do. The cause
 44 | of this kind of bug can be difficult to track down after the fact, especially
 45 | when the second piece of code changes the value only _sometimes_.
 46 | 
 47 | Cairo, unlike most other languages, has immutable memory. This makes a
 48 | whole class of bugs impossible, because values will never change unexpectedly.
 49 | This makes code easier to reason about.
 50 | 
 51 | But mutability can be very useful, and can make code more convenient to write.
 52 | Although variables are immutable by default, you can make them mutable by
 53 | adding `mut` in front of the variable name. Adding `mut` also conveys
 54 | intent to future readers of the code by indicating that other parts of the code
 55 | will be changing the value associated to this variable.
 56 | 
 57 | <!-- TODO: add an illustration of this -->
 58 | 
 59 | However, you might be wondering at this point what exactly happens when a variable
 60 | is declared as `mut`, as we previously mentioned that Cairo's memory is immutable.
 61 | The answer is that the _value_ is immutable, but the _variable_ isn't. The value
 62 | associated to the variable can be changed. Assigning to a mutable variable in Cairo
 63 | is essentially equivalent to redeclaring it to refer to another value in another memory cell,
 64 | but the compiler handles that for you, and the keyword `mut` makes it explicit.
 65 | Upon examining the low-level Cairo Assembly code, it becomes clear that
 66 | variable mutation is implemented as syntactic sugar, which translates mutation operations
 67 | into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo
 68 | level, the variable is not redeclared so its type cannot change.
 69 | 
 70 | For example, lets change _src/lib.cairo_ to the following:
 71 | 
 72 | ```cairo
 73 | {{#include ../listings/ch02-common-programming-concepts/no_listing_02_adding_mut/src/lib.cairo}}
 74 | ```
 75 | 
 76 | When we run the program now, we get this:
 77 | 
 78 | ```shell
 79 | {{#include ../listings/ch02-common-programming-concepts/no_listing_02_adding_mut/output.txt}}
 80 | ```
 81 | 
 82 | Were allowed to change the value bound to `x` from `5` to `6` when `mut` is
 83 | used. Ultimately, deciding whether to use mutability or not is up to you and
 84 | depends on what you think is clearest in that particular situation.
 85 | 
 86 | ## Constants
 87 | 
 88 | Like immutable variables, _constants_ are values that are bound to a name and
 89 | are not allowed to change, but there are a few differences between constants
 90 | and variables.
 91 | 
 92 | First, you arent allowed to use `mut` with constants. Constants arent just
 93 | immutable by defaulttheyre always immutable. You declare constants using the
 94 | `const` keyword instead of the `let` keyword, and the type of the value _must_
 95 | be annotated. Well cover types and type annotations in the next section,
 96 | [Data Types][data-types], so dont worry about the details
 97 | right now. Just know that you must always annotate the type.
 98 | 
 99 | Constant variables can be declared with any usual data type, including structs, enums and fixed-size arrays.
100 | 
101 | Constants can only be declared in the global scope, which makes
102 | them useful for values that many parts of code need to know about.
103 | 
104 | The last difference is that constants may natively be set only to a constant expression,
105 | not the result of a value that could only be computed at runtime.
106 | 
107 | Heres an example of constants declaration:
108 | 
109 | ```cairo,noplayground
110 | {{#include ../listings/ch02-common-programming-concepts/no_listing_00_consts/src/lib.cairo:const_expressions}}
111 | ```
112 | 
113 | Nonetheless, it is possible to use the `consteval_int!` macro to create a `const` variable that is the result of some computation:
114 | 
115 | ```cairo, noplayground
116 | {{#include ../listings/ch02-common-programming-concepts/no_listing_00_consts/src/lib.cairo:consteval_const}}
117 | ```
118 | 
119 | We will dive into more detail about macros in the [dedicated section](./ch11-05-macros.md).
120 | 
121 | Cairo's naming convention for constants is to use all uppercase with underscores between words.
122 | 
123 | Constants are valid for the entire time a program runs, within the scope in
124 | which they were declared. This property makes constants useful for values in
125 | your application domain that multiple parts of the program might need to know
126 | about, such as the maximum number of points any player of a game is allowed to
127 | earn, or the speed of light.
128 | 
129 | Naming hardcoded values used throughout your program as constants is useful in
130 | conveying the meaning of that value to future maintainers of the code. It also
131 | helps to have only one place in your code you would need to change if the
132 | hardcoded value needed to be updated in the future.
133 | 
134 | [data-types]: ./ch02-02-data-types.md
135 | 
136 | ## Shadowing
137 | 
138 | Variable shadowing refers to the declaration of a
139 | new variable with the same name as a previous variable. Caironautes say that the
140 | first variable is _shadowed_ by the second, which means that the second
141 | variable is what the compiler will see when you use the name of the variable.
142 | In effect, the second variable overshadows the first, taking any uses of the
143 | variable name to itself until either it itself is shadowed or the scope ends.
144 | We can shadow a variable by using the same variables name and repeating the
145 | use of the `let` keyword as follows:
146 | 
147 | ```cairo
148 | {{#include ../listings/ch02-common-programming-concepts/no_listing_03_shadowing/src/lib.cairo}}
149 | ```
150 | 
151 | This program first binds `x` to a value of `5`. Then it creates a new variable
152 | `x` by repeating `let x =`, taking the original value and adding `1` so the
153 | value of `x` is then `6`. Then, within an inner scope created with the curly
154 | brackets, the third `let` statement also shadows `x` and creates a new
155 | variable, multiplying the previous value by `2` to give `x` a value of `12`.
156 | When that scope is over, the inner shadowing ends and `x` returns to being `6`.
157 | When we run this program, it will output the following:
158 | 
159 | ```shell
160 | {{#include ../listings/ch02-common-programming-concepts/no_listing_03_shadowing/output.txt}}
161 | ```
162 | 
163 | Shadowing is different from marking a variable as `mut` because well get a
164 | compile-time error if we accidentally try to reassign to this variable without
165 | using the `let` keyword. By using `let`, we can perform a few transformations
166 | on a value but have the variable be immutable after those transformations have
167 | been completed.
168 | 
169 | Another distinction between `mut` and shadowing is that when we use the `let` keyword again,
170 | we are effectively creating a new variable, which allows us to change the type of the
171 | value while reusing the same name. As mentioned before, variable shadowing and mutable variables
172 | are equivalent at the lower level.
173 | The only difference is that by shadowing a variable, the compiler will not complain
174 | if you change its type. For example, say our program performs a type conversion between the
175 | `u64` and `felt252` types.
176 | 
177 | ```cairo
178 | {{#include ../listings/ch02-common-programming-concepts/no_listing_04_shadowing_different_type/src/lib.cairo}}
179 | ```
180 | 
181 | The first `x` variable has a `u64` type while the second `x` variable has a `felt252` type.
182 | Shadowing thus spares us from having to come up with different names, such as `x_u64`
183 | and `x_felt252`; instead, we can reuse the simpler `x` name. However, if we try to use
184 | `mut` for this, as shown here, well get a compile-time error:
185 | 
186 | ```cairo,does_not_compile
187 | {{#include ../listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo}}
188 | ```
189 | 
190 | The error says we were expecting a `u64` (the original type) but we got a different type:
191 | 
192 | ```shell
193 | {{#include ../listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/output.txt}}
194 | ```
195 | 
196 | {{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}
197 | 
198 | Now that weve explored how variables work, lets look at more data types they can have.
199 | 


--------------------------------------------------------------------------------
/src/ch02-02-data-types.md:
--------------------------------------------------------------------------------
  1 | # Data Types
  2 | 
  3 | Every value in Cairo is of a certain _data type_, which tells Cairo what kind of
  4 | data is being specified so it knows how to work with that data. This section covers two subsets of data types: scalars and compounds.
  5 | 
  6 | Keep in mind that Cairo is a _statically typed_ language, which means that it
  7 | must know the types of all variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In cases when many types are possible, we can use a conversion method where we specify the desired output type.
  8 | 
  9 | ```cairo
 10 | {{#include ../listings/ch02-common-programming-concepts/no_listing_06_data_types/src/lib.cairo}}
 11 | ```
 12 | 
 13 | Youll see different type annotations for other data types.
 14 | 
 15 | ## Scalar Types
 16 | 
 17 | A _scalar_ type represents a single value. Cairo has three primary scalar types:
 18 | felts, integers, and booleans. You may recognize
 19 | these from other programming languages. Lets jump into how they work in Cairo.
 20 | 
 21 | ### Felt Type
 22 | 
 23 | In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword `felt252`. In the context of Cairo, when we say a field element we mean an integer in the range \\( 0 \leq x < P \\),
 24 | where \\( P \\) is a very large prime number currently equal to \\( {2^{251}} + 17 \cdot {2^{192}} + 1 \\). When adding, subtracting, or multiplying, if the result falls outside the specified range of the prime number, an overflow (or underflow) occurs, and an appropriate multiple of \\( P \\) is added or subtracted to bring the result back within the range (i.e., the result is computed \\( \mod P \\) ).
 25 | 
 26 | The most important difference between integers and field elements is division: Division of field elements (and therefore division in Cairo) is unlike regular CPUs division, where
 27 | integer division \\( \frac{x}{y} \\) is defined as \\( \left\lfloor \frac{x}{y} \right\rfloor \\)
 28 | where the integer part of the quotient is returned (so you get \\( \frac{7}{3} = 2 \\)) and it may or may not satisfy the equation \\( \frac{x}{y} \cdot y == x \\),
 29 | depending on the divisibility of `x` by `y`.
 30 | 
 31 | In Cairo, the result of \\( \frac{x}{y} \\) is defined to always satisfy the equation \\( \frac{x}{y} \cdot y == x \\). If y divides x as integers, you will get the expected result in Cairo (for example \\( \frac{6}{2} \\) will indeed result in `3`).
 32 | But when y does not divide x, you may get a surprising result: for example, since \\( 2 \cdot \frac{P + 1}{2} = P + 1 \equiv 1 \mod P \\), the value of \\( \frac{1}{2} \\) in Cairo is \\( \frac{P + 1}{2} \\) (and not 0 or 0.5), as it satisfies the above equation.
 33 | 
 34 | ### Integer Types
 35 | 
 36 | The felt252 type is a fundamental type that serves as the basis for creating all types in the core library.
 37 | However, it is highly recommended for programmers to use the integer types instead of the `felt252` type whenever possible, as the `integer` types come with added security features that provide extra protection against potential vulnerabilities in the code, such as overflow and underflow checks. By using these integer types, programmers can ensure that their programs are more secure and less susceptible to attacks or other security threats.
 38 | An `integer` is a number without a fractional component. This type declaration indicates the number of bits the programmer can use to store the integer.
 39 | Table 3-1 shows the built-in integer types in Cairo. We can use any of these variants to declare the type of an integer value.
 40 | 
 41 | | Length  | Unsigned |
 42 | | ------- | -------- |
 43 | | 8-bit   | `u8`     |
 44 | | 16-bit  | `u16`    |
 45 | | 32-bit  | `u32`    |
 46 | | 64-bit  | `u64`    |
 47 | | 128-bit | `u128`   |
 48 | | 256-bit | `u256`   |
 49 | | 32-bit  | `usize`  |
 50 | 
 51 | <br>
 52 | <div align="center"><span class="caption">Table 3-1: Integer Types in Cairo.</span></div>
 53 | 
 54 | Each variant has an explicit size. Note that for now, the `usize` type is just an alias for `u32`; however, it might be useful when in the future Cairo can be compiled to MLIR.
 55 | As variables are unsigned, they can't contain a negative number. This code will cause the program to panic:
 56 | 
 57 | ```cairo
 58 | {{#include ../listings/ch02-common-programming-concepts/no_listing_07_integer_types/src/lib.cairo}}
 59 | ```
 60 | 
 61 | All integer types previously mentioned fit into a `felt252`, except for `u256` which needs 4 more bits to be stored. Under the hood, `u256` is basically a struct with 2 fields: `u256 {low: u128, high: u128}`.
 62 | 
 63 | Cairo also provides support for signed integers, starting with the prefix `i`. These integers can represent both positive and negative values, with sizes ranging from `i8` to `i128`.
 64 | Each signed variant can store numbers from \\( -({2^{n - 1}}) \\) to \\( {2^{n - 1}} - 1 \\) inclusive, where `n` is the number of bits that variant uses. So an i8 can store numbers from \\( -({2^7}) \\) to \\( {2^7} - 1 \\), which equals `-128` to `127`.
 65 | 
 66 | You can write integer literals in any of the forms shown in Table 3-2. Note
 67 | that number literals that can be multiple numeric types allow a type suffix,
 68 | such as `57_u8`, to designate the type.
 69 | It is also possible to use a visual separator `_` for number literals, in order to improve code readability.
 70 | 
 71 | | Numeric literals | Example   |
 72 | | ---------------- | --------- |
 73 | | Decimal          | `98222`   |
 74 | | Hex              | `0xff`    |
 75 | | Octal            | `0o04321` |
 76 | | Binary           | `0b01`    |
 77 | 
 78 | <br>
 79 | <div align="center"><span class="caption">Table 3-2: Integer Literals in Cairo.</span></div>
 80 | 
 81 | So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the good size.
 82 | The primary situation in which youd use `usize` is when indexing some sort of collection.
 83 | 
 84 | ### Numeric Operations
 85 | 
 86 | Cairo supports the basic mathematical operations youd expect for all the integer
 87 | types: addition, subtraction, multiplication, division, and remainder. Integer
 88 | division truncates toward zero to the nearest integer. The following code shows
 89 | how youd use each numeric operation in a `let` statement:
 90 | 
 91 | ```cairo
 92 | {{#include ../listings/ch02-common-programming-concepts/no_listing_08_numeric_operations/src/lib.cairo}}
 93 | ```
 94 | 
 95 | Each expression in these statements uses a mathematical operator and evaluates
 96 | to a single value, which is then bound to a variable.
 97 | 
 98 | [Appendix B][operators] contains a list of all operators that Cairo provides.
 99 | 
100 | [operators]: ./appendix-02-operators-and-symbols.md#operators
101 | 
102 | ### The Boolean Type
103 | 
104 | As in most other programming languages, a Boolean type in Cairo has two possible
105 | values: `true` and `false`. Booleans are one `felt252` in size. The Boolean type in
106 | Cairo is specified using `bool`. For example:
107 | 
108 | ```cairo
109 | {{#include ../listings/ch02-common-programming-concepts/no_listing_09_boolean_type/src/lib.cairo}}
110 | ```
111 | 
112 | When declaring a `bool` variable, it is mandatory to use either `true` or `false` literals as value. Hence, it is not allowed to use integer literals (i.e. `0` instead of false) for `bool` declarations.
113 | 
114 | The main way to use Boolean values is through conditionals, such as an `if`
115 | expression. Well cover how `if` expressions work in Cairo in the ["Control Flow"][control-flow] section.
116 | 
117 | [control-flow]: ./ch02-05-control-flow.md
118 | 
119 | ### String Types
120 | 
121 | Cairo doesn't have a native type for strings but provides two ways to handle them: short strings using simple quotes and ByteArray using double quotes.
122 | 
123 | #### Short strings
124 | 
125 | A short string is an ASCII string where each character is encoded on one byte (see the [ASCII table][ascii]). For example:
126 | 
127 | - `'a'` is equivalent to `0x61`
128 | - `'b'` is equivalent to `0x62`
129 | - `'c'` is equivalent to `0x63`
130 | - `0x616263` is equivalent to `'abc'`.
131 | 
132 | Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits, a short string is limited to 31 characters (31 \* 8 = 248 bits, which is the maximum multiple of 8 that fits in 251 bits).
133 | 
134 | You can choose to represent your short string with an hexadecimal value like `0x616263` or by directly writing the string using simple quotes like `'abc'`, which is more convenient.
135 | 
136 | Here are some examples of declaring short strings in Cairo:
137 | 
138 | ```cairo
139 | {{#rustdoc_include ../listings/ch02-common-programming-concepts/no_listing_10_short_string_type/src/lib.cairo:2:6}}
140 | ```
141 | 
142 | [ascii]: https://www.asciitable.com/
143 | 
144 | #### Byte Array Strings
145 | 
146 | Cairo's Core Library provides a `ByteArray` type for handling strings and byte sequences longer than short strings. This type is particularly useful for longer strings or when you need to perform operations on the string data.
147 | 
148 | The `ByteArray` in Cairo is implemented as a combination of two parts:
149 | 
150 | 1. An array of `bytes31` words, where each word contains 31 bytes of data.
151 | 2. A pending `felt252` word that acts as a buffer for bytes that haven't yet filled a complete `bytes31` word.
152 | 
153 | This design enables efficient handling of byte sequences while aligning with Cairo's memory model and basic types. Developers interact with `ByteArray` through its provided methods and operators, abstracting away the internal implementation details.
154 | 
155 | Unlike short strings, `ByteArray` strings can contain more than 31 characters and are written using double quotes:
156 | 
157 | ```cairo
158 | {{#rustdoc_include ../listings/ch02-common-programming-concepts/no_listing_10_short_string_type/src/lib.cairo:8:8}}
159 | ```
160 | 
161 | ## Compound Types
162 | 
163 | ### The Tuple Type
164 | 
165 | A _tuple_ is a general way of grouping together a number of values with a
166 | variety of types into one compound type. Tuples have a fixed length: once
167 | declared, they cannot grow or shrink in size.
168 | 
169 | We create a tuple by writing a comma-separated list of values inside
170 | parentheses. Each position in the tuple has a type, and the types of the
171 | different values in the tuple dont have to be the same. Weve added optional
172 | type annotations in this example:
173 | 
174 | ```cairo
175 | {{#include ../listings/ch02-common-programming-concepts/no_listing_12_tuple_type/src/lib.cairo}}
176 | ```
177 | 
178 | The variable `tup` binds to the entire tuple because a tuple is considered a
179 | single compound element. To get the individual values out of a tuple, we can
180 | use pattern matching to destructure a tuple value, like this:
181 | 
182 | ```cairo
183 | {{#include ../listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration/src/lib.cairo}}
184 | ```
185 | 
186 | This program first creates a tuple and binds it to the variable `tup`. It then
187 | uses a pattern with `let` to take `tup` and turn it into three separate
188 | variables, `x`, `y`, and `z`. This is called _destructuring_ because it breaks
189 | the single tuple into three parts. Finally, the program prints `y is 6!` as the value of
190 | `y` is `6`.
191 | 
192 | We can also declare the tuple with value and types, and destructure it at the same time.
193 | For example:
194 | 
195 | ```cairo
196 | {{#include ../listings/ch02-common-programming-concepts/no_listing_14_tuple_types/src/lib.cairo}}
197 | ```
198 | 
199 | #### The Unit Type ()
200 | 
201 | A _unit type_ is a type which has only one value `()`.
202 | It is represented by a tuple with no elements.
203 | Its size is always zero, and it is guaranteed to not exist in the compiled code.
204 | 
205 | You might be wondering why you would even need a unit type? In Cairo, everything is an expression, and an expression that returns nothing actually returns `()` implicitly.
206 | 
207 | ### The Fixed Size Array Type
208 | 
209 | Another way to have a collection of multiple values is with a _fixed size array_. Unlike a tuple, every element of a fixed size array must have the same type.
210 | 
211 | We write the values in a fixed-size array as a comma-separated list inside square brackets. The arrays type is written using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:
212 | 
213 | ```cairo
214 | {{#include ../listings/ch02-common-programming-concepts/no_listing_40_fixed_size_arr_type/src/lib.cairo}}
215 | ```
216 | 
217 | In the type annotation `[u64; 5]`, `u64` specifies the type of each element, while `5` after the semicolon defines the array's length. This syntax ensures that the array always contains exactly 5 elements of type `u64`.
218 | 
219 | Fixed size arrays are useful when you want to hardcode a potentially long sequence of data directly in your program. This type of array must not be confused with the [`Array<T>` type][arrays], which is a similar collection type provided by the core library that _is_ allowed to grow in size. If you're unsure whether to use a fixed size array or the `Array<T>` type, chances are that you are looking for the `Array<T>` type.
220 | 
221 | Because their size is known at compile-time, fixed-size arrays don't require runtime memory management, which makes them more efficient than dynamically-sized arrays. Overall, they're more useful when you know the number of elements will not need to change. For example, they can be used to efficiently store lookup tables that won't change during runtime. If you were using the names of the month in a program, you would probably use a fixed size array rather than an `Array<T>` because you know it will always contain 12 elements:
222 | 
223 | ```cairo
224 | {{#include ../listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/src/lib.cairo:months}}
225 | ```
226 | 
227 | You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:
228 | 
229 | ```cairo
230 | {{#include ../listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/src/lib.cairo:repeated_values}}
231 | ```
232 | 
233 | The array named `a` will contain `5` elements that will all be set to the value `3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a more concise way.
234 | 
235 | #### Accessing Fixed Size Arrays Elements
236 | 
237 | As a fixed-size array is a data structure known at compile time, it's content is represented as a sequence of values in the program bytecode. Accessing an element of that array will simply read that value from the program bytecode efficiently.
238 | 
239 | We have two different ways of accessing fixed size array elements:
240 | 
241 | - Deconstructing the array into multiple variables, as we did with tuples.
242 | 
243 | ```cairo
244 | {{#include ../listings/ch02-common-programming-concepts/no_listing_42_fixed_size_arr_accessing_elements/src/lib.cairo}}
245 | ```
246 | 
247 | - Converting the array to a [Span][span], that supports indexing. This operation is _free_ and doesn't incur any runtime cost.
248 | 
249 | ```cairo
250 | {{#include ../listings/ch02-common-programming-concepts/no_listing_44_fixed_size_arr_accessing_elements_span/src/lib.cairo}}
251 | ```
252 | 
253 | Note that if we plan to repeatedly access the array, then it makes sense to call `.span()` only once and keep it available throughout the accesses.
254 | 
255 | ## Type Conversion
256 | 
257 | Cairo addresses conversion between types by using the `try_into` and `into` methods provided by the `TryInto` and `Into` traits from the core library. There are numerous implementations of these traits within the standard library for conversion between types, and they can be implemented for [custom types as well][custom-type-conversion].
258 | 
259 | ### Into
260 | 
261 | The `Into` trait allows for a type to define how to convert itself into another type. It can be used for type conversion when success is guaranteed, such as when the source type is smaller than the destination type.
262 | 
263 | To perform the conversion, call `var.into()` on the source value to convert it to another type. The new variable's type must be explicitly defined, as demonstrated in the example below.
264 | 
265 | ```cairo
266 | {{#include ../listings/ch02-common-programming-concepts/no_listing_11_into/src/lib.cairo}}
267 | ```
268 | 
269 | ### TryInto
270 | 
271 | Similar to `Into`, `TryInto` is a generic trait for converting between types. Unlike `Into`, the `TryInto` trait is used for fallible conversions, and as such, returns [Option\<T\>][option]. An example of a fallible conversion is when the target type might not fit the source value.
272 | 
273 | Also similar to `Into` is the process to perform the conversion; just call `var.try_into()` on the source value to convert it to another type. The new variable's type also must be explicitly defined, as demonstrated in the example below.
274 | 
275 | ```cairo
276 | {{#include ../listings/ch02-common-programming-concepts/no_listing_39_tryinto/src/lib.cairo}}
277 | ```
278 | 
279 | {{#quiz ../quizzes/ch02-02-data-types.toml}}
280 | 
281 | [arrays]: ./ch03-01-arrays.md
282 | [option]: ./ch06-01-enums.md#the-option-enum-and-its-advantages
283 | [custom-type-conversion]: ./ch05-02-an-example-program-using-structs.md#conversions-of-custom-types
284 | [span]: ./ch03-01-arrays.md#Span
285 | 


--------------------------------------------------------------------------------
/src/ch02-03-functions.md:
--------------------------------------------------------------------------------
  1 | # Functions
  2 | 
  3 | Functions are prevalent in Cairo code. Youve already seen one of the most
  4 | important functions in the language: the `main` function, which is the entry
  5 | point of many programs. Youve also seen the `fn` keyword, which allows you to
  6 | declare new functions.
  7 | 
  8 | Cairo code uses _snake case_ as the conventional style for function and variable
  9 | names, in which all letters are lowercase and underscores separate words.
 10 | Heres a program that contains an example function definition:
 11 | 
 12 | ```cairo
 13 | {{#include ../listings/ch02-common-programming-concepts/no_listing_15_functions/src/lib.cairo}}
 14 | ```
 15 | 
 16 | We define a function in Cairo by entering `fn` followed by a function name and a
 17 | set of parentheses. The curly brackets tell the compiler where the function
 18 | body begins and ends.
 19 | 
 20 | We can call any function weve defined by entering its name followed by a set
 21 | of parentheses. Because `another_function` is defined in the program, it can be
 22 | called from inside the `main` function. Note that we defined `another_function`
 23 | _before_ the `main` function in the source code; we could have defined it after
 24 | as well. Cairo doesnt care where you define your functions, only that theyre
 25 | defined somewhere in a scope that can be seen by the caller.
 26 | 
 27 | Lets start a new project with Scarb named _functions_ to explore functions
 28 | further. Place the `another_function` example in _src/lib.cairo_ and run it. You
 29 | should see the following output:
 30 | 
 31 | ```shell
 32 | {{#include ../listings/ch02-common-programming-concepts/no_listing_15_functions/output.txt}}
 33 | ```
 34 | 
 35 | The lines execute in the order in which they appear in the `main` function.
 36 | First the `Hello, world!` message prints, and then `another_function` is called
 37 | and its message is printed.
 38 | 
 39 | ## Parameters
 40 | 
 41 | We can define functions to have _parameters_, which are special variables that
 42 | are part of a functions signature. When a function has parameters, you can
 43 | provide it with concrete values for those parameters. Technically, the concrete
 44 | values are called _arguments_, but in casual conversation, people tend to use
 45 | the words _parameter_ and _argument_ interchangeably for either the variables
 46 | in a functions definition or the concrete values passed in when you call a
 47 | function.
 48 | 
 49 | In this version of `another_function` we add a parameter:
 50 | 
 51 | ```cairo
 52 | {{#include ../listings/ch02-common-programming-concepts/no_listing_16_single_param/src/lib.cairo}}
 53 | ```
 54 | 
 55 | Try running this program; you should get the following output:
 56 | 
 57 | ```shell
 58 | {{#include ../listings/ch02-common-programming-concepts/no_listing_16_single_param/output.txt}}
 59 | ```
 60 | 
 61 | The declaration of `another_function` has one parameter named `x`. The type of
 62 | `x` is specified as `felt252`. When we pass `5` in to `another_function`, the
 63 | `println!` macro puts `5` where the pair of curly brackets containing `x` was in the format string.
 64 | 
 65 | In function signatures, you _must_ declare the type of each parameter. This is
 66 | a deliberate decision in Cairos design: requiring type annotations in function
 67 | definitions means the compiler almost never needs you to use them elsewhere in
 68 | the code to figure out what type you mean. The compiler is also able to give
 69 | more helpful error messages if it knows what types the function expects.
 70 | 
 71 | When defining multiple parameters, separate the parameter declarations with
 72 | commas, like this:
 73 | 
 74 | ```cairo
 75 | {{#include ../listings/ch02-common-programming-concepts/no_listing_17_multiple_params/src/lib.cairo}}
 76 | ```
 77 | 
 78 | This example creates a function named `print_labeled_measurement` with two
 79 | parameters. The first parameter is named `value` and is a `u128`. The second is
 80 | named `unit_label` and is of type `ByteArray` - Cairo's internal type to represent string literals. The function then prints text containing both the `value` and the `unit_label`.
 81 | 
 82 | Lets try running this code. Replace the program currently in your _functions_
 83 | projects _src/lib.cairo_ file with the preceding example and run it using `scarb cairo-run`:
 84 | 
 85 | ```shell
 86 | {{#include ../listings/ch02-common-programming-concepts/no_listing_17_multiple_params/output.txt}}
 87 | ```
 88 | 
 89 | Because we called the function with `5` as the value for value and `"h"` as the value for `unit_label`, the program output contains those values.
 90 | 
 91 | ### Named Parameters
 92 | 
 93 | In Cairo, named parameters allow you to specify the names of arguments when you call a function. This makes the function calls more readable and self-descriptive.
 94 | If you want to use named parameters, you need to specify the name of the parameter and the value you want to pass to it. The syntax is `parameter_name: value`. If you pass a variable that has the same name as the parameter, you can simply write `:parameter_name` instead of `parameter_name: variable_name`.
 95 | 
 96 | Here is an example:
 97 | 
 98 | ```cairo
 99 | {{#include ../listings/ch02-common-programming-concepts/no_listing_18_named_parameters/src/lib.cairo}}
100 | ```
101 | 
102 | ## Statements and Expressions
103 | 
104 | Function bodies are made up of a series of statements optionally ending in an
105 | expression. So far, the functions weve covered havent included an ending
106 | expression, but you have seen an expression as part of a statement. Because
107 | Cairo is an expression-based language, this is an important distinction to
108 | understand. Other languages dont have the same distinctions, so lets look at
109 | what statements and expressions are and how their differences affect the bodies
110 | of functions.
111 | 
112 | - **Statements** are instructions that perform some action and do not return
113 |   a value.
114 | - **Expressions** evaluate to a resultant value. Lets look at some examples.
115 | 
116 | Weve actually already used statements and expressions. Creating a variable and
117 | assigning a value to it with the `let` keyword is a statement. In Listing {{#ref fn-main}},
118 | `let y = 6;` is a statement.
119 | 
120 | ```cairo
121 | {{#include ../listings/ch02-common-programming-concepts/no_listing_19_statement/src/lib.cairo}}
122 | ```
123 | 
124 | {{#label fn-main}}
125 | <span class="caption">Listing {{#ref fn-main}}: A `main` function declaration containing one statement</span>
126 | 
127 | Function definitions are also statements; the entire preceding example is a statement in itself.
128 | 
129 | Statements do not return values. Therefore, you cant assign a `let` statement
130 | to another variable, as the following code tries to do; youll get an error:
131 | 
132 | ```cairo, noplayground
133 | {{#include ../listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo}}
134 | ```
135 | 
136 | When you run this program, the error youll get looks like this:
137 | 
138 | ```shell
139 | {{#include ../listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/output.txt}}
140 | ```
141 | 
142 | The `let y = 6` statement does not return a value, so there isnt anything for
143 | `x` to bind to. This is different from what happens in other languages, such as
144 | C and Ruby, where the assignment returns the value of the assignment. In those
145 | languages, you can write `x = y = 6` and have both `x` and `y` have the value
146 | `6`; that is not the case in Cairo.
147 | 
148 | Expressions evaluate to a value and make up most of the rest of the code that
149 | youll write in Cairo. Consider a math operation, such as `5 + 6`, which is an
150 | expression that evaluates to the value `11`. Expressions can be part of
151 | statements: in Listing {{#ref fn-main}}, the `6` in the statement `let y = 6;` is an
152 | expression that evaluates to the value `6`.
153 | 
154 | Calling a function is an expression since it always evaluates to a value: the function's explicit return value, if specified, or the 'unit' type `()` otherwise.
155 | 
156 | A new scope block created with curly brackets is an expression, for example:
157 | 
158 | ```cairo
159 | {{#include ../listings/ch02-common-programming-concepts/no_listing_21_blocks_are_expressions/src/lib.cairo:all}}
160 | ```
161 | 
162 | This expression:
163 | 
164 | ```cairo, noplayground
165 | {{#include ../listings/ch02-common-programming-concepts/no_listing_21_blocks_are_expressions/src/lib.cairo:block_expr}}
166 | ```
167 | 
168 | is a block that, in this case, evaluates to `4`. That value gets bound to `y`
169 | as part of the `let` statement. Note that the `x + 1` line doesnt have a
170 | semicolon at the end, which is unlike most of the lines youve seen so far.
171 | Expressions do not include ending semicolons. If you add a semicolon to the end
172 | of an expression, you turn it into a statement, and it will then not return a
173 | value. Keep this in mind as you explore function return values and expressions
174 | next.
175 | 
176 | ## Functions with Return Values
177 | 
178 | Functions can return values to the code that calls them. We dont name return
179 | values, but we must declare their type after an arrow (`->`). In Cairo, the
180 | return value of the function is synonymous with the value of the final
181 | expression in the block of the body of a function. You can return early from a
182 | function by using the `return` keyword and specifying a value, but most
183 | functions return the last expression implicitly. Heres an example of a
184 | function that returns a value:
185 | 
186 | ```cairo
187 | {{#include ../listings/ch02-common-programming-concepts/no_listing_22_function_return_values/src/lib.cairo}}
188 | ```
189 | 
190 | There are no function calls, or even `let` statements in the `five`
191 | functionjust the number `5` by itself. Thats a perfectly valid function in
192 | Cairo. Note that the functions return type is specified too, as `-> u32`. Try
193 | running this code; the output should look like this:
194 | 
195 | ```shell
196 | {{#include ../listings/ch02-common-programming-concepts/no_listing_22_function_return_values/output.txt}}
197 | ```
198 | 
199 | The `5` in `five` is the functions return value, which is why the return type
200 | is `u32`. Lets examine this in more detail. There are two important bits:
201 | first, the line `let x = five();` shows that were using the return value of a
202 | function to initialize a variable. Because the function `five` returns a `5`,
203 | that line is the same as the following:
204 | 
205 | ```cairo, noplayground
206 | let x = 5;
207 | ```
208 | 
209 | Second, the `five` function has no parameters and defines the type of the
210 | return value, but the body of the function is a lonely `5` with no semicolon
211 | because its an expression whose value we want to return.
212 | Lets look at another example:
213 | 
214 | ```cairo
215 | {{#include ../listings/ch02-common-programming-concepts/no_listing_23_function_return_values_2/src/lib.cairo}}
216 | ```
217 | 
218 | Running this code will print `x = 6`. But if we place a
219 | semicolon at the end of the line containing `x + 1`, changing it from an
220 | expression to a statement, well get an error:
221 | 
222 | ```cairo,does_not_compile
223 | {{#include ../listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo}}
224 | ```
225 | 
226 | ```shell
227 | {{#include ../listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/output.txt}}
228 | ```
229 | 
230 | The main error message, `Unexpected return type`, reveals the core issue with this
231 | code. The definition of the function `plus_one` says that it will return an
232 | `u32`, but statements dont evaluate to a value, which is expressed by `()`,
233 | the unit type. Therefore, nothing is returned, which contradicts the function
234 | definition and results in an error.
235 | 
236 | {{#quiz ../quizzes/ch02-03-functions.toml}}
237 | 


--------------------------------------------------------------------------------
/src/ch02-04-comments.md:
--------------------------------------------------------------------------------
 1 | # Comments
 2 | 
 3 | All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave comments in their source code that the compiler will ignore but people reading the source code may find useful.
 4 | 
 5 | Heres a simple comment:
 6 | 
 7 | ```cairo,noplayground
 8 | // hello, world
 9 | ```
10 | 
11 | In Cairo, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, youll need to include `//` on each line, like this:
12 | 
13 | ```cairo,noplayground
14 | // So were doing something complicated here, long enough that we need
15 | // multiple lines of comments to do it! Whew! Hopefully, this comment will
16 | // explain whats going on.
17 | ```
18 | 
19 | Comments can also be placed at the end of lines containing code:
20 | 
21 | ```cairo
22 | {{#include ../listings/ch02-common-programming-concepts/no_listing_25_comments/src/lib.cairo}}
23 | ```
24 | 
25 | But youll more often see them used in this format, with the comment on a separate line above the code its annotating:
26 | 
27 | ```cairo
28 | {{#include ../listings/ch02-common-programming-concepts/no_listing_26_comments/src/lib.cairo}}
29 | ```
30 | 
31 | ## Item-level Documentation
32 | 
33 | Item-level documentation comments refer to specific items such as functions, implementations, traits, etc. They are prefixed with three slashes (`///`). These comments provide a detailed description of the item, examples of usage, and any conditions that might cause a panic. In case of functions, the comments may also include separate sections for parameter and return value descriptions.
34 | 
35 | ```cairo,noplayground
36 | {{#include ../listings/ch02-common-programming-concepts/no_listing_37_item_doc_comments/src/lib.cairo}}
37 | ```
38 | 
39 | ## Module Documentation
40 | 
41 | Module documentation comments provide an overview of the entire module, including its purpose and examples of use. These comments are meant to be placed above the module they're describing and are prefixed with `//!`. This type of documentation gives a broad understanding of what the module does and how it can be used.
42 | 
43 | ```cairo,noplayground
44 | {{#include ../listings/ch02-common-programming-concepts/no_listing_38_mod_doc_comments/src/lib.cairo}}
45 | ```
46 | 
47 | {{#quiz ../quizzes/ch02-04-comments.toml}}
48 | 


--------------------------------------------------------------------------------
/src/ch02-05-control-flow.md:
--------------------------------------------------------------------------------
  1 | # Control Flow
  2 | 
  3 | The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops.
  4 | 
  5 | ## `if` Expressions
  6 | 
  7 | An if expression allows you to branch your code depending on conditions. You provide a condition and then state, If this condition is met, run this block of code. If the condition is not met, do not run this block of code.
  8 | 
  9 | Create a new project called _branches_ in your _cairo_projects_ directory to explore the `if` expression. In the _src/lib.cairo_ file, input the following:
 10 | 
 11 | ```cairo
 12 | {{#include ../listings/ch02-common-programming-concepts/no_listing_27_if/src/lib.cairo}}
 13 | ```
 14 | 
 15 | All `if` expressions start with the keyword `if`, followed by a condition. In this case, the condition checks whether or not the variable `number` has a value equal to 5. We place the block of code to execute if the condition is `true` immediately after the condition inside curly brackets.
 16 | 
 17 | Optionally, we can also include an `else` expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to `false`. If you dont provide an `else` expression and the condition is `false`, the program will just skip the `if` block and move on to the next bit of code.
 18 | 
 19 | Try running this code; you should see the following output:
 20 | 
 21 | ```shell
 22 | {{#include ../listings/ch02-common-programming-concepts/no_listing_27_if/output.txt}}
 23 | ```
 24 | 
 25 | Lets try changing the value of `number` to a value that makes the condition `true` to see what happens:
 26 | 
 27 | ```cairo, noplayground
 28 |     let number = 5;
 29 | ```
 30 | 
 31 | ```shell
 32 | $ scarb cairo-run
 33 | condition was true and number = 5
 34 | Run completed successfully, returning []
 35 | ```
 36 | 
 37 | Its also worth noting that the condition in this code must be a `bool`. If the condition isnt a `bool`, well get an error. For example, try running the following code:
 38 | 
 39 | ```cairo
 40 | {{#include ../listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo}}
 41 | ```
 42 | 
 43 | The `if` condition evaluates to a value of 3 this time, and Cairo throws an error:
 44 | 
 45 | ```shell
 46 | {{#include ../listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/output.txt}}
 47 | ```
 48 | 
 49 | The error indicates that Cairo inferred the type of `number` to be a `bool`
 50 | based on its later use as a condition of the `if` statement. It tries to create
 51 | a `bool` from the value `3`, but Cairo doesn't support instantiating a `bool`
 52 | from a numeric literal anyway - you can only use `true` or `false` to create a
 53 | `bool`. Unlike languages such as Ruby and JavaScript, Cairo will not
 54 | automatically try to convert non-Boolean types to a Boolean. If we want the `if`
 55 | code block to run only when a number is not equal to 0, for example, we can
 56 | change the if expression to the following:
 57 | 
 58 | ```cairo
 59 | {{#include ../listings/ch02-common-programming-concepts/no_listing_29_ter_if_not_equal_zero/src/lib.cairo}}
 60 | 
 61 | ```
 62 | 
 63 | Running this code will print `number was something other than zero`.
 64 | 
 65 | ## Handling Multiple Conditions with `else if`
 66 | 
 67 | You can use multiple conditions by combining `if` and `else` in an `else if` expression. For example:
 68 | 
 69 | ```cairo
 70 | {{#include ../listings/ch02-common-programming-concepts/no_listing_30_else_if/src/lib.cairo}}
 71 | ```
 72 | 
 73 | This program has four possible paths it can take. After running it, you should see the following output:
 74 | 
 75 | ```shell
 76 | {{#include ../listings/ch02-common-programming-concepts/no_listing_30_else_if/output.txt}}
 77 | ```
 78 | 
 79 | When this program executes, it checks each `if` expression in turn and executes the first body for which the condition evaluates to `true`. Note that even though `number - 2 == 1` is `true`, we dont see the output `number minus 2 is 1` nor do we see the `number not found` text from the `else` block. Thats because Cairo only executes the block for the first true condition, and once it finds one, it doesnt even check the rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want to refactor your code. [Chapter {{#chap enums-and-pattern-matching}}][match] describes a powerful Cairo branching construct called `match` for these cases.
 80 | 
 81 | [match]: ./ch06-02-the-match-control-flow-construct.md
 82 | 
 83 | ## Using `if` in a `let` Statement
 84 | 
 85 | Because `if` is an expression, we can use it on the right side of a `let` statement to assign the outcome to a variable.
 86 | 
 87 | ```cairo
 88 | {{#include ../listings/ch02-common-programming-concepts/no_listing_31_if_let/src/lib.cairo}}
 89 | ```
 90 | 
 91 | ```shell
 92 | {{#include ../listings/ch02-common-programming-concepts/no_listing_31_if_let/output.txt}}
 93 | ```
 94 | 
 95 | The `number` variable will be bound to a value based on the outcome of the `if` expression, which will be 5 here.
 96 | 
 97 | ## Repetition with Loops
 98 | 
 99 | Its often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and then start immediately back at the beginning. To experiment with loops, lets create a new project called _loops_.
100 | 
101 | Cairo has three kinds of loops: `loop`, `while`, and `for`. Lets try each one.
102 | 
103 | ### Repeating Code with `loop`
104 | 
105 | The `loop` keyword tells Cairo to execute a block of code over and over again forever or until you explicitly tell it to stop.
106 | 
107 | As an example, change the _src/lib.cairo_ file in your _loops_ directory to look like this:
108 | 
109 | ```cairo
110 | {{#include ../listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/src/lib.cairo}}
111 | ```
112 | 
113 | When we run this program, well see `again!` printed over and over continuously until either the program runs out of gas or we stop the program manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. Give it a try:
114 | 
115 | ```shell
116 | $ scarb cairo-run --available-gas=20000000
117 |    Compiling loops v0.1.0 (file:///projects/loops)
118 |     Finished release target(s) in 0 seconds
119 |      Running loops
120 | again!
121 | again!
122 | again!
123 | ^Cagain!
124 | ```
125 | 
126 | The symbol `^C` represents where you pressed ctrl-c. You may or may not see the word `again!` printed after the ^C, depending on where the code was in the loop when it received the interrupt signal.
127 | 
128 | > Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a program. By setting a value to the `--available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In the previous case, we set the gas limit high enough for the program to run for quite some time.
129 | 
130 | > It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network.
131 | > If you're writing a program that needs to run a loop, you will need to execute it with the `--available-gas` flag set to a value that is large enough to run the program.
132 | 
133 | Now, try running the same program again, but this time with the `--available-gas` flag set to `200000` instead of `2000000000000`. You will see the program only prints `again!` 3 times before it stops, as it ran out of gas to keep executing the loop.
134 | 
135 | Fortunately, Cairo also provides a way to break out of a loop using code. You can place the `break` keyword within the loop to tell the program when to stop executing the loop.
136 | 
137 | ```cairo
138 | {{#include ../listings/ch02-common-programming-concepts/no_listing_33_loop_break/src/lib.cairo}}
139 | ```
140 | 
141 | The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration.
142 | Let's add a `continue` statement to our loop to skip the `println!` statement when `i` is equal to `5`.
143 | 
144 | ```cairo
145 | {{#include ../listings/ch02-common-programming-concepts/no_listing_34_loop_continue/src/lib.cairo}}
146 | ```
147 | 
148 | Executing this program will not print the value of `i` when it is equal to `5`.
149 | 
150 | ### Returning Values from Loops
151 | 
152 | One of the uses of a `loop` is to retry an operation you know might fail, such
153 | as checking whether an operation has succeeded. You might also need to pass
154 | the result of that operation out of the loop to the rest of your code. To do
155 | this, you can add the value you want returned after the `break` expression you
156 | use to stop the loop; that value will be returned out of the loop so you can
157 | use it, as shown here:
158 | 
159 | ```cairo
160 | {{#include ../listings/ch02-common-programming-concepts/no_listing_35_loop_return_values/src/lib.cairo}}
161 | ```
162 | 
163 | Before the loop, we declare a variable named `counter` and initialize it to
164 | `0`. Then we declare a variable named `result` to hold the value returned from
165 | the loop. On every iteration of the loop, we check whether the `counter` is equal to `10`, and then add `1` to the `counter` variable.
166 | When the condition is met, we use the `break` keyword with the value `counter * 2`. After the loop, we use a
167 | semicolon to end the statement that assigns the value to `result`. Finally, we
168 | print the value in `result`, which in this case is `20`.
169 | 
170 | ### Conditional Loops with `while`
171 | 
172 | A program will often need to evaluate a condition within a loop.
173 | While the condition is `true`, the loop runs.
174 | When the condition ceases to be `true`, the program calls `break`, stopping the loop.
175 | Its possible to implement behavior like this using a combination of `loop`, `if`, `else`, and `break`; you could try that now in a program, if youd like.
176 | However, this pattern is so common that Cairo has a built-in language construct for it, called a `while` loop.
177 | 
178 | In Listing {{#ref while-true}}, we use `while` to loop the program three times, counting down each time after printing the value of `number`, and then, after the loop, print a message and exit.
179 | 
180 | ```cairo
181 | {{#include ../listings/ch02-common-programming-concepts/no_listing_36_while_loop/src/lib.cairo}}
182 | ```
183 | 
184 | {{#label while-true}}
185 | <span class="caption">Listing {{#ref while-true}}: Using a `while` loop to run code while a condition holds `true`.</span>
186 | 
187 | This construct eliminates a lot of nesting that would be necessary if you used `loop`, `if`, `else`, and `break`, and its clearer.
188 | While a condition evaluates to `true`, the code runs; otherwise, it exits the loop.
189 | 
190 | ### Looping Through a Collection with `for`
191 | 
192 | You can also use the while construct to loop over the elements of a collection, such as an array. For example, the loop in Listing {{#ref iter-while}} prints each element in the array `a`.
193 | 
194 | ```cairo
195 | {{#include ../listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/src/lib.cairo}}
196 | ```
197 | 
198 | {{#label iter-while}}
199 | <span class="caption">Listing {{#ref iter-while}}: Looping through each element of a collection using a `while` loop</span>
200 | 
201 | Here, the code counts up through the elements in the array. It starts at index `0`, and then loops until it reaches the final index in the array (that is, when `index < 5` is no longer `true`). Running this code will print every element in the array:
202 | 
203 | ```shell
204 | {{#include ../listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/output.txt}}
205 | ```
206 | 
207 | All five array values appear in the terminal, as expected. Even though `index` will reach a value of `5` at some point, the loop stops executing before trying to fetch a sixth value from the array.
208 | 
209 | However, this approach is error prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the `a` array to have four elements but forgot to update the condition to `while index < 4`, the code would panic. Its also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.
210 | 
211 | As a more concise alternative, you can use a `for` loop and execute some code for each item in a collection. A `for` loop looks like the code in Listing {{#ref iter-for}}.
212 | 
213 | ```cairo
214 | {{#include ../listings/ch02-common-programming-concepts/no_listing_46_iter_loop_for/src/lib.cairo}}
215 | ```
216 | 
217 | {{#label iter-for}}
218 | <span class="caption">Listing {{#ref iter-for}}: Looping through each element of a collection using a `for` loop</span>
219 | 
220 | When we run this code, well see the same output as in Listing {{#ref iter-while}}. More importantly, weve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.
221 | 
222 | Using the `for` loop, you wouldnt need to remember to change any other code if you changed the number of values in the array, as you would with the method used in Listing {{#ref iter-while}}.
223 | 
224 | The safety and conciseness of `for` loops make them the most commonly used loop construct in Cairo. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a while loop in Listing {{#ref while-true}}. Another way to run code a certain number of times would be to use a `Range`, provided by the core library, which generates all numbers in sequence starting from one number and ending before another number.
225 | 
226 | Heres how you can use a `Range` to count from 1 to 3:
227 | 
228 | ```cairo
229 | {{#include ../listings/ch02-common-programming-concepts/no_listing_47_for_range/src/lib.cairo}}
230 | ```
231 | 
232 | This code is a bit nicer, isnt it?
233 | 
234 | ## Equivalence Between Loops and Recursive Functions
235 | 
236 | Loops and recursive functions are two common ways to repeat a block of code multiple times. The `loop` keyword is used to create an infinite loop that can be broken by using the `break` keyword.
237 | 
238 | ```cairo
239 | {{#include ../listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/examples/loop_example.cairo}}
240 | ```
241 | 
242 | Loops can be transformed into recursive functions by calling the function within itself. Here is an example of a recursive function that mimics the behavior of the `loop` example above.
243 | 
244 | ```cairo
245 | {{#include ../listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/examples/recursion_example.cairo}}
246 | ```
247 | 
248 | In both cases, the code block will run indefinitely until the condition `x == 2` is met, at which point the value of x will be displayed.
249 | 
250 | In Cairo, loops and recursions are not only conceptually equivalent: they are also compiled down to similar low-level representations. To understand this, we can compile both examples to Sierra, and analyze the Sierra Code generated by the Cairo compiler for both examples. Add the following in your `Scarb.toml` file:
251 | 
252 | ```toml
253 | [lib]
254 | sierra-text = true
255 | ```
256 | 
257 | Then, run `scarb build` to compile both examples. You will find the Sierra code generated by for both examples is extremely similar, as the loop is compiled to a recursive function in the Sierra statements.
258 | 
259 | > Note: For our example, our findings came from understanding the **statements** section in Sierra that shows the execution traces of the two programs. If you are curious to learn more about Sierra, check out [Exploring Sierra](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5).
260 | 
261 | {{#quiz ../quizzes/ch02-05-control-flow.toml}}
262 | 
263 | ## Summary
264 | 
265 | You made it! This was a sizable chapter: you learned about variables, data types, functions, comments,
266 | `if` expressions and loops! To practice with the concepts discussed in this chapter,
267 | try building programs to do the following:
268 | 
269 | - Generate the _n_-th Fibonacci number.
270 | - Compute the factorial of a number _n_.
271 | 
272 | Now, well review the common collection types in Cairo in the next chapter.
273 | 


--------------------------------------------------------------------------------
/src/ch03-00-common-collections.md:
--------------------------------------------------------------------------------
1 | # Common Collections
2 | 
3 | Cairo provides a set of common collection types that can be used to store and manipulate data. These collections are designed to be efficient, flexible, and easy to use. This section introduces the primary collection types available in Cairo: Arrays and Dictionaries.
4 | 


--------------------------------------------------------------------------------
/src/ch03-01-arrays.md:
--------------------------------------------------------------------------------
  1 | # Arrays
  2 | 
  3 | An array is a collection of elements of the same type. You can create and use array methods by using the `ArrayTrait` trait from the core library.
  4 | 
  5 | An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose values can't be modified.
  6 | This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items from the front.
  7 | 
  8 | ## Creating an Array
  9 | 
 10 | Creating an array is done with the `ArrayTrait::new()` call. Here's an example of creating an array and appending 3 elements to it:
 11 | 
 12 | ```cairo
 13 | {{#include ../listings/ch03-common-collections/no_listing_01_array_new_append/src/lib.cairo}}
 14 | ```
 15 | 
 16 | When required, you can pass the expected type of items inside the array when instantiating the array like this, or explicitly define the type of the variable.
 17 | 
 18 | ```cairo, noplayground
 19 | let mut arr = ArrayTrait::<u128>::new();
 20 | ```
 21 | 
 22 | ```cairo, noplayground
 23 | let mut arr:Array<u128> = ArrayTrait::new();
 24 | ```
 25 | 
 26 | ## Updating an Array
 27 | 
 28 | ### Adding Elements
 29 | 
 30 | To add an element to the end of an array, you can use the `append()` method:
 31 | 
 32 | ```cairo
 33 | {{#rustdoc_include ../listings/ch03-common-collections/no_listing_01_array_new_append/src/lib.cairo:5}}
 34 | ```
 35 | 
 36 | ### Removing Elements
 37 | 
 38 | You can only remove elements from the front of an array by using the `pop_front()` method.
 39 | This method returns an `Option` that can be unwrapped, containing the removed element, or `Option::None` if the array is empty.
 40 | 
 41 | ```cairo
 42 | {{#include ../listings/ch03-common-collections/no_listing_02_array_pop_front/src/lib.cairo}}
 43 | ```
 44 | 
 45 | The above code will print `The first value is 10` as we remove the first element that was added.
 46 | 
 47 | In Cairo, memory is immutable, which means that it is not possible to modify the elements of an array once they've been added. You can only add elements to the end of an array and remove elements from the front of an array. These operations do not require memory mutation, as they involve updating pointers rather than directly modifying the memory cells.
 48 | 
 49 | ## Reading Elements from an Array
 50 | 
 51 | To access array elements, you can use `get()` or `at()` array methods that return different types. Using `arr.at(index)` is equivalent to using the subscripting operator `arr[index]`.
 52 | 
 53 | ### `get()` Method
 54 | 
 55 | The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the ["References and Snapshots"][snapshots] chapter.
 56 | 
 57 | Here is an example with the `get()` method:
 58 | 
 59 | ```cairo
 60 | {{#include ../listings/ch03-common-collections/no_listing_03_array_get/src/lib.cairo}}
 61 | ```
 62 | 
 63 | [snapshots]: ./ch04-02-references-and-snapshots.md#snapshots
 64 | 
 65 | ### `at()` Method
 66 | 
 67 | The `at` function, and its equivalent the subscripting operator, on the other hand, directly return a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.
 68 | 
 69 | ```cairo
 70 | {{#include ../listings/ch03-common-collections/no_listing_04_array_at/src/lib.cairo}}
 71 | ```
 72 | 
 73 | In this example, the variable named `first` will get the value `0` because that
 74 | is the value at index `0` in the array. The variable named `second` will get
 75 | the value `1` from index `1` in the array.
 76 | 
 77 | In summary, use `at` when you want to panic on out-of-bounds access attempts, and use `get` when you prefer to handle such cases gracefully without panicking.
 78 | 
 79 | ## Size-related Methods
 80 | 
 81 | To determine the number of elements in an array, use the `len()` method. The return value is of type `usize`.
 82 | 
 83 | If you want to check if an array is empty or not, you can use the `is_empty()` method, which returns `true` if the array is empty and `false` otherwise.
 84 | 
 85 | ## `array!` Macro
 86 | 
 87 | Sometimes, we need to create arrays with values that are already known at compile time. The basic way of doing that is redundant. You would first declare the array and then append each value one by one. `array!` is a simpler way of doing this task by combining the two steps.
 88 | At compile-time, the compiler will expand the macro to generate the code that appends the items sequentially.
 89 | 
 90 | Without `array!`:
 91 | 
 92 | ```cairo
 93 | {{#include ../listings/ch03-common-collections/no_listing_06_array_macro/src/lib.cairo:no_macro}}
 94 | ```
 95 | 
 96 | With `array!`:
 97 | 
 98 | ```cairo
 99 | {{#include ../listings/ch03-common-collections/no_listing_06_array_macro/src/lib.cairo:array_macro}}
100 | ```
101 | 
102 | ## Storing Multiple Types with Enums
103 | 
104 | If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. Enums will be explained in more detail in the ["Enums and Pattern Matching"][enums] chapter.
105 | 
106 | ```cairo
107 | {{#include ../listings/ch03-common-collections/no_listing_07_array_with_enums/src/lib.cairo}}
108 | ```
109 | 
110 | [enums]: ./ch06-00-enums-and-pattern-matching.md
111 | 
112 | ## Span
113 | 
114 | `Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations, as introduced in ["References and Snapshots"][references].
115 | 
116 | All methods provided by `Array` can also be used with `Span`, except for the `append()` method.
117 | 
118 | [references]: ./ch04-02-references-and-snapshots.md
119 | 
120 | ### Turning an Array into Span
121 | 
122 | To create a `Span` of an `Array`, call the `span()` method:
123 | 
124 | ```cairo
125 | {{#rustdoc_include ../listings/ch03-common-collections/no_listing_08_array_span/src/lib.cairo:3}}
126 | ```
127 | 
128 | {{#quiz ../quizzes/ch03-01-arrays.toml}}
129 | 


--------------------------------------------------------------------------------
/src/ch03-02-dictionaries.md:
--------------------------------------------------------------------------------
  1 | # Dictionaries
  2 | 
  3 | Cairo provides in its core library a dictionary-like type. The `Felt252Dict<T>` data type represents a collection of key-value pairs where each key is unique and associated with a corresponding value. This type of data structure is known differently across different programming languages such as maps, hash tables, associative arrays and many others.
  4 | 
  5 | The `Felt252Dict<T>` type is useful when you want to organize your data in a certain way for which using an `Array<T>` and indexing doesn't suffice. Cairo dictionaries also allow the programmer to easily simulate the existence of mutable memory when there is none.
  6 | 
  7 | ## Basic Use of Dictionaries
  8 | 
  9 | It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to `felt252`, leaving only the possibility to specify the value data type, represented by `T` in `Felt252Dict<T>`.
 10 | 
 11 | The core functionality of a `Felt252Dict<T>` is implemented in the trait `Felt252DictTrait` which includes all basic operations. Among them we can find:
 12 | 
 13 | 1. `insert(felt252, T) -> ()` to write values to a dictionary instance and
 14 | 2. `get(felt252) -> T` to read values from it.
 15 | 
 16 | These functions allow us to manipulate dictionaries like in any other language. In the following example, we create a dictionary to represent a mapping between individuals and their balance:
 17 | 
 18 | ```cairo
 19 | {{#include ../listings/ch03-common-collections/no_listing_09_intro/src/lib.cairo}}
 20 | ```
 21 | 
 22 | We can create a new instance of `Felt252Dict<u64>` by using the `default` method of the `Default` trait and add two individuals, each one with their own balance, using the `insert` method. Finally, we check the balance of our users with the `get` method. These methods are defined in the `Felt252DictTrait` trait in the core library.
 23 | 
 24 | Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the `Felt252Dict<T>` type represents a way to overcome this obstacle. We will explain how this is implemented later on in ["Dictionaries Underneath"][dict underneath].
 25 | 
 26 | Building upon our previous example, let us show a code example where the balance of the same user changes:
 27 | 
 28 | ```cairo
 29 | {{#include ../listings/ch03-common-collections/no_listing_10_intro_rewrite/src/lib.cairo}}
 30 | ```
 31 | 
 32 | Notice how in this example we added the 'Alex' individual twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! `Felt252Dict<T>` effectively allows us to "rewrite" the stored value for any given key.
 33 | 
 34 | Before heading on and explaining how dictionaries are implemented it is worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the scenes all keys have their associated values initialized as zero. This means that if for example, you tried to get the balance of an inexistent user you will get 0 instead of an error or an undefined value. This also means there is no way to delete data from a dictionary. Something to take into account when incorporating this structure into your code.
 35 | 
 36 | Until this point, we have seen all the basic features of `Felt252Dict<T>` and how it mimics the same behavior as the corresponding data structures in any other language, that is, externally of course. Cairo is at its core a non-deterministic Turing-complete programming language, very different from any other popular language in existence, which as a consequence means that dictionaries are implemented very differently as well!
 37 | 
 38 | In the following sections, we are going to give some insights about `Felt252Dict<T>` inner mechanisms and the compromises that were taken to make them work. After that, we are going to take a look at how to use dictionaries with other data structures as well as use the `entry` method as another way to interact with them.
 39 | 
 40 | [dict underneath]: ./ch03-02-dictionaries.md#dictionaries-underneath
 41 | 
 42 | ## Dictionaries Underneath
 43 | 
 44 | One of the constraints of Cairo's non-deterministic design is that its memory system is immutable, so in order to simulate mutability, the language implements `Felt252Dict<T>` as a list of entries. Each of the entries represents a time when a dictionary was accessed for reading/updating/writing purposes. An entry has three fields:
 45 | 
 46 | 1. A `key` field that identifies the key for this key-value pair of the dictionary.
 47 | 2. A `previous_value` field that indicates which previous value was held at `key`.
 48 | 3. A `new_value` field that indicates the new value that is held at `key`.
 49 | 
 50 | If we try implementing `Felt252Dict<T>` using high-level structures we would internally define it as `Array<Entry<T>>` where each `Entry<T>` has information about what key-value pair it represents and the previous and new values it holds. The definition of `Entry<T>` would be:
 51 | 
 52 | ```cairo,noplayground
 53 | {{#include ../listings/ch03-common-collections/no_listing_11_entries/src/lib.cairo:struct}}
 54 | ```
 55 | 
 56 | For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be registered:
 57 | 
 58 | - A `get` would register an entry where there is no change in state, and previous and new values are stored with the same value.
 59 | - An `insert` would register a new `Entry<T>` where the `new_value` would be the element being inserted, and the `previous_value` the last element inserted before this. In case it is the first entry for a certain key, then the previous value will be zero.
 60 | 
 61 | The use of this entry list shows how there isn't any rewriting, just the creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an example of this using the `balances` dictionary from the previous section and inserting the users 'Alex' and 'Maria':
 62 | 
 63 | ```cairo
 64 | {{#rustdoc_include ../listings/ch03-common-collections/no_listing_11_entries/src/lib.cairo:inserts}}
 65 | ```
 66 | 
 67 | These instructions would then produce the following list of entries:
 68 | 
 69 | |  key  | previous | new |
 70 | | :---: | -------- | --- |
 71 | | Alex  | 0        | 100 |
 72 | | Maria | 0        | 50  |
 73 | | Alex  | 100      | 200 |
 74 | | Maria | 50       | 50  |
 75 | 
 76 | Notice that since 'Alex' was inserted twice, it appears twice and the `previous` and `current` values are set properly. Also reading from 'Maria' registered an entry with no change from previous to current values.
 77 | 
 78 | This approach to implementing `Felt252Dict<T>` means that for each read/write operation, there is a scan for the whole entry list in search of the last entry with the same `key`. Once the entry has been found, its `new_value` is extracted and used on the new entry to be added as the `previous_value`. This means that interacting with `Felt252Dict<T>` has a worst-case time complexity of `O(n)` where `n` is the number of entries in the list.
 79 | 
 80 | If you pour some thought into alternate ways of implementing `Felt252Dict<T>` you'd surely find them, probably even ditching completely the need for a `previous_value` field, nonetheless, since Cairo is not your normal language this won't work.
 81 | One of the purposes of Cairo is, with the STARK proof system, to generate proofs of computational integrity. This means that you need to verify that program execution is correct and inside the boundaries of Cairo restrictions. One of those boundary checks consists of "dictionary squashing" and that requires information on both previous and new values for every entry.
 82 | 
 83 | ## Squashing Dictionaries
 84 | 
 85 | To verify that the proof generated by a Cairo program execution that used a `Felt252Dict<T>` is correct, we need to check that there wasn't any illegal tampering with the dictionary. This is done through a method called `squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution.
 86 | 
 87 | The process of squashing is as follows: given all entries with certain key `k`, taken in the same order as they were inserted, verify that the ith entry `new_value` is equal to the ith + 1 entry `previous_value`.
 88 | 
 89 | For example, given the following entry list:
 90 | 
 91 | |   key   | previous | new |
 92 | | :-----: | -------- | --- |
 93 | |  Alex   | 0        | 150 |
 94 | |  Maria  | 0        | 100 |
 95 | | Charles | 0        | 70  |
 96 | |  Maria  | 100      | 250 |
 97 | |  Alex   | 150      | 40  |
 98 | |  Alex   | 40       | 300 |
 99 | |  Maria  | 250      | 190 |
100 | |  Alex   | 300      | 90  |
101 | 
102 | After squashing, the entry list would be reduced to:
103 | 
104 | |   key   | previous | new |
105 | | :-----: | -------- | --- |
106 | |  Alex   | 0        | 90  |
107 | |  Maria  | 0        | 190 |
108 | | Charles | 0        | 70  |
109 | 
110 | In case of a change on any of the values of the first table, squashing would have failed during runtime.
111 | 
112 | ## Dictionary Destruction
113 | 
114 | If you run the examples from ["Basic Use of Dictionaries"][basic dictionaries] section, you'd notice that there was never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the scene was that squash was called automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call occurred just before the `balance` dictionary went out of scope.
115 | 
116 | The `Destruct<T>` trait represents another way of removing instances out of scope apart from `Drop<T>`. The main difference between these two is that `Drop<T>` is treated as a no-op operation, meaning it does not generate new CASM while `Destruct<T>` does not have this restriction. The only type which actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these traits in [Drop and Destruct][drop destruct] section of Appendix C.
117 | 
118 | Later in ["Dictionaries as Struct Members"][dictionaries in structs] section, we will have a hands-on example where we implement the `Destruct<T>` trait for a custom type.
119 | 
120 | [basic dictionaries]: ./ch03-02-dictionaries.md#basic-use-of-dictionaries
121 | [drop destruct]: ./appendix-03-derivable-traits.md#drop-and-destruct
122 | [dictionaries in structs]: ./ch11-01-custom-data-structures.md#dictionaries-as-struct-members
123 | 
124 | ## More Dictionaries
125 | 
126 | Up to this point, we have given a comprehensive overview of the functionality of `Felt252Dict<T>` as well as how and why it is implemented in a certain way. If you haven't understood all of it, don't worry because in this section we will have some more examples using dictionaries.
127 | 
128 | We will start by explaining the `entry` method which is part of a dictionary basic functionality included in `Felt252DictTrait<T>` which we didn't mention at the beginning. Soon after, we will see examples of how to use `Felt252Dict<T>` with other [complex types][nullable dictionaries values] such as `Array<T>`.
129 | 
130 | [nullable dictionaries values]: ./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively
131 | 
132 | ## Entry and Finalize
133 | 
134 | In the ["Dictionaries Underneath"][dict underneath] section, we explained how `Felt252Dict<T>` internally worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The Cairo language gives us the tools to replicate this ourselves through the `entry` and `finalize` methods.
135 | 
136 | The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose of creating a new entry given a certain key. Once called, this method takes ownership of the dictionary and returns the entry to update. The method signature is as follows:
137 | 
138 | ```cairo,noplayground
139 | fn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic
140 | ```
141 | 
142 | The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a `Felt252DictEntry<T>`, which is the type used by Cairo to represent dictionary entries, and a `T` representing the value held previously.
143 | The `nopanic` notation simply indicates that the function is guaranteed to never panic.
144 | 
145 | The next thing to do is to update the entry with the new value. For this, we use the `finalize` method which inserts the entry and returns ownership of the dictionary:
146 | 
147 | ```cairo,noplayground
148 | fn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T>
149 | ```
150 | 
151 | This method receives the entry and the new value as parameters, and returns the updated dictionary.
152 | 
153 | Let us see an example using `entry` and `finalize`. Imagine we would like to implement our own version of the `get` method from a dictionary. We should then do the following:
154 | 
155 | 1. Create the new entry to add using the `entry` method.
156 | 2. Insert back the entry where the `new_value` equals the `previous_value`.
157 | 3. Return the value.
158 | 
159 | Implementing our custom get would look like this:
160 | 
161 | ```cairo,noplayground
162 | {{#include ../listings/ch03-common-collections/no_listing_12_custom_methods/src/lib.cairo:imports}}
163 | 
164 | {{#include ../listings/ch03-common-collections/no_listing_12_custom_methods/src/lib.cairo:custom_get}}
165 | ```
166 | 
167 | The `ref` keyword means that the ownership of the variable will be given back at the end of
168 | the function. This concept will be explained in more detail in the ["References and Snapshots"][references] section.
169 | 
170 | Implementing the `insert` method would follow a similar workflow, except for inserting a new value when finalizing. If we were to implement it, it would look like the following:
171 | 
172 | ```cairo,noplayground
173 | {{#include ../listings/ch03-common-collections/no_listing_12_custom_methods/src/lib.cairo:imports}}
174 | 
175 | {{#include ../listings/ch03-common-collections/no_listing_12_custom_methods/src/lib.cairo:custom_insert}}
176 | ```
177 | 
178 | As a finalizing note, these two methods are implemented in a similar way to how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows some example usage:
179 | 
180 | ```cairo
181 | {{#rustdoc_include ../listings/ch03-common-collections/no_listing_12_custom_methods/src/lib.cairo:main}}
182 | ```
183 | 
184 | [dict underneath]: ./ch03-02-dictionaries.md#dictionaries-underneath
185 | [references]: ./ch04-02-references-and-snapshots.md
186 | 
187 | ## Dictionaries of Types not Supported Natively
188 | 
189 | One restriction of `Felt252Dict<T>` that we haven't talked about is the trait `Felt252DictValue<T>`.
190 | This trait defines the `zero_default` method which is the one that gets called when a value does not exist in the dictionary.
191 | This is implemented by some common data types, such as most unsigned integers, `bool` and `felt252` - but it is not implemented for more complex types such as arrays, structs (including `u256`), and other types from the core library.
192 | This means that making a dictionary of types not natively supported is not a straightforward task, because you would need to write a couple of trait implementations in order to make the data type a valid dictionary value type.
193 | To compensate this, you can wrap your type inside a `Nullable<T>`.
194 | 
195 | `Nullable<T>` is a smart pointer type that can either point to a value or be `null` in the absence of value. It is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference with `Option` is that the wrapped value is stored inside a `Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to use a dedicated `boxed_segment` memory segment for our data, and access this segment using a pointer that can only be manipulated in one place at a time. See [Smart Pointers Chapter](./ch11-02-smart-pointers.md) for more information.
196 | 
197 | Let's show using an example. We will try to store a `Span<felt252>` inside a dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are storing a `Span<T>` and not an `Array<T>` because the latter does not implement the `Copy<T>` trait which is required for reading from a dictionary.
198 | 
199 | ```cairo,noplayground
200 | {{#include ../listings/ch03-common-collections/no_listing_13_dict_of_complex/src/lib.cairo:imports}}
201 | 
202 | {{#include ../listings/ch03-common-collections/no_listing_13_dict_of_complex/src/lib.cairo:header}}
203 | 
204 | //...
205 | ```
206 | 
207 | In this code snippet, the first thing we did was to create a new dictionary `d`. We want it to hold a `Nullable<Span>`. After that, we created an array and filled it with values.
208 | 
209 | The last step is inserting the array as a span inside the dictionary. Notice that we do this using the `new` function of the `NullableTrait`.
210 | 
211 | Once the element is inside the dictionary, and we want to get it, we follow the same steps but in reverse order. The following code shows how to achieve that:
212 | 
213 | ```cairo,noplayground
214 | //...
215 | 
216 | {{#include ../listings/ch03-common-collections/no_listing_13_dict_of_complex/src/lib.cairo:footer}}
217 | ```
218 | 
219 | Here we:
220 | 
221 | 1. Read the value using `get`.
222 | 2. Verified it is non-null using the `match_nullable` function.
223 | 3. Unwrapped the value inside the box and asserted it was correct.
224 | 
225 | The complete script would look like this:
226 | 
227 | ```cairo
228 | {{#include ../listings/ch03-common-collections/no_listing_13_dict_of_complex/src/lib.cairo:all}}
229 | ```
230 | 
231 | ## Using Arrays inside Dictionaries
232 | 
233 | In the previous section, we explored how to store and retrieve complex types inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a look at how to store an array inside a dictionary and dynamically modify its contents.
234 | 
235 | Storing arrays in dictionaries in Cairo is slightly different from storing other types. This is because arrays are more complex data structures that require special handling to avoid issues with memory copying and references.
236 | 
237 | First, let's look at how to create a dictionary and insert an array into it. This process is pretty straightforward and follows a similar pattern to inserting other types of data:
238 | 
239 | ```cairo
240 | {{#include ../listings/ch03-common-collections/no_listing_14_dict_of_array_insert/src/lib.cairo}}
241 | ```
242 | 
243 | However, attempting to read an array from the dictionary using the `get` method will result in a compiler error. This is because `get` tries to copy the array in memory, which is not possible for arrays (as we've already mentioned in the [previous section][nullable dictionaries values], `Array<T>` does not implement the `Copy<T>` trait):
244 | 
245 | ```cairo
246 | {{#include ../listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo}}
247 | ```
248 | 
249 | ```shell
250 | {{#include ../listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/output.txt}}
251 | ```
252 | 
253 | To correctly read an array from the dictionary, we need to use dictionary entries. This allows us to get a reference to the array value without copying it:
254 | 
255 | ```cairo,noplayground
256 | {{#include ../listings/ch03-common-collections/no_listing_16_dict_of_array/src/lib.cairo:get}}
257 | ```
258 | 
259 | > Note: We must convert the array to a `Span` before finalizing the entry, because calling `NullableTrait::new(arr)` moves the array, thus making it impossible to return it from the function.
260 | 
261 | To modify the stored array, such as appending a new value, we can use a similar approach. The following `append_value` function demonstrates this:
262 | 
263 | ```cairo,noplayground
264 | {{#include ../listings/ch03-common-collections/no_listing_16_dict_of_array/src/lib.cairo:append}}
265 | ```
266 | 
267 | In the `append_value` function, we access the dictionary entry, dereference the array, append the new value, and finalize the entry with the updated array.
268 | 
269 | > Note: Removing an item from a stored array can be implemented in a similar manner.
270 | 
271 | Below is the complete example demonstrating the creation, insertion, reading, and modification of an array in a dictionary:
272 | 
273 | ```cairo
274 | {{#include ../listings/ch03-common-collections/no_listing_16_dict_of_array/src/lib.cairo:all}}
275 | ```
276 | 
277 | {{#quiz ../quizzes/ch03-02-dictionaries.toml}}
278 | 


--------------------------------------------------------------------------------
/src/ch04-00-understanding-ownership.md:
--------------------------------------------------------------------------------
1 | # Understanding Cairo's Ownership system
2 | 
3 | Cairo is a language built around a linear type system that allows us to
4 | statically ensure that in every Cairo program, a value is used exactly once.
5 | This linear type system helps prevent runtime errors by ensuring that operations that could cause such errors, such as writing twice to a memory cell, are detected at compile time.
6 | This is achieved by implementing an ownership system
7 | and forbidding copying and dropping values by default. In this chapter, well
8 | talk about Cairo's ownership system as well as references and snapshots.
9 | 


--------------------------------------------------------------------------------
/src/ch04-01-what-is-ownership.md:
--------------------------------------------------------------------------------
  1 | # Ownership Using a Linear Type System
  2 | 
  3 | Cairo uses a linear type system. In such a type system, any value (a basic type, a struct, an enum) must be used and must only be used once. 'Used' here means that the value is either _destroyed_ or _moved_.
  4 | 
  5 | _Destruction_ can happen in several ways:
  6 | 
  7 | - a variable goes out of scope.
  8 | - a struct is destructured.
  9 | - explicit destruction using `destruct()`.
 10 | 
 11 | _Moving_ a value simply means passing that value to another function.
 12 | 
 13 | This results in somewhat similar constraints to the Rust ownership model, but there are some differences.
 14 | In particular, the Rust ownership model exists (in part) to avoid data races and concurrent mutable access to a memory value. This is obviously impossible in Cairo since the memory is immutable.
 15 | Instead, Cairo leverages its linear type system for two main purposes:
 16 | 
 17 | - Ensuring that all code is provable and thus verifiable.
 18 | - Abstracting away the immutable memory of the Cairo VM.
 19 | 
 20 | ### Ownership
 21 | 
 22 | In Cairo, ownership applies to _variables_ and not to _values_. A value can safely be referred to by many different variables (even if they are mutable variables), as the value itself is always immutable.
 23 | Variables however can be mutable, so the compiler must ensure that constant variables aren't accidentally modified by the programmer.
 24 | This makes it possible to talk about ownership of a variable: the owner is the code that can read (and write if mutable) the variable.
 25 | 
 26 | This means that variables (not values) follow similar rules to Rust values:
 27 | 
 28 | - Each variable in Cairo has an owner.
 29 | - There can only be one owner at a time.
 30 | - When the owner goes out of scope, the variable is destroyed.
 31 | 
 32 | Now that were past basic Cairo syntax, we wont include all the `fn main() {` code in examples, so if youre following along, make sure to put the following examples inside a main function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.
 33 | 
 34 | ## Variable Scope
 35 | 
 36 | As a first example of the linear type system, well look at the _scope_ of some variables. A
 37 | scope is the range within a program for which an item is valid. Take the
 38 | following variable:
 39 | 
 40 | ```cairo,noplayground
 41 | let s = 'hello';
 42 | ```
 43 | 
 44 | The variable `s` refers to a short string. The variable is valid from the point at
 45 | which its declared until the end of the current _scope_. Listing {{#ref variable-scope}} shows a
 46 | program with comments annotating where the variable `s` would be valid.
 47 | 
 48 | ```cairo
 49 | {{#rustdoc_include ../listings/ch04-understanding-ownership/listing_01_variable_and_scope/src/lib.cairo:here}}
 50 | ```
 51 | 
 52 | {{#label variable-scope}}
 53 | <span class="caption">Listing {{#ref variable-scope}}: A variable and the scope in which it is valid</span>
 54 | 
 55 | In other words, there are two important points in time here:
 56 | 
 57 | - When `s` comes _into_ scope, it is valid.
 58 | - It remains valid until it goes _out of_ scope.
 59 | 
 60 | At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now well build on top of this understanding by using the `Array` type we introduced in the previous ["Arrays"][array] section.
 61 | 
 62 | [array]: ./ch03-01-arrays.md
 63 | 
 64 | ### Moving values
 65 | 
 66 | As said earlier, _moving_ a value simply means passing that value to another function. When that happens, the variable referring to that value in the original scope is destroyed and can no longer be used, and a new variable is created to hold the same value.
 67 | 
 68 | Arrays are an example of a complex type that is moved when passing it to another function.
 69 | Here is a short reminder of what an array looks like:
 70 | 
 71 | ```cairo
 72 | {{#rustdoc_include ../listings/ch04-understanding-ownership/no_listing_01_array/src/lib.cairo:2:4}}
 73 | ```
 74 | 
 75 | How does the type system ensure that the Cairo program never tries to write to the same memory cell twice?
 76 | Consider the following code, where we try to remove the front of the array twice:
 77 | 
 78 | ```cairo,does_not_compile
 79 | {{#include ../listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo}}
 80 | ```
 81 | 
 82 | In this case, we try to pass the same value (the array in the `arr` variable) to both function calls. This means our code tries to remove the first element twice, which would try to write to the same memory cell twice - which is forbidden by the Cairo VM, leading to a runtime error.
 83 | Thankfully, this code does not actually compile. Once we have passed the array to the `foo` function, the variable `arr` is no longer usable. We get this compile-time error, telling us that we would need Array to implement the Copy Trait:
 84 | 
 85 | ```shell
 86 | {{#include ../listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/output.txt}}
 87 | ```
 88 | 
 89 | ## The `Copy` Trait
 90 | 
 91 | The `Copy` trait allows simple types to be duplicated by copying felts, without allocating new memory segments. This contrasts with Cairo's default "move" semantics, which transfer ownership of values to ensure memory safety and prevent issues like multiple writes to the same memory cell. `Copy` is implemented for types where duplication is safe and efficient, bypassing the need for move semantics. Types like `Array` and `Felt252Dict` cannot implement `Copy`, as manipulating them in different scopes is forbidden by the type system.
 92 | 
 93 | All basic types previously described in ["Data Types"][data types] implement by default the `Copy` trait.
 94 | 
 95 | While Arrays and Dictionaries can't be copied, custom types that don't contain either of them can be.
 96 | You can implement the `Copy` trait on your type by adding the `#[derive(Copy)]` annotation to your type definition. However, Cairo won't allow a type to be annotated with Copy if the type itself or any of its components doesn't implement the Copy trait.
 97 | 
 98 | ```cairo,ignore_format
 99 | {{#include ../listings/ch04-understanding-ownership/no_listing_03_copy_trait/src/lib.cairo}}
100 | ```
101 | 
102 | In this example, we can pass `p1` twice to the foo function because the `Point` type implements the `Copy` trait. This means that when we pass `p1` to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In ownership terms, this means that the ownership of `p1` remains with the `main` function.
103 | If you remove the `Copy` trait derivation from the `Point` type, you will get a compile-time error when trying to compile the code.
104 | 
105 | _Don't worry about the `Struct` keyword. We will introduce this in [Chapter {{#chap using-structs-to-structure-related-data}}][structs]._
106 | 
107 | [data types]: ./ch02-02-data-types.md
108 | [structs]: ./ch05-00-using-structs-to-structure-related-data.md
109 | 
110 | ## Destroying Values - Example with FeltDict
111 | 
112 | The other way linear types can be _used_ is by being destroyed. Destruction must ensure that the 'resource' is now correctly released. In Rust, for example, this could be closing the access to a file, or locking a mutex.
113 | In Cairo, one type that has such behaviour is `Felt252Dict`. For provability, dicts must be 'squashed' when they are destructed.
114 | This would be very easy to forget, so it is enforced by the type system and the compiler.
115 | 
116 | ### No-op Destruction: the `Drop` Trait
117 | 
118 | You may have noticed that the `Point` type in the previous example also implements the `Drop` trait.
119 | For example, the following code will not compile, because the struct `A` is not moved or destroyed before it goes out of scope:
120 | 
121 | ```cairo,does_not_compile
122 | {{#include ../listings/ch04-understanding-ownership/no_listing_04_no_drop_derive_fails/src/lib.cairo}}
123 | ```
124 | 
125 | However, types that implement the `Drop` trait are automatically destroyed when going out of scope. This destruction does nothing, it is a no-op - simply a hint to the compiler that this type can safely be destroyed once it's no longer useful. We call this "dropping" a value.
126 | 
127 | At the moment, the `Drop` implementation can be derived for all types, allowing them to be dropped when going out of scope, except for dictionaries (`Felt252Dict`) and types containing dictionaries.
128 | For example, the following code compiles:
129 | 
130 | ```cairo
131 | {{#include ../listings/ch04-understanding-ownership/no_listing_05_drop_derive_compiles/src/lib.cairo}}
132 | ```
133 | 
134 | ### Destruction with a Side-effect: the `Destruct` Trait
135 | 
136 | When a value is destroyed, the compiler first tries to call the `drop` method on that type. If it doesn't exist, then the compiler tries to call `destruct` instead. This method is provided by the `Destruct` trait.
137 | 
138 | As said earlier, dictionaries in Cairo are types that must be "squashed" when destructed, so that the sequence of access can be proven. This is easy for developers to forget, so instead dictionaries implement the `Destruct` trait to ensure that all dictionaries are _squashed_ when going out of scope.
139 | As such, the following example will not compile:
140 | 
141 | ```cairo,does_not_compile
142 | {{#include ../listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/src/lib.cairo}}
143 | ```
144 | 
145 | If you try to run this code, you will get a compile-time error:
146 | 
147 | ```shell
148 | {{#include ../listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/output.txt}}
149 | ```
150 | 
151 | When `A` goes out of scope, it can't be dropped as it implements neither the `Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the `Destruct` trait. To fix this, we can derive the `Destruct` trait implementation for the `A` type:
152 | 
153 | ```cairo
154 | {{#include ../listings/ch04-understanding-ownership/no_listing_07_destruct_compiles/src/lib.cairo}}
155 | ```
156 | 
157 | Now, when `A` goes out of scope, its dictionary will be automatically `squashed`, and the program will compile.
158 | 
159 | ## Copy Array Data with `clone`
160 | 
161 | If we _do_ want to deeply copy the data of an `Array`, we can use a common method called `clone`. Well discuss method syntax in a dedicated section in [Chapter {{#chap using-structs-to-structure-related-data}}][method syntax], but because methods are a common feature in many programming languages, youve probably seen them before.
162 | 
163 | Heres an example of the `clone` method in action.
164 | 
165 | ```cairo
166 | {{#include ../listings/ch04-understanding-ownership/no_listing_08_array_clone/src/lib.cairo}}
167 | ```
168 | 
169 | When you see a call to `clone`, you know that some arbitrary code is being executed and that code may be expensive. Its a visual indicator that something different is going on.
170 | In this case, the _value_ `arr1` refers to is being copied, resulting in new memory cells being used, and a new _variable_ `arr2` is created, referring to the new copied value.
171 | 
172 | [method syntax]: ./ch05-03-method-syntax.md
173 | 
174 | ## Return Values and Scope
175 | 
176 | Returning values is equivalent to _moving_ them. Listing {{#ref move-return-values}} shows an example of a
177 | function that returns some value, with similar annotations as those in Listing {{#ref variable-scope}}.
178 | 
179 | <span class="filename">Filename: src/lib.cairo</span>
180 | 
181 | ```cairo
182 | {{#include ../listings/ch04-understanding-ownership/listing_02_moving_return_values/src/lib.cairo}}
183 | ```
184 | 
185 | {{#label move-return-values}}
186 | <span class="caption">Listing {{#ref move-return-values}}: Moving return values</span>
187 | 
188 | While this works, moving into and out of every function is a bit tedious. What if we want to let a function use a value but not move the value? Its quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.
189 | 
190 | Cairo does let us return multiple values using a tuple, as shown in Listing {{#ref return-multiple-values}}.
191 | 
192 | <span class="filename">Filename: src/lib.cairo</span>
193 | 
194 | ```cairo
195 | {{#include ../listings/ch04-understanding-ownership/listing_03_returning_many_values/src/lib.cairo}}
196 | ```
197 | 
198 | {{#label return-multiple-values}}
199 | <span class="caption">Listing {{#ref return-multiple-values}}: Returning many values</span>
200 | 
201 | But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Cairo has two features for passing a value without destroying or moving it, called _references_ and _snapshots_.
202 | 


--------------------------------------------------------------------------------
/src/ch04-02-references-and-snapshots.md:
--------------------------------------------------------------------------------
  1 | # References and Snapshots
  2 | 
  3 | The issue with the tuple code in previous Listing {{#ref return-multiple-values}} is that we have to return the
  4 | `Array` to the calling function so we can still use the `Array` after the
  5 | call to `calculate_length`, because the `Array` was moved into
  6 | `calculate_length`.
  7 | 
  8 | ## Snapshots
  9 | 
 10 | In the previous chapter, we talked about how Cairo's ownership system prevents
 11 | us from using a variable after we've moved it, protecting us from potentially
 12 | writing twice to the same memory cell. However, it's not very convenient.
 13 | Let's see how we can retain ownership of the variable in the calling function using snapshots.
 14 | 
 15 | In Cairo, a snapshot is an immutable view of a value at a certain point in time.
 16 | Recall that memory is immutable, so modifying a value actually creates a new memory cell.
 17 | The old memory cell still exists, and snapshots are variables that refer to that "old" value.
 18 | In this sense, snapshots are a view "into the past".
 19 | 
 20 | Here is how you would define and use a `calculate_length` function that takes a
 21 | snapshot of an array as a parameter instead of taking ownership of the underlying value. In this example,
 22 | the `calculate_length` function returns the length of the array passed as a parameter.
 23 | As we're passing it as a snapshot, which is an immutable view of the array, we can be sure that
 24 | the `calculate_length` function will not mutate the array, and ownership of the array is kept in the `main` function.
 25 | 
 26 | <span class="filename">Filename: src/lib.cairo</span>
 27 | 
 28 | ```cairo
 29 | {{#include ../listings/ch04-understanding-ownership/no_listing_09_snapshots/src/lib.cairo}}
 30 | ```
 31 | 
 32 | > Note: it is only possible to call the `len()` method on an array snapshot because it is defined as such in the `ArrayTrait` trait. If you try to call a method that is not defined for snapshots on a snapshot, you will get a compilation error. However, you can call methods expecting a snapshot on non-snapshot types.
 33 | 
 34 | The output of this program is:
 35 | 
 36 | ```shell
 37 | {{#include ../listings/ch04-understanding-ownership/no_listing_09_snapshots/output.txt}}
 38 | ```
 39 | 
 40 | First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note
 41 | that we pass `@arr1` into `calculate_length` and, in its definition, we take `@Array<u128>` rather than `Array<u128>`.
 42 | 
 43 | Lets take a closer look at the function call here:
 44 | 
 45 | ```cairo
 46 | let second_length = calculate_length(@arr1); // Calculate the current length of the array
 47 | ```
 48 | 
 49 | The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because a snapshot is an immutable view of a value at a specific point in time, the usual rules of the linear type system are not enforced. In particular, snapshot variables always implement the `Drop` trait, never the `Destruct` trait, even dictionary snapshots.
 50 | 
 51 | Similarly, the signature of the function uses `@` to indicate that the type of the parameter `arr` is a snapshot. Lets add some explanatory annotations:
 52 | 
 53 | ```cairo, noplayground
 54 | fn calculate_length(
 55 |     array_snapshot: @Array<u128> // array_snapshot is a snapshot of an Array
 56 | ) -> usize {
 57 |     array_snapshot.len()
 58 | } // Here, array_snapshot goes out of scope and is dropped.
 59 | // However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.
 60 | ```
 61 | 
 62 | The scope in which the variable `array_snapshot` is valid is the same as any function parameters scope, but the underlying value of the snapshot is not dropped when `array_snapshot` stops being used. When functions have snapshots as parameters instead of the actual values, we wont need to return the values in order to give back ownership of the original value, because we never had it.
 63 | 
 64 | ### Desnap Operator
 65 | 
 66 | To convert a snapshot back into a regular variable, you can use the `desnap` operator `*`, which serves as the opposite of the `@` operator.
 67 | 
 68 | Only `Copy` types can be desnapped. However, in the general case, because the value is not modified, the new variable created by the `desnap` operator reuses the old value, and so desnapping is a completely free operation, just like `Copy`.
 69 | 
 70 | In the following example, we want to calculate the area of a rectangle, but we don't want to take ownership of the rectangle in the `calculate_area` function, because we might want to use the rectangle again after the function call. Since our function doesn't mutate the rectangle instance, we can pass the snapshot of the rectangle to the function, and then transform the snapshots back into values using the `desnap` operator `*`.
 71 | 
 72 | ```cairo
 73 | {{#include ../listings/ch04-understanding-ownership/no_listing_10_desnap/src/lib.cairo}}
 74 | ```
 75 | 
 76 | But, what happens if we try to modify something were passing as a snapshot? Try the code in
 77 | Listing {{#ref modify-snapshot}}. Spoiler alert: it doesnt work!
 78 | 
 79 | <span class="filename">Filename: src/lib.cairo</span>
 80 | 
 81 | ```cairo,does_not_compile
 82 | {{#include ../listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo}}
 83 | ```
 84 | 
 85 | {{#label modify-snapshot}}
 86 | 
 87 | <span class="caption">Listing {{#ref modify-snapshot}}: Attempting to modify a snapshot value</span>
 88 | 
 89 | Heres the error:
 90 | 
 91 | ```shell
 92 | {{#include ../listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/output.txt}}
 93 | ```
 94 | 
 95 | The compiler prevents us from modifying values associated to snapshots.
 96 | 
 97 | ## Mutable References
 98 | 
 99 | We can achieve the behavior we want in Listing {{#ref modify-snapshot}} by using a _mutable reference_ instead of a snapshot. Mutable references are actually mutable values passed to a function that are implicitly returned at the end of the function, returning ownership to the calling context. By doing so, they allow you to mutate the value passed while keeping ownership of it by returning it automatically at the end of the execution.
100 | In Cairo, a parameter can be passed as _mutable reference_ using the `ref` modifier.
101 | 
102 | > **Note**: In Cairo, a parameter can only be passed as _mutable reference_ using the `ref` modifier if the variable is declared as mutable with `mut`.
103 | 
104 | In Listing 4-5, we use a mutable reference to modify the value of the `height` and `width` fields of the `Rectangle` instance in the `flip` function.
105 | 
106 | ```cairo
107 | {{#include ../listings/ch04-understanding-ownership/listing_05_mutable_reference/src/lib.cairo}}
108 | ```
109 | 
110 | <span class="caption">Listing 4-5: Use of a mutable reference to modify a value</span>
111 | 
112 | First, we change `rec` to be `mut`. Then we pass a mutable reference of `rec` into `flip` with `ref rec`, and update the function signature to accept a mutable reference with `ref rec: Rectangle`. This makes it very clear that the `flip` function will mutate the value of the `Rectangle` instance passed as parameter.
113 | 
114 | The output of the program is:
115 | 
116 | ```shell
117 | {{#include ../listings/ch04-understanding-ownership/listing_05_mutable_reference/output.txt}}
118 | ```
119 | 
120 | As expected, the `height` and `width` fields of the `rec` variable have been swapped.
121 | 
122 | {{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}
123 | 
124 | ## Small Recap
125 | 
126 | Lets recap what weve discussed about the linear type system, ownership, snapshots, and references:
127 | 
128 | - At any given time, a variable can only have one owner.
129 | - You can pass a variable by-value, by-snapshot, or by-reference to a function.
130 | - If you pass-by-value, ownership of the variable is transferred to the function.
131 | - If you want to keep ownership of the variable and know that your function wont mutate it, you can pass it as a snapshot with `@`.
132 | - If you want to keep ownership of the variable and know that your function will mutate it, you can pass it as a mutable reference with `ref`.
133 | 


--------------------------------------------------------------------------------
/src/ch05-00-using-structs-to-structure-related-data.md:
--------------------------------------------------------------------------------
1 | # Using Structs to Structure Related Data
2 | 
3 | A struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If youre familiar with an object-oriented language, a struct is like an objects data attributes. In this chapter, well compare and contrast tuples with structs to build on what you already know and demonstrate when structs are a better way to group data.
4 | 
5 | Well demonstrate how to define and instantiate structs. Well discuss how to define associated functions, especially the kind of associated functions called methods, to specify behavior associated with a struct type. Structs and enums (discussed in the [next chapter](ch06-01-enums.md)) are the building blocks for creating new types in your programs domain to take full advantage of Cairo's compile-time type checking.
6 | 


--------------------------------------------------------------------------------
/src/ch05-01-defining-and-instantiating-structs.md:
--------------------------------------------------------------------------------
  1 | # Defining and Instantiating Structs
  2 | 
  3 | Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-types.md) section, in that both hold multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a struct youll name each piece of data so its clear what the values mean. Adding these names means that structs are more flexible than tuples: you dont have to rely on the order of the data to specify or access the values of an instance.
  4 | 
  5 | To define a struct, we enter the keyword `struct` and name the entire struct. A structs name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call fields. For example, Listing {{#ref user-struct}} shows a struct that stores information about a user account.
  6 | 
  7 | <span class="filename">Filename: src/lib.cairo</span>
  8 | 
  9 | ```cairo, noplayground
 10 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/src/lib.cairo:user}}
 11 | ```
 12 | 
 13 | {{#label user-struct}}
 14 | 
 15 | <span class="caption">Listing {{#ref user-struct}}: A `User` struct definition</span>
 16 | 
 17 | To use a struct after weve defined it, we create an _instance_ of that struct by specifying concrete values for each of the fields.
 18 | We create an instance by stating the name of the struct and then add curly brackets containing _key: value_ pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We dont have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type.
 19 | 
 20 | For example, we can declare two particular users as shown in Listing {{#ref user-instances}}.
 21 | 
 22 | <span class="filename">Filename: src/lib.cairo</span>
 23 | 
 24 | ```cairo
 25 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/src/lib.cairo:all}}
 26 | ```
 27 | 
 28 | {{#label user-instances}}
 29 | <span class="caption">Listing {{#ref user-instances}}: Creating two instances of the `User` struct</span>
 30 | 
 31 | To get a specific value from a struct, we use dot notation. For example, to access `user1`'s email address, we use `user1.email`. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing {{#ref user-mut}} shows how to change the value in the `email` field of a mutable `User` instance.
 32 | 
 33 | <span class="filename">Filename: src/lib.cairo</span>
 34 | 
 35 | ```cairo
 36 | {{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:main}}
 37 | ```
 38 | 
 39 | {{#label user-mut}}
 40 | <span class="caption">Listing {{#ref user-mut}}: Changing the value in the email field of a `User` instance</span>
 41 | 
 42 | Note that the entire instance must be mutable; Cairo doesnt allow us to mark only certain fields as mutable.
 43 | 
 44 | As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.
 45 | 
 46 | Listing {{#ref build-user}} shows a `build_user` function that returns a `User` instance with the given email and username. The `active` field gets the value of `true`, and the `sign_in_count` gets a value of `1`.
 47 | 
 48 | <span class="filename">Filename: src/lib.cairo</span>
 49 | 
 50 | ```cairo
 51 | {{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:build_user}}
 52 | ```
 53 | 
 54 | {{#label build-user}}
 55 | <span class="caption">Listing {{#ref build-user}}: A `build_user` function that takes an email and username and returns a `User` instance.</span>
 56 | 
 57 | It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the `email` and `username` field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, theres a convenient shorthand!
 58 | 
 59 | ## Using the Field Init Shorthand
 60 | 
 61 | Because the parameter names and the struct field names are exactly the same in Listing {{#ref build-user}}, we can use the field init shorthand syntax to rewrite `build_user` so it behaves exactly the same but doesnt have the repetition of `username` and `email`, as shown in Listing {{#ref init-shorthand}}.
 62 | 
 63 | <span class="filename">Filename: src/lib.cairo</span>
 64 | 
 65 | ```cairo
 66 | {{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:build_user2}}
 67 | ```
 68 | 
 69 | {{#label init-shorthand}}
 70 | <span class="caption">Listing {{#ref init-shorthand}}: A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields.</span>
 71 | 
 72 | Here, were creating a new instance of the `User` struct, which has a field named `email`. We want to set the `email` fields value to the value in the `email` parameter of the `build_user` function. Because the `email` field and the `email` parameter have the same name, we only need to write `email` rather than `email: email`.
 73 | 
 74 | ## Creating Instances from Other Instances with Struct Update Syntax
 75 | 
 76 | Its often useful to create a new instance of a struct that includes most of
 77 | the values from another instance, but changes some. You can do this using
 78 | _struct update syntax_.
 79 | 
 80 | First, in Listing {{#ref without-update-syntax}} we show how to create a new `User` instance in `user2`
 81 | regularly, without the update syntax. We set a new value for `email` but
 82 | otherwise use the same values from `user1` that we created in Listing {{#ref user-instances}}.
 83 | 
 84 | <span class="filename">Filename: src/lib.cairo</span>
 85 | 
 86 | ```cairo
 87 | {{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_without_update_syntax/src/lib.cairo:here}}
 88 | ```
 89 | 
 90 | {{#label without-update-syntax}}
 91 | 
 92 | <span class="caption">Listing {{#ref without-update-syntax}}: Creating a new `User` instance using all but one of the values from `user1`</span>
 93 | 
 94 | Using struct update syntax, we can achieve the same effect with less code, as
 95 | shown in Listing {{#ref update-syntax}}. The syntax `..` specifies that the remaining fields not
 96 | explicitly set should have the same value as the fields in the given instance.
 97 | 
 98 | <span class="filename">Filename: src/lib.cairo</span>
 99 | 
100 | ```cairo
101 | {{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_update_syntax/src/lib.cairo:here}}
102 | ```
103 | 
104 | {{#label update-syntax}}
105 | 
106 | <span class="caption">Listing {{#ref update-syntax}}: Using struct update syntax to set a new
107 | `email` value for a `User` instance but to use the rest of the values from `user1`</span>
108 | 
109 | The code in Listing {{#ref update-syntax}} also creates an instance of `user2` that has a
110 | different value for `email` but has the same values for the `username`,
111 | `active`, and `sign_in_count` fields as `user1`. The `..user1` part must come last
112 | to specify that any remaining fields should get their values from the
113 | corresponding fields in `user1`, but we can choose to specify values for as
114 | many fields as we want in any order, regardless of the order of the fields in
115 | the structs definition.
116 | 
117 | Note that the struct update syntax uses `=` like an assignment; this is because it moves the data,
118 | just as we saw in the ["Moving Values"][move]<!-- ignore --> section. In this example, we can no
119 | longer use `user1` as a whole after creating `user2` because the `ByteArray` in the
120 | `username` field of `user1` was moved into `user2`. If we had given `user2` new
121 | `ByteArray` values for both `email` and `username`, and thus only used the
122 | `active` and `sign_in_count` values from `user1`, then `user1` would still be
123 | valid after creating `user2`. Both `active` and `sign_in_count` are types that
124 | implement the `Copy` trait, so the behavior we discussed in the ["`Copy` Trait"][copy]<!-- ignore --> section would apply.
125 | 
126 | {{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}
127 | 
128 | [move]: ch04-01-what-is-ownership.md#moving-values
129 | [copy]: ch04-01-what-is-ownership.md#the-copy-trait
130 | 


--------------------------------------------------------------------------------
/src/ch05-02-an-example-program-using-structs.md:
--------------------------------------------------------------------------------
 1 | # An Example Program Using Structs
 2 | 
 3 | To understand when we might want to use structs, lets write a program that calculates the area of a rectangle. Well start by using single variables, and then refactor the program until were using structs instead.
 4 | 
 5 | Lets make a new project with Scarb called _rectangles_ that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing {{#ref area-fn}} shows a short program with one way of doing exactly that in our projects _src/lib.cairo_.
 6 | 
 7 | <span class="filename">Filename: src/lib.cairo</span>
 8 | 
 9 | ```cairo
10 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/src/lib.cairo:all}}
11 | ```
12 | 
13 | {{#label area-fn}}
14 | <span class="caption">Listing {{#ref area-fn}}: Calculating the area of a rectangle specified by separate width and height variables.</span>
15 | 
16 | Now run the program with `scarb cairo-run`:
17 | 
18 | ```shell
19 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/output.txt}}
20 | ```
21 | 
22 | This code succeeds in figuring out the area of the rectangle by calling the `area` function with each dimension, but we can do more to make this code clear and readable.
23 | 
24 | The issue with this code is evident in the signature of `area`:
25 | 
26 | ```cairo,noplayground
27 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/src/lib.cairo:here}}
28 | ```
29 | 
30 | The `area` function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters, and its not clear anywhere in our program that the parameters are related. It would be more readable and more manageable to group width and height together. Weve already discussed one way we might do that in the [Tuple Section of Chapter {{#chap common-programming-concepts}}](./ch02-02-data-types.md#the-tuple-type).
31 | 
32 | ## Refactoring with Tuples
33 | 
34 | Listing {{#ref rectangle-tuple}} shows another version of our program that uses tuples.
35 | 
36 | <span class="filename">Filename: src/lib.cairo</span>
37 | 
38 | ```cairo
39 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_04_w_tuples/src/lib.cairo}}
40 | ```
41 | 
42 | {{#label rectangle-tuple}}
43 | <span class="caption">Listing {{#ref rectangle-tuple}}: Specifying the width and height of the rectangle with a tuple.</span>
44 | 
45 | In one way, this program is better. Tuples let us add a bit of structure, and were now passing just one argument. But in another way, this version is less clear: tuples dont name their elements, so we have to index into the parts of the tuple, making our calculation less obvious.
46 | 
47 | Mixing up the width and height wouldnt matter for the area calculation, but if we want to calculate the difference, it would matter! We would have to keep in mind that `width` is the tuple index `0` and `height` is the tuple index `1`. This would be even harder for someone else to figure out and keep in mind if they were to use our code. Because we havent conveyed the meaning of our data in our code, its now easier to introduce errors.
48 | 
49 | ## Refactoring with Structs: Adding More Meaning
50 | 
51 | We use structs to add meaning by labeling the data. We can transform the tuple were using into a struct with a name for the whole as well as names for the parts.
52 | 
53 | <span class="filename">Filename: src/lib.cairo</span>
54 | 
55 | ```cairo
56 | {{#include ../listings/ch05-using-structs-to-structure-related-data/listing_05_w_structs/src/lib.cairo}}
57 | ```
58 | 
59 | {{#label rectangle-struct}}
60 | <span class="caption">Listing {{#ref rectangle-struct}}: Defining a `Rectangle` struct.</span>
61 | 
62 | Here weve defined a struct and named it `Rectangle`. Inside the curly brackets, we defined the fields as `width` and `height`, both of which have type `u64`. Then, in `main`, we created a particular instance of `Rectangle` that has a width of `30` and a height of `10`. Our `area` function is now defined with one parameter, which weve named `rectangle` which is of type `Rectangle` struct. We can then access the fields of the instance with dot notation, and it gives descriptive names to the values rather than using the tuple index values of `0` and `1`.
63 | 
64 | ## Conversions of Custom Types
65 | 
66 | We've already described how to perform type conversion on in-built types, see [Data Types > Type Conversion][type-conversion]. In this section, we will see how to define conversions for custom types.
67 | 
68 | > Note: conversion can be defined for compound types, e.g. tuples, too.
69 | 
70 | [type-conversion]: ./ch02-02-data-types.md#type-conversion
71 | 
72 | ### Into
73 | 
74 | Defining a conversion for a custom type using the `Into` trait will typically require specification of the type to convert into, as the compiler is unable to determine this most of the time. However this is a small trade-off considering we get the functionality for free.
75 | 
76 | ```cairo
77 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_07_into/src/lib.cairo}}
78 | ```
79 | 
80 | ### TryInto
81 | 
82 | Defining a conversion for `TryInto` is similar to defining it for `Into`.
83 | 
84 | ```cairo
85 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_08_tryinto/src/lib.cairo}}
86 | ```
87 | 
88 | {{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}
89 | 


--------------------------------------------------------------------------------
/src/ch05-03-method-syntax.md:
--------------------------------------------------------------------------------
  1 | # Method Syntax
  2 | 
  3 | _Methods_ are similar to functions: we declare them with the `fn` keyword and a name, they can have parameters and a return value, and they contain some code thats run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum which we cover in [Chapter {{#chap enums-and-pattern-matching}}][enums]), and their first parameter is always `self`, which represents the instance of the type the method is being called on.
  4 | 
  5 | ## Defining Methods
  6 | 
  7 | Lets change the `area` function that has a `Rectangle` instance as a parameter and instead make an `area` method defined on the `Rectangle` struct, as shown in Listing {{#ref area-method}}
  8 | 
  9 | ```cairo, noplayground
 10 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_01_define_methods/src/lib.cairo:all}}
 11 | ```
 12 | 
 13 | {{#label area-method}}
 14 | Listing {{#ref area-method}}: Defining an `area` method on the `Rectangle` struct.
 15 | 
 16 | To define the function within the context of `Rectangle`, we start an `impl` (implementation) block for a trait `RectangleTrait` that defines the methods that can be called on a `Rectangle` instance. As impl blocks can only be defined for traits and not types, we need to define this trait first - but it's not meant to be used for anything else.
 17 | 
 18 | Everything within this `impl` block will be associated with the `Rectangle` type. Then we move the `area` function within the `impl` curly brackets and change the first (and in this case, only) parameter to be `self` in the signature and everywhere within the body. In `main`, where we called the `area` function and passed `rect1` as an argument, we can instead use _method syntax_ to call the `area` method on our `Rectangle` instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.
 19 | 
 20 | In the signature for `area`, we use `self: @Rectangle` instead of `rectangle: @Rectangle`.
 21 | Methods must have a parameter named `self`, for their first parameter, and the type of `self` indicates the type that method can be called on. Methods can take ownership of `self`, but `self` can also be passed by snapshot or by reference, just like any other parameter.
 22 | 
 23 | > There is no direct link between a type and a trait. Only the type of the `self` parameter of a method defines the type from which this method can be called. That means, it is technically possible to define methods on multiple types in a same trait (mixing `Rectangle` and `Circle` methods, for example). But **this is not a recommended practice** as it can lead to confusion.
 24 | 
 25 | The main reason for using methods instead of functions, in addition to providing method syntax, is for organization. Weve put all the things we can do with an instance of a type in one `impl` block rather than making future users of our code search for capabilities of `Rectangle` in various places in the library we provide.
 26 | 
 27 | ## The `generate_trait` Attribute
 28 | 
 29 | If you are familiar with Rust, you may find Cairo's approach confusing because methods cannot be defined directly on types. Instead, you must define a [trait](./ch08-02-traits-in-cairo.md) and an implementation of this trait associated with the type for which the method is intended.
 30 | However, defining a trait and then implementing it to define methods on a specific type is verbose, and unnecessary: the trait itself will not be reused.
 31 | 
 32 | So, to avoid defining useless traits, Cairo provides the `#[generate_trait]` attribute to add above a trait implementation, which tells to the compiler to generate the corresponding trait definition for you, and let's you focus on the implementation only. Both approaches are equivalent, but it's considered a best practice to not explicitly define traits in this case.
 33 | 
 34 | The previous example can also be written as follows:
 35 | 
 36 | ```cairo
 37 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_02_gen_trait/src/lib.cairo}}
 38 | ```
 39 | 
 40 | Let's use this `#[generate_trait]` in the following chapters to make our code cleaner.
 41 | 
 42 | ## Snapshots and References
 43 | 
 44 | As the `area` method does not modify the calling instance, `self` is declared as a snapshot of a `Rectangle` instance with the `@` snapshot operator. But, of course, we can also define some methods receiving a mutable reference of this instance, to be able to modify it.
 45 | 
 46 | Let's write a new method `scale` which resizes a rectangle of a `factor` given as parameter:
 47 | 
 48 | ```cairo
 49 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/src/lib.cairo:trait_impl}}
 50 | 
 51 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/src/lib.cairo:main}}
 52 | ```
 53 | 
 54 | It is also possible to define a method which takes ownership of the instance by using just `self` as the first parameter but it is rare. This technique is usually used when the method transforms `self` into something else and you want to prevent the caller from using the original instance after the transformation.
 55 | 
 56 | Look at the [Understanding Ownership](ch04-00-understanding-ownership.md) chapter for more details about these important notions.
 57 | 
 58 | ## Methods with Several Parameters
 59 | 
 60 | Lets practice using methods by implementing another method on the `Rectangle` struct. This time we want to write the method `can_hold` which accepts another instance of `Rectangle` and returns `true` if this rectangle can fit completely within self; otherwise, it should return false.
 61 | 
 62 | ```cairo
 63 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/src/lib.cairo:trait_impl}}
 64 | 
 65 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/src/lib.cairo:main}}
 66 | ```
 67 | 
 68 | Here, we expect that `rect1` can hold `rect2` but not `rect3`.
 69 | 
 70 | ## Associated functions
 71 | 
 72 | We call _associated functions_ all functions that are defined inside an `impl` block that are associated to a specific type. While this is not enforced by the compiler, it is a good practice to keep associated functions related to the same type in the same `impl` block - for example, all functions related to `Rectangle` will be grouped in the same `impl` block for `RectangleTrait`.
 73 | 
 74 | Methods are a special kind of associated function, but we can also define associated functions that dont have `self` as their first parameter (and thus are not methods) because they dont need an instance of the type to work with, but are still associated with that type.
 75 | 
 76 | Associated functions that arent methods are often used for constructors that
 77 | will return a new instance of the type. These are often called `new`, but
 78 | `new` isnt a special name and isnt built into the language. For example, we
 79 | could choose to provide an associated function named `square` that would have
 80 | one dimension parameter and use that as both width and height, thus making it
 81 | easier to create a square `Rectangle` rather than having to specify the same
 82 | value twice:
 83 | 
 84 | Let's create the function `new` which creates a `Rectangle` from a `width` and a `height`, `square` which creates a square `Rectangle` from a `size` and `avg` which computes the average of two `Rectangle` instances:
 85 | 
 86 | ```cairo
 87 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/src/lib.cairo:trait_impl}}
 88 | 
 89 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/src/lib.cairo:main}}
 90 | ```
 91 | 
 92 | To call the `square` associated function, we use the `::` syntax with the struct name;
 93 | `let sq = Rectangle::square(3);` is an example. This function is namespaced by
 94 | the struct: the `::` syntax is used for both associated functions and
 95 | namespaces created by modules. Well discuss modules in [Chapter
 96 | 7][modules].
 97 | 
 98 | Note that the `avg` function could also be written as a method with `self` as the first rectangle. In this case, instead of using the method with `RectangleTrait::avg(@rect1, @rect2)`, it would be called with `rect1.avg(rect2)`.
 99 | 
100 | ## Multiple Traits and `impl` Blocks
101 | 
102 | Each struct is allowed to have multiple `trait` and `impl` blocks. For example,
103 | the following code is equivalent to the code shown in the _Methods with several parameters_ section, which has each method in its own `trait` and `impl` blocks.
104 | 
105 | ```cairo
106 | {{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_06_multiple_traits/src/lib.cairo:here}}
107 | ```
108 | 
109 | Theres no strong reason to separate these methods into multiple `trait` and `impl`
110 | blocks here, but this is valid syntax.
111 | 
112 | {{#quiz ../quizzes/ch05-03-method-syntax.toml}}
113 | 
114 | [enums]: ./ch06-01-enums.md
115 | [modules]: ./ch07-02-defining-modules-to-control-scope.md
116 | 


--------------------------------------------------------------------------------
/src/ch06-00-enums-and-pattern-matching.md:
--------------------------------------------------------------------------------
 1 | # Enums and Pattern Matching
 2 | 
 3 | In this chapter, well look at _enumerations_, also referred to as _enums_.
 4 | Enums allow you to define a type by enumerating its possible _variants_. First,
 5 | well define and use an enum to show how an enum can encode meaning along with
 6 | data. Next, well explore a particularly useful enum, called `Option`, which
 7 | expresses that a value can be either something or nothing. Finally, well look at
 8 | how pattern matching in the `match` expression makes it easy to run different
 9 | code for different values of an enum.
10 | 


--------------------------------------------------------------------------------
/src/ch06-01-enums.md:
--------------------------------------------------------------------------------
 1 | # Enums
 2 | 
 3 | Enums, short for "enumerations," are a way to define a custom data type that consists of a fixed set of named values, called _variants_. Enums are useful for representing a collection of related values where each value is distinct and has a specific meaning.
 4 | 
 5 | ## Enum Variants and Values
 6 | 
 7 | Here's a simple example of an enum:
 8 | 
 9 | ```cairo, noplayground
10 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_01_enum_example/src/lib.cairo:enum_example}}
11 | ```
12 | 
13 | In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and `West`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the `Direction` type. In this particular example, variants don't have any associated value. One variant can be instantiated using this syntax:
14 | 
15 | ```cairo, noplayground
16 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_01_enum_example/src/lib.cairo:here}}
17 | ```
18 | 
19 | Now let's imagine that our variants have associated values, that store the exact degree of the direction. We can define a new `Direction` enum:
20 | 
21 | ```cairo, noplayground
22 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_02_enum_with_values_example/src/lib.cairo:enum_example}}
23 | ```
24 | 
25 | and instantiate it as follows:
26 | 
27 | ```cairo, noplayground
28 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_02_enum_with_values_example/src/lib.cairo:here}}
29 | ```
30 | 
31 | In this code, each variant is associated with a `u128` value, representing the direction in degrees. In the next example, we will see that it is also possible to associate different data types with each variant.
32 | 
33 | It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a direction. You can learn more about it in the [Match Control Flow Construct][match] section.
34 | 
35 | [match]: ./ch06-02-the-match-control-flow-construct.md
36 | 
37 | ## Enums Combined with Custom Types
38 | 
39 | Enums can also be used to store more interesting custom data associated with each variant. For example:
40 | 
41 | ```cairo, noplayground
42 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_03_enum_message/src/lib.cairo:message}}
43 | ```
44 | 
45 | In this example, the `Message` enum has three variants: `Quit`, `Echo`, and `Move`, all with different types:
46 | 
47 | - `Quit` doesn't have any associated value.
48 | - `Echo` is a single `felt252`.
49 | - `Move` is a tuple of two `u128` values.
50 | 
51 | You could even use a Struct or another enum you defined inside one of your enum variants.
52 | 
53 | ## Trait Implementations for Enums
54 | 
55 | In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and behaviors associated with the enum. Here's an example of defining a trait and implementing it for the previous `Message` enum:
56 | 
57 | ```cairo, noplayground
58 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_03_enum_message/src/lib.cairo:trait_impl}}
59 | ```
60 | 
61 | In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a `Quit` message:
62 | 
63 | ```cairo
64 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_03_enum_message/src/lib.cairo:main}}
65 | ```
66 | 
67 | ## The `Option` Enum and Its Advantages
68 | 
69 | The `Option` enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: `Some: T` and `None`. `Some: T` indicates that there's a value of type `T`, while `None` represents the absence of a value.
70 | 
71 | ```cairo,noplayground
72 | enum Option<T> {
73 |     Some: T,
74 |     None,
75 | }
76 | ```
77 | 
78 | The `Option` enum is helpful because it allows you to explicitly represent the possibility of a value being absent, making your code more expressive and easier to reason about. Using `Option` can also help prevent bugs caused by using uninitialized or unexpected `null` values.
79 | 
80 | To give you an example, here is a function which returns the index of the first element of an array with a given value, or `None` if the element is not present.
81 | 
82 | We are demonstrating two approaches for the above function:
83 | 
84 | - Recursive approach with `find_value_recursive`.
85 | - Iterative approach with `find_value_iterative`.
86 | 
87 | ```cairo,noplayground
88 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_04_enum_option/src/lib.cairo}}
89 | ```
90 | 
91 | Enums can be useful in many situations, especially when using the `match` flow construct that we just used. We will describe it in the next section.
92 | 
93 | Other enums are used very often, such as the `Result` enum, allowing to handle errors gracefully. We will explain the `Result` enum in detail in the ["Error Handling"][result enum] chapter.
94 | 
95 | {{#quiz ../quizzes/ch06-01-enums.toml}}
96 | 
97 | [result enum]: ./ch09-02-recoverable-errors.md#the-result-enum
98 | 


--------------------------------------------------------------------------------
/src/ch06-02-the-match-control-flow-construct.md:
--------------------------------------------------------------------------------
  1 | # The Match Control Flow Construct
  2 | 
  3 | Cairo has an extremely powerful control flow construct called `match` that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things. The power of `match` comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.
  4 | 
  5 | Think of a `match` expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value fits, the value falls into the associated code block to be used during execution.
  6 | 
  7 | Speaking of coins, lets use them as an example using `match`! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which coin it is and returns its value in cents, as shown in Listing {{#ref match-enum}}.
  8 | 
  9 | ```cairo,noplayground
 10 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_05_match_example/src/lib.cairo:all}}
 11 | ```
 12 | 
 13 | {{#label match-enum}}
 14 | <span class="caption">Listing {{#ref match-enum}}: An enum and a `match` expression that has the variants of the enum as its patterns</span>
 15 | 
 16 | Lets break down the `match` expression in the `value_in_cents` function. First, we list the `match` keyword followed by an expression, which in this case is the value `coin`. This seems very similar to a conditional expression used with the `if` statement, but theres a big difference: with `if`, the condition needs to evaluate to a boolean value, but here it can be any type. The type of `coin` in this example is the `Coin` enum that we defined on the first line.
 17 | 
 18 | Next are the `match` arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value `Coin::Penny` and then the `=>` operator that separates the pattern and the code to run. The code in this case is just the value `1`. Each arm is separated from the next with a comma.
 19 | 
 20 | When the `match` expression executes, it compares the resultant value against the pattern of each arm, in the order they are given. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesnt match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in the above example, our `match` has four arms.
 21 | 
 22 | The code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire match expression.
 23 | 
 24 | We dont typically use curly brackets if the `match` arm code is short, as it is in our example where each arm just returns a value. If you want to run multiple lines of code in a `match` arm, you must use curly brackets, with a comma following the arm. For example, the following code prints Lucky penny! every time the method is called with a `Coin::Penny`, but still returns the last value of the block, `1`:
 25 | 
 26 | ```cairo,noplayground
 27 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_06_match_arms_block/src/lib.cairo:here}}
 28 | ```
 29 | 
 30 | ## Patterns That Bind to Values
 31 | 
 32 | Another useful feature of `match` arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.
 33 | 
 34 | As an example, lets change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our `enum` by changing the `Quarter` variant to include a `UsState` value stored inside it, which weve done in Listing {{#ref match-pattern-bind}}.
 35 | 
 36 | ```cairo,noplayground
 37 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/src/lib.cairo:enum_def}}
 38 | ```
 39 | 
 40 | {{#label match-pattern-bind}}
 41 | <span class="caption">Listing {{#ref match-pattern-bind}}: A `Coin` enum in which the `Quarter` variant also holds a `UsState` value</span>
 42 | 
 43 | Lets imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, well also call out the name of the state associated with each quarter so that if its one our friend doesnt have, they can add it to their collection.
 44 | 
 45 | In the `match` expression for this code, we add a variable called `state` to the pattern that matches values of the variant `Coin::Quarter`. When a `Coin::Quarter` matches, the `state` variable will bind to the value of that quarters state. Then we can use `state` in the code for that arm, like so:
 46 | 
 47 | ```cairo,noplayground
 48 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/src/lib.cairo:function}}
 49 | ```
 50 | 
 51 | Because `state` is an `UsState` enum which implements the `Debug` trait, we can print `state` value with `println!` macro.
 52 | 
 53 | > Note: `{:?}` is a special formatting syntax that allows to print a debug form of the parameter passed to the `println!` macro. You can find more information about it in [Appendix C][debug trait].
 54 | 
 55 | If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each of the match arms, none of them match until we reach `Coin::Quarter(state)`. At that point, the binding for `state` will be the value `UsState::Alaska`. We can then use that binding in `println!` macro, thus getting the inner state value out of the `Coin` enum variant for `Quarter`.
 56 | 
 57 | [debug trait]: ./appendix-03-derivable-traits.md#debug-for-printing-and-debugging
 58 | 
 59 | ## Matching with `Option<T>`
 60 | 
 61 | In the previous section, we wanted to get the inner `T` value out of the `Some` case when using `Option<T>`; we can also handle `Option<T>` using `match`, as we did with the `Coin` enum! Instead of comparing coins, well compare the variants of `Option<T>`, but the way the `match` expression works remains the same.
 62 | 
 63 | Lets say we want to write a function that takes an `Option<u8>` and, if theres a value inside, adds `1` to that value. If there is no value inside, the function should return the `None` value and not attempt to perform any operations.
 64 | 
 65 | This function is very easy to write, thanks to `match`, and will look like Listing {{#ref match-option}}.
 66 | 
 67 | ```cairo
 68 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:all}}
 69 | ```
 70 | 
 71 | {{#label match-option}}
 72 | <span class="caption">Listing {{#ref match-option}}: A function that uses a `match` expression on an `Option<u8>`</span>
 73 | 
 74 | Lets examine the first execution of `plus_one` in more detail. When we call `plus_one(five)`, the variable `x` in the body of `plus_one` will have the value `Some(5)`. We then compare that against each `match` arm:
 75 | 
 76 | ```cairo,noplayground
 77 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:option_some}}
 78 | ```
 79 | 
 80 | Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! We have the same variant. The `val` binds to the value contained in `Option::Some`, so `val` takes the value `5`. The code in the `match` arm is then executed, so we add `1` to the value of `val` and create a new `Option::Some` value with our total `6` inside. Because the first arm matched, no other arms are compared.
 81 | 
 82 | Now lets consider the second call of `plus_one` in our main function, where `x` is `Option::None`. We enter the `match` and compare to the first arm:
 83 | 
 84 | ```cairo,noplayground
 85 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:option_some}}
 86 | ```
 87 | 
 88 | The `Option::Some(val)` value doesnt match the pattern `Option::None`, so we continue to the next arm:
 89 | 
 90 | ```cairo
 91 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:option_none}}
 92 | ```
 93 | 
 94 | It matches! Theres no value to add to, so the matching construct ends and returns the `Option::None` value on the right side of `=>`.
 95 | 
 96 | Combining `match` and enums is useful in many situations. Youll see this pattern a lot in Cairo code: `match` against an enum, bind a variable to the data inside, and then execute code based on it. Its a bit tricky at first, but once you get used to it, youll wish you had it in all languages. Its consistently a user favorite.
 97 | 
 98 | ## Matches Are Exhaustive
 99 | 
100 | Theres one other aspect of `match` we need to discuss: the arms patterns must cover all possibilities. Consider this version of our `plus_one` function, which has a bug and wont compile:
101 | 
102 | ```cairo,noplayground
103 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:here}}
104 | ```
105 | 
106 | We didnt handle the `None` case, so this code will cause a bug.
107 | Luckily, its a bug Cairo knows how to catch. If we try to compile this code, well get this error:
108 | 
109 | ```shell
110 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/output.txt}}
111 | ```
112 | 
113 | Cairo knows that we didnt cover every possible case, and even knows which pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle the `None` case, it protects us from assuming that we have a value when we might have null, thus making the [billion-dollar mistake][null pointer] discussed earlier impossible.
114 | 
115 | [null pointer]: https://en.wikipedia.org/wiki/Null_pointer#History
116 | 
117 | ## Catch-all with the `_` Placeholder
118 | 
119 | Using enums, we can also take special actions for a few particular values, but for all other values take one default action.
120 | `_` is a special pattern that matches any value and does not bind to that value.
121 | You can use it by simply adding a new arm with `_` as the pattern for the last arm of the `match` expression.
122 | 
123 | Imagine we have a vending machine that only accepts Dime coins.
124 | We want to have a function that processes inserted coins and returns `true` only if the coin is accepted.
125 | 
126 | Here's a `vending_machine_accept` function that implements this logic:
127 | 
128 | ```cairo,noplayground
129 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_10_match_catch_all/src/lib.cairo:here}}
130 | ```
131 | 
132 | This example also meets the exhaustiveness requirement because were explicitly ignoring all other values in the last arm; we havent forgotten anything.
133 | 
134 | > There's no catch-all pattern in Cairo that allows you to use the value of the pattern.
135 | 
136 | <!--
137 |   TODO move the following in a separate chapter when there's more pattern matching features in upcoming Cairo versions. cf rust book chapter 18
138 | -->
139 | 
140 | ## Multiple Patterns with the `|` Operator
141 | 
142 | In `match` expressions, you can match multiple patterns using the `|` syntax, which is the pattern _or_ operator.
143 | 
144 | For example, in the following code we modified the `vending_machine_accept` function to accept both `Dime` and `Quarter` coins in a single arm:
145 | 
146 | ```cairo,noplayground
147 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_11_match_or/src/lib.cairo:here}}
148 | ```
149 | 
150 | ## Matching Tuples
151 | 
152 | It is possible to match tuples.
153 | Let's introduce a new `DayType` enum:
154 | 
155 | ```cairo,noplayground
156 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_12_match_tuple/src/lib.cairo:enum_def}}
157 | ```
158 | 
159 | Now, let's suppose that our vending machine accepts any coin on weekdays, but only accepts quarters and dimes on weekends and holidays.
160 | We can modify the `vending_machine_accept` function to accept a tuple of a `Coin` and a `Weekday` and return `true` only if the given coin is accepted on the specified day:
161 | 
162 | ```cairo,noplayground
163 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_12_match_tuple/src/lib.cairo:here}}
164 | ```
165 | 
166 | Writing `(_, _)` for the last arm of a tuple matching pattern might feel superfluous. Hence, we can use the `_ =>` syntax if we want, for example, that our vending machine only accepts quarters on weekdays:
167 | 
168 | ```cairo,noplayground
169 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_12_match_tuple/src/lib.cairo:week}}
170 | ```
171 | 
172 | ## Matching `felt252` and Integer Variables
173 | 
174 | You can also match `felt252` and integer variables. This is useful when you want to match against a range of values.
175 | However, there are some restrictions:
176 | 
177 | - Only integers that fit into a single `felt252` are supported (i.e. `u256` is not supported).
178 | - The first arm must be 0.
179 | - Each arm must cover a sequential segment, contiguously with other arms.
180 | 
181 | Imagine were implementing a game where you roll a six-sided die to get a number between 0 and 5.
182 | If you have 0, 1 or 2 you win. If you have 3, you can roll again. For all other values you lose.
183 | 
184 | Here's a match that implements that logic:
185 | 
186 | ```cairo,noplayground
187 | {{#include ../listings/ch06-enums-and-pattern-matching/no_listing_13_match_integers/src/lib.cairo:here}}
188 | ```
189 | 
190 | {{#quiz ../quizzes/ch06-02-match.toml}}
191 | 
192 | > These restrictions are planned to be relaxed in future versions of Cairo.
193 | 


--------------------------------------------------------------------------------
/src/ch06-03-concise-control-flow-with-if-let-and-while-let.md:
--------------------------------------------------------------------------------
 1 | # Concise Control Flow with `if let` and `while let`
 2 | 
 3 | ## `if let`
 4 | 
 5 | The `if let` syntax lets you combine `if` and `let` into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing {{#ref config_max}} that matches on an `Option::Some<u8>` value in the `config_max` variable but only wants to execute code if the value is `Option::Some` variant.
 6 | 
 7 | ```cairo
 8 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_14_if_let_match_one/src/lib.cairo:match}}
 9 | ```
10 | 
11 | {{#label config_max}}
12 | <span class="caption">Listing {{#ref config_max}}: A `match` that only cares about executing
13 | code when the value is `Option::Some`</span>
14 | 
15 | If the value is `Option::Some`, we print out the value in the `Option::Some` variant by binding
16 | the value to the variable `max` in the pattern. We dont want to do anything
17 | with the `None` value. To satisfy the `match` expression, we have to add `_ =>
18 | ()` after processing just one variant, which is annoying boilerplate code to
19 | add.
20 | 
21 | Instead, we could write this in a shorter way using `if let`. The following
22 | code behaves the same as the `match` in Listing {{#ref config_max}}:
23 | 
24 | ```cairo
25 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_15_if_let/src/lib.cairo:here}}
26 | ```
27 | 
28 | The syntax `if let` takes a pattern and an expression separated by an equal
29 | sign. It works the same way as a `match`, where the expression is given to the
30 | `match` and the pattern is its first arm. In this case, the pattern is
31 | `Option::Some(max)`, and `max` binds to the value inside `Option::Some`. We can then
32 | use `max` in the body of the `if let` block in the same way we used `max` in
33 | the corresponding `match` arm. The code in the `if let` block isnt run if the
34 | value doesnt match the pattern.
35 | 
36 | Using `if let` means less typing, less indentation, and less boilerplate code.
37 | However, you lose the exhaustive checking that `match` enforces. Choosing
38 | between `match` and `if let` depends on what youre doing in your particular
39 | situation and whether gaining conciseness is an appropriate trade-off for
40 | losing exhaustive checking.
41 | 
42 | In other words, you can think of `if let` as syntactic sugar for a `match` that
43 | runs code when the value matches one pattern and then ignores all other values.
44 | 
45 | We can include an `else` with an `if let`. The block of code that goes with `else`
46 | is the same as the block of code that would go with the `_` case in the `match`
47 | expression. Recall the `Coin` enum definition in Listing {{#ref match-pattern-bind}},
48 | where the `Quarter` variant also held a `UsState` value. If we wanted to count
49 | all non-quarter coins we see while also announcing the state of the quarters,
50 | we could do that with a `match` expression, like this:
51 | 
52 | ```cairo
53 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_16_if_let_coiner_match/src/lib.cairo:here}}
54 | ```
55 | 
56 | Or we could use an `if let` and `else` expression, like this:
57 | 
58 | ```cairo
59 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_17_if_let_coiner/src/lib.cairo:here}}
60 | ```
61 | 
62 | If you have a situation in which your program has logic that is too verbose to
63 | express using `match`, remember that `if let` is in your Cairo toolbox as well.
64 | 
65 | ## `while let`
66 | 
67 | The `while let` syntax is similar to the `if let` syntax, but it allows you to loop over a collection of values and execute a block of code for each value that matches a specified pattern. In the case below, the pattern is `Option::Some(x)`, which matches any `Some` variant of the `Option` enum.
68 | 
69 | ```cairo
70 | {{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no_listing_18_while_let/src/lib.cairo}}
71 | ```
72 | 
73 | Using `while let` provides a more concise and idiomatic way of writing this loop compared to a traditional `while` loop with explicit pattern matching or handling of the `Option` type. However, as with `if let`, you lose the exhaustive checking that a `match` expression provides, so you need to be careful to handle any remaining cases outside the `while let` loop if necessary.
74 | 


--------------------------------------------------------------------------------
/src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:
--------------------------------------------------------------------------------
 1 | # Managing Cairo Projects with Packages, Crates and Modules
 2 | 
 3 | As you write large programs, organizing your code will become increasingly
 4 | important. By grouping related functionality and separating code with distinct
 5 | features, youll clarify where to find code that implements a particular
 6 | feature and where to go to change how a feature works.
 7 | 
 8 | The programs weve written so far have been in one module in one file. As a
 9 | project grows, you should organize code by splitting it into multiple modules
10 | and then multiple files. As a package grows, you can extract parts into
11 | separate crates that become external dependencies. This chapter covers all
12 | these techniques.
13 | 
14 | Well also discuss encapsulating implementation details, which lets you reuse
15 | code at a higher level: once youve implemented an operation, other code can
16 | call your code without having to know how the
17 | implementation works.
18 | 
19 | A related concept is scope: the nested context in which code is written has a
20 | set of names that are defined as in scope. When reading, writing, and
21 | compiling code, programmers and compilers need to know whether a particular
22 | name at a particular spot refers to a variable, function, struct, enum, module,
23 | constant, or other item and what that item means. You can create scopes and
24 | change which names are in or out of scope. You cant have two items with the
25 | same name in the same scope.
26 | 
27 | Cairo has a number of features that allow you to manage your codes
28 | organization. These features, sometimes
29 | collectively referred to as the _module system_, include:
30 | 
31 | - **Packages:** A Scarb feature that lets you build, test, and share crates.
32 | - **Crates:** A tree of modules that corresponds to a single compilation unit.
33 |   It has a root directory, and a root module defined at the _lib.cairo_ file under this directory.
34 | - **Modules** and **use:** Let you control the organization and scope of items.
35 | - **Paths:** A way of naming an item, such as a struct, function, or module.
36 | 
37 | In this chapter, well cover all these features, discuss how they interact, and
38 | explain how to use them to manage scope. By the end, you should have a solid
39 | understanding of the module system and be able to work with scopes like a pro!
40 | 


--------------------------------------------------------------------------------
/src/ch07-01-packages-and-crates.md:
--------------------------------------------------------------------------------
 1 | # Packages and Crates
 2 | 
 3 | ## What is a Crate?
 4 | 
 5 | A crate is a subset of a package that is used in the actual Cairo compilation. This includes:
 6 | 
 7 | - The package source code, identified by the package name and the crate root, which is the main entry point of the package.
 8 | - A subset of the package metadata that identifies crate-level settings of the Cairo compiler, for example, the `edition` field in the _Scarb.toml_ file.
 9 | 
10 | Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as will be discussed in the subsequent sections.
11 | 
12 | ## What is the Crate Root?
13 | 
14 | The crate root is the _lib.cairo_ source file that the Cairo compiler starts from and makes up the root module of your crate. Well explain modules in depth in the ["Defining Modules to Control Scope"][modules] chapter.
15 | 
16 | [modules]: ./ch07-02-defining-modules-to-control-scope.md
17 | 
18 | ## What is a Package?
19 | 
20 | A Cairo package is a directory (or equivalent) containing:
21 | 
22 | - A _Scarb.toml_ manifest file with a `[package]` section.
23 | - Associated source code.
24 | 
25 | This definition implies that a package might contain other packages, with a corresponding _Scarb.toml_ file for each package.
26 | 
27 | ## Creating a Package with Scarb
28 | 
29 | You can create a new Cairo package using the Scarb command-line tool. To create a new package, run the following command:
30 | 
31 | ```bash
32 | scarb new my_package
33 | ```
34 | 
35 | This command will generate a new package directory named _my_package_ with the following structure:
36 | 
37 | ```
38 | my_package/
39 |  Scarb.toml
40 |  src
41 |      lib.cairo
42 | ```
43 | 
44 | - _src/_ is the main directory where all the Cairo source files for the package will be stored.
45 | - _lib.cairo_ is the default root module of the crate, which is also the main entry point of the package.
46 | - _Scarb.toml_ is the package manifest file, which contains metadata and configuration options for the package, such as dependencies, package name, version, and authors. You can find documentation about it on the [Scarb reference][manifest].
47 | 
48 | ```toml
49 | [package]
50 | name = "my_package"
51 | version = "0.1.0"
52 | edition = "2024_07"
53 | 
54 | [dependencies]
55 | # foo = { path = "vendor/foo" }
56 | ```
57 | 
58 | As you develop your package, you may want to organize your code into multiple Cairo source files. You can do this by creating additional _.cairo_ files within the _src_ directory or its subdirectories.
59 | 
60 | {{#quiz ../quizzes/ch07-01-packages-crates.toml}}
61 | 
62 | [manifest]: https://docs.swmansion.com/scarb/docs/reference/manifest.html
63 | 


--------------------------------------------------------------------------------
/src/ch07-02-defining-modules-to-control-scope.md:
--------------------------------------------------------------------------------
  1 | # Defining Modules to Control Scope
  2 | 
  3 | In this section, well talk about modules and other parts of the module system,
  4 | namely _paths_ that allow you to name items and the `use` keyword that brings a
  5 | path into scope. 
  6 | 
  7 | First, were going to start with a list of rules for easy reference when youre
  8 | organizing your code in the future. Then well explain each of the rules in
  9 | detail.
 10 | 
 11 | ## Modules Cheat Sheet
 12 | 
 13 | Here we provide a quick reference on how modules, paths and the `use` keyword
 14 | work in the compiler, and how most developers organize their
 15 | code. Well be going through examples of each of these rules throughout this
 16 | chapter, but this is a great place to refer to as a reminder of how modules
 17 | work. You can create a new Scarb project with `scarb new backyard` to follow along.
 18 | 
 19 | - **Start from the crate root**: When compiling a crate, the compiler first
 20 |   looks in the crate root file (_src/lib.cairo_) for code to compile.
 21 | - **Declaring modules**: In the crate root file, you can declare new modules;
 22 |   say, you declare a garden module with `mod garden;`. The compiler will look
 23 |   for the modules code in these places:
 24 | 
 25 |   - Inline, within curly brackets that replace the semicolon following `mod garden`.
 26 | 
 27 |     ```cairo,noplayground
 28 |       // crate root file (src/lib.cairo)
 29 |       mod garden {
 30 |           // code defining the garden module goes here
 31 |       }
 32 |     ```
 33 | 
 34 |   - In the file _src/garden.cairo_.
 35 | 
 36 | - **Declaring submodules**: In any file other than the crate root, you can
 37 |   declare submodules. For example, you might declare `mod vegetables;` in
 38 |   _src/garden.cairo_. The compiler will look for the submodules code within the
 39 |   directory named for the parent module in these places:
 40 | 
 41 |   - Inline, directly following `mod vegetables`, within curly brackets instead
 42 |     of the semicolon.
 43 | 
 44 |     ```cairo,noplayground
 45 |     // src/garden.cairo file
 46 |     mod vegetables {
 47 |         // code defining the vegetables submodule goes here
 48 |     }
 49 |     ```
 50 | 
 51 |   - In the file _src/garden/vegetables.cairo_.
 52 | 
 53 | - **Paths to code in modules**: Once a module is part of your crate, you can
 54 |   refer to code in that module from anywhere else in that same crate, using the path
 55 |   to the code. For example, an `Asparagus` type in the `vegetables` submodule would be found at
 56 |   `crate::garden::vegetables::Asparagus`.
 57 | - **Private vs public**: Code within a module is private from its parent modules by default. This means that it may only be
 58 |   accessed by the current module and its descendants. To make a module public, declare it with `pub mod` instead of `mod`. To make items within a public module public as well, use `pub` before their declarations. Cairo also provides the `pub(crate)` keyword, allowing an item or module to be only visible within the crate in which the definition is included.
 59 | - **The `use` keyword**: Within a scope, the `use` keyword creates shortcuts to
 60 |   items to reduce repetition of long paths. In any scope that can refer to
 61 |   `crate::garden::vegetables::Asparagus`, you can create a shortcut with
 62 |   `use crate::garden::vegetables::Asparagus;` and from then on you only need to
 63 |   write `Asparagus` to make use of that type in the scope.
 64 | 
 65 | Here we create a crate named `backyard` that illustrates these rules. The
 66 | crates directory, also named `backyard`, contains these files and directories:
 67 | 
 68 | ```text
 69 | backyard/
 70 |  Scarb.toml
 71 |  src
 72 |      garden
 73 |         vegetables.cairo
 74 |      garden.cairo
 75 |      lib.cairo
 76 | ```
 77 | 
 78 | The crate root file in this case is _src/lib.cairo_, and it contains:
 79 | 
 80 | <span class="filename">Filename: src/lib.cairo</span>
 81 | 
 82 | ```cairo
 83 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_01_lib/src/lib.cairo:crate}}
 84 | ```
 85 | 
 86 | The `pub mod garden;` line imports the `garden` module. Using `pub` to make `garden` publicly accessible, or `pub(crate)` if you really want to make `garden` only available for your crate, is optional to run our program here, as the `main` function resides in the same module as `pub mod garden;` declaration. Nevertheless, not declaring `garden` as `pub` will make it not accessible from any other package.
 87 | This line tells the compiler to include the code it finds in _src/garden.cairo_, which is:
 88 | 
 89 | <span class="filename">Filename: src/garden.cairo</span>
 90 | 
 91 | ```cairo,noplayground
 92 | pub mod vegetables;
 93 | ```
 94 | 
 95 | Here, `pub mod vegetables;` means the code in *src/garden/vegetables.cairo* is included too. That code is:
 96 | 
 97 | ```cairo,noplayground
 98 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/no_listing_02_garden/src/lib.cairo}}
 99 | ```
100 | 
101 | The line `use crate::garden::vegetables::Asparagus;` lets us bring the `Asparagus` type into scope,
102 | so we can use it in the `main` function.
103 | 
104 | Now lets get into the details of these rules and demonstrate them in action!
105 | 
106 | ## Grouping Related Code in Modules
107 | 
108 | _Modules_ let us organize code within a crate for readability and easy reuse.
109 | Modules also allow us to control the privacy of items, because code within a module
110 | is private by default. Private items are internal implementation details not
111 | available for outside use. We can choose to make modules and the items within
112 | them public, which exposes them to allow external code to use and depend on them.
113 | 
114 | As an example, lets write a library crate that provides the functionality of a
115 | restaurant. Well define the signatures of functions but leave their bodies
116 | empty to concentrate on the organization of the code, rather than the
117 | implementation of a restaurant.
118 | 
119 | In the restaurant industry, some parts of a restaurant are referred to as
120 | _front of house_ and others as _back of house_. Front of house is where
121 | customers are; this encompasses where the hosts seat customers, servers take
122 | orders and payment, and bartenders make drinks. Back of house is where the
123 | chefs and cooks work in the kitchen, dishwashers clean up, and managers do
124 | administrative work.
125 | 
126 | To structure our crate in this way, we can organize its functions into nested
127 | modules. Create a new package named _restaurant_ by running `scarb new restaurant`; then enter the code in Listing {{#ref front_of_house}} into _src/lib.cairo_ to
128 | define some modules and function signatures. Heres the front of house section:
129 | 
130 | <span class="filename">Filename: src/lib.cairo</span>
131 | 
132 | ```cairo,noplayground
133 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_01_basic_nested_modules/src/lib.cairo:front_of_house}}
134 | ```
135 | 
136 | {{#label front_of_house}}
137 | <span class="caption">Listing {{#ref front_of_house}}: A `front_of_house` module containing other modules that then contain functions</span>
138 | 
139 | We define a module with the `mod` keyword followed by the name of the module
140 | (in this case, `front_of_house`). The body of the module then goes inside curly
141 | brackets. Inside modules, we can place other modules, as in this case with the
142 | modules `hosting` and `serving`. Modules can also hold definitions for other
143 | items, such as structs, enums, constants, traits, and functions.
144 | 
145 | By using modules, we can group related definitions together and name why
146 | theyre related. Programmers using this code can navigate the code based on the
147 | groups rather than having to read through all the definitions, making it easier
148 | to find the definitions relevant to them. Programmers adding new functionality
149 | to this code would know where to place the code to keep the program organized.
150 | 
151 | Earlier, we mentioned that _src/lib.cairo_ is called the crate
152 | root. The reason for this name is that the content of this file forms a module named after the crate name at the root of the crates module structure, known as the _module tree_.
153 | 
154 | Listing {{#ref module-tree}} shows the module tree for the structure in Listing {{#ref front_of_house}}.
155 | 
156 | ```text
157 | restaurant
158 |   front_of_house
159 |       hosting
160 |          add_to_waitlist
161 |          seat_at_table
162 |       serving
163 |           take_order
164 |           serve_order
165 |           take_payment
166 | ```
167 | 
168 | {{#label module-tree}}
169 | <span class="caption">Listing {{#ref module-tree}}: The module tree for the code in Listing {{#ref front_of_house}}</span>
170 | 
171 | This tree shows how some of the modules nest inside one another; for example,
172 | `hosting` nests inside `front_of_house`. The tree also shows that some modules
173 | are _siblings_ to each other, meaning theyre defined in the same module;
174 | `hosting` and `serving` are siblings defined within `front_of_house`. If module
175 | A is contained inside module B, we say that module A is the _child_ of module B
176 | and that module B is the _parent_ of module A. Notice that the entire module
177 | tree is rooted under the explicit name of the crate _restaurant_.
178 | 
179 | The module tree might remind you of the filesystems directory tree on your
180 | computer; this is a very apt comparison! Just like directories in a filesystem,
181 | you use modules to organize your code. And just like files in a directory, we
182 | need a way to find our modules.
183 | 
184 | {{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}
185 | 


--------------------------------------------------------------------------------
/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:
--------------------------------------------------------------------------------
  1 | # Paths for Referring to an Item in the Module Tree
  2 | 
  3 | To show Cairo where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path.
  4 | 
  5 | A path can take two forms:
  6 | 
  7 | - An _absolute path_ is the full path starting from a crate root. The absolute path begins with the crate name.
  8 | - A _relative path_ starts from the current module.
  9 | 
 10 | Both absolute and relative paths are followed by one or more identifiers separated by double colons (`::`).
 11 | 
 12 | To illustrate this notion let's take back our example Listing {{#ref front_of_house}} for the restaurant we used in the last chapter. We have a crate named _restaurant_ in which we have a module named `front_of_house` that contains a module named `hosting`. The `hosting` module contains a function named `add_to_waitlist`. We want to call the `add_to_waitlist` function from the `eat_at_restaurant` function. We need to tell Cairo the path to the `add_to_waitlist` function so it can find it.
 13 | 
 14 | <span class="filename">Filename: src/lib.cairo</span>
 15 | 
 16 | ```cairo,noplayground
 17 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:paths}}
 18 | ```
 19 | 
 20 | {{#label path-types}}
 21 | <span class="caption">Listing {{#ref path-types}}: Calling the `add_to_waitlist` function using absolute and relative paths</span>
 22 | 
 23 | The `eat_at_restaurant` function is part of our library's public API, so we mark it with the `pub` keyword. Well go into more detail about `pub` in the ["Exposing Paths with the `pub` Keyword"][pub] section.
 24 | 
 25 | The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,
 26 | we use an absolute path. The `add_to_waitlist` function is defined in the same
 27 | crate as `eat_at_restaurant`. In Cairo, absolute paths start from the crate root, which you need to refer to by using the crate name. You can imagine a filesystem with the same structure: wed specify the path _/front_of_house/hosting/add_to_waitlist_ to run the _add_to_waitlist_ program; using the crate name to start from the crate root is like using a slash (`/`) to start from the filesystem root in your shell.
 28 | 
 29 | The second time we call `add_to_waitlist`, we use a relative path. The path starts with `front_of_house`, the name of the module defined at the same level of the module tree as `eat_at_restaurant`. Here the filesystem equivalent would be using the path _./front_of_house/hosting/add_to_waitlist_. Starting with a module name means that the path is relative to the current module.
 30 | 
 31 | Lets try to compile Listing {{#ref path-types}} and find out why it wont compile yet! We get the following error:
 32 | 
 33 | ```shell
 34 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/output.txt}}
 35 | ```
 36 | 
 37 | The error messages say that module `hosting` and the `add_to_waitlist` function are not visible. In other words, we have the correct paths for the `hosting` module and the `add_to_waitlist` function, but Cairo wont let us use them because it doesnt have access to them. In Cairo, all items (functions, methods, structs, enums, modules, and constants) are private to parent modules by default. If you want to make an item like a function or struct private, you put it in a module.
 38 | 
 39 | Items in a parent module cant use the private items inside child modules, but items in child modules can use the items in their ancestor modules. This is because child modules wrap and hide their implementation details, but the child modules can see the context in which theyre defined. To continue with our metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant they operate.
 40 | 
 41 | Cairo chose to have the module system function this way so that hiding inner implementation details is the default. That way, you know which parts of the inner code you can change without breaking outer code. However, Cairo does give you the option to expose inner parts of child modules code to outer ancestor modules by using the `pub` keyword to make an item public.
 42 | 
 43 | [pub]: ./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#exposing-paths-with-the-pub-keyword
 44 | 
 45 | ## Exposing Paths with the `pub` Keyword
 46 | 
 47 | Lets return to the previous error that told us the `hosting` module and the `add_to_waitlist` function are not visible. We want the `eat_at_restaurant` function in the parent module to have access to the `add_to_waitlist` function in the child module, so we mark the `hosting` module with the `pub` keyword, as shown in Listing {{#ref pub-keyword-not-compiling}}.
 48 | 
 49 | <span class="filename">Filename: src/lib.cairo</span>
 50 | 
 51 | ```cairo,noplayground
 52 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_03_pub_keyword/src/lib.cairo}}
 53 | ```
 54 | 
 55 | {{#label pub-keyword-not-compiling}}
 56 | <span class="caption">Listing {{#ref pub-keyword-not-compiling}}: Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`</span>
 57 | 
 58 | Unfortunately, the code in Listing {{#ref pub-keyword-not-compiling}} still results in an error.
 59 | 
 60 | What happened? Adding the `pub` keyword in front of `mod hosting;` makes the module public. With this change, if we can access `front_of_house`, we can access `hosting`. But the contents of `hosting` are still private; making the module public doesnt make its contents public. The `pub` keyword on a module only lets code in its ancestor modules refer to it, not access its inner code. Because modules are containers, theres not much we can do by only making the module public; we need to go further and choose to make one or more of the items within the module public as well.
 61 | 
 62 | Lets also make the `add_to_waitlist` function public by adding the `pub` keyword before its definition, as in Listing {{#ref pub-keyword}}.
 63 | 
 64 | <span class="filename">Filename: src/lib.cairo</span>
 65 | 
 66 | ```cairo,noplayground
 67 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_04_pub_compiles/src/lib.cairo}}
 68 | ```
 69 | 
 70 | {{#label pub-keyword}}
 71 | <span class="caption">Listing {{#ref pub-keyword}}: Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`</span>
 72 | 
 73 | Now the code will compile! To see why adding the `pub` keyword lets us use these paths in `add_to_waitlist` with respect to the privacy rules, lets look at the absolute and the relative paths.
 74 | 
 75 | In the absolute path, we start with the crate root, the root of our crates module tree. The `front_of_house` module is defined in the crate root. While `front_of_house` isnt public, because the `eat_at_restaurant` function is defined in the same module as `front_of_house` (that is, `front_of_house` and `eat_at_restaurant` are siblings), we can refer to `front_of_house` from `eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can access the parent module of `hosting`, so we can access `hosting` itself. Finally, the `add_to_waitlist` function is marked with `pub` and we can access its parent module, so this function call works!
 76 | 
 77 | In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from `front_of_house`. The `front_of_house` module is defined within the same module as `eat_at_restaurant`, so the relative path starting from the module in which `eat_at_restaurant` is defined works. Then, because `hosting` and `add_to_waitlist` are marked with `pub`, the rest of the path works, and this function call is valid!
 78 | 
 79 | {{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}
 80 | 
 81 | ## Starting Relative Paths with `super`
 82 | 
 83 | We can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using `super` at the start of the path. This is like starting a filesystem path with the `..` syntax. Using `super` allows us to reference an item that we know is in the parent module, which can make rearranging the module tree easier when the module is closely related to the parent, but the parent might be moved elsewhere in the module tree someday.
 84 | 
 85 | Consider the code in Listing {{#ref relative-path}} that models the situation in which a chef fixes an incorrect order and personally brings it out to the customer. The function `fix_incorrect_order` defined in the `back_of_house` module calls the function `deliver_order` defined in the parent module by specifying the path to `deliver_order` starting with `super`:
 86 | 
 87 | <span class="filename">Filename: src/lib.cairo</span>
 88 | 
 89 | ```cairo,noplayground
 90 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_05_super/src/lib.cairo}}
 91 | ```
 92 | 
 93 | {{#label relative-path}}
 94 | <span class="caption">Listing {{#ref relative-path}}: Calling a function using a relative path starting with `super`</span>
 95 | 
 96 | Here you can see directly that you access a parent's module easily using `super`, which wasn't the case previously.
 97 | Note that the `back_of_house` is kept private, as external users are not supposed to interact with the back of house directly.
 98 | 
 99 | ## Making Structs and Enums Public
100 | 
101 | We can also use `pub` to designate structs and enums as public, but there are a few extra details to consider when using `pub` with structs and enums.
102 | 
103 | - If we use `pub` before a struct definition, we make the struct public, but the structs fields will still be private. We can make each field public or not on a case-by-case basis.
104 | - In contrast, if we make an enum public, all of its variants are then public. We only need the `pub` before the `enum` keyword.
105 | 
106 | Theres one more situation involving `pub` that we havent covered, and that is our last module system feature: the `use` keyword. Well cover `use` by itself first, and then well show how to combine `pub` and `use`.
107 | 
108 | {{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}
109 | 


--------------------------------------------------------------------------------
/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:
--------------------------------------------------------------------------------
  1 | # Bringing Paths into Scope with the `use` Keyword
  2 | 
  3 | Having to write out the paths to call functions can feel inconvenient and repetitive. Fortunately, theres a way to simplify this process: we can create a shortcut to a path with the `use` keyword once, and then use the shorter name everywhere else in the scope.
  4 | 
  5 | In Listing {{#ref use-keyword}}, we bring the `crate::front_of_house::hosting` module into the
  6 | scope of the `eat_at_restaurant` function so we only have to specify
  7 | `hosting::add_to_waitlist` to call the `add_to_waitlist` function in
  8 | `eat_at_restaurant`.
  9 | 
 10 | <span class="filename">Filename: src/lib.cairo</span>
 11 | 
 12 | ```cairo
 13 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_06_use/src/lib.cairo:use}}
 14 | ```
 15 | 
 16 | {{#label use-keyword}}
 17 | <span class="caption">Listing {{#ref use-keyword}}: Bringing a module into scope with `use`</span>
 18 | 
 19 | Adding `use` and a path in a scope is similar to creating a symbolic link in the filesystem. By adding `use crate::front_of_house::hosting;` in the crate root, `hosting` is now a valid name in that scope, just as though the `hosting` module had been defined in the crate root.
 20 | 
 21 | Note that `use` only creates the shortcut for the particular scope in which the `use` occurs. Listing {{#ref  use-scope}} moves the `eat_at_restaurant` function into a new child module named `customer`, which is then a different scope than the `use`
 22 | statement, so the function body wont compile:
 23 | 
 24 | <span class="filename">Filename: src/lib.cairo</span>
 25 | 
 26 | ```cairo
 27 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:wrong-path}}
 28 | ```
 29 | 
 30 | {{#label use-scope}}
 31 | <span class="caption">Listing {{#ref  use-scope}}: A `use` statement only applies in the scope its in.</span>
 32 | 
 33 | The compiler error shows that the shortcut no longer applies within the `customer` module:
 34 | 
 35 | ```shell
 36 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/output.txt}}
 37 | ```
 38 | 
 39 | ## Creating Idiomatic `use` Paths
 40 | 
 41 | In Listing {{#ref use-keyword}}, you might have wondered why we specified `use crate::front_of_house::hosting`
 42 | and then called `hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the `use` path all the way out to
 43 | the `add_to_waitlist` function to achieve the same result, as in Listing {{#ref unidiomatic-use}}.
 44 | 
 45 | <span class="filename">Filename: src/lib.cairo</span>
 46 | 
 47 | ```cairo
 48 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_08_unidiomatic_use/src/lib.cairo:unidiomatic-path}}
 49 | ```
 50 | 
 51 | {{#label unidiomatic-use}}
 52 | <span class="caption">Listing {{#ref unidiomatic-use}}: Bringing the `add_to_waitlist` function into scope with `use`, which is unidiomatic</span>
 53 | 
 54 | Although both Listing {{#ref use-keyword}} and {{#ref unidiomatic-use}} accomplish the same task, Listing {{#ref use-keyword}} is
 55 | the idiomatic way to bring a function into scope with `use`. Bringing the
 56 | functions parent module into scope with `use` means we have to specify the
 57 | parent module when calling the function. Specifying the parent module when
 58 | calling the function makes it clear that the function isnt locally defined
 59 | while still minimizing repetition of the full path. The code in Listing {{#ref unidiomatic-use}} is
 60 | unclear as to where `add_to_waitlist` is defined.
 61 | 
 62 | On the other hand, when bringing in structs, enums, traits, and other items with `use`, its idiomatic to specify the full path. Listing {{#ref idiomatic-use}} shows the idiomatic way to bring the core librarys `BitSize` trait into the scope, allowing to call `bits` method to retrieve the size in bits of a type.
 63 | 
 64 | ```cairo
 65 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_09_idiomatic_import/src/lib.cairo}}
 66 | ```
 67 | 
 68 | {{#label idiomatic-use}}
 69 | <span class="caption">Listing {{#ref idiomatic-use}}: Bringing `BitSize` trait into scope in an idiomatic way</span>
 70 | 
 71 | Theres no strong reason behind this idiom: its just the convention that has
 72 | emerged in the Rust community, and folks have gotten used to reading and writing Rust code this way.
 73 | As Cairo shares many idioms with Rust, we follow this convention as well.
 74 | 
 75 | The exception to this idiom is if were bringing two items with the same name
 76 | into scope with `use` statements, because Cairo doesnt allow that.
 77 | 
 78 | ### Providing New Names with the `as` Keyword
 79 | 
 80 | Theres another solution to the problem of bringing two types of the same name
 81 | into the same scope with `use`: after the path, we can specify `as` and a new
 82 | local name, or _alias_, for the type. Listing {{#ref as-keyword}} shows how you can rename an import with `as`:
 83 | 
 84 | <span class="filename">Filename: src/lib.cairo</span>
 85 | 
 86 | ```cairo
 87 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_10_as_keyword/src/lib.cairo}}
 88 | ```
 89 | 
 90 | {{#label as-keyword}}
 91 | <span class="caption">Listing {{#ref as-keyword}}: Renaming a trait when its brought into scope with the `as` keyword</span>
 92 | 
 93 | Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now access the trait's methods with the `Arr` identifier.
 94 | 
 95 | ### Importing Multiple Items from the Same Module
 96 | 
 97 | When you want to import multiple items (like functions, structs or enums)
 98 | from the same module in Cairo, you can use curly braces `{}` to list all of
 99 | the items that you want to import. This helps to keep your code clean and easy
100 | to read by avoiding a long list of individual `use` statements.
101 | 
102 | The general syntax for importing multiple items from the same module is:
103 | 
104 | ```cairo
105 | use module::{item1, item2, item3};
106 | ```
107 | 
108 | Here is an example where we import three structures from the same module:
109 | 
110 | ```cairo
111 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_11_multiple_items/src/lib.cairo}}
112 | ```
113 | 
114 | {{#label multiple-imports}}
115 | <span class="caption">Listing {{#ref multiple-imports}}: Importing multiple items from the same module</span>
116 | 
117 | ## Re-exporting Names in Module Files
118 | 
119 | When we bring a name into scope with the `use` keyword, the name available in
120 | the new scope can be imported as if it had been defined in that codes scope.
121 | This technique is called _re-exporting_ because were bringing an item into scope,
122 | but also making that item available for others to bring into their scope, with the `pub` keyword.
123 | 
124 | For example, let's re-export the `add_to_waitlist` function in the restaurant example:
125 | 
126 | <span class="filename">Filename: src/lib.cairo</span>
127 | 
128 | ```cairo
129 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_12_pub_use/src/lib.cairo:reexporting}}
130 | ```
131 | 
132 | {{#label reexporting}}
133 | <span class="caption">Listing {{#ref reexporting}}: Making a name available for any code to use from a new scope with `pub use`</span>
134 | 
135 | Before this change, external code would have to call the `add_to_waitlist`
136 | function by using the path `restaurant::front_of_house::hosting::add_to_waitlist()`.
137 | Now that this `pub use` has re-exported the `hosting` module from the root module, external code
138 | can now use the path `restaurant::hosting::add_to_waitlist()` instead.
139 | 
140 | Re-exporting is useful when the internal structure of your code is different
141 | from how programmers calling your code would think about the domain. For
142 | example, in this restaurant metaphor, the people running the restaurant think
143 | about front of house and back of house. But customers visiting a restaurant
144 | probably wont think about the parts of the restaurant in those terms. With
145 | `pub use`, we can write our code with one structure but expose a different
146 | structure. Doing so makes our library well organized for programmers working on
147 | the library and programmers calling the library.
148 | 
149 | ## Using External Packages in Cairo with Scarb
150 | 
151 | You might need to use external packages to leverage the functionality provided by the community. Scarb allows you to use dependencies by cloning packages from their Git repositories. To use an external package in your project with Scarb, simply declare the Git repository URL of the dependency you want to add in a dedicated `[dependencies]` section in your _Scarb.toml_ configuration file. Note that the URL might correspond to the main branch, or any specific commit, branch or tag. For this, you will have to pass an extra `rev`, `branch`, or `tag` field, respectively. For example, the following code imports the main branch of _alexandria_math_ crate from _alexandria_ package:
152 | 
153 | ```cairo
154 | [dependencies]
155 | alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git" }
156 | ```
157 | 
158 | while the following code imports a specific branch (which is deprecated and should not be used):
159 | 
160 | ```cairo
161 | [dependencies]
162 | alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git", branch = "cairo-v2.3.0-rc0" }
163 | ```
164 | 
165 | If you want to import multiple packages in your project, you need to create only one `[dependencies]` section and list all the desired packages beneath it. You can also specify development dependencies by declaring a `[dev-dependencies]` section.
166 | 
167 | After that, simply run `scarb build` to fetch all external dependencies and compile your package with all the dependencies included.
168 | 
169 | Note that it is also possible to add dependencies with the `scarb add` command, which will automatically edit the _Scarb.toml_ file for you. For development dependencies, just use the `scarb add --dev` command.
170 | 
171 | To remove a dependency, simply remove the corresponding line from your _Scarb.toml_ file, or use the `scarb rm` command.
172 | 
173 | ## The Glob Operator
174 | 
175 | If we want to bring _all_ public items defined in a path into scope, we can
176 | specify that path followed by the `*` glob operator:
177 | 
178 | ```rust
179 | use core::num::traits::*;
180 | ```
181 | 
182 | This `use` statement brings all public items defined in `core::num::traits` into
183 | the current scope. Be careful when using the glob operator! Glob can make it
184 | harder to tell what names are in scope and where a name used in your program
185 | was defined.
186 | 
187 | The glob operator is often used when testing to bring everything under test
188 | into the `tests` module; well talk about that in the [How to Write
189 | Tests][writing-tests] section in Chapter {{#chap how-to-write-tests}}.
190 | 
191 | [writing-tests]: ./ch10-01-how-to-write-tests.md
192 | 
193 | {{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}
194 | 


--------------------------------------------------------------------------------
/src/ch07-05-separating-modules-into-different-files.md:
--------------------------------------------------------------------------------
  1 | # Separating Modules into Different Files
  2 | 
  3 | So far, all the examples in this chapter defined multiple modules in one file.
  4 | When modules get large, you might want to move their definitions to a separate
  5 | file to make the code easier to navigate.
  6 | 
  7 | For example, lets start from the code in Listing {{#ref use-keyword}} that had multiple
  8 | restaurant modules. Well extract modules into files instead of having all the
  9 | modules defined in the crate root file. In this case, the crate root file is
 10 | _src/lib.cairo_.
 11 | 
 12 | First, well extract the `front_of_house` module to its own file. Remove the
 13 | code inside the curly brackets for the `front_of_house` module, leaving only
 14 | the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the code
 15 | shown in Listing {{#ref front-extraction}}. Note that this wont compile until we create the
 16 | _src/front_of_house.cairo_ file.
 17 | 
 18 | <span class="filename">Filename: src/lib.cairo</span>
 19 | 
 20 | ```cairo,noplayground
 21 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_13_front_extraction/src/lib.cairo:front-extraction}}
 22 | ```
 23 | 
 24 | {{#label front-extraction}}
 25 | <span class="caption">Listing {{#ref front-extraction}}: Declaring the `front_of_house` module whose body will be in _src/front_of_house.cairo_</span>
 26 | 
 27 | Next, place the code that was in the curly brackets into a new file named
 28 | _src/front_of_house.cairo_, as shown in Listing {{#ref module-foh}}. The compiler knows to look
 29 | in this file because it came across the module declaration in the crate root
 30 | with the name `front_of_house`.
 31 | 
 32 | <span class="filename">Filename: src/front_of_house.cairo</span>
 33 | 
 34 | ```cairo,noplayground
 35 | {{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_14_front_definition/src/lib.cairo}}
 36 | ```
 37 | 
 38 | {{#label module-foh}}
 39 | <span class="caption">Listing {{#ref module-foh}}: Definitions inside the `front_of_house` module in _src/front_of_house.cairo_</span>
 40 | 
 41 | Note that you only need to load a file using a `mod` declaration _once_ in your
 42 | module tree. Once the compiler knows the file is part of the project (and knows
 43 | where in the module tree the code resides because of where youve put the `mod`
 44 | statement), other files in your project should refer to the loaded files code
 45 | using a path to where it was declared, as covered in the ["Paths for Referring to an Item in the Module Tree"][path] chapter.
 46 | In other words, `mod` is _not_ an include operation that you may have seen in other
 47 | programming languages.
 48 | 
 49 | Next, well extract the `hosting` module to its own file. The process is a bit
 50 | different because `hosting` is a child module of `front_of_house`, not of the
 51 | root module. Well place the file for `hosting` in a new directory that will be
 52 | named for its ancestors in the module tree, in this case _src/front_of_house/_.
 53 | 
 54 | To start moving `hosting`, we change _src/front_of_house.cairo_ to contain only the
 55 | declaration of the `hosting` module:
 56 | 
 57 | <span class="filename">Filename: src/front_of_house.cairo</span>
 58 | 
 59 | ```cairo,noplayground
 60 | pub mod hosting;
 61 | ```
 62 | 
 63 | Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ to
 64 | contain the definitions made in the `hosting` module:
 65 | 
 66 | <span class="filename">Filename: src/front_of_house/hosting.cairo</span>
 67 | 
 68 | ```cairo,noplayground
 69 | pub fn add_to_waitlist() {}
 70 | ```
 71 | 
 72 | If we instead put _hosting.cairo_ in the _src_ directory, the compiler would
 73 | expect the _hosting.cairo_ code to be in a `hosting` module declared in the crate
 74 | root, and not declared as a child of the `front_of_house` module. The
 75 | compilers rules for which files to check for which modules code means the
 76 | directories and files more closely match the module tree.
 77 | 
 78 | Weve moved each modules code to a separate file, and the module tree remains
 79 | the same. The function calls in `eat_at_restaurant` will work without any
 80 | modification, even though the definitions live in different files. This
 81 | technique lets you move modules to new files as they grow in size.
 82 | 
 83 | Note that the `use crate::front_of_house::hosting;` statement in
 84 | _src/lib.cairo_ also hasnt changed, nor does `use` have any impact on what files
 85 | are compiled as part of the crate. The `mod` keyword declares modules, and Cairo
 86 | looks in a file with the same name as the module for the code that goes into
 87 | that module.
 88 | 
 89 | [path]: ./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md
 90 | 
 91 | ## Summary
 92 | 
 93 | Cairo lets you split a package into multiple crates and a crate into modules
 94 | so you can refer to items defined in one module from another module. You can do
 95 | this by specifying absolute or relative paths. These paths can be brought into
 96 | scope with a `use` statement so you can use a shorter path for multiple uses of
 97 | the item in that scope. Module code is **private** by default.
 98 | 
 99 | {{#quiz ../quizzes/ch07-05-separate-modules.toml}}
100 | 


--------------------------------------------------------------------------------
/src/ch08-00-generic-types-and-traits.md:
--------------------------------------------------------------------------------
 1 | # Generic Types and Traits
 2 | 
 3 | Every programming language has tools for effectively handling the duplication of concepts. In Cairo, one such tool is generics: abstract stand-ins for concrete types or other properties. We can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.
 4 | 
 5 | Functions can take parameters of some generic type, instead of a concrete type like `u32` or `bool`, in the same way a function takes parameters with unknown values to run the same code on multiple concrete values. In fact, weve already used generics in [Chapter {{#chap enums-and-pattern-matching}}][option enum] with `Option<T>`.
 6 | 
 7 | In this chapter, youll explore how to define your own types, functions, and traits with generics.
 8 | 
 9 | Generics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication. Upon compilation, the compiler creates a new definition for each concrete type that replaces a generic type, reducing development time for the programmer, but code duplication at compile level still exists. This may be of importance if you are writing Starknet contracts and using a generic for multiple types which will cause contract size to increment.
10 | 
11 | Then youll learn how to use traits to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to accept only those types that have a particular behavior, as opposed to just any type.
12 | 
13 | [option enum]: ./ch06-01-enums.md#the-option-enum-and-its-advantages
14 | 
15 | ## Removing Duplication by Extracting a Function
16 | 
17 | Generics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication. Before diving into generics syntax, lets first look at how to remove duplication in a way that doesnt involve generic types by extracting a function that replaces specific values with a placeholder that represents multiple values. Then well apply the same technique to extract a generic function! By learning how to identify duplicated code that can be extracted into a function, you'll start to recognize instances where generics can be used to reduce duplication.
18 | 
19 | We begin with a short program that finds the largest number in an array of `u8`:
20 | 
21 | ```cairo
22 | {{#include ../listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_01/src/lib.cairo}}
23 | ```
24 | 
25 | We store an array of `u8` in the variable `number_list` and extract the first number in the array in a variable named `largest`. We then iterate through all the numbers in the array, and if the current number is greater than the number stored in `largest`, we update the value of `largest`. However, if the current number is less than or equal to the largest number seen so far, the variable doesnt change, and the code moves on to the next number in the list. After considering all the numbers in the array, `largest` should contain the largest number, which in this case is 100.
26 | 
27 | We've now been tasked with finding the largest number in two different arrays of numbers. To do so, we can choose to duplicate the previous code and use the same logic at two different places in the program, as follows:
28 | 
29 | ```cairo
30 | {{#include ../listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_02/src/lib.cairo}}
31 | ```
32 | 
33 | Although this code works, duplicating code is tedious and error-prone. We also have to remember to update the code in multiple places when we want to change it.
34 | 
35 | To eliminate this duplication, well create an abstraction by defining a function that operates on any array of `u8` passed in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in an array abstractly.
36 | 
37 | To do that, we extract the code that finds the largest number into a function named `largest`. Then we call the function to find the largest number in the two arrays. We could also use the function on any other array of `u8` values we might have in the future.
38 | 
39 | ```cairo
40 | {{#include ../listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_03/src/lib.cairo}}
41 | ```
42 | 
43 | The largest function has a parameter called `number_list`, passed by reference, which represents any concrete array of `u8` values we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.
44 | 
45 | In summary, here are the steps we took to change the code:
46 | 
47 | - Identify duplicate code.
48 | - Extract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature.
49 | - Update the two instances of duplicated code to call the function instead.
50 | 
51 | Next, well use these same steps with generics to reduce code duplication. In the same way that the function body can operate on an abstract `Array<T>` instead of specific `u8` values, generics allow code to operate on abstract types.
52 | 


--------------------------------------------------------------------------------
/src/ch08-01-generic-data-types.md:
--------------------------------------------------------------------------------
  1 | # Generic Data Types
  2 | 
  3 | We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo, we can use generics when defining functions, structs, enums, traits, implementations and methods. In this chapter, we are going to take a look at how to effectively use generic types with all of them.
  4 | 
  5 | Generics allow us to write reusable code that works with many types, thus avoiding code duplication, while enhancing code maintainability.
  6 | 
  7 | ## Generic Functions
  8 | 
  9 | Making a function generic means it can operate on different types, avoiding the need for multiple, type-specific implementations. This leads to significant code reduction and increases the flexibility of the code.
 10 | 
 11 | When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two `Array` of items, will return the largest one. If we need to perform this operation for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks.
 12 | 
 13 | ```cairo
 14 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_01_missing_tdrop/src/lib.cairo:generic}}
 15 | ```
 16 | 
 17 | The `largest_list` function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to guarantee that an `Array<T>` is droppable when executing the `main` function. In order to drop an array of `T`, the compiler must first know how to drop `T`. This can be fixed by specifying in the function signature of `largest_list` that `T` must implement the `Drop` trait. The correct function definition of `largest_list` is as follows:
 18 | 
 19 | ```cairo
 20 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_02_with_tdrop/src/lib.cairo}}
 21 | ```
 22 | 
 23 | The new `largest_list` function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. This is what we call _trait bounds_. The `main` function remains unchanged, the compiler is smart enough to deduce which concrete type is being used and if it implements the `Drop` trait.
 24 | 
 25 | ### Constraints for Generic Types
 26 | 
 27 | When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allows us to use it more effectively in a function's logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the `TDrop` implementation as part of the generic arguments of `largest_list`. While `TDrop` was added to satisfy the compiler's requirements, we can also add constraints to benefit our function logic.
 28 | 
 29 | Imagine that we want, given a list of elements of some generic type `T`, to find the smallest element among them. Initially, we know that for an element of type `T` to be comparable, it must implement the `PartialOrd` trait. The resulting function would be:
 30 | 
 31 | ```cairo
 32 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_03_missing_tcopy/src/lib.cairo:missing-tcopy}}
 33 | ```
 34 | 
 35 | The `smallest_element` function uses a generic type `T` that implements the `PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and returns a copy of the smallest element. Because the parameter is of type `@Array<T>`, we no longer need to drop it at the end of the execution and so we are not required to implement the `Drop` trait for `T` as well. Why does it not compile then?
 36 | 
 37 | When indexing on `list`, the value results in a snap of the indexed element, and unless `PartialOrd` is implemented for `@T` we need to desnap the element using `*`. The `*` operation requires a copy from `@T` to `T`, which means that `T` needs to implement the `Copy` trait. After copying an element of type `@T` to `T`, there are now variables with type `T` that need to be dropped, requiring `T` to implement the `Drop` trait as well. We must then add both `Drop` and `Copy` traits implementation for the function to be correct. After updating the `smallest_element` function the resulting code would be:
 38 | 
 39 | ```cairo
 40 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_04_with_tcopy/src/lib.cairo}}
 41 | ```
 42 | 
 43 | ### Anonymous Generic Implementation Parameter (`+` Operator)
 44 | 
 45 | Until now, we have always specified a name for each implementation of the required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for `Drop<T>`, and `TCopy` for `Copy<T>`.
 46 | 
 47 | However, most of the time, we don't use the implementation in the function body; we only use it as a constraint. In these cases, we can use the `+` operator to specify that the generic type must implement a trait without naming the implementation. This is referred to as an _anonymous generic implementation parameter_.
 48 | 
 49 | For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: PartialOrd<T>`.
 50 | 
 51 | We can rewrite the `smallest_element` function signature as follows:
 52 | 
 53 | ```cairo
 54 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_05_with_anonymous_impl/src/lib.cairo:1}}
 55 | ```
 56 | 
 57 | ## Structs
 58 | 
 59 | We can also define structs to use a generic type parameter for one or more fields using the `<>` syntax, similar to function definitions. First, we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition `Wallet<T>` which has a `balance` field of type `T`.
 60 | 
 61 | ```cairo
 62 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_06_derive_generics/src/lib.cairo}}
 63 | ```
 64 | 
 65 | The above code derives the `Drop` trait for the `Wallet` type automatically. It is equivalent to writing the following code:
 66 | 
 67 | ```cairo
 68 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_07_drop_explicit/src/lib.cairo}}
 69 | ```
 70 | 
 71 | We avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead define our own `WalletDrop` implementation. Notice that we must define, just like functions, an additional generic type for `WalletDrop` saying that `T` implements the `Drop` trait as well. We are basically saying that the struct `Wallet<T>` is droppable as long as `T` is also droppable.
 72 | 
 73 | Finally, if we want to add a field to `Wallet` representing its address and we want that field to be different than `T` but generic as well, we can simply add another generic type between the `<>`:
 74 | 
 75 | ```cairo
 76 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_08_two_generics/src/lib.cairo}}
 77 | ```
 78 | 
 79 | We add to the `Wallet` struct definition a new generic type `U` and then assign this type to the new field member `address`. Notice that the `derive` attribute for the `Drop` trait works for `U` as well.
 80 | 
 81 | ## Enums
 82 | 
 83 | As we did with structs, we can define enums to hold generic data types in their variants. For example the `Option<T>` enum provided by the Cairo core library:
 84 | 
 85 | ```cairo,noplayground
 86 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_09_option/src/lib.cairo}}
 87 | ```
 88 | 
 89 | The `Option<T>` enum is generic over a type `T` and has two variants: `Some`, which holds one value of type `T` and `None` that doesn't hold any value. By using the `Option<T>` enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type `T` we can use this abstraction with any type.
 90 | 
 91 | Enums can use multiple generic types as well, like the definition of the `Result<T, E>` enum that the core library provides:
 92 | 
 93 | ```cairo,noplayground
 94 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_10_result/src/lib.cairo}}
 95 | ```
 96 | 
 97 | The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`).
 98 | 
 99 | ## Generic Methods
100 | 
101 | We can implement methods on structs and enums, and use the generic types in their definitions, too. Using our previous definition of `Wallet<T>` struct, we define a `balance` method for it:
102 | 
103 | ```cairo
104 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_11_generic_methods/src/lib.cairo}}
105 | ```
106 | 
107 | We first define `WalletTrait<T>` trait using a generic type `T` which defines a method that returns the value of the field `balance` from `Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. Note that you need to include a generic type in both definitions of the trait and the implementation.
108 | 
109 | We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for `Wallet<u128>` instances rather than `Wallet<T>`. In the code example, we define an implementation for wallets which have a concrete type of `u128` for the `balance` field.
110 | 
111 | ```cairo
112 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_12_constrained_generics/src/lib.cairo}}
113 | ```
114 | 
115 | The new method `receive` increments the size of `balance` of any instance of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a mutable variable in order for it to be able to update its balance. If we were to change the initialization of `w` by changing the type of `balance` the previous code wouldn't compile.
116 | 
117 | Cairo allows us to define generic methods inside generic traits as well. Using the past implementation from `Wallet<U, V>` we are going to define a trait that picks two wallets of different generic types and creates a new one with a generic type of each. First, let's rewrite the struct definition:
118 | 
119 | ```cairo,noplayground
120 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_13_not_compiling/src/lib.cairo:struct}}
121 | ```
122 | 
123 | Next, we are going to naively define the mixup trait and implementation:
124 | 
125 | ```cairo,noplayground
126 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_13_not_compiling/src/lib.cairo:trait_impl}}
127 | 
128 | ```
129 | 
130 | We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` and `other` are getting dropped at the end of the function, which is why this code does not compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifying that they will implement the `Drop` trait for the compiler to know how to drop instances of `Wallet<T, U>`. The updated implementation is as follows:
131 | 
132 | ```cairo
133 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_14_compiling/src/lib.cairo:trait_impl}}
134 | ```
135 | 
136 | We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` declaration. Then we do the same for `T2` and `U2`, this time as part of `mixup` signature. We can now try the `mixup` function:
137 | 
138 | ```cairo,noplayground
139 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_14_compiling/src/lib.cairo:main}}
140 | ```
141 | 
142 | We first create two instances: one of `Wallet<bool, u128>` and the other of `Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, u8>` instance.
143 | 


--------------------------------------------------------------------------------
/src/ch08-02-traits-in-cairo.md:
--------------------------------------------------------------------------------
  1 | # Traits in Cairo
  2 | 
  3 | A trait defines a set of methods that can be implemented by a type. These methods can be called on instances of the type when this trait is implemented.
  4 | A trait combined with a generic type defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way.
  5 | We can use _trait bounds_ to specify that a generic type can be any type that has certain behavior.
  6 | 
  7 | > Note: Traits are similar to a feature often called interfaces in other languages, although with some differences.
  8 | 
  9 | While traits can be written to not accept generic types, they are most useful when used with generic types. We already covered generics in the [previous chapter][generics], and we will use them in this chapter to demonstrate how traits can be used to define shared behavior for generic types.
 10 | 
 11 | [generics]: ./ch08-01-generic-data-types.md
 12 | 
 13 | ## Defining a Trait
 14 | 
 15 | A types behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.
 16 | 
 17 | For example, lets say we have a struct `NewsArticle` that holds a news story in a particular location. We can define a trait `Summary` that describes the behavior of something that can summarize the `NewsArticle` type.
 18 | 
 19 | ```cairo,noplayground
 20 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_14_simple_trait/src/lib.cairo:trait}}
 21 | ```
 22 | 
 23 | {{#label first_trait_signature}}
 24 | <span class="caption"> Listing {{#ref first_trait_signature}}: A `Summary` trait that consists of the behavior provided by a `summarize` method</span>
 25 | 
 26 | In Listing {{#ref first_trait_signature}}, we declare a trait using the `trait` keyword and then the traits name, which is `Summary` in this case.
 27 | Weve also declared the trait as `pub` so that crates depending on this crate can make use of this trait too, as well see in a few examples.
 28 | 
 29 | Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is `fn summarize(self: @NewsArticle) -> ByteArray;`. After the method signature, instead of providing an implementation within curly brackets, we use a semicolon.
 30 | 
 31 | > Note: the `ByteArray` type is the type used to represent strings in Cairo.
 32 | 
 33 | As the trait is not generic, the `self` parameter is not generic either and is of type `@NewsArticle`. This means that the `summarize` method can only be called on instances of `NewsArticle`.
 34 | 
 35 | Now, consider that we want to make a media aggregator library crate named _aggregator_ that can display summaries of data that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we need a summary from each type, and well request that summary by calling a summarize method on an instance of that type. By defining the `Summary` trait on generic type `T`, we can implement the `summarize` method on any type we want to be able to summarize.
 36 | 
 37 | ```cairo,noplayground
 38 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_15_traits/src/lib.cairo:trait}}
 39 | ```
 40 | 
 41 | {{#label trait_signature}}
 42 | <span class="caption"> Listing {{#ref trait_signature}}: A `Summary` trait that consists of the behavior provided by a `summarize` method for a generic type</span>
 43 | 
 44 | Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that implements the `Summary` trait will have the method `summarize` defined with this signature exactly.
 45 | 
 46 | A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.
 47 | 
 48 | ## Implementing a Trait on a Type
 49 | 
 50 | Now that weve defined the desired signatures of the `Summary` traits methods,
 51 | we can implement it on the types in our media aggregator. The following code shows
 52 | an implementation of the `Summary` trait on the `NewsArticle` struct that uses
 53 | the headline, the author, and the location to create the return value of
 54 | `summarize`. For the `Tweet` struct, we define `summarize` as the username
 55 | followed by the entire text of the tweet, assuming that tweet content is
 56 | already limited to 280 characters.
 57 | 
 58 | ```cairo,noplayground
 59 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_15_traits/src/lib.cairo:impl}}
 60 | ```
 61 | 
 62 | {{#label trait_impl}}
 63 | <span class="caption"> Listing {{#ref trait_impl}}: Implementation of the `Summary` trait on `NewsArticle` and `Tweet`</span>
 64 | 
 65 | Implementing a trait on a type is similar to implementing regular methods. The
 66 | difference is that after `impl`, we put a name for the implementation,
 67 | then use the `of` keyword, and then specify the name of the trait we are writing the implementation for.
 68 | If the implementation is for a generic type, we place the generic type name in the angle brackets after the trait name.
 69 | 
 70 | Note that for the trait method to be accessible, there must be an implementation of that trait visible from the scope where the method is called. If the trait is `pub` and the implementation is not, and the implementation is not visible in the scope where the trait method is called, this will cause a compilation error.
 71 | 
 72 | Within the `impl` block, we put the method signatures
 73 | that the trait definition has defined. Instead of adding a semicolon after each
 74 | signature, we use curly brackets and fill in the method body with the specific
 75 | behavior that we want the methods of the trait to have for the particular type.
 76 | 
 77 | Now that the library has implemented the `Summary` trait on `NewsArticle` and
 78 | `Tweet`, users of the crate can call the trait methods on instances of
 79 | `NewsArticle` and `Tweet` in the same way we call regular methods. The only
 80 | difference is that the user must bring the trait into scope as well as the
 81 | types. Heres an example of how a crate could use our `aggregator` crate:
 82 | 
 83 | ```cairo
 84 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_15_traits/src/lib.cairo:main}}
 85 | ```
 86 | 
 87 | {{#label trait_main}}
 88 | 
 89 | This code prints the following:
 90 | 
 91 | ```shell
 92 | {{#include ../listings/ch08-generic-types-and-traits/no_listing_15_traits/output.txt}}
 93 | ```
 94 | 
 95 | Other crates that depend on the _aggregator_ crate can also bring the `Summary` trait into scope to implement `Summary` on their own types.
 96 | 
 97 | ## Default Implementations
 98 | 
 99 | Sometimes its useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type. Then, as we implement the trait on a particular type, we can keep or override each methods default behavior.
100 | 
101 | In Listing {{#ref default_impl}} we specify a default string for the `summarize` method of the `Summary` trait instead of only defining the method signature, as we did in Listing {{#ref trait_signature}}.
102 | 
103 | <span class="caption">Filename: src/lib.cairo</span>
104 | 
105 | ```cairo
106 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/listing_default_impl/src/lib.cairo:trait}}
107 | ```
108 | 
109 | {{#label default_impl}}
110 | <span class="caption"> Listing {{#ref default_impl}}: Defining a `Summary` trait with a default implementation of the `summarize` method</span>
111 | 
112 | To use a default implementation to summarize instances of `NewsArticle`, we specify an empty `impl` block with `impl NewsArticleSummary of Summary<NewsArticle> {}`.
113 | 
114 | Even though were no longer defining the `summarize` method on `NewsArticle` directly, weve provided a default implementation and specified that `NewsArticle` implements the `Summary` trait. As a result, we can still call the `summarize` method on an instance of `NewsArticle`, like this:
115 | 
116 | ```cairo
117 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/listing_default_impl/src/lib.cairo:main}}
118 | ```
119 | 
120 | This code prints `New article available! (Read more...)`.
121 | 
122 | Creating a default implementation doesnt require us to change anything about the previous implementation of `Summary` on `Tweet`. The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesnt have a default implementation.
123 | 
124 | Default implementations can call other methods in the same trait, even if those other methods dont have a default implementation. In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it. For example, we could define the `Summary` trait to have a `summarize_author` method whose implementation is required, and then define a `summarize` method that has a default implementation that calls the `summarize_author` method:
125 | 
126 | ```cairo
127 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_default_impl_self_call/src/lib.cairo:trait}}
128 | ```
129 | 
130 | To use this version of `Summary`, we only need to define `summarize_author` when we implement the trait on a type:
131 | 
132 | ```cairo
133 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_default_impl_self_call/src/lib.cairo:impl}}
134 | ```
135 | 
136 | After we define `summarize_author`, we can call `summarize` on instances of the `Tweet` struct, and the default implementation of `summarize` will call the definition of `summarize_author` that weve provided. Because weve implemented `summarize_author`, the `Summary` trait has given us the behavior of the `summarize` method without requiring us to write any more code.
137 | 
138 | ```cairo
139 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_default_impl_self_call/src/lib.cairo:main}}
140 | ```
141 | 
142 | This code prints `1 new tweet: (Read more from @EliBenSasson...)`.
143 | 
144 | Note that it isnt possible to call the default implementation from an overriding implementation of that same method.
145 | 
146 | <!-- TODO: NOT AVAILABLE IN CAIRO FOR NOW move traits as parameters here -->
147 | <!-- ## Traits as parameters
148 | 
149 | Now that you know how to define and implement traits, we can explore how to use
150 | traits to define functions that accept many different types. We'll use the
151 | `Summary` trait we implemented on the `NewsArticle` and `Tweet` types to define a `notify` function that calls the `summarize` method
152 | on its `item` parameter, which is of some type that implements the `Summary` trait. To do this, we use the `impl Trait` syntax. 
153 | 
154 | Instead of a concrete type for the `item` parameter, we specify the `impl`
155 | keyword and the trait name. This parameter accepts any type that implements the
156 | specified trait. In the body of `notify`, we can call any methods on `item`
157 | that come from the `Summary` trait, such as `summarize`. We can call `notify`
158 | and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
159 | function with any other type, such as a `String` or an `i32`, wont compile
160 | because those types dont implement `Summary`. -->
161 | 
162 | <!-- TODO NOT AVAILABLE IN CAIRO FOR NOW Using trait bounds to conditionally implement methods -->
163 | 
164 | ## Managing and Using External Trait
165 | 
166 | To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In some cases you might need to import not only the trait but also the implementation if they are declared in separate modules.
167 | If `CircleGeometry` implementation was in a separate module/file named _circle_, then to define `boundary` method on `Circle` struct, we'd need to import `ShapeGeometry` trait in the _circle_ module.
168 | 
169 | If the code were to be organized into modules like in Listing {{#ref external_trait}} where the implementation of a trait is defined in a different module than the trait itself, explicitly importing the relevant trait or implementation would be required.
170 | 
171 | ```cairo,noplayground
172 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_17_generic_traits/src/lib.cairo}}
173 | ```
174 | 
175 | {{#label external_trait}}
176 | <span class="caption"> Listing {{#ref external_trait}}: Implementing an external trait</span>
177 | 
178 | Note that in Listing {{#ref external_trait}}, `CircleGeometry` and `RectangleGeometry` implementations don't need to be declared as `pub`. Indeed, `ShapeGeometry` trait, which is public, is used to print the result in the `main` function. The compiler will find the appropriate implementation for the `ShapeGeometry` public trait, regardless of the implementation visibility.
179 | 
180 | ## Impl Aliases
181 | 
182 | Implementations can be aliased when imported. This is most useful when you want to instantiate generic implementations with concrete types. For example, let's say we define a trait `Two` that is used to return the value `2` for a type `T`. We can write a trivial generic implementation of `Two` for all types that implement the `One` trait, simply by adding twice the value of `one` and returning it. However, in our public API, we may only want to expose the `Two` implementation for the `u8` and `u128` types.
183 | 
184 | ```cairo,noplayground
185 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/listing_impl_aliases/src/lib.cairo}}
186 | ```
187 | 
188 | {{#label impl-aliases}}
189 | <span class="caption"> Listing {{#ref impl-aliases}}: Using impl aliases to instantiate generic impls with concrete types</span>
190 | 
191 | We can define the generic implementation in a private module, use an impl alias to instantiate the generic implementation for these two concrete types, and make these two implementations public, while keeping the generic implementation private and unexposed. This way, we can avoid code duplication using the generic implementation, while keeping the public API clean and simple.
192 | 
193 | ## Negative Impls
194 | 
195 | > Note: This is still an experimental feature and can only be used if `experimental-features = ["negative_impls"]` is enabled in your _Scarb.toml_ file, under the `[package]` section.
196 | 
197 | Negative implementations, also known as negative traits or negative bounds, are a mechanism that allows you to express that a type does not implement a certain trait when defining the implementation of a trait over a generic type. Negative impls enable you to write implementations that are applicable only when another implementation does not exist in the current scope.
198 | 
199 | For example, let's say we have a trait `Producer` and a trait `Consumer`, and we want to define a generic behavior where all types implement the `Consumer` trait by default. However, we want to ensure that no type can be both a `Consumer` and a `Producer`. We can use negative impls to express this restriction.
200 | 
201 | In Listing {{#ref negative-impls}}, we define a `ProducerType` that implements the `Producer` trait, and two other types, `AnotherType` and `AThirdType`, which do not implement the `Producer` trait. We then use negative impls to create a default implementation of the `Consumer` trait for all types that do not implement the `Producer` trait.
202 | 
203 | ```cairo
204 | {{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_18_negative_impl/src/lib.cairo}}
205 | ```
206 | 
207 | {{#label negative-impls}}
208 | <span class="caption"> Listing {{#ref negative-impls}}: Using negative impls to enforce that a type cannot implement both `Producer` and `Consumer` traits simultaneously</span>
209 | 
210 | In the `main` function, we create instances of `ProducerType`, `AnotherType`, and `AThirdType`. We then call the `produce` method on the `producer` instance and pass the result to the `consume` method on the `another_type` and `third_type` instances. Finally, we try to call the `consume` method on the `producer` instance, which results in a compile-time error because `ProducerType` does not implement the `Consumer` trait.
211 | 
212 | {{#quiz ../quizzes/ch08-02-traits.toml}}
213 | 


--------------------------------------------------------------------------------
/src/ch09-00-error-handling.md:
--------------------------------------------------------------------------------
1 | # Error handling
2 | 
3 | In this chapter, we will explore various error handling techniques provided by Cairo, which not only allow you to address potential issues in your code, but also make it easier to create programs that are adaptable and maintainable. By examining different approaches to managing errors, such as pattern matching with the `Result` enum, using the `?` operator for more ergonomic error propagation, and employing the `unwrap` or `expect` methods for handling recoverable errors, you'll gain a deeper understanding of Cairo's error handling features. These concepts are crucial for building robust applications that can effectively handle unexpected situations, ensuring your code is ready for production.
4 | 


--------------------------------------------------------------------------------
/src/ch09-01-unrecoverable-errors-with-panic.md:
--------------------------------------------------------------------------------
 1 | # Unrecoverable Errors with `panic`
 2 | 
 3 | In Cairo, unexpected issues may arise during program execution, resulting in runtime errors. While the `panic` function from the core library doesn't provide a resolution for these errors, it does acknowledge their occurrence and terminates the program. There are two primary ways that a panic can be triggered in Cairo: inadvertently, through actions causing the code to panic (e.g., accessing an array beyond its bounds), or deliberately, by invoking the `panic` function.
 4 | 
 5 | When a panic occurs, it leads to an abrupt termination of the program. The `panic` function takes an array as an argument, which can be used to provide an error message and performs an unwind process where all variables are dropped and dictionaries squashed to ensure the soundness of the program to safely terminate the execution.
 6 | 
 7 | Here is how we can call `panic` from inside a program and return the error code `2`:
 8 | 
 9 | <span class="filename">Filename: src/lib.cairo</span>
10 | 
11 | ```cairo
12 | {{#include ../listings/ch09-error-handling/no_listing_01_panic/src/lib.cairo}}
13 | ```
14 | 
15 | Running the program will produce the following output:
16 | 
17 | ```shell
18 | {{#include ../listings/ch09-error-handling/no_listing_01_panic/output.txt}}
19 | ```
20 | 
21 | As you can notice in the output, the call to `println!` macro is never reached, as the program terminates after encountering the `panic` statement.
22 | 
23 | An alternative and more idiomatic approach to panic in Cairo would be to use the `panic_with_felt252` function. This function serves as an abstraction of the array-defining process and is often preferred due to its clearer and more concise expression of intent. By using `panic_with_felt252`, developers can panic in a one-liner by providing a `felt252` error message as an argument, making the code more readable and maintainable.
24 | 
25 | Let's consider an example:
26 | 
27 | ```cairo
28 | {{#include ../listings/ch09-error-handling/no_listing_02_with_felt252/src/lib.cairo}}
29 | ```
30 | 
31 | Executing this program will yield the same error message as before. In that case, if there is no need for an array and multiple values to be returned within the error, `panic_with_felt252` is a more succinct alternative.
32 | 
33 | ## `panic!` Macro
34 | 
35 | `panic!` macro can be really helpful. The previous example returning the error code `2` shows how convenient `panic!` macro is. There is no need to create an array and pass it as an argument like with the `panic` function.
36 | 
37 | ```cairo
38 | {{#include ../listings/ch09-error-handling/no_listing_03_panic_macro/src/lib.cairo}}
39 | ```
40 | 
41 | Unlike the `panic_with_felt252` function, using `panic!` allows the input, which is ultimately the panic error, to be a literal longer than 31 bytes. This is because `panic!` takes a string as a parameter. For example, the following line of code will successfully compile:
42 | 
43 | ```cairo, noplayground
44 | panic!("the error for panic! macro is not limited to 31 characters anymore");
45 | ```
46 | 
47 | ## `nopanic` Notation
48 | 
49 | You can use the `nopanic` notation to indicate that a function will never panic. Only `nopanic` functions can be called in a function annotated as `nopanic`.
50 | 
51 | Here is an example:
52 | 
53 | ```cairo,noplayground
54 | {{#include ../listings/ch09-error-handling/no_listing_04_nopanic/src/lib.cairo}}
55 | ```
56 | 
57 | This function will always return `42` and is guaranteed to never panic. Conversely, the following function is not guaranteed to never panic:
58 | 
59 | ```cairo,noplayground
60 | {{#include ../listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:wrong-nopanic}}
61 | ```
62 | 
63 | If you try to compile this function that includes code that may panic, you will get the following error:
64 | 
65 | ```shell
66 | {{#include ../listings/ch09-error-handling/no_listing_05_nopanic_wrong/output.txt}}
67 | ```
68 | 
69 | Note that there are two functions that may panic here, `assert` and equality with `==`. We usually don't use `assert` function in practice and use `assert!` macro instead. We will discuss `assert!` macro in more detail in the [Testing Cairo Programs][assert macro] chapter.
70 | 
71 | [assert macro]: ./ch10-01-how-to-write-tests.md#checking-results-with-the-assert-macro
72 | 
73 | ## `panic_with` Attribute
74 | 
75 | You can use the `panic_with` attribute to mark a function that returns an `Option` or `Result`. This attribute takes two arguments, which are the data that is passed as the panic reason as well as the name for a wrapping function. It will create a wrapper for your annotated function which will panic if the function returns `None` or `Err`, with the given data as the panic error.
76 | 
77 | Example:
78 | 
79 | ```cairo
80 | {{#include ../listings/ch09-error-handling/no_listing_06_panic_with/src/lib.cairo}}
81 | ```
82 | 
83 | {{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}
84 | 


--------------------------------------------------------------------------------
/src/ch09-02-recoverable-errors.md:
--------------------------------------------------------------------------------
  1 | # Recoverable Errors with `Result`
  2 | 
  3 | Most errors arent serious enough to require the program to stop entirely. Sometimes, when a function fails, its for a reason that you can easily interpret and respond to. For example, if you try to add two large integers and the operation overflows because the sum exceeds the maximum representable value, you might want to return an error or a wrapped result instead of causing undefined behavior or terminating the process.
  4 | 
  5 | ## The `Result` Enum
  6 | 
  7 | Recall from [Generic data types][generic enums] section in Chapter {{#chap generic-types-and-traits}} that the `Result` enum is defined as having two variants, `Ok` and `Err`, as follows:
  8 | 
  9 | ```cairo,noplayground
 10 | {{#include ../listings/ch09-error-handling/no_listing_07_result_enum/src/lib.cairo}}
 11 | ```
 12 | 
 13 | The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`).
 14 | 
 15 | [generic enums]: ./ch08-01-generic-data-types.md#enums
 16 | 
 17 | ## The `ResultTrait`
 18 | 
 19 | The `ResultTrait` trait provides methods for working with the `Result<T, E>` enum, such as unwrapping values, checking whether the `Result` is `Ok` or `Err`, and panicking with a custom message. The `ResultTraitImpl` implementation defines the logic of these methods.
 20 | 
 21 | ```cairo,noplayground
 22 | {{#include ../listings/ch09-error-handling/no_listing_08_result_trait/src/lib.cairo}}
 23 | ```
 24 | 
 25 | The `expect` and `unwrap` methods are similar in that they both attempt to extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` variant. If the `Result` is `Ok(x)`, both methods return the value `x`. However, the key difference between the two methods lies in their behavior when the `Result` is in the `Err` variant. The `expect` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap` method panics with a default error message, providing less information about the cause of the panic.
 26 | 
 27 | The `expect_err` and `unwrap_err` methods have the exact opposite behavior. If the `Result` is `Err(x)`, both methods return the value `x`. However, the key difference between the two methods is in case of `Result::Ok()`. The `expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap_err` method panics with a default error message, providing less information about the cause of the panic.
 28 | 
 29 | A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the first four methods signatures. This syntax represents generic type constraints in the Cairo language, as seen in the previous chapter. These constraints indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` and `E`, respectively.
 30 | 
 31 | Finally, the `is_ok` and `is_err` methods are utility functions provided by the `ResultTrait` trait to check the variant of a `Result` enum value.
 32 | 
 33 | - `is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Ok` variant, meaning the operation was successful. If the `Result` is the `Err` variant, it returns `false`.
 34 | - `is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Err` variant, meaning the operation encountered an error. If the `Result` is the `Ok` variant, it returns `false`.
 35 | 
 36 | These methods are helpful when you want to check the success or failure of an operation without consuming the `Result` value, allowing you to perform additional operations or make decisions based on the variant without unwrapping it.
 37 | 
 38 | You can find the implementation of the `ResultTrait` [here][result corelib].
 39 | 
 40 | It is always easier to understand with examples. Have a look at this function signature:
 41 | 
 42 | ```cairo,noplayground
 43 | {{#include ../listings/ch09-error-handling/no_listing_09_result_example/src/lib.cairo:overflow}}
 44 | ```
 45 | 
 46 | It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, u128>` where the `Ok` variant holds the sum if the addition does not overflow, and the `Err` variant holds the overflowed value if the addition does overflow.
 47 | 
 48 | Now, we can use this function elsewhere. For instance:
 49 | 
 50 | ```cairo,noplayground
 51 | {{#include ../listings/ch09-error-handling/no_listing_09_result_example/src/lib.cairo:checked-add}}
 52 | 
 53 | ```
 54 | 
 55 | Here, it accepts two `u128` integers, `a` and `b`, and returns an `Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to determine the success or failure of the addition operation. The `match` expression checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it returns `Option::None` to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow.
 56 | 
 57 | Let's take another example:
 58 | 
 59 | ```cairo,noplayground
 60 | {{#include ../listings/ch09-error-handling/listing_09_01/src/lib.cairo:function}}
 61 | ```
 62 | 
 63 | In this example, the `parse_u8` function takes a `felt252` and tries to convert it into a `u8` integer using the `try_into` method. If successful, it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`.
 64 | 
 65 | Our two test cases are:
 66 | 
 67 | ```cairo,noplayground
 68 | {{#rustdoc_include ../listings/ch09-error-handling/listing_09_01/src/lib.cairo:tests}}
 69 | ```
 70 | 
 71 | Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in more detail its meaning in the next [Testing Cairo Programs][tests] chapter.
 72 | 
 73 | `#[test]` attribute means the function is a test function, and `#[should_panic]` attribute means this test will pass if the test execution panics.
 74 | 
 75 | The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The second test function attempts to convert a value that is out of the `u8` range, expecting the `unwrap` method to panic with the error message `Invalid integer`.
 76 | 
 77 | [result corelib]: https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20
 78 | [tests]: ./ch10-01-how-to-write-tests.md
 79 | 
 80 | ### The `?` Operator
 81 | 
 82 | The last operator we will talk about is the `?` operator. The `?` operator is used for more idiomatic and concise error handling. When you use the `?` operator on a `Result` or `Option` type, it will do the following:
 83 | 
 84 | - If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner value `x` directly.
 85 | - If the value is `Result::Err(e)` or `Option::None`, it will propagate the error or `None` by immediately returning from the function.
 86 | 
 87 | The `?` operator is useful when you want to handle errors implicitly and let the calling function deal with them.
 88 | 
 89 | Here is an example:
 90 | 
 91 | ```cairo,noplayground
 92 | {{#include ../listings/ch09-error-handling/listing_09_02/src/lib.cairo:function}}
 93 | ```
 94 | 
 95 | We can see that `do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8` function. The `?` operator is used to propagate the error, if any, or unwrap the successful value.
 96 | 
 97 | And with a little test case:
 98 | 
 99 | ```cairo,noplayground
100 | {{#rustdoc_include ../listings/ch09-error-handling/listing_09_02/src/lib.cairo:tests}}
101 | ```
102 | 
103 | The console will print the error `Invalid Integer`.
104 | 
105 | ### Summary
106 | 
107 | We saw that recoverable errors can be handled in Cairo using the `Result` enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is generic, with types `T` and `E` representing the successful and error values, respectively. The `ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or `Err`, and panicking with custom messages.
108 | 
109 | To handle recoverable errors, a function can return a `Result` type and use pattern matching to handle the success or failure of an operation. The `?` operator can be used to implicitly handle errors by propagating the error or unwrapping the successful value. This allows for more concise and clear error handling, where the caller is responsible for managing errors raised by the called function.
110 | 
111 | {{#quiz ../quizzes/ch09-02-error-handling-result.toml}}
112 | 


--------------------------------------------------------------------------------
/src/ch10-00-testing-cairo-programs.md:
--------------------------------------------------------------------------------
1 | # Testing Cairo Programs
2 | 
3 | Correctness in our programs is the extent to which our code does what we intend it to do. Cairo is designed with a high degree of concern about the correctness of programs, but correctness is complex and not easy to prove. Cairo's linear type system shoulders a huge part of this burden, but the type system cannot catch everything. As such, Cairo includes support for writing tests.
4 | 
5 | Testing is a complex skill: although we cant cover every detail about how to write good tests in one chapter, well discuss the mechanics of Cairo's testing facilities. Well talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.
6 | 


--------------------------------------------------------------------------------
/src/ch10-01-how-to-write-tests.md:
--------------------------------------------------------------------------------
  1 | # How To Write Tests
  2 | 
  3 | ## The Anatomy of a Test Function
  4 | 
  5 | Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:
  6 | 
  7 | - Set up any needed data or state.
  8 | - Run the code you want to test.
  9 | - Assert the results are what you expect.
 10 | 
 11 | Lets look at the features Cairo provides for writing tests that take these actions, which include:
 12 | 
 13 | - `#[test]` attribute.
 14 | - `assert!`macro.
 15 | - `assert_eq!`, `assert_ne!`, `assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` macros. In order to use them, you will need to add `assert_macros = "2.8.2"` as a dev dependency.
 16 | - `#[should_panic]` attribute.
 17 | 
 18 | > Note: Make sure to select Starknet Foundry as a test runner when creating your project.
 19 | 
 20 | ### The Anatomy of a Test Function
 21 | 
 22 | At its simplest, a test in Cairo is a function thats annotated with the `#[test]` attribute. Attributes are metadata about pieces of Cairo code; one example is the `#[derive()]` attribute we used with structs in [Chapter {{#chap using-structs-to-structure-related-data}}][structs]. To change a function into a test function, add `#[test]` on the line before `fn`. When you run your tests with the `scarb test` command, Scarb runs Starknet Foundry's test runner binary that runs the annotated functions and reports on whether each test function passes or fails.
 23 | 
 24 | Let's create a new project called _adder_ using Scarb with the command `scarb new adder`. Remove the _tests_ folder.
 25 | 
 26 | ```shell
 27 | adder
 28 |  Scarb.toml
 29 |  src
 30 |      lib.cairo
 31 | ```
 32 | 
 33 | In _lib.cairo_, let's remove the existing content and add a `tests` module containing the first test, as shown in Listing {{#ref first-test}}.
 34 | 
 35 | <span class="filename">Filename: src/lib.cairo</span>
 36 | 
 37 | ```cairo, noplayground
 38 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_01/src/lib.cairo:it_works}}
 39 | ```
 40 | 
 41 | {{#label first-test}}
 42 | <span class="caption">Listing {{#ref first-test}}: A simple test function</span>
 43 | 
 44 | Note the `#[test]` annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.
 45 | 
 46 | We use the `#[cfg(test)]` attribute for the `tests` module, so that the compiler knows the code it contains needs to be compiled only when running tests. This is actually not an option: if you put a simple test with the `#[test]` attribute in a _lib.cairo_ file, it will not compile. We will talk more about the `#[cfg(test)]` attribute in the next [Test Organization][test organization] section.
 47 | 
 48 | The example function body uses the `assert_eq!` macro, which contains the result of adding 2 and 2, which equals 4. This assertion serves as an example of the format for a typical test. We'll explain in more detail how `assert_eq!` works later in this chapter. Lets run it to see that this test passes.
 49 | 
 50 | The `scarb test` command runs all tests found in our project, and shows the following output:
 51 | 
 52 | ```shell
 53 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_01/output.txt}}
 54 | ```
 55 | 
 56 | `scarb test` compiled and ran the test. We see the line `Collected 1 test(s) from adder package` followed by the line `Running 1 test(s) from src/`. The next line shows the name of the test function, called `it_works`, and that the result of running that test is `ok`. The test runner also provides an estimation of the gas consumption. The overall summary shows that all the tests passed, and the portion that reads `1 passed; 0 failed` totals the number of tests that passed or failed.
 57 | 
 58 | Its possible to mark a test as ignored so it doesnt run in a particular instance; well cover that in the [Ignoring Some Tests Unless Specifically Requested](#ignoring-some-tests-unless-specifically-requested) section later in this chapter. Because we havent done that here, the summary shows `0 ignored`. We can also pass an argument to the `scarb test` command to run only a test whose name matches a string; this is called filtering and well cover that in the [Running Single Tests](#running-single-tests) section. Since we havent filtered the tests being run, the end of the summary shows `0 filtered out`.
 59 | 
 60 | Lets start to customize the test to our own needs. First change the name of the `it_works` function to a different name, such as `exploration`, like so:
 61 | 
 62 | ```cairo, noplayground
 63 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_01/src/lib.cairo:exploration}}
 64 | ```
 65 | 
 66 | Then run `scarb test` again. The output now shows `exploration` instead of `it_works`:
 67 | 
 68 | ```shell
 69 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_01/output.txt}}
 70 | ```
 71 | 
 72 | Now well add another test, but this time well make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. Enter the new test as a function named `another`, so your _src/lib.cairo_ file looks like in Listing {{#ref second-test}}.
 73 | 
 74 | <span class="filename">Filename: src/lib.cairo</span>
 75 | 
 76 | ```cairo, noplayground
 77 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_02/src/lib.cairo:exploration-and-another}}
 78 | ```
 79 | 
 80 | {{#label second-test}}
 81 | <span class="caption">Listing {{#ref second-test}}: Adding a second test in _lib.cairo_ that will fail</span>
 82 | 
 83 | Run `scarb test` and you will see the following output:
 84 | 
 85 | ```shell
 86 | Collected 2 test(s) from adder package
 87 | Running 2 test(s) from src/
 88 | [FAIL] adder::tests::another
 89 | 
 90 | Failure data:
 91 |     "Make this test fail"
 92 | 
 93 | [PASS] adder::tests::exploration (gas: ~1)
 94 | Tests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out
 95 | 
 96 | Failures:
 97 |     adder::tests::another
 98 | ```
 99 | 
100 | Instead of `[PASS]`, the line `adder::tests::another` shows `[FAIL]`. A new section appears between the individual results and the summary. It displays the detailed reason for each test failure. In this case, we get the details that `another` failed because it panicked with `"Make this test fail"` error.
101 | 
102 | After that, the summary line is displayed: we had one test pass and one test fail. At the end, we see a list of the failing tests.
103 | 
104 | Now that you've seen what the test results look like in different scenarios, lets look at some functions that are useful in tests.
105 | 
106 | [structs]: ./ch05-01-defining-and-instantiating-structs.md
107 | [test organization]: ./ch10-02-test-organization.md
108 | 
109 | ## Checking Results with the `assert!` Macro
110 | 
111 | The `assert!` macro, provided by Cairo, is useful when you want to ensure that some condition in a test evaluates to `true`. We give the `assert!` macro the first argument that evaluates to a boolean. If the value is `true`, nothing happens and the test passes. If the value is `false`, the `assert!` macro calls `panic()` to cause the test to fail with a message we defined as the second argument. Using the `assert!` macro helps us check that our code is functioning in the way we intended.
112 | 
113 | Remember in [Chapter {{#chap using-structs-to-structure-related-data}}][method syntax], we used a `Rectangle` struct and a `can_hold` method, which are repeated here in Listing {{#ref rectangle}}. Lets put this code in the _src/lib.cairo_ file, then write some tests for it using the `assert!` macro.
114 | 
115 | <span class="filename">Filename: src/lib.cairo</span>
116 | 
117 | ```cairo, noplayground
118 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_03/src/lib.cairo:trait_impl}}
119 | ```
120 | 
121 | {{#label rectangle}}
122 | <span class="caption">Listing {{#ref rectangle}}: Using the `Rectangle` struct and its `can_hold` method from Chapter {{#chap using-structs-to-structure-related-data}}</span>
123 | 
124 | The `can_hold` method returns a `bool`, which means its a perfect use case for the `assert!` macro. We can write a test that exercises the `can_hold` method by creating a `Rectangle` instance that has a width of `8` and a height of `7` and asserting that it can hold another `Rectangle` instance that has a width of `5` and a height of `1`.
125 | 
126 | ```cairo, noplayground
127 | {{#rustdoc_include ../listings/ch10-testing-cairo-programs/listing_10_03/src/lib.cairo:test1}}
128 | ```
129 | 
130 | Note the `use super::*;` line inside the `tests` module. The `tests` module is
131 | a regular module that follows the usual visibility rules we covered in Chapter
132 | {{#chap paths-for-referring-to-an-item-in-the-module-tree}} in the [Paths for Referring to an Item in the Module
133 | Tree][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -->
134 | section. Because the `tests` module is an inner module, we need to bring the
135 | code under test in the outer module into the scope of the inner module. We use
136 | a glob here, so anything we define in the outer module is available to this
137 | `tests` module.
138 | 
139 | Weve named our test `larger_can_hold_smaller`, and weve created the two `Rectangle` instances that we need. Then we called the `assert!` macro and passed it the result of calling `larger.can_hold(@smaller)`. This expression is supposed to return `true`, so our test should pass. Lets find out!
140 | 
141 | ```shell
142 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_03/output.txt}}
143 | ```
144 | 
145 | It does pass! Lets add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:
146 | 
147 | <span class="filename">Filename: src/lib.cairo</span>
148 | 
149 | ```cairo, noplayground
150 | {{#rustdoc_include ../listings/ch10-testing-cairo-programs/listing_10_03/src/lib.cairo:test2}}
151 | ```
152 | 
153 | {{#label another-test}}
154 | <span class="caption">Listing {{#ref another-test}}: Adding another test in _lib.cairo_ that will pass</span>
155 | 
156 | Because the correct result of the `can_hold` method, in this case, is `false`, we need to negate that result before we pass it to the `assert!` macro. As a result, our test will pass if `can_hold` returns `false`:
157 | 
158 | ```shell
159 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_03/output.txt}}
160 | ```
161 | 
162 | Two tests that pass! Now lets see what happens to our test results when we introduce a bug in our code. Well change the implementation of the `can_hold` method by replacing the `>` sign with a `<` sign when it compares the widths:
163 | 
164 | ```cairo, noplayground
165 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/src/lib.cairo:wrong_impl}}
166 | ```
167 | 
168 | Running the tests now produces the following:
169 | 
170 | ```shell
171 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/output.txt}}
172 | ```
173 | 
174 | Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` is `5`, the comparison of the widths in `can_hold` now returns `false` (`8` is not less than `5`) in the `larger_can_hold_smaller` test. Notice that the `smaller_cannot_hold_larger` test still passes: to make this test fail, the height comparison should also be modified in `can_hold` method, replacing the `>` sign with a `<` sign.
175 | 
176 | [method syntax]: ./ch05-03-method-syntax.md
177 | 
178 | ## Testing Equality and Comparisons with the `assert_xx!` Macros
179 | 
180 | ### `assert_eq!` and `assert_ne!` Macros
181 | 
182 | A common way to verify functionality is to test for equality between the result
183 | of the code under test and the value you expect the code to return. You could
184 | do this using the `assert!` macro and passing it an expression using the `==`
185 | operator. However, this is such a common test that the standard library
186 | provides a pair of macros  `assert_eq!` and `assert_ne!`  to perform this test
187 | more conveniently. These macros compare two arguments for equality or
188 | inequality, respectively. Theyll also print the two values if the assertion
189 | fails, which makes it easier to see _why_ the test failed; conversely, the
190 | `assert!` macro only indicates that it got a `false` value for the `==`
191 | expression, without printing the values that led to the `false` value.
192 | 
193 | In Listing {{#ref add_two}}, we write a function named `add_two` that adds `2` to its
194 | parameter, then we test this function using `assert_eq!` and `assert_ne!` macros.
195 | 
196 | <span class="filename">Filename: src/lib.cairo</span>
197 | 
198 | ```cairo, noplayground
199 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_04/src/add_two.cairo}}
200 | ```
201 | 
202 | {{#label add_two}}
203 | <span class="caption">Listing {{#ref add_two}}: Testing the function `add_two` using `assert_eq!` and `assert_ne!` macros</span>
204 | 
205 | Lets check that it passes!
206 | 
207 | ```shell
208 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_04/output.txt}}
209 | ```
210 | 
211 | In the `it_adds_two` test, we pass `4` as argument to `assert_eq!` macro, which is equal to the result of
212 | calling `add_two(2)`. The line for this test is `[PASS] adder::tests::it_adds_two (gas: ~1)`.
213 | 
214 | In the `wrong_check` test, we pass `0` as argument to `assert_ne!` macro, which is not equal to the result of
215 | calling `add_two(2)`. Tests that use the `assert_ne!` macro will pass if the two values we give it are _not_ equal and
216 | fail if theyre equal. This macro is most useful for cases when were not sure
217 | what a value _will_ be, but we know what the value definitely _shouldnt_ be.
218 | For example, if were testing a function that is guaranteed to change its input
219 | in some way, but how the input is changed depends on the day of
220 | the week that we run our tests, the best thing to assert might be that the
221 | output of the function is not equal to the input.
222 | 
223 | Lets introduce a bug into our code to see what `assert_eq!` looks like when it
224 | fails. Change the implementation of the `add_two` function to instead add `3`:
225 | 
226 | ```cairo, noplayground
227 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_04/src/wrong_add_two.cairo}}
228 | ```
229 | 
230 | Run the tests again:
231 | 
232 | ```shell
233 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_04/output.txt}}
234 | ```
235 | 
236 | Our test caught the bug! The `it_adds_two` test failed with the following
237 | message: ``"assertion `4 == add_two(2)` failed``.
238 | It tells us that the assertion that failed was `` "assertion `left == right` failed`` and the `left`
239 | and `right` values are printed on the next lines as `left: left_value` and `right: right_value`.
240 | This helps us start debugging: the `left` argument was `4` but the `right` argument, where we had
241 | `add_two(2)`, was `5`. You can imagine that this would be especially helpful
242 | when we have a lot of tests going on.
243 | 
244 | Note that in some languages and test frameworks, the parameters for equality
245 | assertion functions are called `expected` and `actual`, and the order in which
246 | we specify the arguments matters. However, in Cairo, theyre called `left` and
247 | `right`, and the order in which we specify the value we expect and the value
248 | the code produces doesnt matter. We could write the assertion in this test as
249 | `assert_eq!(add_two(2), 4)`, which would result in the same failure message
250 | that displays `` assertion failed: `(left == right)` ``.
251 | 
252 | Here is a simple example comparing two structs, showing how to use `assert_eq!` and `assert_ne!` macros:
253 | 
254 | ```cairo, noplayground
255 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_10_assert_eq_ne_macro/src/lib.cairo}}
256 | ```
257 | 
258 | Under the surface, `assert_eq!` and `assert_ne!` macros use the operators
259 | `==` and `!=`, respectively. They both take snapshots of values as arguments. When the assertions fail, these macros print their
260 | arguments using debug formatting (`{:?}` syntax), which means the values being compared must
261 | implement `PartialEq` and `Debug` traits. All primitive types and most of
262 | the core library types implement these traits. For structs and enums that
263 | you define yourself, youll need to implement `PartialEq` to assert equality of
264 | those types. Youll also need to implement `Debug` to print the values when the
265 | assertion fails. Because both traits are derivable, this is usually as straightforward as adding the
266 | `#[derive(Drop, Debug, PartialEq)]` annotation to your struct or enum definition. See
267 | [Appendix C][derivable traits] for more details about these and other derivable traits.
268 | 
269 | [derivable traits]: ./appendix-03-derivable-traits.md
270 | 
271 | ### `assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` Macros
272 | 
273 | Comparisons in tests can be done using the `assert_xx!` macros:
274 | 
275 | - `assert_lt!` checks if a given value is lower than another value, and reverts otherwise.
276 | - `assert_le!` checks if a given value is lower or equal than another value, and reverts otherwise.
277 | - `assert_gt!` checks if a given value is greater than another value, and reverts otherwise.
278 | - `assert_ge!` checks if a given value is greater or equal than another value, and reverts otherwise.
279 | 
280 | Listing {{#ref assert_macros}} demonstrates how to use these macros:
281 | 
282 | ```cairo, noplayground
283 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_08/src/lib.cairo}}
284 | ```
285 | 
286 | {{#label assert_macros}}
287 | <span class="caption">Listing {{#ref assert_macros}}: Example of tests that use the `assert_xx!` macros for comparisons</span>
288 | 
289 | In this example, we roll a `Dice` struct multiple times and compare the results. We need to manually implement the `PartialOrd` trait for our struct so that we can compare `Dice` instances with `lt`, `le`, `gt` and `ge` functions, which are used by `assert_lt!`, `assert_le!`, `assert_gt!` and `assert_ge!` macros, respectively. We also need to derive the `Copy` trait on our `Dice` struct to use the instantiated structs multiple times, as the comparison functions take ownership of the variables.
290 | 
291 | ## Adding Custom Failure Messages
292 | 
293 | You can also add a custom message to be printed with the failure message as
294 | optional arguments to `assert!`, `assert_eq!`, and `assert_ne!` macros. Any
295 | arguments specified after the required arguments are passed along to the
296 | `format!` macro (discussed in the [Printing][formatting] chapter), so you can pass a format string that contains `{}` placeholders and
297 | values to go in those placeholders. Custom messages are useful for documenting
298 | what an assertion means; when a test fails, youll have a better idea of what
299 | the problem is with the code.
300 | 
301 | Lets add a custom failure message composed of a format
302 | string with a placeholder filled in with the actual value we got from the previous
303 | `add_two` function:
304 | 
305 | ```cairo, noplayground
306 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/src/lib.cairo:here}}
307 | ```
308 | 
309 | Now when we run the test, well get a more informative error message:
310 | 
311 | ```shell
312 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/output.txt}}
313 | ```
314 | 
315 | We can see the value we actually got in the test output, which would help us
316 | debug what happened instead of what we were expecting to happen.
317 | 
318 | [formatting]: ./ch11-08-printing.md#formatting
319 | 
320 | ## Checking for panics with `should_panic`
321 | 
322 | In addition to checking return values, its important to check that our code handles error conditions as we expect. For example, consider the `Guess` type in Listing {{#ref guess}}:
323 | 
324 | <span class="filename">Filename: src/lib.cairo</span>
325 | 
326 | ```cairo, noplayground
327 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_05/src/lib.cairo:guess}}
328 | ```
329 | 
330 | {{#label guess}}
331 | <span class="caption">Listing {{#ref guess}}: `Guess` struct and its `new` method</span>
332 | 
333 | Other code that uses `Guess` depends on the guarantee that `Guess` instances will contain only values between `1` and `100`. We can write a test that ensures that attempting to create a `Guess` instance with a value outside that range panics.
334 | 
335 | We do this by adding the attribute `should_panic` to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesnt panic.
336 | 
337 | ```cairo, noplayground
338 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_05/src/lib.cairo:test}}
339 | ```
340 | 
341 | We place the `#[should_panic]` attribute after the `#[test]` attribute and before the test function it applies to. Lets look at the result to see that this test passes:
342 | 
343 | ```shell
344 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_05/output.txt}}
345 | ```
346 | 
347 | Looks good! Now lets introduce a bug in our code by removing the condition that the `new` function will panic if the value is greater than `100`:
348 | 
349 | ```cairo, noplayground
350 | {{#rustdoc_include ../listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/src/lib.cairo:here}}
351 | ```
352 | 
353 | When we run the test, it will fail:
354 | 
355 | ```shell
356 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/output.txt}}
357 | ```
358 | 
359 | We dont get a very helpful message in this case, but when we look at the test function, we see that its annotated with `#[should_panic]` attribute. The failure we got means that the code in the test function did not cause a panic.
360 | 
361 | Tests that use `should_panic` can be imprecise. A `should_panic` test would pass even if the test panics for a different reason from the one we were expecting. To make `should_panic` tests more precise, we can add an optional `expected` parameter to the `#[should_panic]` attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for `GuessImpl` in Listing {{#ref guess-2}} where the `new` function panics with different messages depending on whether the value is too small or too large:
362 | 
363 | <span class="filename">Filename: src/lib.cairo</span>
364 | 
365 | ```cairo, noplayground
366 | {{#rustdoc_include ../listings/ch10-testing-cairo-programs/listing_10_06/src/lib.cairo:here}}
367 | ```
368 | 
369 | {{#label guess-2}}
370 | <span class="caption">Listing {{#ref guess-2}}: `new` implementation that panics with different error messages</span>
371 | 
372 | The test will pass because the value we put in the `should_panic` attributes `expected` parameter is the string that the `Guess::new` method panics with. We need to specify the entire panic message that we expect.
373 | 
374 | To see what happens when a `should_panic` test with an expected message fails, lets again introduce a bug into our code by swapping the bodies of the `if value < 1` and the `else if value > 100` blocks:
375 | 
376 | ```cairo, noplayground
377 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_04_new_bug/src/lib.cairo:here}}
378 | ```
379 | 
380 | This time when we run the `should_panic` test, it will fail:
381 | 
382 | ```shell
383 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_04_new_bug/output.txt}}
384 | ```
385 | 
386 | The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string. The panic message that we did get in this case was `Guess must be >= 1`. Now we can start figuring out where our bug is!
387 | 
388 | ## Running Single Tests
389 | 
390 | Sometimes, running a full test suite can take a long time. If youre working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing `scarb test` the name of the test you want to run as an argument.
391 | 
392 | To demonstrate how to run a single test, well first create two test functions, as shown in Listing {{#ref two-tests}}, and choose which ones to run.
393 | 
394 | <span class="filename">Filename: src/lib.cairo</span>
395 | 
396 | ```cairo, noplayground
397 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_07/src/lib.cairo}}
398 | ```
399 | 
400 | {{#label two-tests}}
401 | <span class="caption">Listing {{#ref two-tests}}: Two tests with two different names</span>
402 | 
403 | We can pass the name of any test function to `scarb test` to run only that test:
404 | 
405 | ```shell
406 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_07/output.txt}}
407 | ```
408 | 
409 | Only the test with the name `add_two_and_two` ran; the other test didnt match that name. The test output lets us know we had one more test that didnt run by displaying `1 filtered out;` at the end.
410 | 
411 | We can also specify part of a test name, and any test whose name contains that value will be run.
412 | 
413 | ## Ignoring Some Tests Unless Specifically Requested
414 | 
415 | Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of `scarb test`. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the `#[ignore]` attribute to exclude them, as shown here:
416 | 
417 | ```cairo, noplayground
418 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/src/lib.cairo}}
419 | ```
420 | 
421 | After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now when we run our tests, `it_works` runs, but `expensive_test` doesnt:
422 | 
423 | ```shell
424 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/output.txt}}
425 | ```
426 | 
427 | The `expensive_test` function is listed as ignored.
428 | 
429 | When youre at a point where it makes sense to check the results of the ignored tests and you have time to wait for the results, you can run `scarb test --include-ignored` to run all tests, whether theyre ignored or not.
430 | 
431 | ## Testing Recursive Functions or Loops
432 | 
433 | When testing recursive functions or loops, the test is instantiated by default with a maximum amount of gas that it can consume. This prevents running infinite loops or consuming too much gas, and can help you benchmark the efficiency of your implementations. This value is assumed reasonably large enough, but you can override it by adding the `#[available_gas(<Number>)]` attribute to the test function. The following example shows how to use it:
434 | 
435 | ```cairo, noplayground
436 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_06_test_gas/src/lib.cairo}}
437 | ```
438 | 
439 | ## Benchmarking Cairo Programs
440 | 
441 | Starknet Foundry contains a profiling feature that is useful to analyze and optimize the performance of your Cairo programs.
442 | 
443 | The [profiling][profiling] feature generates execution traces for successful tests, which are used to create profile outputs. This allows you to benchmark specific parts of your code.
444 | 
445 | To use the profiler, you will need to:
446 | 
447 | 1. Install [Cairo Profiler][cairo profiler] from Software Mansion.
448 | 2. Install [Go][go], [Graphviz][graphviz] and [pprof][pprof], all of them are required to visualize the generated profile output.
449 | 3. Run `snforge test --build-profile` command, which generates a trace file for each passing test, stored in the _snfoundry_trace_ directory of your project. This command also generates the corresponding output files in the _profile_ directory.
450 | 4. Run `go tool pprof -http=":8000" path/to/profile/output.pb.gz` to analyse a profile. This will start a web server at the specified port.
451 | 
452 | Let's reuse the `sum_n` function studied above:
453 | 
454 | ```cairo, noplayground
455 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_06_test_gas/src/lib.cairo}}
456 | ```
457 | 
458 | After generating the trace file and the profile output, running `go tool pprof` in your project will start the web server where you can find many useful information about the test that you ran:
459 | 
460 | - The test includes one function call, corresponding to the call to the test function. Calling `sum_n` multiple times in the test function will still return 1 call. This is because `snforge` simulates a contract call when executing a test.
461 | 
462 | - The `sum_n` function execution uses 256 Cairo steps:
463 | 
464 | <div align="center">
465 |     <img src="pprof-steps.png" alt="pprof number of steps" width="800px"/>
466 | </div>
467 | 
468 | Other information is also available such as memory holes (i.e., unused memory cells) or builtins usage. The Cairo Profiler is under active development, and many other features will be made available in the future.
469 | 
470 | [hello world]: ./ch01-02-hello-world.md#creating-a-project-with-scarb
471 | [profiling]: https://foundry-rs.github.io/starknet-foundry/snforge-advanced-features/profiling.html
472 | [cairo profiler]: https://github.com/software-mansion/cairo-profiler
473 | [go]: https://go.dev/doc/install
474 | [Graphviz]: https://www.graphviz.org/download/
475 | [pprof]: https://github.com/google/pprof?tab=readme-ov-file#building-pprof
476 | [paths-for-referring-to-an-item-in-the-module-tree]: ./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md
477 | 
478 | {{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}
479 | 


--------------------------------------------------------------------------------
/src/ch10-02-test-organization.md:
--------------------------------------------------------------------------------
  1 | # Test Organization
  2 | 
  3 | We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private functions. Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.
  4 | 
  5 | Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.
  6 | 
  7 | ## Unit Tests
  8 | 
  9 | The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isnt working as expected. Youll put unit tests in the `src` directory in each file with the code that theyre testing.
 10 | 
 11 | The convention is to create a module named `tests` in each file to contain the test functions and to annotate the module with `#[cfg(test)]` attribute.
 12 | 
 13 | ### The Tests Module and `#[cfg(test)]`
 14 | 
 15 | The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run the test code only when you run `scarb test`, not when you run `scarb build`. This saves compile time when you only want to build the project and saves space in the resulting compiled artifact because the tests are not included. Youll see that because integration tests go in a different directory, they dont need the `#[cfg(test)]` annotation. However, because unit tests go in the same files as the code, youll use `#[cfg(test)]` to specify that they shouldnt be included in the compiled result.
 16 | 
 17 | Recall that when we created the new `adder` project in the first section of this chapter, we wrote this first test:
 18 | 
 19 | ```cairo
 20 | {{#include ../listings/ch10-testing-cairo-programs/listing_10_01/src/lib.cairo:it_works}}
 21 | ```
 22 | 
 23 | The attribute `cfg` stands for _configuration_ and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration option is `test`, which is provided by Cairo for compiling and running tests. By using the `cfg` attribute, Cairo compiles our test code only if we actively run the tests with `scarb test`. This includes any helper functions that might be within this module, in addition to the functions annotated with `#[test]`.
 24 | 
 25 | ### Testing Private Functions
 26 | 
 27 | Theres debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Cairo's privacy rules do allow you to test private functions. Consider the code below with the private function `internal_adder`.
 28 | 
 29 | <span class="caption">Filename: src/lib.cairo</span>
 30 | 
 31 | ```cairo, noplayground
 32 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/src/lib.cairo}}
 33 | ```
 34 | 
 35 | {{#label test_internal}}
 36 | <span class="caption">Listing {{#ref test_internal}}: Testing a private function</span>
 37 | 
 38 | Note that the `internal_adder` function is not marked as `pub`. Tests are just Cairo code, and the tests module is just another module. As we discussed in the ["Paths for Referring to an Item in the Module Tree"](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md) section, items in child modules can use the items in their ancestor modules. In this test, we bring the `tests` modules parent `internal_adder` into scope with `use super::internal_adder;` and then the test can call `internal_adder`. If you dont think private functions should be tested, theres nothing in Cairo that will compel you to do so.
 39 | 
 40 | ## Integration Tests
 41 | 
 42 | Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a _tests_ directory.
 43 | 
 44 | ### The _tests_ Directory
 45 | 
 46 | We create a _tests_ directory at the top level of our project directory, next to _src_. Scarb knows to look for integration test files in this directory. We can then make as many test files as we want, and Scarb will compile each of the files as an individual crate.
 47 | 
 48 | Lets create an integration test. With the code in Listing {{#ref test_internal}} still in the _src/lib.cairo_ file, make a _tests_ directory, and create a new file named _tests/integration_test.cairo_. Your directory structure should look like this:
 49 | 
 50 | ```shell
 51 | adder
 52 |  Scarb.lock
 53 |  Scarb.toml
 54 |  src
 55 |     lib.cairo
 56 |  tests
 57 |      integration_tests.cairo
 58 | 
 59 | ```
 60 | 
 61 | Enter the code in Listing {{#ref test_integration}} into the _tests/integration_test.cairo_ file:
 62 | 
 63 | <span class="caption">Filename: tests/integration_tests.cairo</span>
 64 | 
 65 | ```cairo, noplayground
 66 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_09_integration_test/tests/integration_tests.cairo}}
 67 | ```
 68 | 
 69 | {{#label test_integration}}
 70 | <span class="caption">Listing {{#ref test_integration}}: An integration test of a function in the `adder` crate</span>
 71 | 
 72 | Each file in the `tests` directory is a separate crate, so we need to bring our library into each test crates scope. For that reason we add `use adder::add_two` at the top of the code, which we didnt need in the unit tests.
 73 | 
 74 | We dont need to annotate any code in _tests/integration_test.cairo_ with `#[cfg(test)]`. Scarb treats the tests directory specially and compiles files in this directory only when we run `scarb test`. Run `scarb test` now:
 75 | 
 76 | ```shell
 77 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_09_integration_test/output.txt}}
 78 | ```
 79 | 
 80 | The two sections of output include the unit tests and the integration tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there wont be any output for integration tests because those tests will only be run if all unit tests are passing.
 81 | 
 82 | The first displayed section is for the integration tests.
 83 | Each integration test file has its own section, so if we add more files in the _tests_ directory, there will be more integration test sections.
 84 | 
 85 | The second displayed section is the same as weve been seeing: one line for each unit test (one named add that we added just above) and then a summary line for the unit tests.
 86 | 
 87 | We can still run a particular integration test function by specifying the test functions name as an argument of the option -f to `scarb test` like for instance `scarb test -f integration_tests::internal`. To run all the tests in a particular integration test file, we use the same option of `scarb test` but using only the name of the file.
 88 | 
 89 | Then, to run all of our integration tests, we can just add a filter to only run tests whose path contains _integration_tests_.
 90 | 
 91 | ```shell
 92 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_09_integration_test/output_integration.txt}}
 93 | ```
 94 | 
 95 | We see that in the second section for the unit tests, 1 has been filtered out because it is not in the _integration_tests_ file.
 96 | 
 97 | ### Submodules in Integration Tests
 98 | 
 99 | As you add more integration tests, you might want to make more files in the _tests_ directory to help organize them; for example, you can group the test functions by the functionality theyre testing. As mentioned earlier, each file in the tests directory is compiled as its own separate crate, which is useful for creating separate scopes to more closely imitate the way end users will be using your crate. However, this means files in the tests directory dont share the same behavior as files in _src_ do, as you learned in Chapter {{#chap packages-and-crates}} regarding how to separate code into modules and files.
100 | 
101 | The different behavior of tests directory files is most noticeable when you have a set of helper functions to use in multiple integration test files and you try to follow the steps in the [Separating Modules into Different Files](ch07-05-separating-modules-into-different-files.md) section of Chapter {{#chap packages-and-crates}} to extract them into a common module. For example, if we create _tests/common.cairo_ and place a function named `setup` in it, we can add some code to `setup` that we want to call from multiple test functions in multiple test files:
102 | 
103 | <span class="caption">Filename: tests/common.cairo</span>
104 | 
105 | ```cairo, noplayground
106 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_12_submodules/tests/common.cairo}}
107 | ```
108 | 
109 | <span class="caption">Filename: tests/integration_tests.cairo</span>
110 | 
111 | ```cairo, noplayground
112 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_12_submodules/tests/integration_tests.cairo}}
113 | ```
114 | 
115 | <span class="caption">Filename: src/lib.cairo</span>
116 | 
117 | ```cairo, noplayground
118 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_12_submodules/src/lib.cairo}}
119 | ```
120 | 
121 | When we run the tests with `scarb test`, well see a new section in the test output for the _common.cairo_ file, even though this file doesnt contain any test functions nor did we call the setup function from anywhere:
122 | 
123 | ```shell
124 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_12_submodules/output.txt}}
125 | ```
126 | 
127 | To avoid systematically getting a section for each file of the _tests_ folder, we also have the option of making the `tests/` directory behave like a regular crate, by adding a `tests/lib.cairo` file. In that case, the `tests` directory will no longer compile as one crate per file, but as one crate for the whole directory.
128 | 
129 | Let's create this _tests/lib.cairo_ file :
130 | 
131 | <span class="caption">Filename: tests/lib.cairo</span>
132 | 
133 | ```cairo, noplayground
134 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/tests/lib.cairo}}
135 | ```
136 | 
137 | The project directory will now look like this :
138 | 
139 | ```shell
140 | adder
141 |  Scarb.lock
142 |  Scarb.toml
143 |  src
144 |     lib.cairo
145 |  tests
146 |      common.cairo
147 |      integration_tests.cairo
148 |      lib.cairo
149 | ```
150 | 
151 | When we run the `scarb test` command again, here is the output :
152 | 
153 | ```shell
154 | {{#include ../listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/output.txt}}
155 | ```
156 | 
157 | This way, only the test functions will be tested and the `setup` function can be imported without being tested.
158 | 
159 | ## Summary
160 | 
161 | Cairo's testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the librarys public API to test the code in the same way external code will use it. Even though Cairo's type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.
162 | 
163 | {{#quiz ../quizzes/ch10-02-testing-organization.toml}}
164 | 


--------------------------------------------------------------------------------
/src/ch11-00-advanced-features.md:
--------------------------------------------------------------------------------
1 | # Advanced Features
2 | 
3 | Now, let's learn about more advanced features offered by Cairo.
4 | 


--------------------------------------------------------------------------------
/src/ch11-01-custom-data-structures.md:
--------------------------------------------------------------------------------
  1 | # Custom Data Structures
  2 | 
  3 | When you first start programming in Cairo, you'll likely want to use arrays
  4 | (`Array<T>`) to store collections of data. However, you will quickly realize
  5 | that arrays have one big limitation - the data stored in them is immutable. Once
  6 | you append a value to an array, you can't modify it.
  7 | 
  8 | This can be frustrating when you want to use a mutable data structure. For
  9 | example, say you're making a game where the players have a level, and they can
 10 | level up. You might try to store the level of the players in an array:
 11 | 
 12 | ```cairo,noplayground
 13 | {{#include ../listings/ch11-advanced-features/listing_01_array_collection/src/lib.cairo:array_append}}
 14 | ```
 15 | 
 16 | But then you realize you can't increase the level at a specific index once it's
 17 | set. If a player dies, you cannot remove it from the array unless he happens to
 18 | be in the first position.
 19 | 
 20 | Fortunately, Cairo provides a handy built-in [dictionary type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to
 21 | simulate the behavior of mutable data structures. Let's first explore how to create a struct that contains, among others, a `Felt252Dict<T>`.
 22 | 
 23 | > Note: Several concepts used in this chapter were already presented earlier in the book. We recommend checking out the following chapters if you need to revise them:
 24 | > [Structs](ch05-00-using-structs-to-structure-related-data.md),
 25 | > [Methods](./ch05-03-method-syntax.md),
 26 | > [Generic types](./ch08-00-generic-types-and-traits.md),
 27 | > [Traits](./ch08-02-traits-in-cairo.md).
 28 | 
 29 | ## Dictionaries as Struct Members
 30 | 
 31 | Defining dictionaries as struct members is possible in Cairo but correctly interacting with them may not be entirely seamless. Let's try implementing a custom _user database_ that will allow us to add users and query them. We will need to define a struct to represent the new type and a trait to define its functionality:
 32 | 
 33 | ```cairo,noplayground
 34 | {{#include ../listings/ch11-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:struct}}
 35 | 
 36 | {{#include ../listings/ch11-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:trait}}
 37 | ```
 38 | 
 39 | Our new type `UserDatabase<T>` represents a database of users. It is generic over the balances of the users, giving major flexibility to whoever uses our data type. Its two members are:
 40 | 
 41 | - `users_updates`, the number of users updates in the dictionary.
 42 | - `balances`, a mapping of each user to its balance.
 43 | 
 44 | The database core functionality is defined by `UserDatabaseTrait`. The following methods are defined:
 45 | 
 46 | - `new` for easily creating new `UserDatabase` types.
 47 | - `update_user` to update the balance of users in the database.
 48 | - `get_balance` to find user's balance in the database.
 49 | 
 50 | The only remaining step is to implement each of the methods in `UserDatabaseTrait`, but since we are working with [Generic types](./ch08-00-generic-types-and-traits.md) we also need to correctly establish the requirements of `T` so it can be a valid `Felt252Dict<T>` value type:
 51 | 
 52 | 1. `T` should implement the `Copy<T>` since it's required for getting values from a `Felt252Dict<T>`.
 53 | 2. All value types of a dictionary implement the `Felt252DictValue<T>`, our generic type should do as well.
 54 | 3. To insert values, `Felt252DictTrait<T>` requires all value types to be droppable (implement the `Drop<T>` trait).
 55 | 
 56 | The implementation, with all restrictions in place, would be as follows:
 57 | 
 58 | ```cairo,noplayground
 59 | {{#include ../listings/ch11-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:impl}}
 60 | ```
 61 | 
 62 | Our database implementation is almost complete, except for one thing: the compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait.
 63 | Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are forced to implement the `Destruct<T>` trait manually (refer to the [Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more information).
 64 | Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` definition won't work because of the use of [Generic types][generics] in the struct definition. We need to code the `Destruct<T>` trait implementation by ourselves:
 65 | 
 66 | ```cairo,noplayground
 67 | {{#include ../listings/ch11-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:destruct}}
 68 | ```
 69 | 
 70 | Implementing `Destruct<T>` for `UserDatabase` was our last step to get a fully functional database. We can now try it out:
 71 | 
 72 | ```cairo
 73 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:main}}
 74 | ```
 75 | 
 76 | [generics]: ./ch08-00-generic-types-and-traits.md
 77 | 
 78 | ## Simulating a Dynamic Array with Dicts
 79 | 
 80 | First, let's think about how we want our mutable dynamic array to behave. What
 81 | operations should it support?
 82 | 
 83 | It should:
 84 | 
 85 | - Allow us to append items at the end.
 86 | - Let us access any item by index.
 87 | - Allow setting the value of an item at a specific index.
 88 | - Return the current length.
 89 | 
 90 | We can define this interface in Cairo like:
 91 | 
 92 | ```cairo,noplayground
 93 | {{#include ../listings/ch11-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:trait}}
 94 | ```
 95 | 
 96 | This provides a blueprint for the implementation of our dynamic array. We named
 97 | it _MemoryVec_ as it is similar to the `Vec<T>` data structure in Rust.
 98 | 
 99 | > Note: The core library of Cairo already includes a `Vec<T>` data structure, strictly used as a storage type in smart contracts.
100 | > To differentiate our data structure from the core library's one, we named our implementation _MemoryVec_.
101 | 
102 | ### Implementing a Dynamic Array in Cairo
103 | 
104 | To store our data, we'll use a `Felt252Dict<T>` which maps index numbers (felts)
105 | to values. We'll also store a separate `len` field to track the length.
106 | 
107 | Here is what our struct looks like. We wrap the type `T` inside `Nullable`
108 | pointer to allow using any type `T` in our data structure, as explained in the
109 | [Dictionaries][nullable] section:
110 | 
111 | ```cairo,noplayground
112 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:struct}}
113 | ```
114 | 
115 | Since we again have `Felt252Dict<T>` as a struct member, we need to implement the `Destruct<T>` trait to tell the compiler how to make `MemoryVec<T>` go out of scope.
116 | 
117 | ```cairo,noplayground
118 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:destruct}}
119 | ```
120 | 
121 | The key thing that makes this vector mutable is that we can insert values into
122 | the dictionary to set or update values in our data structure. For example, to
123 | update a value at a specific index, we do:
124 | 
125 | ```cairo,noplayground
126 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:set}}
127 | ```
128 | 
129 | This overwrites the previously existing value at that index in the dictionary.
130 | 
131 | While arrays are immutable, dictionaries provide the flexibility we need for
132 | modifiable data structures like vectors.
133 | 
134 | The implementation of the rest of the interface is straightforward. The
135 | implementation of all the methods defined in our interface can be done as follow
136 | :
137 | 
138 | ```cairo,noplayground
139 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:implem}}
140 | ```
141 | 
142 | The full implementation of the `MemoryVec` structure can be found in the
143 | community-maintained library [Alexandria](https://github.com/keep-starknet-strange/alexandria/blob/main/packages/data_structures/src/vec.cairo).
144 | 
145 | [nullable]: ./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively
146 | 
147 | ## Simulating a Stack with Dicts
148 | 
149 | We will now look at a second example and its implementation details: a Stack.
150 | 
151 | A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new
152 | element and removal of an existing element takes place at the same end,
153 | represented as the top of the stack.
154 | 
155 | Let us define what operations we need to create a stack:
156 | 
157 | - Push an item to the top of the stack.
158 | - Pop an item from the top of the stack.
159 | - Check whether there are still any elements in the stack.
160 | 
161 | From these specifications we can define the following interface :
162 | 
163 | ```cairo,noplayground
164 | {{#include ../listings/ch11-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:trait}}
165 | ```
166 | 
167 | ### Implementing a Mutable Stack in Cairo
168 | 
169 | To create a stack data structure in Cairo, we can again use a `Felt252Dict<T>`
170 | to store the values of the stack along with a `usize` field to keep track of the
171 | length of the stack to iterate over it.
172 | 
173 | The Stack struct is defined as:
174 | 
175 | ```cairo,noplayground
176 | {{#include ../listings/ch11-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:struct}}
177 | ```
178 | 
179 | Next, let's see how our main functions `push` and `pop` are implemented.
180 | 
181 | ```cairo,noplayground
182 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:implem}}
183 | ```
184 | 
185 | The code uses the `insert` and `get` methods to access the values in the
186 | `Felt252Dict<T>`. To push an element to the top of the stack, the `push`
187 | function inserts the element in the dict at index `len` and increases the
188 | `len` field of the stack to keep track of the position of the stack top. To
189 | remove a value, the `pop` function decreases the value of `len` to update the
190 | position of the stack top and then retrieves the last value at position `len`.
191 | 
192 | The full implementation of the Stack, along with more data structures that you
193 | can use in your code, can be found in the community-maintained
194 | [Alexandria][alexandria data structures] library, in the "data_structures" crate.
195 | 
196 | [alexandria data structures]: https://github.com/keep-starknet-strange/alexandria/tree/main/packages/data_structures/src
197 | 
198 | {{#quiz ../quizzes/ch11-01-custom-structs.toml}}
199 | 
200 | ## Summary
201 | 
202 | Well done! Now you have knowledge of arrays, dictionaries and even custom data structures.
203 | While Cairo's memory model is immutable and can make it difficult to implement
204 | mutable data structures, we can fortunately use the `Felt252Dict<T>` type to
205 | simulate mutable data structures. This allows us to implement a wide range of
206 | data structures that are useful for many applications, effectively hiding the
207 | complexity of the underlying memory model.
208 | 


--------------------------------------------------------------------------------
/src/ch11-02-smart-pointers.md:
--------------------------------------------------------------------------------
  1 | # Smart Pointers
  2 | 
  3 | A pointer is a general concept for a variable that contains a memory address. This address refers to, or points at, some other data. While pointers are a powerful feature, they can also be a source of bugs and security vulnerabilities. For example, a pointer can reference an unassigned memory cell, which means that attempting to access the data at that address would cause the program to crash, making it unprovable. To prevent such issues, Cairo uses _Smart Pointers_.
  4 | 
  5 | Smart pointers are data structures that act like a pointer, but also have additional metadata and capabilities. The concept of smart pointers isnt unique to Cairo: smart pointers originated in C++ and exist in other languages like Rust as well. In the specific case of Cairo, smart pointers ensure that memory is not addressed in an unsafe way that could cause a program to be unprovable, by providing a safe way to access memory through strict type checking and ownership rules.
  6 | 
  7 | Though we didnt call them as such at the time, weve already encountered a few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` in Chapter {{#chap common-collections}}. Both these types count as smart pointers because they own a memory segment and allow you to manipulate it. They also have metadata and extra capabilities or guarantees. Arrays keep track of their current length to ensure that existing elements are not overwritten, and that new elements are only appended to the end.
  8 | 
  9 | The Cairo VM memory is composed by multiple segments that can store data, each identified by a unique index. When you create an array, you allocate a new segment in the memory to store the future elements. The array itself is just a pointer to that segment where the elements are stored.
 10 | 
 11 | ## The `Box<T>` Type to Manipulate Pointers
 12 | 
 13 | The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. Manually defining boxes allow you to store data in a specific memory segment of the Cairo VM called the _boxed segment_. This segment is dedicated to store all boxed values, and what remains in the execution segment is only a pointer to the boxed segment. Whenever you instantiate a new pointer variable of type `Box<T>`, you append the data of type `T` to the boxed segment.
 14 | 
 15 | Boxes have very little performance overhead, other than writing their inner values to the boxed segment. But they dont have many extra capabilities either. Youll use them most often in these situations:
 16 | 
 17 | - When you have a type whose size cant be known at compile time and you want to use a value of that type in a context that requires an exact size
 18 | - When you have a large amount of data and you want to transfer ownership but ensure the data wont be copied when you do so
 19 | 
 20 | Well demonstrate the first situation in the [Enabling Recursive Types with Boxes][nullable recursive types] section.
 21 | In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around in memory. To improve performance in this situation, we can store the large amount of data in the boxed segment using a box type. Then, only the small amount of pointer data is copied around in memory, while the data it references stays in one place on the boxed segment.
 22 | 
 23 | [nullable recursive types]: ./ch11-02-smart-pointers.md#enabling-recursive-types-with-nullable-boxes
 24 | 
 25 | ### Using a `Box<T>` to Store Data in the Boxed Segment
 26 | 
 27 | Before we discuss the boxed segment storage use cases for `Box<T>`, well cover the syntax and how to interact with values stored within a `Box<T>`.
 28 | 
 29 | Listing {{#ref basic_box}} shows how to use a box to store a value in the boxed segment:
 30 | 
 31 | ```cairo
 32 | {{#include ../listings/ch11-advanced-features/listing_04_basic_box/src/lib.cairo}}
 33 | ```
 34 | 
 35 | {{#label basic_box}}
 36 | <span class="caption">Listing {{#ref basic_box}}: Storing a `u128` value in the boxed segment using a box</span>
 37 | 
 38 | We define the variable `b` to have the value of a `Box` that points to the value `5`, which is stored in the boxed segment. This program will print `b = 5`; in this case, we can access the data in the box similar to how we would if this data was simply in the execution memory. Putting a single value in a box isnt very useful, so you wont use boxes by themselves in this way very often. Having values like a single `u128` in the execution memory, where theyre stored by default, is more appropriate in the majority of situations. Lets look at a case where boxes allow us to define types that we wouldnt be allowed to if we didnt have boxes.
 39 | 
 40 | ### Enabling Recursive Types with Boxes
 41 | 
 42 | A value of recursive type can have another value of the same type as part of itself. Recursive types pose an issue because at compile time because Cairo needs to know how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Cairo cant know how much space the value needs. Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.
 43 | 
 44 | As an example of a recursive type, lets explore the implementation of a binary tree. The binary tree type well define is straightforward except for the recursion; therefore, the concepts in the example well work with will be useful any time you get into more complex situations involving recursive types.
 45 | 
 46 | A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. The last element of a branch is a leaf, which is a node without children.
 47 | 
 48 | Listing {{#ref recursive_types_wrong}} shows an attempt to implement a binary tree of `u32` values. Note that this code wont compile yet because the `BinaryTree` type doesnt have a known size, which well demonstrate.
 49 | 
 50 | ```cairo, noplayground
 51 | {{#include ../listings/ch11-advanced-features/listing_recursive_types_wrong/src/lib.cairo}}
 52 | ```
 53 | 
 54 | {{#label recursive_types_wrong}}
 55 | <span class="caption">Listing {{#ref recursive_types_wrong}}: The first attempt at implementing a binary tree of `u32` values</span>
 56 | 
 57 | > Note: Were implementing a binary tree that holds only u32 values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter {{#chap generic-types-and-traits}}, to define a binary tree that could store values of any type.
 58 | 
 59 | The root node contains 5 and two child nodes. The left child is a leaf containing 1. The right child is another node containing 4, which in turn has two leaf children: one containing 2 and another containing 3. This structure forms a simple binary tree with a depth of 2.
 60 | 
 61 | If we try to compile the code in listing {{#ref recursive_types_wrong}}, we get the following error:
 62 | 
 63 | ```plaintext
 64 | {{#include ../listings/ch11-advanced-features/listing_recursive_types_wrong/output.txt}}
 65 | ```
 66 | 
 67 | The error shows this type has infinite size. The reason is that weve defined `BinaryTree` with a variant that is recursive: it holds another value of itself directly. As a result, Cairo cant figure out how much space it needs to store a `BinaryTree` value.
 68 | 
 69 | <!-- TODO: explain why we get this error? -->
 70 | 
 71 | Hopefully, we can fix this error by using a `Box<T>` to store the recursive variant of `BinaryTree`. Because a `Box<T>` is a pointer, Cairo always knows how much space a `Box<T>` needs: a pointers size doesnt change based on the amount of data its pointing to. This means we can put a `Box<T>` inside the `Node` variant instead of another `BinaryTree` value directly. The `Box<T>` will point to the child `BinaryTree` values that will be stored in their own segment, rather than inside the `Node` variant. Conceptually, we still have a binary tree, created with binary trees holding other binary trees, but this implementation is now more like placing the items next to one another rather than inside one another.
 72 | 
 73 | We can change the definition of the `BinaryTree` enum in Listing {{#ref recursive_types_wrong}} and the usage of the `BinaryTree` in Listing {{#ref recursive_types_wrong}} to the code in Listing {{#ref recursive_types}}, which will compile:
 74 | 
 75 | ```cairo
 76 | {{#include ../listings/ch11-advanced-features/listing_recursive_types/src/lib.cairo}}
 77 | ```
 78 | 
 79 | {{#label recursive_types}}
 80 | <span class="caption">Listing {{#ref recursive_types}}: Defining a recursive Binary Tree using Boxes</span>
 81 | 
 82 | The `Node` variant now holds a `(u32, Box<BinaryTree>, Box<BinaryTree>)`, indicating that the `Node` variant will store a `u32` value, and two `Box<BinaryTree>` values. Now, we know that the `Node` variant will need a size of `u32` plus the size of the two `Box<BinaryTree>` values. By using a box, weve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a `BinaryTree` value.
 83 | 
 84 | <!--  Figure {{label Node-size}} shows what the Node variant looks like now. -->
 85 | 
 86 | ### Using Boxes to Improve Performance
 87 | 
 88 | Passing pointers between functions allows you to reference data without copying the data itself. Using boxes can improve performance as it allows you to pass a pointer to some data from one function to another, without the need to copy the entire data in memory before performing the function call. Instead of having to write `n` values into memory before calling a function, only a single value is written, corresponding to the pointer to the data. If the data stored in the box is very large, the performance improvement can be significant, as you would save `n-1` memory operations before each function call.
 89 | 
 90 | Let's take a look at the code in Listing {{#ref box}}, which shows two ways of passing data to a function: by value and by pointer.
 91 | 
 92 | ```cairo
 93 | {{#include ../listings/ch11-advanced-features/listing_05_box/src/lib.cairo}}
 94 | ```
 95 | 
 96 | {{#label box}}
 97 | <span class="caption">Listing {{#ref box}}: Storing large amounts of data in a box for performance.</span>
 98 | 
 99 | The `main` function includes 2 function calls:
100 | 
101 | - `pass_data` that takes a variable of type `Cart`.
102 | - `pass_pointer` that takes a pointer of type `Box<Cart>`.
103 | 
104 | When passing data to a function, the entire data is copied into the last available memory cells right before the function call. Calling `pass_data` will copy all 3 fields of `Cart` to memory, while `pass_pointer` only requires the copy of the `new_box` pointer which is of size 1.
105 | 
106 | <div align="center">
107 |     <img src="box_memory.png" alt="box memory" width="500px"/>
108 | <div align="center">
109 |     </div>
110 |     <span class="caption">CairoVM Memory layout when using boxes</span>
111 | </div>
112 | 
113 | The illustration above demonstrates how the memory behaves in both cases. The first instance of `Cart` is stored in the execution segment, and we need to copy all its fields to memory before calling the `pass_data` function. The second instance of `Cart` is stored in the boxed segment, and the pointer to it is stored in the execution segment. When calling the `pass_pointer` function, only the pointer to the struct is copied to memory right before the function call. In both cases, however, instantiating the struct will store all its values in the execution segment: the boxed segment can only be filled with data taken from the execution segment.
114 | 
115 | ## The `Nullable<T>` Type for Dictionaries
116 | 
117 | `Nullable<T>` is another type of smart pointer that can either point to a value or be `null` in the absence of value. It is defined at the Sierra level. This type is mainly used in dictionaries that contain types that don't implement the `zero_default` method of the `Felt252DictValue<T>` trait (i.e., arrays and structs).
118 | 
119 | If we try to access an element that does not exist in a dictionary, the code will fail if the `zero_default` method cannot be called.
120 | 
121 | [Chapter {{#chap common-collections}}][dictionary nullable span] about dictionaries thoroughly explains how to store a `Span<felt252>` variable inside a dictionary using the `Nullable<T>` type. Please refer to it for further information.
122 | 
123 | [dictionary nullable span]: ./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively
124 | 
125 | {{#quiz ../quizzes/ch11-02-smart_pointers.toml}}
126 | 


--------------------------------------------------------------------------------
/src/ch11-03-operator-overloading.md:
--------------------------------------------------------------------------------
 1 | # Operator Overloading
 2 | 
 3 | Operator overloading is a feature in some programming languages that allows the redefinition of standard operators, such as addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`), to work with user-defined types. This can make the syntax of the code more intuitive, by enabling operations on user-defined types to be expressed in the same way as operations on primitive types.
 4 | 
 5 | In Cairo, operator overloading is achieved through the implementation of specific traits. Each operator has an associated trait, and overloading that operator involves providing an implementation of that trait for a custom type.
 6 | However, it's essential to use operator overloading judiciously. Misuse can lead to confusion, making the code more difficult to maintain, for example when there is no semantic meaning to the operator being overloaded.
 7 | 
 8 | Consider an example where two `Potions` need to be combined. `Potions` have two data fields, mana and health. Combining two `Potions` should add their respective fields.
 9 | 
10 | ```cairo
11 | {{#include ../listings/ch11-advanced-features/no_listing_01_potions/src/lib.cairo}}
12 | ```
13 | 
14 | In the code above, we're implementing the `Add` trait for the `Potion` type. The add function takes two arguments: `lhs` and `rhs` (left and right-hand side). The function body returns a new `Potion` instance, its field values being a combination of `lhs` and `rhs`.
15 | 
16 | As illustrated in the example, overloading an operator requires specification of the concrete type being overloaded. The overloaded generic trait is `Add<T>`, and we define a concrete implementation for the type `Potion` with `Add<Potion>`.
17 | 
18 | {{#quiz ../quizzes/ch11-03-operator-overloading.toml}}
19 | 


--------------------------------------------------------------------------------
/src/ch11-04-hash.md:
--------------------------------------------------------------------------------
 1 | # Hashes
 2 | 
 3 | At its essence, hashing is a process of converting input data (often called a message) of any length into a fixed-size value, typically referred to as a "hash." This transformation is deterministic, meaning that the same input will always produce the same hash value. Hash functions are a fundamental component in various fields, including data storage, cryptography and data integrity verification. They are very often used when developing smart contracts, especially when working with [Merkle trees][merkle tree wiki].
 4 | 
 5 | In this chapter, we will present the two hash functions implemented natively in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when and how to use them, and see examples with Cairo programs.
 6 | 
 7 | [merkle tree wiki]: https://en.wikipedia.org/wiki/Merkle_tree#Uses
 8 | 
 9 | ### Hash Functions in Cairo
10 | 
11 | The Cairo core library provides two hash functions: Pedersen and Poseidon.
12 | 
13 | Pedersen hash functions are cryptographic algorithms that rely on [elliptic curve cryptography][ec wiki]. These functions perform operations on points along an elliptic curve  essentially, doing math with the locations of these points  which are easy to do in one direction and hard to undo. This one-way difficulty is based on the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is a problem so hard to solve that it ensures the security of the hash function. The difficulty of reversing these operations is what makes the Pedersen hash function secure and reliable for cryptographic purposes.
14 | 
15 | Poseidon is a family of hash functions designed to be very efficient as algebraic circuits. Its design is particularly efficient for Zero-Knowledge proof systems, including STARKs (so, Cairo). Poseidon uses a method called a 'sponge construction,' which soaks up data and transforms it securely using a process known as the Hades permutation. Cairo's version of Poseidon is based on a three-element state permutation with [specific parameters][poseidon parameters].
16 | 
17 | [ec wiki]: https://en.wikipedia.org/wiki/Elliptic-curve_cryptography
18 | [poseidon parameters]: https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt
19 | 
20 | #### When to Use Them?
21 | 
22 | Pedersen was the first hash function used on Starknet, and is still used to compute the addresses of variables in storage (for example, `LegacyMap` uses Pedersen to hash the keys of a storage mapping on Starknet). However, as Poseidon is cheaper and faster than Pedersen when working with STARK proofs system, it's now the recommended hash function to use in Cairo programs.
23 | 
24 | ### Working with Hashes
25 | 
26 | The core library makes it easy to work with hashes. The `Hash` trait is implemented for all types that can be converted to `felt252`, including `felt252` itself. For more complex types like structs, deriving `Hash` allows them to be hashed easily using the hash function of your choice - given that all of the struct's fields are themselves hashable. You cannot derive the `Hash` trait on a struct that contains un-hashable values, such as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable.
27 | 
28 | The `Hash` trait is accompanied by the `HashStateTrait` and `HashStateExTrait` that define the basic methods to work with hashes. They allow you to initialize a hash state that will contain the temporary values of the hash after each application of the hash function, update the hash state and finalize it when the computation is completed. `HashStateTrait` and `HashStateExTrait` are defined as follows:
29 | 
30 | ```cairo,noplayground
31 | {{#include ../listings/ch11-advanced-features/no_listing_03_hash_trait/src/lib.cairo:hashtrait}}
32 | ```
33 | 
34 | To use hashes in your code, you must first import the relevant traits and functions. In the following example, we will demonstrate how to hash a struct using both the Pedersen and Poseidon hash functions.
35 | 
36 | The first step is to initialize the hash with either `PoseidonTrait::new() -> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending on which hash function we want to work with. Then the hash state can be updated with the `update(self: HashState, value: felt252) -> HashState` or `update_with(self: S, value: T) -> S` functions as many times as required. Then the function `finalize(self: HashState) -> felt252` is called on the hash state and it returns the value of the hash as a `felt252`.
37 | 
38 | ```cairo
39 | {{#include ../listings/ch11-advanced-features/no_listing_04_hash_poseidon/src/lib.cairo}}
40 | ```
41 | 
42 | Pedersen is different from Poseidon, as it starts with a base state. This base state must be of `felt252` type, which forces us to either hash the struct with an arbitrary base state using the `update_with` method, or serialize the struct into an array to loop through all of its fields and hash its elements together.
43 | 
44 | Here is a short example of Pedersen hashing:
45 | 
46 | ```cairo
47 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_04_hash_pedersen/src/lib.cairo:main}}
48 | ```
49 | 
50 | ### Advanced Hashing: Hashing Arrays with Poseidon
51 | 
52 | Let us look at an example of hashing a struct that contains a `Span<felt252>`.
53 | To hash a `Span<felt252>` or a struct that contains a `Span<felt252>` you can use the built-in function `poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` by calling `poseidon_hash_span` on its span.
54 | 
55 | First, let us import the following traits and function:
56 | 
57 | ```cairo,noplayground
58 | {{#include ../listings/ch11-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:import}}
59 | ```
60 | 
61 | Now we define the struct. As you might have noticed, we didn't derive the `Hash` trait. If you attempt to derive the `Hash` trait for this struct, it will result in an error because the structure contains a field that is not hashable.
62 | 
63 | ```cairo, noplayground
64 | {{#include ../listings/ch11-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:structure}}
65 | ```
66 | 
67 | In this example, we initialized a `HashState` (`hash`), updated it and then called the function `finalize()` on the
68 | `HashState` to get the computed hash `hash_felt252`. We used `poseidon_hash_span` on the `Span` of the `Array<felt252>` to compute its hash.
69 | 
70 | ```cairo
71 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:main}}
72 | ```
73 | 


--------------------------------------------------------------------------------
/src/ch11-05-macros.md:
--------------------------------------------------------------------------------
 1 | # Macros
 2 | 
 3 | The Cairo language has some plugins that allow developers to simplify their code. They are called `inline_macros` and are a way of writing code that generates other code.
 4 | 
 5 | ## `consteval_int!` Macro
 6 | 
 7 | In some situations, a developer might need to declare a constant that is the result of a computation of integers. To compute a constant expression and use its result at compile time, it is required to use the `consteval_int!` macro.
 8 | 
 9 | Here is an example of `consteval_int!`:
10 | 
11 | ```cairo,noplayground
12 | const a: felt252 = consteval_int!(2 * 2 * 2);
13 | ```
14 | 
15 | This will be interpreted as `const a: felt252 = 8;` by the compiler.
16 | 
17 | ## `selector!` Macro
18 | 
19 | `selector!("function_name")` macro generates the entry point selector for the given function name.
20 | 
21 | ## `print!` and `println!` Macros
22 | 
23 | Please refer to the [Printing](./ch11-08-printing.md) page.
24 | 
25 | ## `array!` Macro
26 | 
27 | Please refer to the [Arrays](./ch03-01-arrays.md) page.
28 | 
29 | ## `panic!` Macro
30 | 
31 | See [Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-panic.md#panic-macro) page.
32 | 
33 | ## `assert!` and `assert_xx!` Macros
34 | 
35 | See [How to Write Tests](./ch10-01-how-to-write-tests.md) page.
36 | 
37 | ## `format!` Macro
38 | 
39 | See [Printing](./ch11-08-printing.md#formatting) page.
40 | 
41 | ## `write!` and `writeln!` Macros
42 | 
43 | See [Printing](./ch11-08-printing.md#printing-custom-data-types) page.
44 | 
45 | ## `get_dep_component!`, `get_dep_component_mut` and `component!` Macros
46 | 
47 | Please refer to the [Composability and Components](./ch16-02-00-composability-and-components.md) chapter.
48 | 


--------------------------------------------------------------------------------
/src/ch11-06-inlining-in-cairo.md:
--------------------------------------------------------------------------------
  1 | # Inlining in Cairo
  2 | 
  3 | Inlining is a common code optimization technique supported by most compilers. It involves replacing a function call at the call site with the actual code of the called function, eliminating the overhead associated with the function call itself. This can improve performance by reducing the number of instructions executed, but may increase the total size of the program. When you're thinking about whether to inline a function, take into account things like how big it is, what parameters it has, how often it gets called, and how it might affect the size of your compiled code.
  4 | 
  5 | ## The `inline` Attribute
  6 | 
  7 | In Cairo, the `inline` attribute suggests whether or not the Sierra code corresponding to the attributed function should be directly injected in the caller function's context, rather than using a `function_call` libfunc to execute that code.
  8 | 
  9 | There are three variants of the `inline` attribute that one can use:
 10 | 
 11 | - `#[inline]` suggests performing an inline expansion.
 12 | - `#[inline(always)]` suggests that an inline expansion should always be performed.
 13 | - `#[inline(never)]` suggests that an inline expansion should never be performed.
 14 | 
 15 | > Note: the `inline` attribute in every form is a hint, with no requirements on the language to place a copy of the attributed function in the caller. This means that the attribute may be ignored by the compiler. In practice, `#[inline(always)]` will cause inlining in all but the most exceptional cases.
 16 | 
 17 | Many of the Cairo corelib functions are inlined. User-defined functions may also be annotated with the `inline` attribute. Annoting functions with the `#[inline(always)]` attribute reduces the total number of steps required when calling these attributed functions. Indeed, injecting the Sierra code at the caller site avoids the step-cost involved in calling functions and obtaining their arguments.
 18 | 
 19 | However, inlining can also lead to increased code size. Whenever a function is inlined, the call site contains a copy of the function's Sierra code, potentially leading to duplication of code across the compiled code.
 20 | 
 21 | Therefore, inlining should be applied with caution. Using `#[inline]` or `#[inline(always)]` indiscriminately will lead to increased compile time. It is particularly useful to inline small functions, ideally with many arguments. This is because inlining large functions will increase the code length of the program, and handling many arguments will increase the number of steps to execute these functions.
 22 | 
 23 | The more frequently a function is called, the more beneficial inlining becomes in terms of performance. By doing so, the number of steps for the execution will be lower, while the code length will not grow that much or might even decrease in terms of total number of instructions.
 24 | 
 25 | > Inlining is often a tradeoff between number of steps and code length. Use the `inline` attribute cautiously where it is appropriate.
 26 | 
 27 | ## Inlining decision process
 28 | 
 29 | The Cairo compiler follows the `inline` attribute but for functions without explicit inline directives, it will use a heuristic approach. The decision to inline or not a function will be made depending on the complexity of the attributed function and mostly rely on the threshold `DEFAULT_INLINE_SMALL_FUNCTIONS_THRESHOLD`.
 30 | 
 31 | The compiler calculates a function's "weight" using the `ApproxCasmInlineWeight` struct, which estimates the number of Cairo Assembly (CASM) statements the function will generate. This weight calculation provides a more nuanced view of the function's complexity than a simple statement count. If a function's weight falls below the threshold, it will be inlined.
 32 | 
 33 | In addition to the weight-based approach, the compiler also considers the raw statement count. Functions with fewer statements than the threshold are typically inlined, promoting the optimization of small, frequently called functions.
 34 | 
 35 | The inlining process also accounts for special cases. Very simple functions, such as those that only call another function or return a constant, are always inlined regardless of other factors. Conversely, functions with complex control flow structures like `Match` or those ending with a `Panic` are generally not inlined.
 36 | 
 37 | ## Inlining Example
 38 | 
 39 | Let's introduce a short example to illustrate the mechanisms of inlining in Cairo. Listing {{#ref inlining}} shows a basic program allowing comparison between inlined and non-inlined functions.
 40 | 
 41 | ```cairo
 42 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_03_inlining_example/src/lib.cairo}}
 43 | ```
 44 | 
 45 | {{#label inlining}}
 46 | <span class="caption">Listing {{#ref inlining}}: A small Cairo program that adds the return value of 2 functions, with one of them being inlined</span>
 47 | 
 48 | Let's take a look at the corresponding Sierra code to see how inlining works under the hood:
 49 | 
 50 | ```cairo,noplayground
 51 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_03_inlining_example/src/inlining.sierra}}
 52 | ```
 53 | 
 54 | The Sierra file is structured in three parts:
 55 | 
 56 | - Type and libfunc declarations.
 57 | - Statements that constitute the program.
 58 | - Declaration of the functions of the program.
 59 | 
 60 | The Sierra code statements always match the order of function declarations in the Cairo program. Indeed, the declaration of the functions of the program tells us that:
 61 | 
 62 | - `main` function starts at line 0, and returns a `felt252` on line 5.
 63 | - `inlined` function starts at line 6, and returns a `felt252` on line 8.
 64 | - `not_inlined` function starts at line 9, and returns a `felt252` on line 11.
 65 | 
 66 | All statements corresponding to the `main` function are located between lines 0 and 5:
 67 | 
 68 | ```cairo,noplayground
 69 | 00 function_call<user@main::main::not_inlined>() -> ([0])
 70 | 01 felt252_const<1>() -> ([1])
 71 | 02 store_temp<felt252>([1]) -> ([1])
 72 | 03 felt252_add([1], [0]) -> ([2])
 73 | 04 store_temp<felt252>([2]) -> ([2])
 74 | 05 return([2])
 75 | ```
 76 | 
 77 | The `function_call` libfunc is called on line 0 to execute the `not_inlined` function. This will execute the code from lines 9 to 10 and store the return value in the variable with id `0`.
 78 | 
 79 | ```cairo,noplayground
 80 | 09	felt252_const<2>() -> ([0])
 81 | 10	store_temp<felt252>([0]) -> ([0])
 82 | ```
 83 | 
 84 | This code uses a single data type, `felt252`. It uses two library functions - `felt252_const<2>`, which returns the constant `felt252` 2, and `store_temp<felt252>`, which pushes a constant value to memory. The first line calls the `felt252_const<2>` libfunc to create a variable with id `0`. Then, the second line pushes this variable to memory for later use.
 85 | 
 86 | After that, Sierra statements from line 1 to 2 are the actual body of the `inlined` function:
 87 | 
 88 | ```cairo,noplayground
 89 | 06	felt252_const<1>() -> ([0])
 90 | 07	store_temp<felt252>([0]) -> ([0])
 91 | ```
 92 | 
 93 | The only difference is that the inlined code will store the `felt252_const` value in a variable with id `1`, because `[0]` refers to a variable previously assigned:
 94 | 
 95 | ```cairo,noplayground
 96 | 01	felt252_const<1>() -> ([1])
 97 | 02	store_temp<felt252>([1]) -> ([1])
 98 | ```
 99 | 
100 | > Note: in both cases (inlined or not), the `return` instruction of the function being called is not executed, as this would lead to prematurely end the execution of the `main` function. Instead, return values of `inlined` and `not_inlined` will be added and the result will be returned.
101 | 
102 | Lines 3 to 5 contain the Sierra statements that will add the values contained in variables with ids `0` and `1`, store the result in memory and return it:
103 | 
104 | ```cairo,noplayground
105 | 03	felt252_add([1], [0]) -> ([2])
106 | 04	store_temp<felt252>([2]) -> ([2])
107 | 05	return([2])
108 | ```
109 | 
110 | Now, let's take a look at the Casm code corresponding to this program to really understand the benefits of inlining.
111 | 
112 | ## Casm Code Explanations
113 | 
114 | Here is the Casm code for our previous program example:
115 | 
116 | ```cairo,noplayground
117 | 1	call rel 3
118 | 2	ret
119 | 3	call rel 9
120 | 4	[ap + 0] = 1, ap++
121 | 5	[ap + 0] = [ap + -1] + [ap + -2], ap++
122 | 6	ret
123 | 7	[ap + 0] = 1, ap++
124 | 8	ret
125 | 9	[ap + 0] = 2, ap++
126 | 10	ret
127 | 11	ret
128 | ```
129 | 
130 | Don't hesitate to use [cairovm.codes](https://cairovm.codes/) playground to follow along and see all the execution trace.
131 | 
132 | Each instruction and each argument for any instruction increment the Program Counter (known as PC) by 1. This means that `ret` on line 2 is actually the instruction at `PC = 3`, as the argument `3` corresponds to `PC = 2`.
133 | 
134 | The `call` and `ret` instructions allow implementation of a function stack:
135 | 
136 | - `call` instruction acts like a jump instruction, updating the PC to a given value, whether relatively to the current value using `rel` or absolutely using `abs`.
137 | - `ret` instruction jumps back right after the `call` instruction and continues the execution of the code.
138 | 
139 | We can now decompose how these instructions are executed to understand what this code does:
140 | 
141 | - `call rel 3`: this instruction increments the PC by 3 and executes the instruction at this location, which is `call rel 9` at `PC = 4`.
142 | - `call rel 9` increments the PC by 9 and executes the instruction at `PC = 13`, which is actually line 9.
143 | - `[ap + 0] = 2, ap++`: `ap` stands for Allocation Pointer, which points to the first memory cell that has not been used by the program so far. This means we store the value `2` in the next free memory cell indicated by the current value of `ap`, after which we increment `ap` by 1. Then, we go to the next line which is `ret`.
144 | - `ret`: jumps back to the line after `call rel 9`, so we go to line 4.
145 | - `[ap + 0] = 1, ap++` : we store the value `1` in `[ap]` and we apply `ap++` so that `[ap - 1] = 1`. This means we now have `[ap-1] = 1, [ap-2] = 2` and we go to the next line.
146 | - `[ap + 0] = [ap + -1] + [ap + -2], ap++`: we sum the values `1` and `2` and store the result in `[ap]`, and we apply `ap++` so the result is `[ap-1] = 3, [ap-2] = 1, [ap-3]=2`.
147 | - `ret`: jumps back to the line after `call rel 3`, so we go to line 2.
148 | - `ret`: last instruction executed as there is no more `call` instruction where to jump right after. This is the actual return instruction of the Cairo `main` function.
149 | 
150 | To summarize:
151 | 
152 | - `call rel 3` corresponds to the `main` function, which is obviously not inlined.
153 | - `call rel 9` triggers the call to the `not_inlined` function, which returns `2` and stores it at the final location `[ap-3]`.
154 | - The line 4 is the inlined code of the `inlined` function, which returns `1` and stores it at the final location `[ap-2]`. We clearly see that there is no `call` instruction in this case, because the body of the function is inserted and directly executed.
155 | - After that, the sum is computed and we ultimately go back to the line 2 which contains the final `ret` instruction that returns the sum, corresponding to the return value of the `main` function.
156 | 
157 | It is interesting to note that in both Sierra code and Casm code, the `not_inlined` function will be called and executed before the body of the `inlined` function, even though the Cairo program executes `inlined() + not_inlined()`.
158 | 
159 | > The Casm code of our program clearly shows that there is a function call for the `not_inlined` function, while the `inlined` function is correctly inlined.
160 | 
161 | ## Additional Optimizations
162 | 
163 | Let's study another program that shows other benefits that inlining may sometimes provide. Listing {{#ref code_removal}} shows a Cairo program that calls 2 functions and doesn't return anything:
164 | 
165 | ```cairo
166 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_02_inlining/src/lib.cairo}}
167 | ```
168 | 
169 | {{#label code_removal}}
170 | <span class="caption">Listing {{#ref code_removal}}: A small Cairo program that calls `inlined` and `not_inlined` and doesn't return any value.</span>
171 | 
172 | Here is the corresponding Sierra code:
173 | 
174 | ```cairo,noplayground
175 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_02_inlining/src/inlining.sierra}}
176 | ```
177 | 
178 | In this specific case, we can observe that the compiler has applied additional optimizations to the `main` function of our code : the code of the `inlined` function, which is annotated with the `#[inline(always)]` attribute, is actually not copied in the `main` function. Instead, the `main` function starts with the `function_call` libfunc to call the `not_inlined` function, entirely omitting the code of the `inlined` function.
179 | 
180 | > Because `inlined` return value is never used, the compiler optimizes the `main` function by skipping the `inlined` function code. This will actually reduce the code length while reducing the number of steps required to execute `main`.
181 | 
182 | In contrast, line 0 uses the `function_call` libfunc to execute the `not_inlined` function normally. This means that all the code from lines 7 to 8 will be executed:
183 | 
184 | ```cairo,noplayground
185 | 07 felt252_const<133508164995039583817065828>() -> ([0])
186 | 08 store_temp<felt252>([0]) -> ([0])
187 | ```
188 | 
189 | This value stored in the variable with id `0` is then dropped on line 1, as it is not used in the `main` function:
190 | 
191 | ```cairo,noplayground
192 | 01 drop<felt252>([0]) -> ()
193 | ```
194 | 
195 | Finally, as the `main` function doesn't return any value, a variable of unit type `()` is created and returned:
196 | 
197 | ```cairo,noplayground
198 | 02 struct_construct<Unit>() -> ([1])
199 | 03 return([1])
200 | ```
201 | 
202 | ## Summary
203 | 
204 | Inlining is a compiler optimization technique that can be very useful in various situations. Inlining a function allows to get rid of the overhead of calling a function with the `function_call` libfunc by injecting the Sierra code directly in the caller function's context, while potentially optimizing the Sierra code executed to reduce the number of steps. If used effectively, inlining can even reduce code length as shown in the previous example.
205 | 
206 | Nevertheless, applying the `inline` attribute to a function with a lot of code and few parameters might result in an increased code size, especially if the inlined function is used many times in the codebase. Use inlining only where it makes sense, and be aware that the compiler handles inlining by default. Therefore, manually applying inlining is not recommended in most situations, but can help improve and fine-tune your code's behavior.
207 | 


--------------------------------------------------------------------------------
/src/ch11-07-gas-optimisation.md:
--------------------------------------------------------------------------------
1 | # Gas Optimisation
2 | 


--------------------------------------------------------------------------------
/src/ch11-08-printing.md:
--------------------------------------------------------------------------------
  1 | # Printing
  2 | 
  3 | When writing a program, it is quite common to print some data to the console, either for the normal process of the program or for debugging purpose. In this chapter, we describe the options you have to print simple and complex data types.
  4 | 
  5 | ## Printing Standard Data Types
  6 | 
  7 | Cairo provides two macros to print standard data types:
  8 | 
  9 | - `println!` which prints on a new line
 10 | - `print!` with inline printing
 11 | 
 12 | Both take a `ByteArray` string as first parameter (see [Data Types][byte array]), which can be a simple string to print a message or a string with placeholders to format the way values are printed.
 13 | 
 14 | There are two ways to use these placeholders and both can be mixed:
 15 | 
 16 | - empty curly brackets `{}` are replaced by values given as parameters to the `print!` macro, in the same order.
 17 | - curly brackets with variable names are directly replaced by the variable value.
 18 | 
 19 | Here are some examples:
 20 | 
 21 | ```cairo
 22 | {{#include ../listings/ch11-advanced-features/no_listing_08_print_macro/src/lib.cairo}}
 23 | ```
 24 | 
 25 | > `print!` and `println!` macros use the `Display` trait under the hood, and are therefore used to print the value of types that implement it. This is the case for basic data types, but not for more complex ones. If you try to print complex data type values with these macros, e.g. for debugging purposes, you will get an error. In that case, you can either [manually implement][print with display] the `Display` trait for your type or use the `Debug` trait (see [below][print with debug]).
 26 | 
 27 | [byte array]: ./ch02-02-data-types.md#byte-array-strings
 28 | [print with display]: ./ch11-08-printing.md#printing-custom-data-types
 29 | [print with debug]: ./ch11-08-printing.md#print-debug-traces
 30 | 
 31 | ## Formatting
 32 | 
 33 | Cairo also provides a useful macro to handle string formatting: `format!`. This macro works like `println!`, but instead of printing the output to the screen, it returns a `ByteArray` with the contents. In the following example, we perform string concatenation using either the `+` operator or the
 34 | `format!` macro. The version of the code using `format!` is much easier to read, and the code generated by the `format!` macro uses snapshots, so that this call doesnt take ownership of any of its parameters.
 35 | 
 36 | ```cairo
 37 | {{#include ../listings/ch11-advanced-features/no_listing_06_format_macro/src/lib.cairo}}
 38 | ```
 39 | 
 40 | ## Printing Custom Data Types
 41 | 
 42 | As previously explained, if you try to print the value of a custom data type with `print!` or `println!` macros, you'll get an error telling you that the `Display` trait is not implemented for your custom type:
 43 | 
 44 | ```shell
 45 | error: Trait has no implementation in context: core::fmt::Display::<package_name::struct_name>
 46 | ```
 47 | 
 48 | The `println!` macro can do many kinds of formatting, and by default, the curly brackets tell `println!` to use formatting known as `Display` - output intended for direct end user consumption. The primitive types weve seen so far implement `Display` by default because theres only one way youd want to show a `1` or any other primitive type to a user. But with structs, the way `println!` should format the output is less clear because there are more display possibilities: Do we want commas or not? Do we want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo doesnt try to guess what we want, and structs dont have a provided implementation of `Display` to use with `println!` and the `{}` placeholder.
 49 | 
 50 | Here is the `Display` trait to implement:
 51 | 
 52 | ```cairo,noplayground
 53 | trait Display<T> {
 54 |     fn fmt(self: @T, ref f: Formatter) -> Result<(), Error>;
 55 | }
 56 | ```
 57 | 
 58 | The second parameter `f` is of type `Formatter`, which is just a struct containing a `ByteArray`, representing the pending result of formatting:
 59 | 
 60 | ```cairo,noplayground
 61 | #[derive(Default, Drop)]
 62 | pub struct Formatter {
 63 |     /// The pending result of formatting.
 64 |     pub buffer: ByteArray,
 65 | }
 66 | ```
 67 | 
 68 | Knowing this, here is an example of how to implement the `Display` trait for a custom `Point` struct:
 69 | 
 70 | ```cairo
 71 | {{#include ../listings/ch11-advanced-features/no_listing_09_display_trait_with_format/src/lib.cairo}}
 72 | ```
 73 | 
 74 | Cairo also provides the `write!` and `writeln!` macros to write formatted strings in a formatter.
 75 | Here is a short example using `write!` macro to concatenate multiple strings on the same line and then print the result:
 76 | 
 77 | ```cairo
 78 | {{#include ../listings/ch11-advanced-features/no_listing_07_write_macro/src/lib.cairo}}
 79 | ```
 80 | 
 81 | It is also possible to implement the `Display` trait for the `Point` struct using these macros, as shown here:
 82 | 
 83 | ```cairo
 84 | {{#include ../listings/ch11-advanced-features/no_listing_10_display_trait_with_write/src/lib.cairo}}
 85 | ```
 86 | 
 87 | > Printing complex data types this way might not be ideal as it requires additional steps to use the `print!` and `println!` macros. If you need to print complex data types, especially when debugging, use the `Debug` trait described below instead.
 88 | 
 89 | ## Print Debug Traces
 90 | 
 91 | Cairo provides the `Debug` trait, which can be derived to print the value of variables when debugging. Simply add `:?` within the curly brackets `{}` placeholders in a `print!` or `println!` macro string.
 92 | 
 93 | This trait is very useful and is implemented by default for basic data types. It can also be simply derived for complex data types using the `#[derive(Debug)]` attribute, as long as all types they contain implement it. This eliminates the need to manually implement extra code to print complex data types.
 94 | 
 95 | Note that `assert_xx!` macros used in tests require the provided values to implement the `Debug` trait, as they also print the result in case of assertion failure.
 96 | 
 97 | For more details about the `Debug` trait and its usage for printing values when debugging, please refer to the [Derivable Traits][debug trait] appendix.
 98 | 
 99 | [debug trait]: ./appendix-03-derivable-traits.md#debug-trait-for-printing-and-debugging
100 | 


--------------------------------------------------------------------------------
/src/ch11-09-deref-coercion.md:
--------------------------------------------------------------------------------
 1 | # Deref Coercion
 2 | 
 3 | Deref coercion simplifies the way we interact with nested or wrapped data structures by allowing an instance of one type to behave like an instance of another type. This mechanism is enabled by implementing the `Deref` trait, which allows implicit conversion (or coercion) to a different type, providing direct access to the underlying data.
 4 | 
 5 | > Note: For now, deref coercion allows you to access a member of a type `T` as if it was a type `K`, but will not allow you to call functions whose `self` argument is of the original type when holding an instance of the coerced type.
 6 | 
 7 | Deref coercion is implemented via the `Deref` and `DerefMut` traits. When a type `T` implements `Deref` or `DerefMut` to type `K`, instances of `T` can access the members of `K` directly.
 8 | 
 9 | The `Deref` trait in Cairo is defined as follows:
10 | 
11 | ```cairo, noplayground
12 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_09_deref_coercion/src/lib.cairo:Deref}}
13 | ```
14 | 
15 | The `Target` type specifies the result of dereferencing, and the `deref` method defines how to transform `T` into `K`.
16 | 
17 | ## Using Deref Coercion
18 | 
19 | To better understand how deref coercion works, let's look at a practical example. We'll create a simple generic wrapper type around a type `T` called `Wrapper<T>`, and use it to wrap a `UserProfile` struct.
20 | 
21 | ```cairo, noplayground
22 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_example/src/lib.cairo:Wrapper}}
23 | ```
24 | 
25 | The `Wrapper` struct wraps a single value generic of type `T`. To simplify access to the wrapped value, we implement the `Deref` trait for `Wrapper<T>`.
26 | 
27 | ```cairo, noplayground
28 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_example/src/lib.cairo:deref}}
29 | ```
30 | 
31 | This implementation is quite simple. The `deref` method returns the wrapped value, allowing instances of `Wrapper<T>` to access the members of `T` directly.
32 | 
33 | In practice, this mechanism is totally transparent. The following example demonstrates how, holding
34 | an instance of `Wrapper<UserProfile>`, we can print the `username` and `age` fields of the underlying
35 | `UserProfile` instance.
36 | 
37 | ```cairo
38 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_example/src/lib.cairo:main}}
39 | ```
40 | 
41 | ### Restricting Deref Coercion to Mutable Variables
42 | 
43 | While `Deref` works for both mutable and immutable variables, `DerefMut` will only be applicable to mutable variables. Contrary to what the name might suggest, `DerefMut` does not provide mutable access to the underlying data.
44 | 
45 | ```cairo, noplayground
46 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:derefMut}}
47 | ```
48 | 
49 | If you try to use `DerefMut` with an immutable variable, the compiler would throw an error. Heres an example:
50 | 
51 | ```cairo, noplayground
52 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:error}}
53 | ```
54 | 
55 | Compiling this code will result in the following error:
56 | 
57 | ```plaintext
58 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_mut_example/output.txt}}
59 | ```
60 | 
61 | For the above code to work, we need to define `wrapped_profile` as a mutable variable.
62 | 
63 | ```cairo, noplayground
64 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:example}}
65 | ```
66 | 
67 | ## Summary
68 | 
69 | By using the `Deref` and `DerefMut` traits, we can transparently convert one type into another, simplifying the access to nested or wrapped data structures. This feature is particularly useful when working with generic types or building abstractions that require seamless access to the underlying data and can help reduce boilerplate code.
70 | However, this functionality is quite limited, as you cannot call functions whose `self` argument is of the original type when holding an instance of the coerced type.
71 | 


--------------------------------------------------------------------------------
/src/ch11-10-arithmetic-circuits.md:
--------------------------------------------------------------------------------
  1 | # Arithmetic Circuits
  2 | 
  3 | Arithmetic circuits are mathematical models used to represent polynomial computations. They are defined over a field (typically a finite field \\(F_p\\) where \\(p\\) is prime) and consist of:
  4 | - Input signals (values in the range \\([0, p-1]\\))
  5 | - Arithmetic operations (addition and multiplication gates)
  6 | - Output signals
  7 | 
  8 | Cairo supports emulated arithmetic circuits with modulo up to 384 bits.
  9 | 
 10 | This is especially useful for:
 11 | - Implementing verification for other proof systems
 12 | - Implementing cryptographic primitives
 13 | - Creating more low-level programs, with potential reduced overhead compared to standard Cairo constructs
 14 | 
 15 | ## Implementing Arithmetic Circuits in Cairo
 16 | 
 17 | Cairo's circuit constructs are available in the `core::circuit` module of the corelib.
 18 | 
 19 | Arithmetic circuits consist of:
 20 | - Addition modulo \\(p\\): `AddMod` builtin
 21 | - Multiplication modulo \\(p\\): `MulMod` builtin
 22 | 
 23 | Because of the modulo properties, we can build four basic arithmetic gates:
 24 | - Addition: `AddModGate`
 25 | - Subtraction: `SubModGate`
 26 | - Multiplication: `MulModGate`
 27 | - Inverse: `InvModGate`
 28 | 
 29 | Let's create a circuit that computes \\(a \cdot (a + b)\\) over the BN254 prime field.
 30 | 
 31 | We start from the empty struct `CircuitElement<T>`.
 32 | 
 33 | The inputs of our circuit are defined as `CircuitInput`:
 34 | 
 35 | ```cairo, noplayground
 36 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:inputs}}
 37 | ```
 38 | 
 39 | We can combine circuit inputs and gates: `CircuitElement<a>` and `CircuitElement<b>` combined with an addition gate gives `CircuitElement<AddModGate<a, b>>`.
 40 | 
 41 | We can use `circuit_add`, `circuit_sub`, `circuit_mul` and `circuit_inverse` to directly combine circuit elements.
 42 | For \\(a * (a + b)\\), the description of our circuit is:
 43 | 
 44 | ```cairo, noplayground
 45 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:description}}
 46 | ```
 47 | 
 48 | Note that `a`, `b` and `add` are intermediate circuit elements and not specifically inputs or gates, which is why we need the distinction between the empty struct `CircuitElement<T>` and the circuit description specified by the type `T`.
 49 | 
 50 | The outputs of the circuits are defined as a tuple of circuit elements. It's possible to add any intermediate gates of our circuit, but we must add all gates with degree 0 (gates where the output signal is not used as input of any other gate).
 51 | In our case, we will only add the last gate `mul`:
 52 | 
 53 | ```cairo, noplayground
 54 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:output}}
 55 | ```
 56 | 
 57 | We now have a complete description of our circuit and its outputs.
 58 | We now need to assign a value to each input.
 59 | As circuits are defined with 384-bit modulus, a single `u384` value can be represented as a fixed array of four `u96`.
 60 | We can initialize \\(a\\) and \\(b\\) to respectively \\(10\\) and \\(20\\):
 61 | 
 62 | ```cairo, noplayground
 63 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:instance}}
 64 | ```
 65 | 
 66 | As the number of inputs can vary, Cairo use an accumulator and the `new_inputs` and `next` functions return a variant of the `AddInputResult` enum.
 67 | 
 68 | ```cairo, noplayground
 69 | pub enum AddInputResult<C> {
 70 |     /// All inputs have been filled.
 71 |     Done: CircuitData<C>,
 72 |     /// More inputs are needed to fill the circuit instance's data.
 73 |     More: CircuitInputAccumulator<C>,
 74 | }
 75 | ```
 76 | 
 77 | We have to assign a value to every input, by calling `next` on each `CircuitInputAccumulator` variant.
 78 | After the inputs initialization, by calling the `done` function we get the complete circuit `CircuitData<C>`, where `C` is a long type that encodes the entire circuit instance.
 79 | 
 80 | We then need to define what modulus our circuit is using (up to 384-bit modulus), by defining a `CircuitModulus`. We want to use BN254 prime field modulus:
 81 | 
 82 | ```cairo, noplayground
 83 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:modulus}}
 84 | ```
 85 | 
 86 | The last part is the evaluation of the circuit, i.e. the actual process of passing the input signals correctly through each gate described by our circuit and getting the values of each output gate.
 87 | We can evaluate and get the results for a given modulus as follows:
 88 | 
 89 | ```cairo, noplayground
 90 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:eval}}
 91 | ```
 92 | 
 93 | To retrieve the value of a specific output, we can use the `get_output` function on our results with the `CircuitElement` instance of the output gate we want. We can also retrieve any intermediate gate value as well.
 94 | 
 95 | ```cairo, noplayground
 96 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:output_values}}
 97 | ```
 98 | 
 99 | To recap, we did the following steps:
100 | - Define Circuit Inputs
101 | - Describe the circuit
102 | - Specify the outputs
103 | - Assign values to the inputs
104 | - Define the modulus
105 | - Evaluate the circuit
106 | - Get the output values
107 | 
108 | And the full code is:
109 | 
110 | ```cairo, noplayground
111 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:full}}
112 | ```
113 | 
114 | ## Arithmetic Circuits in Zero-Knowledge Proof Systems
115 | 
116 | In zero-knowledge proof systems, a prover creates a proof of computational statements, which a verifier can check without performing the full computation. However, these statements must first be converted into a suitable representation for the proof system.
117 | 
118 | ### zk-SNARKs Approach
119 | 
120 | Some proof systems, like zk-SNARKs, use arithmetic circuits over a finite field \\(F_p\\). These circuits include constraints at specific gates, represented as equations:
121 | 
122 | \\[
123 |   (a_1 \cdot s_1 + ... + a_n \cdot s_n) \cdot (b_1 \cdot s_1 + ... + b_n \cdot s_n) + (c_1 \cdot s_1 + ... + c_n \cdot s_n) = 0 \mod p
124 | \\]
125 | Where \\(s_1, ..., s_n\\) are signals, and \\(a_i, b_i, c_i\\) are coefficients.
126 | 
127 | A witness is an assignment of signals that satisfies all constraints in a circuit. zk-SNARK proofs use these properties to prove knowledge of a witness without revealing private input signals, ensuring the prover's honesty while preserving privacy.
128 | 
129 | Some work has already been done, such as [Garaga Groth16 verifier](https://felt.gitbook.io/garaga/deploy-your-snark-verifier-on-starknet/groth16/generate-and-deploy-your-verifier-contract)
130 | 
131 | ### zk-STARKs Approach
132 | 
133 | STARKs (which Cairo uses) use an Algebraic Intermediate Representation (AIR) instead of arithmetic circuits. AIR describes computations as a set of polynomial constraints.
134 | 
135 | By allowing emulated arithmetic circuits, Cairo can be used to implement zk-SNARKs proof verification inside STARK proofs.
136 | 


--------------------------------------------------------------------------------
/src/ch11-10-associated-items.md:
--------------------------------------------------------------------------------
  1 | # Associated Items
  2 | 
  3 | _Associated Items_ are the items declared in [traits] or defined in
  4 | [implementations]. Specifically, there are [associated functions] (including methods, that we already covered in Chapter {{#chap using-structs-to-structure-related-data}}), [associated types], [associated constants], and [associated implementations].
  5 | 
  6 | [traits]: ./ch08-02-traits-in-cairo.md
  7 | [implementations]: ./ch08-02-traits-in-cairo.md#implementing-a-trait-on-a-type
  8 | [associated types]: ./ch11-10-associated-items.md#associated-types
  9 | [associated functions]: ./ch05-03-method-syntax.md#associated-functions
 10 | [associated constants]: ./ch11-10-associated-items.md#associated-constants
 11 | [associated implementations]: ./ch11-10-associated-items.md#associated-implementations
 12 | 
 13 | Associated items are useful when they are logically related to the implementation. For example, the `is_some` method on `Option` is intrinsically related to Options, so should be associated.
 14 | 
 15 | Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.
 16 | 
 17 | ## Associated Types
 18 | 
 19 | Associated types are _type aliases_ allowing you to define abstract type placeholders within traits. Instead of specifying concrete types in the trait definition, associated types let trait implementers choose the actual types to use.
 20 | 
 21 | Let's consider the following `Pack` trait:
 22 | 
 23 | ```cairo, noplayground
 24 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:associated_types}}
 25 | ```
 26 | 
 27 | The `Result` type in our `Pack` trait acts as placeholder for a type that will be filled in later. Think of associated types as leaving a blank space in your trait for each implementation to write in the specific type it needs. This approach keeps your trait definition clean and flexible. When you use the trait, you don't need to worry about specifying these types - they're already chosen for you by the implementation. In our `Pack` trait, the type `Result` is such a placeholder. The method's definition shows that it will return values of type `Self::Result`, but it doesn't specify what `Result` actually is. This is left to the implementers of the `Pack` trait, who will specify the concrete type for `Result`. When the `pack` method is called, it will return a value of that chosen concrete type, whatever it may be.
 28 | 
 29 | Let's see how associated types compare to a more traditional generic approach. Suppose we need a function `foo` that can pack two variables of type `T`. Without associated types, we might define a `PackGeneric` trait and an implementation to pack two `u32` like this:
 30 | 
 31 | ```cairo, noplayground
 32 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:generics_usage}}
 33 | ```
 34 | 
 35 | With this approach, `foo` would be implemented as:
 36 | 
 37 | ```cairo, noplayground
 38 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:foo}}
 39 | ```
 40 | 
 41 | Notice how `foo` needs to specify both `T` and `U` as generic parameters. Now, let's compare this to our `Pack` trait with an associated type:
 42 | 
 43 | ```cairo, noplayground
 44 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:associated_types_impl}}
 45 | ```
 46 | 
 47 | With associated types, we can define `bar` more concisely:
 48 | 
 49 | ```cairo, noplayground
 50 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:bar}}
 51 | ```
 52 | 
 53 | Finally, let's see both approaches in action, demonstrating that the end result is the same:
 54 | 
 55 | ```cairo
 56 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_10_associated_types/src/lib.cairo:main}}
 57 | ```
 58 | 
 59 | As you can see, `bar` doesn't need to specify a second generic type for the packing result. This information is hidden in the implementation of the `Pack` trait, making the function signature cleaner and more flexible. Associated types allow us to express the same functionality with less verbosity, while still maintaining the flexibility of generic programming.
 60 | 
 61 | ## Associated Constants
 62 | 
 63 | Associated constants are constants associated with a type. They are declared using the `const` keyword in a trait and defined in its implementation.
 64 | In our next example, we define a generic `Shape` trait that we implement for a `Triangle` and a `Square`. This trait includes an associated constant, defining the number of sides of the type that implements the trait.
 65 | 
 66 | ```cairo, noplayground
 67 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_11_associated_consts/src/lib.cairo:associated_consts}}
 68 | ```
 69 | 
 70 | After that, we create a `print_shape_info` generic function, which requires that the generic argument implements the `Shape` trait. This function will use the associated constant to retrieve the number of sides of the geometric figure, and print it along with its description.
 71 | 
 72 | ```cairo, noplayground
 73 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_11_associated_consts/src/lib.cairo:print_info}}
 74 | ```
 75 | 
 76 | Associated constants allow us to bind a constant number to the `Shape` trait rather than adding it to the struct or just hardcoding the value in the implementation. This approach provides several benefits:
 77 | 
 78 | 1. It keeps the constant closely tied to the trait, improving code organization.
 79 | 2. It allows for compile-time checks to ensure all implementors define the required constant.
 80 | 3. It ensures two instances of the same type have the same number of sides.
 81 | 
 82 | Associated constants can also be used for type-specific behavior or configuration, making them a versatile tool in trait design.
 83 | 
 84 | We can ultimately run the `print_shape_info` and see the output for both `Triangle` and `Square`:
 85 | 
 86 | ```cairo
 87 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_11_associated_consts/src/lib.cairo:main}}
 88 | ```
 89 | 
 90 | ## Associated Implementations
 91 | 
 92 | Associated implementations allow you to declare that a trait implementation must exist for an associated type. This feature is particularly useful when you want to enforce relationships between types and implementations at the trait level. It ensures type safety and consistency across different implementations of a trait, which is important in generic programming contexts.
 93 | 
 94 | To understand the utility of associated implementations, let's examine the `Iterator` and `IntoIterator` traits from the Cairo core library, with their respective implementations using `ArrayIter<T>` as the collection type:
 95 | 
 96 | ```cairo, noplayground
 97 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_12_associated_impls/src/lib.cairo:associated_impls}}
 98 | ```
 99 | 
100 | 1. The `IntoIterator` trait is designed to convert a collection into an iterator.
101 | 2. The `IntoIter` associated type represents the specific iterator type that will be created. This allows different collections to define their own efficient iterator types.
102 | 3. The associated implementation `Iterator: Iterator<Self::IntoIter>` (the key feature we're discussing) declares that this `IntoIter` type must implement the `Iterator` trait.
103 | 4. This design allows for type-safe iteration without needing to specify the iterator type explicitly every time, improving code ergonomics.
104 | 
105 | The associated implementation creates a binding at the trait level, guaranteeing that:
106 | 
107 | - The `into_iter` method will always return a type that implements `Iterator`.
108 | - This relationship is enforced for all implementations of `IntoIterator`, not just on a case-by-case basis.
109 | 
110 | The following `main` function demonstrates how this works in practice for an `Array<felt252>`:
111 | 
112 | ```cairo
113 | {{#rustdoc_include ../listings/ch11-advanced-features/listing_12_associated_impls/src/lib.cairo:main}}
114 | ```
115 | 


--------------------------------------------------------------------------------
/src/ch11-10-procedural-macros.md:
--------------------------------------------------------------------------------
  1 | # Procedural Macros
  2 | 
  3 | Cairo procedural macros are Rust functions that takes Cairo code as input and returns a modified Cairo code as output, enabling developers to extend Cairo's syntax and create reusable code patterns. In the previous chapter, we discussed some Cairo built-in macros like `println!`, `format!`, etc. In this chapter, we will explore how to create and use custom procedural macros in Cairo.
  4 | 
  5 | ## Types of Procedural Macros
  6 | 
  7 | There are three types of procedural macros in Cairo:
  8 | 
  9 | - **Expression Macros** (`macro!()`):
 10 |   These macros are used like function calls and can generate code based on their arguments.
 11 | 
 12 | - **Attribute Macros** (`#[macro]`):
 13 |   These macros can be attached to items like functions or structs to modify their behavior or implementation.
 14 | 
 15 | - **Derive Macros** (`#[derive(Macro)]`):
 16 |   These macros automatically implement traits for structs or enums.
 17 | 
 18 | ## Creating a Procedural Macro
 19 | 
 20 | Before creating or using procedural macros, we need to ensure that the necessary tools are installed:
 21 | 
 22 | - **Rust Toolchain**: Cairo procedural macros are implemented in Rust, so we will need the Rust toolchain setup on our machine.
 23 | - To set up Rust, visit [rustup](https://rustup.rs) and follow the installation instructions for your operating system.
 24 | 
 25 | Since procedural macros are in fact Rust functions, we will need to add a `Cargo.toml` file to the root directory ( same level as the `Scarb.toml` file ). In the `Cargo.toml` file, we need to add a `crate-type = ["cdylib"]` on the `[lib]` target, and also add the `cairo-lang-macro` crate as a dependency.
 26 | 
 27 | > It is essential that both the `Scarb.toml` and `Cargo.toml` have the same package name, or there will be an error when trying to use the macro.
 28 | 
 29 | Below is an example of the `Scarb.toml` and `Cargo.toml` files:
 30 | 
 31 | ```toml
 32 | # Scarb.toml
 33 | [package]
 34 | name = "no_listing_15_pow_macro"
 35 | version = "0.1.0"
 36 | edition = "2024_07"
 37 | 
 38 | # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
 39 | [cairo-plugin]
 40 | 
 41 | [dependencies]
 42 | 
 43 | [dev-dependencies]
 44 | cairo_test = "2.9.1"
 45 | ```
 46 | 
 47 | {{#label procedural-macros-scarb-file}}
 48 | <span class="caption">Listing {{#ref procedural-macros-scarb-file}}: Example `Scarb.toml` file needed for building a procedural macro.</span>
 49 | 
 50 | ```toml
 51 | # Cargo.toml
 52 | [package]
 53 | name = "no_listing_15_pow_macro"
 54 | version = "0.1.0"
 55 | edition = "2021"
 56 | 
 57 | [lib]
 58 | crate-type = ["cdylib"]
 59 | 
 60 | [dependencies]
 61 | bigdecimal = "0.4.5"
 62 | cairo-lang-macro = "0.1"
 63 | cairo-lang-parser = "2.9.1"
 64 | cairo-lang-syntax = "2.9.1"
 65 | 
 66 | [workspace]
 67 | ```
 68 | 
 69 | {{#label some-macro}}
 70 | <span class="caption">Listing {{#ref some-macro}}: Example `Cargo.toml` file needed for building a procedural macro.</span>
 71 | 
 72 | Also notice that you can also add other rust dependencies in your `Cargo.toml` file. In the example above, we added the `bigdecimal`, `cairo-lang-parser` and `cairo-lang-syntax` crates as a dependencies.
 73 | 
 74 | Listing {{#ref pow_macro}} shows the rust code for creating an inline macro in Rust:
 75 | 
 76 | ```rust, noplayground
 77 | {{#rustdoc_include ../listings/ch11-advanced-features/no_listing_15_macro/src/pow.rs:main}}
 78 | ```
 79 | 
 80 | {{#label pow_macro}}
 81 | <span class="caption">Listing {{#ref pow_macro}}: Code for creating inline pow procedural macro</span>
 82 | 
 83 | The essential dependency for building a cairo macro `cairo_lang_macro` is imported here with `inline_macro, Diagnostic, ProcMacroResult, TokenStream`. The `inline_macro` is used for implementing an expression macro, `ProcMacroResult` is used for the function return, `TokenStream` as the input, and the `Diagnostic` is used for error handling. We also use the `cairo-lang-parser` crate to parse the input code. Then the `pow` function is defined utilizing the imports to create a macro that calculate the pow based on the `TokenStream` input.
 84 | 
 85 | ## How to Use Existing Procedural Macros
 86 | 
 87 | > **Note**: While you need Rust installed to use procedural macros, you don't need to know Rust programming to use existing macros in your Cairo project.
 88 | 
 89 | ### Incorporating an Existing Procedural Macro Into Your Project
 90 | 
 91 | Similar to how you add a library dependency in your Cairo project, you can also add a procedural macro as a dependency in your `Scarb.toml` file.
 92 | 
 93 | ```rust, noplayground
 94 | {{#include ../listings/ch11-advanced-features/no_listing_16_procedural_macro/src/lib.cairo:pow_macro}}
 95 | ```
 96 | 
 97 | {{#label using_pow_macro}}
 98 | <span class="caption">Listing {{#ref using_pow_macro}}: Using pow procedural macro</span>
 99 | 
100 | You'd notice a `pow!` macro, which is not a built-in Cairo macro being used in this example above. It is a custom procedural macro that calculates the power of a number as defined in the example above on creating a procedural macro.
101 | 
102 | ```rust, noplayground
103 | {{#include ../listings/ch11-advanced-features/no_listing_16_procedural_macro/src/lib.cairo:derive_macro}}
104 | ```
105 | 
106 | {{#label using_derive_macro}}
107 | <span class="caption">Listing {{#ref using_derive_macro}}: Using derive procedural macro</span>
108 | 
109 | The example above shows using a derive macro on a `struct` B, which grants the custom struct the ability to perform addition, subtraction, multiplication, and division operations on the struct.
110 | 
111 | ```rust, noplayground
112 | {{#include ../listings/ch11-advanced-features/no_listing_16_procedural_macro/src/lib.cairo:b_struct}}
113 | ```
114 | 
115 | ## Summary
116 | 
117 | Procedural macros offer a powerful way to extend Cairo's capabilities by leveraging Rust functions to generate new Cairo code. They allow for code generation, custom syntax, and automated implementations, making them a valuable tool for Cairo developers. While they require some setup and careful consideration of performance impacts, the flexibility they provide can significantly enhance your Cairo development experience.
118 | 


--------------------------------------------------------------------------------
/src/ch13-00-introduction-to-starknet-smart-contracts.md:
--------------------------------------------------------------------------------
 1 | # Introduction to Starknet Smart Contracts
 2 | 
 3 | All through the previous sections, you've mostly written programs with a `main` entrypoint. In the coming sections, you will learn to write and deploy Starknet contracts.
 4 | 
 5 | One of the key applications of the Cairo language is writing smart contracts for the Starknet network. Starknet is a permissionless decentralized network that leverages zk-STARKs technology for scalability. As a Layer 2 (L2) scalability solution for Ethereum, Starknet aims to provide fast, secure, and low-cost transactions. It operates as a validity rollup, commonly known as a zero-knowledge rollup, and is built on top of the Cairo VM.
 6 | 
 7 | Starknet contracts are programs specifically designed to run within the Starknet OS. The Starknet OS is a Cairo program itself, which means that any operation executed by the Starknet OS can be proven and succinctly verified. Smart contracts can access Starknet's persistent state through the OS, enabling them to read or modify variables in Starknets state, communicate with other contracts, and interact seamlessly with the underlying Layer 1 (L1) network.
 8 | 
 9 | If you want to learn more about the Starknet network itself, its architecture and the tooling available, you should read the [Starknet Book][starknet book]. In this book, we will only focus on writing smart contracts in Cairo.
10 | 
11 | [starknet book]: https://book.starknet.io/
12 | 
13 | ## Scarb
14 | 
15 | Scarb facilitates smart contract development for Starknet. To enable this feature, you'll need to make some configurations in your _Scarb.toml_ file (see [Installation][scarb installation] for how to install Scarb).
16 | 
17 | First, add the `starknet` dependency to your _Scarb.toml_ file. Next, enable the Starknet contract compilation of the package by adding a `[[target.starknet-contract]]` section. By default, specifying this target will build a Sierra Contract Class file, which can be deployed on Starknet. If you omit to specify the target, your package will compile but will not produce an output that you can use with Starknet.
18 | 
19 | Below is the minimal _Scarb.toml_ file required to compile a crate containing Starknet contracts:
20 | 
21 | ```toml
22 | [package]
23 | name = "package_name"
24 | version = "0.1.0"
25 | 
26 | [dependencies]
27 | starknet = ">=2.8.0"
28 | 
29 | [[target.starknet-contract]]
30 | ```
31 | 
32 | To compile contracts defined in your package's dependencies, please refer to the [Scarb documentation][compile dep contract].
33 | 
34 | [scarb installation]: ./ch01-01-installation.md
35 | [compile dep contract]: https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts
36 | 
37 | ## Starknet Foundry
38 | 
39 | Starknet Foundry is a toolchain for Starknet smart contract development. It supports many features, including writing and running tests with advanced features, deploying contracts, interacting with the Starknet network, and more.
40 | 
41 | We'll describe Starknet Foundry in more detail in [Chapter {{#chap starknet-smart-contracts-security}}][testing with snfoundry] when discussing Starknet smart contract testing and security.
42 | 
43 | [testing with snfoundry]: ./ch17-02-testing-smart-contracts.md#testing-smart-contracts-with-starknet-foundry
44 | 


--------------------------------------------------------------------------------
/src/ch13-01-general-introduction-to-smart-contracts.md:
--------------------------------------------------------------------------------
 1 | # General Introduction to Smart Contracts
 2 | 
 3 | This chapter will give you a high level introduction to what smart contracts are, what they are used for, and why blockchain developers would use Cairo and Starknet.
 4 | If you are already familiar with blockchain programming, feel free to skip this chapter. The last part might still be interesting though.
 5 | 
 6 | ## Smart Contracts
 7 | 
 8 | Smart contracts gained popularity and became more widespread with the birth of Ethereum. Smart contracts are essentially programs deployed on a blockchain. The term "smart contract" is somewhat misleading, as they are neither "smart" nor "contracts" but rather code and instructions that are executed based on specific inputs. They primarily consist of two components: storage and functions. Once deployed, users can interact with smart contracts by initiating blockchain transactions containing execution data (which function to call and with what input). Smart contracts can modify and read the storage of the underlying blockchain. A smart contract has its own address and is considered a blockchain account, meaning it can hold tokens.
 9 | 
10 | The programming language used to write smart contracts varies depending on the blockchain. For example, on Ethereum and the [EVM-compatible ecosystem][evm], the most commonly used language is Solidity, while on Starknet, it is Cairo. The way the code is compiled also differs based on the blockchain. On Ethereum, Solidity is compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then into Cairo Assembly (CASM).
11 | 
12 | Smart contracts possess several unique characteristics. They are **permissionless**, meaning anyone can deploy a smart contract on the network (within the context of a decentralized blockchain, of course). Smart contracts are also **transparent**; the data stored by the smart contract is accessible to anyone. The code that composes the contract can also be transparent, enabling **composability**. This allows developers to write smart contracts that use other smart contracts. Smart contracts can only access and interact with data from the blockchain they are deployed on. They require third-party software (called _oracles_) to access external data (the price of a token for instance).
13 | 
14 | For developers to build smart contracts that can interact with each other, it is required to know what the other contracts look like. Hence, Ethereum developers started to build standards for smart contract development, the `ERCxx`. The two most used and famous standards are the `ERC20`, used to build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-Fungible Tokens) like `CryptoPunks` or `Everai`.
15 | 
16 | [evm]: https://ethereum.org/en/developers/docs/evm/
17 | 
18 | ## Use Cases
19 | 
20 | There are many possible use cases for smart contracts. The only limits are the technical constraints of the blockchain and the creativity of developers.
21 | 
22 | ### DeFi
23 | 
24 | For now, the principal use case for smart contracts is similar to that of Ethereum or Bitcoin, which is essentially handling money. In the context of the alternative payment system promised by Bitcoin, smart contracts on Ethereum enable the creation of decentralized financial applications that no longer rely on traditional financial intermediaries. This is what we call DeFi (decentralized finance). DeFi consists of various projects such as lending/borrowing applications, decentralized exchanges (DEX), on-chain derivatives, stablecoins, decentralized hedge funds, insurance, and many more.
25 | 
26 | ### Tokenization
27 | 
28 | Smart contracts can facilitate the tokenization of real-world assets, such as real estate, art, or precious metals. Tokenization divides an asset into digital tokens, which can be easily traded and managed on blockchain platforms. This can increase liquidity, enable fractional ownership, and simplify the buying and selling process.
29 | 
30 | ### Voting
31 | 
32 | Smart contracts can be used to create secure and transparent voting systems. Votes can be recorded on the blockchain, ensuring immutability and transparency. The smart contract can then automatically tally the votes and declare the results, minimizing the potential for fraud or manipulation.
33 | 
34 | ### Royalties
35 | 
36 | Smart contracts can automate royalty payments for artists, musicians, and other content creators. When a piece of content is consumed or sold, the smart contract can automatically calculate and distribute the royalties to the rightful owners, ensuring fair compensation and reducing the need for intermediaries.
37 | 
38 | ### Decentralized Identities DIDs
39 | 
40 | Smart contracts can be used to create and manage digital identities, allowing individuals to control their personal information and share it with third parties securely. The smart contract could verify the authenticity of a user's identity and automatically grant or revoke access to specific services based on the user's credentials.
41 | 
42 | <br/>
43 | <br/>
44 | As Ethereum continues to mature, we can expect the use cases and applications of smart contracts to expand further, bringing about exciting new opportunities and reshaping traditional systems for the better.
45 | 
46 | ## The Rise of Starknet and Cairo
47 | 
48 | Ethereum, being the most widely used and resilient smart contract platform, became a victim of its own success. With the rapid adoption of some previously mentioned use cases, mainly DeFi, the cost of performing transactions became extremely high, rendering the network almost unusable. Engineers and researchers in the ecosystem began working on solutions to address this scalability issue.
49 | 
50 | A famous trilemma called The Blockchain Trilemma in the blockchain space states that it is hard to achieve a high level of scalability, decentralization, and security simultaneously; trade-offs must be made. Ethereum is at the intersection of decentralization and security. Eventually, it was decided that Ethereum's purpose would be to serve as a secure settlement layer, while complex computations would be offloaded to other networks built on top of Ethereum. These are called Layer 2s (L2s).
51 | 
52 | The two primary types of L2s are optimistic rollups and validity rollups. Both approaches involve compressing and batching numerous transactions together, computing the new state, and settling the result on Ethereum (L1). The difference lies in the way the result is settled on L1. For optimistic rollups, the new state is considered valid by default, but there is a 7-day window for nodes to identify malicious transactions.
53 | 
54 | In contrast, validity rollups, such as Starknet, use cryptography to prove that the new state has been correctly computed. This is the purpose of STARKs, this cryptographic technology could permit validity rollups to scale significantly more than optimistic rollups. You can learn more about STARKs from Starkware's Medium [article][starks article], which serves as a good primer.
55 | 
56 | > Starknet's architecture is thoroughly described in the [Starknet Book][starknet architecture], which is a great resource to learn more about the Starknet network.
57 | 
58 | Remember Cairo? It is, in fact, a language developed specifically to work with STARKs and make them general-purpose. With Cairo, we can write **provable code**. In the context of Starknet, this allows proving the correctness of computations from one state to another.
59 | 
60 | Unlike most (if not all) of Starknet's competitors that chose to use the EVM (either as-is or adapted) as a base layer, Starknet employs its own VM. This frees developers from the constraints of the EVM, opening up a broader range of possibilities. Coupled with decreased transaction costs, the combination of Starknet and Cairo creates an exciting playground for developers. Native account abstraction enables more complex logic for accounts, that we call "Smart Accounts", and transaction flows. Emerging use cases include **transparent AI** and machine learning applications. Finally, **blockchain games** can be developed entirely **on-chain**. Starknet has been specifically designed to maximize the capabilities of STARK proofs for optimal scalability.
61 | 
62 | > Learn more about Account Abstraction in the [Starknet Book][account abstraction chapter].
63 | 
64 | [starks article]: https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a
65 | [starknet architecture]: https://book.starknet.io/ch03-00-architecture.html
66 | [account abstraction chapter]: https://book.starknet.io/ch04-00-account-abstraction.html
67 | 
68 | ## Cairo Programs and Starknet Contracts: What Is the Difference?
69 | 
70 | Starknet contracts are a special superset of Cairo programs, so the concepts previously learned in this book are still applicable to write Starknet contracts.
71 | As you may have already noticed, a Cairo program must always have a `main` function that serves as the entry point for this program:
72 | 
73 | ```cairo
74 | fn main() {}
75 | ```
76 | 
77 | Contracts deployed on the Starknet network are essentially programs that are run by the sequencer, and as such, have access to Starknet's state. Contracts do not have a `main` function but one or multiple functions that can serve as entry points.
78 | 
79 | Starknet contracts are defined within [modules][module chapter]. For a module to be handled as a contract by the compiler, it must be annotated with the `#[starknet::contract]` attribute.
80 | 
81 | [module chapter]: ./ch07-02-defining-modules-to-control-scope.md
82 | 


--------------------------------------------------------------------------------
/src/ch13-02-anatomy-of-a-simple-contract.md:
--------------------------------------------------------------------------------
  1 | # Anatomy of a Simple Contract
  2 | 
  3 | This chapter will introduce you to the basics of Starknet contracts using a very simple smart contract as example. You will learn how to write a contract that allows anyone to store a single number on the Starknet blockchain.
  4 | 
  5 | Let's consider the following contract for the whole chapter. It might not be easy to understand it all at once, but we will go through it step by step:
  6 | 
  7 | ```cairo,noplayground
  8 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/src/lib.cairo:all}}
  9 | ```
 10 | 
 11 | {{#label simple-contract}}
 12 | <span class="caption">Listing {{#ref simple-contract}}: A simple storage contract</span>
 13 | 
 14 | ## What Is this Contract?
 15 | 
 16 | Contracts are defined by encapsulating state and logic within a module annotated with the `#[starknet::contract]` attribute.
 17 | 
 18 | The state is defined within the `Storage` struct, and is always initialized empty. Here, our struct contains a single field called `stored_data` of type `u128` (unsigned integer of 128 bits), indicating that our contract can store any number between 0 and \\( {2^{128}} - 1 \\).
 19 | 
 20 | The logic is defined by functions that interact with the state. Here, our contract defines and publicly exposes the functions `set` and `get` that can be used to modify or retrieve the value of the stored variable.
 21 | You can think of it as a single slot in a database that you can query and modify by calling functions of the code that manages the database.
 22 | 
 23 | ## The Interface: the Contract's Blueprint
 24 | 
 25 | ```cairo,noplayground
 26 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/src/lib.cairo:interface}}
 27 | ```
 28 | 
 29 | {{#label interface}}
 30 | <span class="caption">Listing {{#ref interface}}: A basic contract interface</span>
 31 | 
 32 | Interfaces represent the blueprint of the contract. They define the functions that the contract exposes to the outside world, without including the function body. In Cairo, they're defined by annotating a trait with the `#[starknet::interface]` attribute. All functions of the trait are considered public functions of any contract that implements this trait, and are callable from the outside world.
 33 | 
 34 | > The contract constructor is not part of the interface. Nor are internal functions.
 35 | 
 36 | All contract interfaces use a generic type for the `self` parameter, representing the contract state. We chose to name this generic parameter `TContractState` in our interface, but this is not enforced and any name can be chosen.
 37 | 
 38 | In our interface, note the generic type `TContractState` of the `self` argument which is passed by reference to the `set` function. Seeing the `self` argument passed in a contract function tells us that this function can access the state of the contract. The `ref` modifier implies that `self` may be modified, meaning that the storage variables of the contract may be modified inside the `set` function.
 39 | 
 40 | On the other hand, the `get` function takes a snapshot of `TContractState`, which immediately tells us that it does not modify the state (and indeed, the compiler will complain if we try to modify storage inside the `get` function).
 41 | 
 42 | By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) mechanism from Cairo, we can make sure that the actual implementation of the contract matches its interface. In fact, you will get a compilation error if your contract doesnt conform with the declared interface. For example, Listing {{#ref wrong-impl}} shows a wrong implementation of the `ISimpleStorage` interface, containing a slightly different `set` function that doesn't have the same signature.
 43 | 
 44 | ```cairo,noplayground
 45 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/src/lib.cairo:impl}}
 46 | ```
 47 | 
 48 | {{#label wrong-impl}}
 49 | <span class="caption">Listing {{#ref wrong-impl}}: A wrong implementation of the interface of the contract. This does not compile, as the signature of `set` doesn't match the trait's.</span>
 50 | 
 51 | Trying to compile a contract using this implementation will result in the following error:
 52 | 
 53 | ```shell
 54 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_02_wrong_impl/output.txt}}
 55 | ```
 56 | 
 57 | ## Public Functions Defined in an Implementation Block
 58 | 
 59 | Before we explore things further down, let's define some terminology.
 60 | 
 61 | - In the context of Starknet, a _public function_ is a function that is exposed to the outside world. A public function can be called by anyone, either from outside the contract or from within the contract itself. In the example above, `set` and `get` are public functions.
 62 | 
 63 | - What we call an _external_ function is a public function that can be directly invoked through a Starknet transaction and that can mutate the state of the contract. `set` is an external function.
 64 | 
 65 | - A _view_ function is a public function that is typically read-only and cannot mutate the state of the contract. However, this limitation is only enforced by the compiler, and not by Starknet itself. We will discuss the implications of this in a later section. `get` is a view function.
 66 | 
 67 | ```cairo,noplayground
 68 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/src/lib.cairo:impl}}
 69 | ```
 70 | 
 71 | {{#label implementation}}
 72 | <span class="caption">Listing {{#ref implementation}}: `SimpleStorage` implementation</span>
 73 | 
 74 | Since the contract interface is defined as the `ISimpleStorage` trait, in order to match the interface, the public functions of the contract must be defined in an implementation of this trait  which allows us to make sure that the implementation of the contract matches its interface.
 75 | 
 76 | However, simply defining the functions in the implementation block is not enough. The implementation block must be annotated with the `#[abi(embed_v0)]` attribute. This attribute exposes the functions defined in this implementation to the outside world  forget to add it and your functions will not be callable from the outside. All functions defined in a block marked as `#[abi(embed_v0)]` are consequently _public functions_.
 77 | 
 78 | Because the `SimpleStorage` contract is defined as a module, we need to access the interface defined in the parent module. We can either bring it to the current scope with the `use` keyword, or refer to it directly using `super`.
 79 | 
 80 | When writing the implementation of an interface, the `self` parameter in the trait methods **must** be of type `ContractState`. The `ContractState` type is generated by the compiler, and gives access to the storage variables defined in the `Storage` struct.
 81 | Additionally, `ContractState` gives us the ability to emit events. The name `ContractState` is not surprising, as its a representation of the contracts state, which is what we think of `self` in the contract interface trait.
 82 | When `self` is a snapshot of `ContractState`, only read access is allowed, and emitting events is not possible.
 83 | 
 84 | ## Accessing and Modifying the Contract's State
 85 | 
 86 | Two methods are commonly used to access or modify the state of a contract:
 87 | 
 88 | - `read`, which returns the value of a storage variable. This method is called on the variable itself and does not take any argument.
 89 | 
 90 | ```cairo,noplayground
 91 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/src/lib.cairo:read_state}}
 92 | ```
 93 | 
 94 | - `write`, which allows to write a new value in a storage slot. This method is also called on the variable itself and takes one argument, which is the value to be written. Note that `write` may take more than one argument, depending on the type of the storage variable. For example, writing on a mapping requires 2 arguments: the key and the value to be written.
 95 | 
 96 | ```cairo,noplayground
 97 | {{#include ../listings/ch13-introduction-to-starknet-smart-contracts/listing_01_simple_contract/src/lib.cairo:write_state}}
 98 | ```
 99 | 
100 | > Reminder: if the contract state is passed as a snapshot with `@` instead of passed by reference with `ref`, attempting to modify the contract state will result in a compilation error.
101 | 
102 | This contract does not do much apart from allowing anyone to store a single number that is accessible by anyone in the world. Anyone could call `set` again with a different value and overwrite the current number. Nevertheless, each value stored in the storage of the contract will still be stored in the history of the blockchain. Later in this book, you will see how you can impose access restrictions so that only you can alter the number.
103 | 


--------------------------------------------------------------------------------
/src/ch14-00-building-starknet-smart-contracts.md:
--------------------------------------------------------------------------------
 1 | # Building Starknet Smart Contracts
 2 | 
 3 | In the previous section, we gave an introductory example of a smart contract written in Cairo, describing the basic blocks to build smart contracts on Starknet. In this section, we'll be taking a deeper look at all the components of a smart contract, step by step.
 4 | 
 5 | When we discussed [_interfaces_][contract interface], we specified the difference between the two types of _public functions_, i.e., _external functions_ and _view functions_, and we mentioned how to interact with the _storage_ of a contract.
 6 | 
 7 | At this point, you should have multiple questions that come to mind:
 8 | 
 9 | - How can I store more complex data types?
10 | - How do I define internal/private functions?
11 | - How can I emit events? How can I index them?
12 | - Is there a way to reduce the boilerplate?
13 | 
14 | Luckily, we'll be answering all these questions in this chapter. Let's consider the `NameRegistry` contract in Listing {{#ref reference-contract}} that we'll be using throughout this chapter:
15 | 
16 | ```cairo,noplayground
17 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:all}}
18 | ```
19 | 
20 | {{#label reference-contract}}
21 | <span class="caption">Listing {{#ref reference-contract}}: Our reference contract for this chapter</span>
22 | 
23 | [contract interface]: ./ch13-02-anatomy-of-a-simple-contract.md#the-interface-the-contracts-blueprint
24 | 


--------------------------------------------------------------------------------
/src/ch14-01-00-contract-storage.md:
--------------------------------------------------------------------------------
  1 | # Contract Storage
  2 | 
  3 | The contracts storage is a persistent storage space where you can read, write, modify, and persist data. The storage is a map with
  4 | \\(2^{251}\\) slots, where each slot is a `felt252` initialized to 0.
  5 | 
  6 | Each storage slot is identified by a `felt252` value, called the storage address, which is computed from the variable's name and parameters that depend on the variable's type, outlined in the ["Addresses of Storage Variables"][storage addresses] section.
  7 | 
  8 | [storage addresses]: ./ch14-01-00-contract-storage.md#addresses-of-storage-variables
  9 | 
 10 | We can interact with the contract's storage in two ways:
 11 | 
 12 | 1. Through high-level storage variables, which are declared in a special `Storage` struct annotated with the `#[storage]` attribute.
 13 | 2. Directly accessing storage slots using their computed address and the low-level `storage_read` and `storage_write` syscalls. This is useful when you need to perform custom storage operations that don't fit well with the structured approach of storage variables, but should generally be avoided; as such, we will not cover them in this chapter.
 14 | 
 15 | ## Declaring and Using Storage Variables
 16 | 
 17 | Storage variables in Starknet contracts are stored in a special struct called `Storage`:
 18 | 
 19 | ```cairo, noplayground
 20 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:storage}}
 21 | ```
 22 | 
 23 | The `Storage` struct is a [struct][structs] like any other, except that it **must** be annotated with the `#[storage]` attribute. This annotation tells the compiler to generate the required code to interact with the blockchain state, and allows you to read and write data from and to storage. This struct can contain any type that implements the `Store` trait, including other structs, enums, as well as [Storage Mappings][storage mappings], [Storage Vectors][storage vecs], and [Storage Nodes][storage nodes]. In this section, we'll focus on simple storage variables, and we'll see how to store more complex types in the next sections.
 24 | 
 25 | [storage mappings]: ./ch14-01-01-storage-mappings.md
 26 | [storage vecs]: ./ch14-01-02-storage-vecs.md
 27 | [storage nodes]: ./ch14-01-00-contract-storage.md#storage-nodes
 28 | [structs]: ./ch05-00-using-structs-to-structure-related-data.md
 29 | 
 30 | ### Accessing Storage Variables
 31 | 
 32 | Variables stored in the `Storage` struct can be accessed and modified using the `read` and `write` functions, respectively. All these functions are automatically generated by the compiler for each storage variable.
 33 | 
 34 | To read the value of the `owner` storage variable, which is of type `Person`, we call the `read` function on the `owner` variable, passing in no arguments.
 35 | 
 36 | ```cairo, noplayground
 37 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:read_owner}}
 38 | ```
 39 | 
 40 | To write a new value to the storage slot of a storage variable, we call the `write` function, passing in the value as argument. Here, we only pass in the value to write to the `owner` variable as it is a simple variable.
 41 | 
 42 | ```cairo, noplayground
 43 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:write_owner}}
 44 | ```
 45 | 
 46 | When working with compound types, instead of calling `read` and `write` on the struct variable itself, which would perform a storage operation for each member, you can call `read` and `write` on specific members of the struct. This allows you to access and modify the values of the struct members directly, minimizing the amount of storage operations performed. In the following example, the `owner` variable is of type `Person`. Thus, it has one attribute called `name`, on which we can call the `read` and `write` functions to access and modify its value.
 47 | 
 48 | ```cairo, noplayground
 49 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:read_owner_name}}
 50 | ```
 51 | 
 52 | ## Storing Custom Types with the `Store` Trait
 53 | 
 54 | The `Store` trait, defined in the `starknet::storage_access` module, is used to specify how a type should be stored in storage. In order for a type to be stored in storage, it **must** implement the `Store` trait. Most types from the core library, such as unsigned integers (`u8`, `u128`, `u256`...), `felt252`, `bool`, `ByteArray`, `ContractAddress`, etc. implement the `Store` trait and can thus be stored without further action. However, **memory collections**, such as `Array<T>` and `Felt252Dict<T>`, **cannot** be stored in contract storage - you will have to use the special types `Vec<T>` and `Map<K, V>` instead.
 55 | 
 56 | But what if you wanted to store a type that you defined yourself, such as an enum or a struct? In that case, you have to explicitly tell the compiler how to store this type.
 57 | 
 58 | In our example, we want to store a `Person` struct in storage, which is only possible by implementing the `Store` trait for the `Person` type. This can be simply achieved by adding a `#[derive(starknet::Store)]` attribute on top of our struct definition. Note that all the members of the struct need to implement the `Store` trait for the trait to be derived.
 59 | 
 60 | ```cairo, noplayground
 61 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:person}}
 62 | ```
 63 | 
 64 | Similarly, Enums can only be written to storage if they implement the `Store` trait, which can be trivially derived as long as all associated types implement the `Store` trait.
 65 | 
 66 | Enums used in contract storage **must** define a default variant. This default variant is returned when reading an empty storage slot - otherwise, it will result in a runtime error.
 67 | 
 68 | Here's an example of how to properly define an enum for use in contract storage:
 69 | 
 70 | ```cairo, noplayground
 71 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:enum}}
 72 | ```
 73 | 
 74 | In this example, we've added the `#[default]` attribute to the `Infinite` variant. This tells the Cairo compiler that if we try to read an uninitialized enum from storage, the `Infinite` variant should be returned.
 75 | 
 76 | You might have noticed that we also derived `Drop` and `Serde` on our custom types. Both of them are required for properly serializing arguments passed to entrypoints and deserializing their outputs.
 77 | 
 78 | ## Structs Storage Layout
 79 | 
 80 | On Starknet, structs are stored in storage as a sequence of primitive types.
 81 | The elements of the struct are stored in the same order as they are defined in the struct definition. The first element of the struct is stored at the base address of the struct, which is computed as specified in the ["Addresses of Storage Variables"][storage addresses] section and can be obtained with `var.__base_address__`. Subsequent elements are stored at addresses contiguous to the previous element.
 82 | For example, the storage layout for the `owner` variable of type `Person` will result in the following layout:
 83 | 
 84 | | Fields  | Address                     |
 85 | | ------- | --------------------------- |
 86 | | name    | `owner.__base_address__`    |
 87 | | address | `owner.__base_address__ +1` |
 88 | 
 89 | Note that tuples are similarly stored in contract's storage, with the first element of the tuple being stored at the base address, and subsequent elements stored contiguously.
 90 | 
 91 | ## Enums Storage Layout
 92 | 
 93 | When you store an enum variant, what you're essentially storing is the variant's index and eventual associated values. This index starts at 0 for the first variant of your enum and increments by 1 for each subsequent variant.
 94 | If your variant has an associated value, this value is stored starting from the address immediately following the address of the index of the variant.
 95 | For example, suppose we have the `Expiration` enum with the `Finite` variant that carries an associated limit date, and the `Infinite` variant without associated data. The storage layout for the `Finite` variant would look like this:
 96 | 
 97 | | Element                      | Address                           |
 98 | | ---------------------------- | --------------------------------- |
 99 | | Variant index (0 for Finite) | `expiration.__base_address__`     |
100 | | Associated limit date        | `expiration.__base_address__ + 1` |
101 | 
102 | while the storage layout for the `Infinite` variant would be as follows:
103 | 
104 | | Element                        | Address                       |
105 | | ------------------------------ | ----------------------------- |
106 | | Variant index (1 for Infinite) | `expiration.__base_address__` |
107 | 
108 | <!-- TODO: add example -->
109 | 
110 | ## Storage Nodes
111 | 
112 | A storage node is a special kind of struct that can contain storage-specific types, such as [`Map`][storage mappings], [`Vec`][storage vecs], or other storage nodes, as members. Unlike regular structs, storage nodes can only exist within contract storage and cannot be instantiated or used outside of it.
113 | You can think of storage nodes as intermediate nodes involved in address calculations within the tree representing the contract's storage space. In the next subsection, we will introduce how this concept is modeled in the core library.
114 | 
115 | The main benefits of storage nodes is that they allow you to create more sophisticated storage layouts, including mappings or vectors inside custom types, and allow you to logically group related data, improving code readability and maintainability.
116 | 
117 | Storage nodes are structs defined with the `#[starknet::storage_node]` attribute. In this new contract that implements a voting system, we implement a `ProposalNode` storage node containing a `Map<ContractAddress, bool>` to keep track of the voters of the proposal, along with other fields to store the proposal's metadata.
118 | 
119 | ```cairo, noplayground
120 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:storage_node}}
121 | ```
122 | 
123 | When accessing a storage node, you can't `read` or `write` it directly. Instead, you have to access its individual members. Here's an example from our `VotingSystem` contract that demonstrates how we populate each field of the `ProposalNode` storage node:
124 | 
125 | ```cairo, noplayground
126 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:create_proposal}}
127 | ```
128 | 
129 | Because no voter has voted on this proposal yet, we don't need to populate the `voters` map when creating the proposal. But we could very well access the `voters` map to check if a given address has already voted on this proposal when it tries to cast its vote:
130 | 
131 | ```cairo, noplayground
132 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:vote}}
133 | ```
134 | 
135 | In this example, we access the `ProposalNode` for a specific proposal ID. We then check if the caller has already voted by reading from the `voters` map within the storage node. If they haven't voted yet, we write to the `voters` map to mark that they have now voted.
136 | 
137 | ## Addresses of Storage Variables
138 | 
139 | The address of a storage variable is computed as follows:
140 | 
141 | - If the variable is a single value, the address is the `sn_keccak` hash of the ASCII encoding of the variable's name. `sn_keccak` is Starknet's version of the Keccak256 hash function, whose output is truncated to 250 bits.
142 | 
143 | - If the variable is composed of multiple values (i.e., a tuple, a struct or an enum), we also use the `sn_keccak` hash of the ASCII encoding of the variable's name to determine the base address in storage. Then, depending on the type, the storage layout will differ. See the ["Storing Custom Types"][custom types storage layout] section.
144 | 
145 | - If the variable is part of a [storage node][storage nodes], its address is based on a chain of hashes that reflects the structure of the node. For a storage node member `m` within a storage variable `variable_name`, the path to that member is computed as `h(sn_keccak(variable_name), sn_keccak(m))`, where `h` is the Pedersen hash. This process continues for nested storage nodes, building a chain of hashes that represents the path to a leaf node. Once a leaf node is reached, the storage calculation proceeds as it normally would for that type of variable.
146 | 
147 | - If the variable is a [Map][storage mappings] or a [Vec][storage vecs], the address is computed relative to the storage base address, which is the `sn_keccak` hash of the variable's name, and the keys of the mapping or indexes in the Vec. The exact computation is described in the ["Storage Mappings"][storage mappings] and ["Storage Vecs"][storage vecs] sections.
148 | 
149 | You can access the base address of a storage variable by accessing the `__base_address__` attribute on the variable, which returns a `felt252` value.
150 | 
151 | ```cairo, noplayground
152 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:owner_address}}
153 | ```
154 | 
155 | This address calculation mechanism is performed through a modelisation of the contract storage space using a concept of StoragePointers and StoragePaths that we'll now introduce.
156 | 
157 | [custom types storage layout]: ./ch14-01-00-contract-storage.md#storing-custom-types
158 | 
159 | ## Modeling of the Contract Storage in the Core Library
160 | 
161 | To understand how storage variables are stored in Cairo, it's important to note that they are not stored contiguously but in different locations in the contract's storage. To facilitate the retrieval of these addresses, the core library provides a model of the contract storage through a system of `StoragePointers` and `StoragePaths`.
162 | 
163 | Each storage variable can be converted to a `StoragePointer`. This pointer contains two main fields:
164 | 
165 | - The base address of the storage variable in the contract's storage.
166 | - The offset, relative to the base address, of the specific storage slot being pointed to.
167 | 
168 | An example is worth a thousand words. Let's consider the `Person` struct defined in the previous section:
169 | 
170 | ```cairo, noplayground
171 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:person}}
172 | ```
173 | 
174 | When we write `let x = self.owner;`, we access a variable of type `StorageBase` that represents the base location of the `owner` variable in the contract's storage.
175 | From this base address, we can either get pointers to the struct's fields (like `name` or `address`) or a pointer to the struct itself. On these pointers, we can call `read` and `write`, defined in the `Store` trait, to read and write the values pointed to.
176 | 
177 | Of course, all of this is transparent to the developer. We can read and write to the struct's fields as if we were accessing regular variables, but the compiler translates these accesses into the appropriate `StoragePointer` manipulations under the hood.
178 | 
179 | For storage mappings, the process is similar, except that we introduce an intermediate type, `StoragePath`. A `StoragePath` is a chain of storage nodes and struct fields that form a path to a specific storage slot. For example, to access a value contained in a `Map<ContractAddress, u128>`, the process would be the following:
180 | 
181 | 1. Start at `StorageBase` of the `Map`, and convert it to a `StoragePath`.
182 | 2. Walk the `StoragePath` to reach the desired value using the `entry` method, which, in the case of a `Map`, hashes the current path with the next key to
183 |    generate the next `StoragePath`.
184 | 3. Repeat step 2 until the `StoragePath` points to the desired value, converting the final value to a `StoragePointer`
185 | 4. Read or write the value at that pointer.
186 | 
187 | Note that we need to convert the `ContractAddress` to a `StoragePointer` before being able to read or write to it.
188 | 
189 | ![Modelisation of the Storage Space in the Core Library](mermaid-storage-model.png)
190 | 
191 | <!-- ./mermaid-storage-model.txt -->
192 | 
193 | ## Summary
194 | 
195 | In this chapter, we covered the following key points:
196 | 
197 | - **Storage Variables**: These are used to store persistent data on the blockchain. They are defined in a special `Storage` struct annotated with the `#[storage]` attribute.
198 | - **Accessing Storage Variables**: You can read and write storage variables using automatically generated `read` and `write` functions. For structs, you can access individual members directly.
199 | - **Custom Types with the `Store` Trait**: To store custom types like structs and enums, they must implement the `Store` trait. This can be achieved using the `#[derive(starknet::Store)]` attribute or writing your own implementation.
200 | - **Addresses of Storage Variables**: The address of a storage variable is computed using the `sn_keccak` hash of its name, and additional steps for special types. For complex types, the storage layout is determined by the type's structure.
201 | - **Structs and Enums Storage Layout**: Structs are stored as a sequence of primitive types, while enums store the variant index and potential associated values.
202 | - **Storage Nodes**: Special structs that can contain storage-specific types like `Map` or `Vec`. They allow for more sophisticated storage layouts and can only exist within contract storage.
203 | 
204 | Next, we'll focus on the `Map` and `Vec` types in depth.
205 | 


--------------------------------------------------------------------------------
/src/ch14-01-01-storage-mappings.md:
--------------------------------------------------------------------------------
 1 | # Storing Key-Value Pairs with Mappings
 2 | 
 3 | Storage mappings in Cairo provide a way to associate keys with values and persist them in the contract's storage. Unlike traditional hash tables, storage mappings do not store the key data itself; instead, they use the hash of the key to compute an address that corresponds to the storage slot where the corresponding value is stored. Therefore, it is not possible to iterate over the keys of a storage mapping.
 4 | 
 5 | <div align="center">
 6 |     <img src="mappings.png" alt="mappings" width="500px"/>
 7 | <div align="center">
 8 |     </div>
 9 |     {{#label fig-mappings}}
10 |     <span class="caption">Figure {{#ref fig-mappings}}: Mapping keys to values in storage</span>
11 | </div>
12 | 
13 | Mappings do not have a concept of length or whether a key-value pair is set. All values are by default set to 0. As such, the only way to remove an entry from a mapping is to set its value to the default value for the type, which would be `0` for the `u64` type.
14 | 
15 | The `Map` type, provided by the Cairo core library, inside the `core::starknet::storage` module, is used to declare mappings in contracts.
16 | 
17 | To declare a mapping, use the `Map` type enclosed in angle brackets `<>`, specifying the key and value types. In Listing {{#ref storage-mappings}}, we create a simple contract that stores values mapped to the caller's address.
18 | 
19 | > The `Felt252Dict` type is a **memory** type that cannot be stored in contract storage. For persistent storage of key-value pairs, use the `Map` type, which is a [phantom type][phantom types] designed specifically for contract storage. However, `Map` has limitations: it can't be instantiated as a regular variable, used as a function parameter, or included as a member in regular structs. `Map` can only be used as a storage variable within a contract's storage struct. To work with the contents of a `Map` in memory or perform complex operations, you'll need to copy its elements to and from a `Felt252Dict` or other suitable data structure.
20 | 
21 | ## Declaring and Using Storage Mappings
22 | 
23 | <!-- TODO PHANTOM TYPES -->
24 | <!-- [phantom types]: ./ch11-03-intro-to-phantom-data.html -->
25 | 
26 | ```cairo, noplayground
27 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_02_storage_mapping/src/lib.cairo:contract}}
28 | ```
29 | 
30 | {{#label storage-mappings}}
31 | <span class="caption">Listing {{#ref storage-mappings}}: Declaring a storage mapping in the Storage struct</span>
32 | 
33 | To read the value corresponding to a key in a mapping, you first need to retrieve the storage pointer associated with that key. This is done by calling the `entry` method on the storage mapping variable, passing in the key as a parameter. Once you have the entry path, you can call the `read` function on it to retrieve the stored value.
34 | 
35 | ```cairo, noplayground
36 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_02_storage_mapping/src/lib.cairo:read}}
37 | ```
38 | 
39 | Similarly, to write a value in a storage mapping, you need to retrieve the storage pointer corresponding to the key. Once you have this storage pointer, you can call the `write` function on it with the value to write.
40 | 
41 | ```cairo, noplayground
42 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_02_storage_mapping/src/lib.cairo:write}}
43 | ```
44 | 
45 | ## Nested Mappings
46 | 
47 | You can also create more complex mappings with multiple keys. To illustrate this, we'll implement a contract representing warehouses assigned to users, where each user can store multiple items with their respective quantities.
48 | 
49 | The `user_warehouse` mapping is a storage mapping that maps `ContractAddress` to another mapping that maps `u64` (item ID) to `u64` (quantity). This can be implemented by declaring a `Map<ContractAddress, Map<u64, u64>>` in the storage struct. Each `ContractAddress` key in the `user_warehouse` mapping corresponds to a user's warehouse, and each user's warehouse contains a mapping of item IDs to their respective quantities.
50 | 
51 | ```cairo, noplayground
52 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_nested_storage_mapping/src/lib.cairo:storage}}
53 | ```
54 | 
55 | In this case, the same principle applies for accessing the stored values. You need to traverse the keys step by step, using the `entry` method to get the storage path to the next key in the sequence, and finally calling `read` or `write` on the innermost mapping.
56 | 
57 | ```cairo, noplayground
58 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_nested_storage_mapping/src/lib.cairo:accesses}}
59 | ```
60 | 
61 | ## Storage Address Computation for Mappings
62 | 
63 | The address in storage of a variable stored in a mapping is computed according to the following rules:
64 | 
65 | - For a single key `k`, the address of the value at key `k` is `h(sn_keccak(variable_name), k)`, where `h` is the Pedersen hash and the final value is taken modulo \\( {2^{251}} - 256\\).
66 | - For multiple keys, the address is computed as `h(...h(h(sn_keccak(variable_name), k_1), k_2), ..., k_n)`, with `k_1, ..., k_n` being all keys that constitute the mapping.
67 | 
68 | If the key of a mapping is a struct, each element of the struct constitutes a key. Moreover, the struct should implement the `Hash` trait, which can be derived with the `#[derive(Hash)]` attribute.
69 | 
70 | ## Summary
71 | 
72 | - Storage mappings allow you to map keys to values in contract storage.
73 | - Use the `Map` type to declare mappings.
74 | - Access mappings using the `entry` method and `read`/`write` functions.
75 | - Mappings can contain other mappings, creating nested storage mappings.
76 | - The address of a mapping variable is computed using the `sn_keccak` and the Pedersen hash functions.
77 | 


--------------------------------------------------------------------------------
/src/ch14-01-02-storage-vecs.md:
--------------------------------------------------------------------------------
 1 | # Storing Collections with Vectors
 2 | 
 3 | The `Vec` type provides a way to store collections of values in the contract's storage. In this section, we will explore how to declare, add elements to and retrieve elements from a `Vec`, as well as how the storage addresses for `Vec` variables are computed.
 4 | 
 5 | The `Vec` type is provided by the Cairo core library, inside the `core::starknet::storage` module. Its associated methods are defined in the `VecTrait` and `MutableVecTrait` traits that you will also need to import for read and write operations on the `Vec` type.
 6 | 
 7 | > The `Array<T>` type is a **memory** type and cannot be directly stored in contract storage. For storage, use the `Vec<T>` type, which is a [phantom type][phantom types] designed specifically for contract storage. However, `Vec<T>` has limitations: it can't be instantiated as a regular variable, used as a function parameter, or included as a member in regular structs. To work with the full contents of a `Vec<T>`, you'll need to copy its elements to and from a memory `Array<T>`.
 8 | 
 9 | ## Declaring and Using Storage Vectors
10 | 
11 | To declare a Storage Vector, use the `Vec` type enclosed in angle brackets `<>`, specifying the type of elements it will store. In Listing {{#ref storage-vecs}}, we create a simple contract that registers all the addresses that call it and stores them in a `Vec`. We can then retrieve the `n`-th registered address, or all registered addresses.
12 | 
13 | ```cairo, noplayground
14 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:contract}}
15 | ```
16 | 
17 | {{#label storage-vecs}}
18 | <span class="caption">Listing {{#ref storage-vecs}}: Declaring a storage `Vec` in the Storage struct</span>
19 | 
20 | To add an element to a `Vec`, you use the `append` method to get a storage pointer to the next available slot, and then call the `write` function on it with the value to add.
21 | 
22 | ```cairo, noplayground
23 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:append}}
24 | ```
25 | 
26 | To retrieve an element, you can use the `at` or `get` methods to get a storage pointer to the element at the specified index, and then call the `read` method to get the value. If the index is out of bounds, the `at` method panics, while the `get` method returns `None`.
27 | 
28 | ```cairo, noplayground
29 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:read}}
30 | ```
31 | 
32 | If you want to retrieve all the elements of the Vec, you can iterate over the indices of the storage `Vec`, read the value at each index, and append it to a memory `Array<T>`.
33 | Similarly, you can't store an `Array<T>` in storage: you would need to iterate over the elements of the array and append them to a storage `Vec<T>`.
34 | 
35 | At this point, you should be familiar with the concept of storage pointers and storage paths introduced in the ["Contract Storage"][contract-storage] section and how they are used to access storage variables through a pointer-based model. Thus how would you modify the address stored at a specific index of a `Vec`?
36 | 
37 | ```cairo, noplayground
38 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:modify}}
39 | ```
40 | 
41 | The answer is fairly simple: get a mutable pointer to the storage pointer at the desired index, and use the `write` method to modify the value at that index.
42 | 
43 | [contract-storage]: ./ch14-01-00-contract-storage.md
44 | 
45 | ## Storage Address Computation for Vecs
46 | 
47 | The address in storage of a variable stored in a `Vec` is computed according to the following rules:
48 | 
49 | - The length of the `Vec` is stored at the base address, computed as `sn_keccak(variable_name)`.
50 | - The elements of the `Vec` are stored in addresses computed as `h(base_address, i)`, where `i` is the index of the element in the `Vec` and `h` is the Pedersen hash function.
51 | 
52 | ## Summary
53 | 
54 | - Use the `Vec` type to store collections of values in contract storage
55 | - Access Vecs using the `append` method to add elements, and the `at` or `get` methods to read elements
56 | - The address of a `Vec` variable is computed using the `sn_keccak` and the Pedersen hash functions
57 | 
58 | This wraps up our tour of the Contract Storage! In the next section, we'll start looking at the different kind of functions defined in a contract. You already know most of them, as we used them in the previous chapters, but we'll explain them in more detail.
59 | 


--------------------------------------------------------------------------------
/src/ch14-02-contract-functions.md:
--------------------------------------------------------------------------------
  1 | # Contract Functions
  2 | 
  3 | In this section, we are going to be looking at the different types of functions you could encounter in Starknet smart contracts.
  4 | 
  5 | Functions can access the contract's state easily via `self: ContractState`, which abstracts away the complexity of underlying system calls (`storage_read_syscall` and `storage_write_syscall`). The compiler provides two modifiers: `ref` and `@` to decorate `self`, which intends to distinguish view and external functions.
  6 | 
  7 | ## 1. Constructors
  8 | 
  9 | Constructors are a special type of function that only runs once when deploying a contract, and can be used to initialize the state of a contract.
 10 | 
 11 | ```cairo,noplayground
 12 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:constructor}}
 13 | ```
 14 | 
 15 | Some important rules to note:
 16 | 
 17 | 1. A contract can't have more than one constructor.
 18 | 2. The constructor function must be named `constructor`, and must be annotated with the `#[constructor]` attribute.
 19 | 
 20 | The `constructor` function might take arguments, which are passed when deploying the contract. In our example, we pass some value corresponding to a `Person` type as argument in order to store the `owner` information (address and name) in the contract.
 21 | 
 22 | Note that the `constructor` function **must** take `self` as a first argument, corresponding to the state of the contract, generally passed by reference with the `ref` keyword to be able to modify the contract's state. We will explain `self` and its type shortly.
 23 | 
 24 | ## 2. Public Functions
 25 | 
 26 | As stated previously, public functions are accessible from outside of the contract. They are usually defined inside an implementation block annotated with the `#[abi(embed_v0)]` attribute, but might also be defined independently under the `#[external(v0)]` attribute.
 27 | 
 28 | The `#[abi(embed_v0)]` attribute means that all functions embedded inside it are implementations of the Starknet interface of the contract, and therefore potential entry points.
 29 | 
 30 | Annotating an impl block with the `#[abi(embed_v0)]` attribute only affects the visibility (i.e., public vs private/internal) of the functions it contains, but it doesn't inform us on the ability of these functions to modify the state of the contract.
 31 | 
 32 | ```cairo,noplayground
 33 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:impl_public}}
 34 | ```
 35 | 
 36 | > Similarly to the `constructor` function, all public functions, either standalone functions annotated with the `#[external(v0)]` or functions within an impl block annotated with the `#[abi(embed_v0)]` attribute, **must** take `self` as a first argument. This is not the case for private functions.
 37 | 
 38 | ### External Functions
 39 | 
 40 | External functions are _public_ functions where the `self: ContractState` argument is passed by reference with the `ref` keyword, which exposes both the `read` and `write` access to storage variables. This allows modifying the state of the contract via `self` directly.
 41 | 
 42 | ```cairo,noplayground
 43 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:external}}
 44 | ```
 45 | 
 46 | ### View Functions
 47 | 
 48 | View functions are _public_ functions where the `self: ContractState` argument is passed as snapshot, which only allows the `read` access to storage variables, and restricts writes to storage made via `self` by causing compilation errors. The compiler will mark their _state_mutability_ to `view`, preventing any state modification through `self` directly.
 49 | 
 50 | ```cairo,noplayground
 51 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:view}}
 52 | ```
 53 | 
 54 | ### State Mutability of Public Functions
 55 | 
 56 | However, as you may have noticed, passing `self` as a snapshot only restricts the storage write access via `self` at compile time. It does not prevent state modification via direct system calls, nor calling another contract that would modify the state.
 57 | 
 58 | The read-only property of view functions is not enforced on Starknet, and sending a transaction targeting a view function _could_ change the state.
 59 | 
 60 | <!-- TODO: add an example of a view function that could modify the state using low-level syscalls -->
 61 | 
 62 | In conclusion, even though external and view functions are distinguished by the Cairo compiler, **all public functions** can be called through an invoke transaction and can potentially modify the Starknet state. Moreover, all public functions can be called with the `starknet_call` RPC method, which will not create a transaction and hence will not change the state.
 63 | 
 64 | > **Warning:** This is different from the EVM where a `staticcall` opcode is provided, which prevents storage modifications in the current context and subcontexts. Hence developers **should not** have the assumption that calling a view function on another contract cannot modify the state.
 65 | 
 66 | ### Standalone Public Functions
 67 | 
 68 | It is also possible to define public functions outside of an implementation of a trait, using the `#[external(v0)]` attribute. Doing this will automatically generate an entry in the contract ABI, allowing these standalone public functions to be callable by anyone from outside. These functions can also be called from within the contract just like any function in Starknet contracts. The first parameter must be `self`.
 69 | 
 70 | Here, we define a standalone `get_contract_name` function outside of an impl block:
 71 | 
 72 | ```cairo,noplayground
 73 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:standalone}}
 74 | ```
 75 | 
 76 | ## 3. Private Functions
 77 | 
 78 | Functions that are not defined with the `#[external(v0)]` attribute or inside a block annotated with the `#[abi(embed_v0)]` attribute are private functions (also called internal functions). They can only be called from within the contract.
 79 | 
 80 | They can be grouped in a dedicated impl block (e.g., in components, to easily import internal functions all at once in the embedding contracts) or just be added as free functions inside the contract module.
 81 | Note that these 2 methods are equivalent. Just choose the one that makes your code more readable and easy to use.
 82 | 
 83 | ```cairo,noplayground
 84 | {{#include ../listings/ch14-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:state_internal}}
 85 | ```
 86 | 
 87 | > Wait, what is this `#[generate_trait]` attribute? Where is the trait definition for this implementation? Well, the `#[generate_trait]` attribute is a special attribute that tells the compiler to generate a trait definition for the implementation block. This allows you to get rid of the boilerplate code of defining a trait with generic parameters and implementing it for the implementation block. With this attribute, we can simply define the implementation block directly, without any generic parameter, and use `self: ContractState` in our functions.
 88 | 
 89 | The `#[generate_trait]` attribute is mostly used to define private impl blocks. It might also be used in addition to `#[abi(per_item)]` to define the various entrypoints of a contract (see [next section][abi per item section]).
 90 | 
 91 | > Note: using `#[generate_trait]` in addition to the `#[abi(embed_v0)]` attribute for a public impl block is not recommended, as it will result in a failure to generate the corresponding ABI. Public functions should only be defined in an impl block annotated with `#[generate_trait]` if this block is also annotated with the `#[abi(per_item)]` attribute.
 92 | 
 93 | [abi per item section]: ./ch14-02-contract-functions.md#4-abiper_item-attribute
 94 | 
 95 | ## `[abi(per_item)]` Attribute
 96 | 
 97 | You can also define the entrypoint type of functions individually inside an impl block using the`#[abi(per_item)]` attribute on top of your impl. It is often used with the `#[generate_trait]` attribute, as it allows you to define entrypoints without an explicit interface. In this case, the functions will not be grouped under an impl in the ABI. Note that when using `#[abi(per_item)]` attribute, public functions need to be annotated with the `#[external(v0)]` attribute - otherwise, they will not be exposed and will be considered as private functions.
 98 | 
 99 | Here is a short example:
100 | 
101 | ```cairo,noplayground
102 | {{#include ../listings/ch14-building-starknet-smart-contracts/no_listing_01_abi_per_item_attribute/src/lib.cairo}}
103 | ```
104 | 
105 | In the case of `#[abi(per_item)]` attribute usage without `#[generate_trait]`, it will only be possible to include `constructor`, `l1-handler` and `internal` functions in the trait implementation. Indeed, `#[abi(per_item)]` only works with a trait that is not defined as a Starknet interface. Hence, it will be mandatory to create another trait defined as interface to implement public functions.
106 | 


--------------------------------------------------------------------------------
/src/ch14-03-contract-events.md:
--------------------------------------------------------------------------------
  1 | # Contract Events
  2 | 
  3 | Events are a way for smart contracts to inform the outside world of any changes that occur during their execution. They play a critical role in the integration of smart contracts into real-world applications.
  4 | 
  5 | Technically speaking, an event is a custom data structure emitted by a smart contract during its execution and stored in the corresponding transaction receipt, allowing any external tool to parse and index it.
  6 | 
  7 | ## Defining Events
  8 | 
  9 | The events of a smart contract are defined in an enum annotated with the attribute `#[event]`. This enum must be named `Event`.
 10 | 
 11 | ```cairo,noplayground
 12 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:event}}
 13 | ```
 14 | 
 15 | Each variant, like `BookAdded` or `FieldUpdated` represents an event that can be emitted by the contract. The variant data represents the data associated to an event. It can be any `struct` or `enum` that implements the `starknet::Event` trait.
 16 | This can be simply achieved by adding a `#[derive(starknet::Event)]` attribute on top of your type definition.
 17 | 
 18 | Each event data field can be annotated with the attribute `#[key]`. Key fields are then stored separately than data fields to be used by external tools to easily filter events on these keys.
 19 | 
 20 | Let's look at the full event definition of this example to add, update and remove books:
 21 | 
 22 | ```cairo,noplayground
 23 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:full_events}}
 24 | ```
 25 | 
 26 | In this example:
 27 | 
 28 | - There are 3 events: `BookAdded`, `FieldUpdated` and `BookRemoved`,
 29 | - `BookAdded` and `BookRemoved` events use a simple `struct` to store their data while the `FieldUpdated` event uses an `enum` of structs,
 30 | - In the `BookAdded` event, the `author` field is a key field and will be used outside of the smart contract to filter `BookAdded` events by `author`, while `id` and `title` are data fields.
 31 | 
 32 | > The **variant** and its associated data structure can be named differently, although it's common practice to use the same name. The **variant name** is used internally as the **first event key** to represent the name of the event and to help filter events, while the **variant data name** is used in the smart contract to **build the event** before it is emitted.
 33 | 
 34 | ### The #[flat] attribute
 35 | 
 36 | Sometimes you may have a complex event structure with some nested enums like the `FieldUpdated` event in the previous example. In this case, you can flatten this structure using the `#[flat]` attribute, which means that the inner variant name is used as the event name instead of the variant name of the annotated enum.
 37 | In the previous example, because the `FieldUpdated` variant is annotated with `#[flat]`, when you emit a `FieldUpdated::Title` event, its name will be `Title` instead of `FieldUpdated`.
 38 | If you have more than 2 nested enums, you can use the `#[flat]` attribute on multiple levels.
 39 | 
 40 | ## Emitting Events
 41 | 
 42 | Once you have defined your list of events, you want to emit them in your smart contracts. This can be simply achieved by calling `self.emit()` with an event data structure in parameter.
 43 | 
 44 | ```cairo,noplayground
 45 | {{#rustdoc_include ../listings/ch14-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:emit_event}}
 46 | ```
 47 | 
 48 | To have a better understanding of what happens under the hood, let's see two examples of emitted events and how they are stored in the transaction receipt:
 49 | 
 50 | ### Example 1: Add a book
 51 | 
 52 | In this example, we send a transaction invoking the `add_book` function with `id` = 42, `title` = 'Misery' and `author` = 'S. King'.
 53 | 
 54 | If you read the "events" section of the transaction receipt, you will get something like:
 55 | 
 56 | ```json
 57 | "events": [
 58 |     {
 59 |       "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",
 60 |       "keys": [
 61 |         "0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc",
 62 |         "0x532e204b696e67"
 63 |       ],
 64 |       "data": [
 65 |         "0x2a",
 66 |         "0x4d6973657279"
 67 |       ]
 68 |     }
 69 |   ]
 70 | ```
 71 | 
 72 | In this receipt:
 73 | 
 74 | - `from_address` is the address of your smart contract,
 75 | - `keys` contains the key fields of the emitted `BookAdded` event, serialized in an array of `felt252`.
 76 |   - The first key `0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc` is the selector of the event name, which is the variant name in the `Event` enum, so `selector!("BookAdded")`,
 77 |   - The second key `0x532e204b696e67 = 'S. King'` is the `author` field of your event as it has been defined using the `#[key]` attribute,
 78 | - `data` contains the data fields of the emitted `BookAdded` event, serialized in an array of `felt252`. The first item `0x2a = 42` is the `id` data field and `0x4d6973657279 = 'Misery'` is the `title` data field.
 79 | 
 80 | ### Example 2: Update a book author
 81 | 
 82 | Now we want to change the author name of the book, so we send a transaction invoking `change_book_author` with `id` = `42` and `new_author` = 'Stephen King'.
 83 | 
 84 | This `change_book_author` call emits a `FieldUpdated` event with the event data `FieldUpdated::Author(UpdatedAuthorData { id: 42, title: author: 'Stephen King' })`. If you read the "events" section of the transaction receipt, you will get something like:
 85 | 
 86 | ```json
 87 | "events": [
 88 |     {
 89 |       "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",
 90 |       "keys": [
 91 |         "0x1b90a4a3fc9e1658a4afcd28ad839182217a69668000c6104560d6db882b0e1",
 92 |         "0x2a"
 93 |       ],
 94 |       "data": [
 95 |         "0x5374657068656e204b696e67"
 96 |       ]
 97 |     }
 98 |   ]
 99 | ```
100 | 
101 | As the `FieldUpdated` variant in `Event` enum has been annotated with the `#[flat]` attribute, this is the inner variant `Author` that is used as event name, instead of `FieldUpdated`. So:
102 | 
103 | - the first key is `selector!("Author")`,
104 | - the second key is the `id` field, annotated with `#[key]`,
105 | - the data field is `0x5374657068656e204b696e67 = 'Stephen King'`.
106 | 


--------------------------------------------------------------------------------
/src/ch15-00-starknet-contract-interactions.md:
--------------------------------------------------------------------------------
1 | # Interacting with Starknet Contracts
2 | 
3 | A smart contract cannot execute itself without an external trigger. It needs to be called by an external entity, such as a user or another smart contract. The possibility for smart contracts to interact with each other enables the creation of sophisticated applications, where the scope of each contract is restricted to a specific functionality.
4 | 
5 | This chapter sheds light on how to interact with smart contracts and make them interact with each other. Specifically, you'll learn what the _Application Binary Interface (ABI)_ is, how to call a smart contract, and how to make contracts communicate with each other. You will also learn how to properly use classes as _libraries_, and when to use them.
6 | 


--------------------------------------------------------------------------------
/src/ch15-01-contract-class-abi.md:
--------------------------------------------------------------------------------
 1 | # Contract Class ABI
 2 | 
 3 | The Contract Class _Application Binary Interface (ABI)_ is the high-level specification of the interface of a contract. It describes the functions that can be called, their expected parameters and return values, along with the types of these parameters and return values. It allows external sources, both from outside the blockchain and other contracts, to communicate with the contract, by encoding and decoding data according to the contract's interface.
 4 | 
 5 | Sources outside the blockchain typically use a JSON representation of the ABI to interact with the contract. This JSON representation is generated from the contract class, and contains an array of items that are either types, functions, or events.
 6 | 
 7 | Contracts, on the other hand, use the ABI of another contract directly in Cairo through the _dispatcher_ pattern, which is a specific type that implements methods to call the functions of another contract. These methods are auto-generated, and contain the entire logic required to encode and decode the data to be sent to the contract.
 8 | 
 9 | When you interact with a smart contract using a block explorer like [Voyager][voyager] or [Starkscan][starkscan], the JSON ABI is used to properly encode the data you send to the contract and decode the data it returns.
10 | 
11 | [voyager]: https://voyager.online/
12 | [starkscan]: https://starkscan.co/
13 | 
14 | ## Entrypoints
15 | 
16 | All the functions exposed in the ABI of a contract are called _entrypoints_. An entrypoint is a function that can be called from outside the contract class.
17 | 
18 | There are 3 different types of entrypoints in a Starknet contract:
19 | 
20 | - [Public functions][public function], the most common entrypoints, exposed either as `view` or `external` depending on their state mutability.
21 | 
22 | > Note: An entrypoint can be marked as `view`, but might still modify the contract's state when invoked along with a transaction, if the contract uses low-level calls whose immutability is not enforced by the compiler.
23 | 
24 | - An optional unique [_constructor_][constructor], which is a specific entrypoint that will be called only once during the deployment of the contract.
25 | 
26 | - L1-Handlers, functions that can only be triggered by the sequencer after receiving a [message][L1-L2 messaging] from the L1 network whose payload contains an instruction to call a contract.
27 | 
28 | [public function]: ./ch14-02-contract-functions.md#2-public-functions
29 | [constructor]: ./ch14-02-contract-functions.md#1-constructors
30 | [L1-L2 messaging]: ./ch16-04-L1-L2-messaging.md
31 | 
32 | A function entrypoint is represented by a _selector_ and a `function_idx` in a Cairo contract class.
33 | 
34 | ## Function Selector
35 | 
36 | While functions are defined with a name, entrypoints are identified by their _selector_. The selector is a unique identifier derived from the function name, and is simply computed as `sn_keccak(function_name)`. As overloading a function with different parameters is not possible in Cairo, the hash of the function name is sufficient to uniquely identify the function to be called.
37 | 
38 | While this process is often abstracted by libraries and when using dispatchers, know that it's possible to call a function directly by providing its selector, for example when using a low-level system call like `starknet::call_contract_syscall` or when interacting with an RPC.
39 | 
40 | ## Encoding
41 | 
42 | Smart contracts are written in a high-level language like Cairo, using strong types to inform us about the data manipulated. However, the code executed on the blockchain is compiled into a sequence of low-level CASM instructions. The base data type in Starknet is `felt252`, and that's the only data manipulated at the CASM level. As such, all data must be serialized into `felt252` before being sent to the contract. The ABI specifies how types can be encoded into a sequence of `felt252`, and decoded back into their original form.
43 | 


--------------------------------------------------------------------------------
/src/ch15-02-interacting-with-another-contract.md:
--------------------------------------------------------------------------------
 1 | # Interacting with Another Contract
 2 | 
 3 | In the previous section, we introduced the dispatcher pattern for contract interactions. This chapter will explore this pattern in depth and demonstrate how to use it.
 4 | 
 5 | The dispatcher pattern allows us to call functions on another contract by using a struct that wraps the contract address and implements the dispatcher trait generated by the compiler from the contract class ABI. This leverages Cairo's trait system to provide a clean and type-safe way to interact with other contracts.
 6 | 
 7 | When a [contract interface][interfaces] is defined, the compiler automatically generates and exports multiple dispatchers. For instance, for an `IERC20` interface, the compiler will generate the following dispatchers:
 8 | 
 9 | - _Contract Dispatchers_: `IERC20Dispatcher` and `IERC20SafeDispatcher`
10 | - _Library Dispatchers_: `IERC20LibraryDispatcher` and `IERC20SafeLibraryDispatcher`
11 | 
12 | These dispatchers serve different purposes:
13 | 
14 | - Contract dispatchers wrap a contract address and are used to call functions on other contracts.
15 | - Library dispatchers wrap a class hash and are used to call functions on classes. Library dispatchers will be discussed in the next chapter, ["Executing code from another class"][library dispatcher].
16 | - _'Safe'_ dispatchers allow the caller to handle potential errors during the execution of the call.
17 | 
18 | > Note: As of Starknet 0.13.2, error handling in contract calls is not yet available. This means that if a contract call fails, the entire transaction will fail. This will change in the future, allowing safe dispatchers to be used on Starknet.
19 | 
20 | Under the hood, these dispatchers use the low-level [`contract_call_syscall`][syscalls], which allows us to call functions on other contracts by passing the contract address, the function selector, and the function arguments. The dispatcher abstracts away the complexity of this syscall, providing a clean and type-safe way to interact with other contracts.
21 | 
22 | To effectively break down the concepts involved, we will use the `ERC20` interface as an illustration.
23 | 
24 | [interfaces]: ./ch13-02-anatomy-of-a-simple-contract.md#the-interface-the-contracts-blueprint
25 | [syscalls]: ./appendix-08-system-calls.md
26 | [library dispatcher]: ./ch15-03-executing-code-from-another-class.md
27 | 
28 | ## The Dispatcher Pattern
29 | 
30 | We mentioned that the compiler would automatically generate the dispatcher struct and the dispatcher trait for a given interface. Listing {{#ref expanded-ierc20dispatcher}} shows an example of the generated items for an `IERC20` interface that exposes a `name` view function and a `transfer` external function:
31 | 
32 | ```cairo,noplayground
33 | {{#include ../listings/ch15-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/src/lib.cairo}}
34 | ```
35 | 
36 | {{#label expanded-ierc20dispatcher}}
37 | <span class="caption">Listing {{#ref expanded-ierc20dispatcher}}: A simplified example of the `IERC20Dispatcher` and its associated trait and impl</span>
38 | 
39 | As you can see, the contract dispatcher is a simple struct that wraps a contract address and implements the `IERC20DispatcherTrait` generated by the compiler. For each function, the implementation of the trait will contain the following elements:
40 | 
41 | - A serialization of the function arguments into a `felt252` array, `__calldata__`.
42 | - A low-level contract call using `contract_call_syscall` with the contract address, the function selector, and the `__calldata__` array.
43 | - A deserialization of the returned value into the expected return type.
44 | 
45 | ## Calling Contracts Using the Contract Dispatcher
46 | 
47 | To illustrate the use of the contract dispatcher, let's create a simple contract that interacts with an ERC20 contract. This wrapper contract will allow us to call the `name` and `transfer_from` functions on the ERC20 contract, as shown in Listing {{#ref contract-dispatcher}}:
48 | 
49 | ```cairo,noplayground
50 | {{#rustdoc_include ../listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:here}}
51 | ```
52 | 
53 | {{#label contract-dispatcher}}
54 | <span class="caption">Listing {{#ref contract-dispatcher}}: A sample contract which uses the dispatcher pattern to call another contract</span>
55 | 
56 | In this contract, we import the `IERC20Dispatcher` struct and the `IERC20DispatcherTrait` trait. We then wrap the address of the ERC20 contract in an instance of the `IERC20Dispatcher` struct. This allows us to call the `name` and `transfer` functions on the ERC20 contract.
57 | 
58 | Calling `transfer_token` external function will modify the state of the contract deployed at `contract_address`.
59 | 
60 | ## Calling Contracts using Low-Level Calls
61 | 
62 | Another way to call other contracts is to directly use the `call_contract_syscall`. While less convenient than using the dispatcher pattern, this syscall provides more control over the serialization and deserialization process and allows for more customized error handling.
63 | 
64 | Listing {{#ref syscalls}} shows an example demonstrating how to call the `transfer_from` function of an `ERC20` contract with a low-level `call_contract_sycall` syscall:
65 | 
66 | ```cairo,noplayground
67 | {{#include ../listings/ch15-starknet-cross-contract-interactions/listing_06_syscalls/src/lib.cairo}}
68 | ```
69 | 
70 | {{#label syscalls}}
71 | <span class="caption">Listing {{#ref syscalls}}: A sample contract using `call_contract_sycall` syscall</span>
72 | 
73 | To use this syscall, we passed in the contract address, the selector of the function we want to call and the call arguments.
74 | The call arguments must be provided as an array of arguments, serialized to a `Span<felt252>`. To serialize the arguments, we can simply use the `Serde` trait, provided that the types being serialized implement this trait. The call returns an array of serialized values, which we'll need to deserialize ourselves!
75 | 


--------------------------------------------------------------------------------
/src/ch15-03-executing-code-from-another-class.md:
--------------------------------------------------------------------------------
 1 | # Executing Code from Another Class
 2 | 
 3 | In previous chapters, we explored how to call external _contracts_ to execute their logic and update their state. But what if we want to execute code from another class without updating the state of another contract? Starknet makes this possible with _library calls_, which allow a contract to execute the logic of another class in its own context, updating its own state.
 4 | 
 5 | ## Library calls
 6 | 
 7 | The key differences between _contract calls_ and _library calls_ lie in the execution context of the logic defined in the class. While contract calls are used to call functions from deployed **contracts**, library calls are used to call stateless **classes** in the context of the caller.
 8 | 
 9 | To illustrate this, let's consider two contracts _A_ and _B_.
10 | 
11 | When A performs a _contract call_ to the **contract** B, the execution context of the logic defined in B is that of B. As such, the value returned by `get_caller_address()` in B will return the address of A, `get_contract_address()` in B will return the address of B, and any storage updates in B will update the storage of B.
12 | 
13 | However, when A uses a _library call_ to call the **class** of B, the execution context of the logic defined in B is that of A. This means that the value returned by `get_caller_address()` in B will be the address of the caller of A, `get_contract_address()` in B's class will return the address of A, and updating a storage variable in B's class will update the storage of A.
14 | 
15 | Library calls can be performed using the dispatcher pattern presented in the previous chapter, only with a class hash instead of a contract address.
16 | 
17 | Listing {{#ref expanded-ierc20-library}} describes the library dispatcher and its associated `IERC20DispatcherTrait` trait and impl using the same `IERC20` example:
18 | 
19 | ```cairo,noplayground
20 | {{#include ../listings/ch15-starknet-cross-contract-interactions/listing_04_expanded_ierc20_library/src/lib.cairo}}
21 | ```
22 | 
23 | {{#label expanded-ierc20-library}}
24 | <span class="caption">Listing {{#ref expanded-ierc20-library}}: A simplified example of the `IERC20DLibraryDispatcher` and its associated trait and impl</span>
25 | 
26 | One notable difference with the contract dispatcher is that the library dispatcher uses `library_call_syscall` instead of `call_contract_syscall`. Otherwise, the process is similar.
27 | 
28 | Let's see how to use library calls to execute the logic of another class in the context of the current contract.
29 | 
30 | ## Using the Library Dispatcher
31 | 
32 | Listing {{#ref library-dispatcher}} defines two contracts: `ValueStoreLogic`, which defines the logic of our example, and `ValueStoreExecutor`, which simply executes the logic of `ValueStoreLogic`'s class.
33 | 
34 | We first need to import the `IValueStoreDispatcherTrait` and `IValueStoreLibraryDispatcher` which were generated from our interface by the compiler. Then, we can create an instance of `IValueStoreLibraryDispatcher`, passing in the `class_hash` of the class we want to make library calls to. From there, we can call the functions defined in that class, executing its logic in the context of our contract.
35 | 
36 | ```cairo,noplayground
37 | {{#include ../listings/ch15-starknet-cross-contract-interactions/listing_05_library_dispatcher/src/lib.cairo}}
38 | ```
39 | 
40 | {{#label library-dispatcher}}
41 | <span class="caption">Listing {{#ref library-dispatcher}}: An example contract using a Library Dispatcher</span>
42 | 
43 | When we call the `set_value` function on `ValueStoreExecutor`, it will make a library call to the `set_value` function defined in `ValueStoreLogic`. Because we are using a library call, `ValueStoreExecutor`'s storage variable `value` will be updated. Similarly, when we call the `get_value` function, it will make a library call to the `get_value` function defined in `ValueStoreLogic`, returning the value of the storage variable `value` - still in the context of `ValueStoreExecutor`.
44 | 
45 | As such, both `get_value` and `get_value_local` return the same value, as they are reading the same storage slot.
46 | 
47 | ## Calling Classes using Low-Level Calls
48 | 
49 | Another way to call classes is to directly use `library_call_syscall`. While less convenient than using the dispatcher pattern, this syscall provides more control over the serialization and deserialization process and allows for more customized error handling.
50 | 
51 | Listing {{#ref library_syscall}} shows an example demonstrating how to use a `library_call_syscall` to call the `set_value` function of `ValueStore` contract:
52 | 
53 | ```cairo,noplayground
54 | {{#include ../listings/ch15-starknet-cross-contract-interactions/listing_07_library_syscall/src/lib.cairo}}
55 | ```
56 | 
57 | {{#label library_syscall}}
58 | <span class="caption">Listing {{#ref library_syscall}}: A sample contract using `library_call_syscall` system call</span>
59 | 
60 | To use this syscall, we passed in the class hash, the selector of the function we want to call and the call arguments.
61 | The call arguments must be provided as an array of arguments, serialized to a `Span<felt252>`. To serialize the arguments, we can simply use the `Serde` trait, provided that the types being serialized implement this trait. The call returns an array of serialized values, which we'll need to deserialize ourselves!
62 | 
63 | ## Summary
64 | 
65 | Congratulations for finishing this chapter! You have learned a lot of new concepts:
66 | 
67 | - How _Contracts_ differ from _Classes_ and how the ABI describes them for external sources
68 | - How to call functions from other contracts and classes using the _Dispatcher_ pattern
69 | - How to use _Library calls_ to execute the logic of another class in the context of the caller
70 | - The two syscalls that Starknet provides to interact with contracts and classes
71 | 
72 | You now have all the required tools to develop complex applications with logic spread across multiple contracts and classes. In the next chapter, we will explore more advanced topics that will help you unleash the full potential of Starknet.
73 | 


--------------------------------------------------------------------------------
/src/ch16-00-building-advanced-starknet-smart-contracts.md:
--------------------------------------------------------------------------------
1 | # Building Advanced Starknet Smart Contracts
2 | 


--------------------------------------------------------------------------------
/src/ch16-01-optimizing-storage-costs.md:
--------------------------------------------------------------------------------
  1 | # Optimizing Storage Costs
  2 | 
  3 | Bit-packing is a simple concept: use as few bits as possible to store a piece of data. When done well, it can significantly reduce the size of the data you need to store. This is especially important in smart contracts, where storage is expensive.
  4 | 
  5 | When writing Cairo smart contracts, it is important to optimize storage usage to reduce gas costs. Indeed, most of the cost associated with a transaction is related to storage updates; and each storage slot costs gas to write to.
  6 | This means that by packing multiple values into fewer slots, you can decrease the gas cost incurred by the users of your smart contract.
  7 | 
  8 | ## Integer Structure and Bitwise Operators
  9 | 
 10 | An integer is coded on a certain number of bits, depending on its size (For example, a `u8` integer is coded on 8 bits).
 11 | 
 12 | <div align="center">
 13 |     <img src="integer_in_bits.png" alt="a u8 integer in bits" width="500px"/>
 14 | <div align="center">
 15 | </div>
 16 |     <span class="caption">Representation of a u8 integer in bits</span>
 17 | </div>
 18 | 
 19 | Intuitively, several integers can be combined into a single integer if the size of this single integer is greater than or equal to the sum of the sizes of the integers (For example, two `u8` and one `u16` in one `u32`).
 20 | 
 21 | But, to do that, we need some bitwise operators:
 22 | 
 23 | - multiplying or dividing an integer by a power of 2 shifts the integer value to the left or to the right respectively
 24 | 
 25 | <div align="center">
 26 |     <img src="shift.png" alt="shift operators" width="500px"/>
 27 | <div align="center">
 28 | </div>
 29 |     <span class="caption">Shifting to the left or to the right an integer value</span>
 30 | </div>
 31 | 
 32 | - applying a mask (`AND` operator) on an integer value isolates some bits of this integer
 33 | 
 34 | <div align="center">
 35 |     <img src="mask.png" alt="applying a mask" width="500px"/>
 36 | <div align="center">
 37 | </div>
 38 |     <span class="caption">Isolate bits with a mask</span>
 39 | </div>
 40 | 
 41 | - adding (`OR` operator) two integers will combine both values into a single one.
 42 | 
 43 | <div align="center">
 44 |     <img src="combine.png" alt="combining two values" width="500px"/>
 45 | <div align="center">
 46 | </div>
 47 |     <span class="caption">Combining two integers</span>
 48 | </div>
 49 | 
 50 | With these bitwise operators, let's see how to combine two `u8` integers into a single `u16` integer (called `packing`) and reversely (called `unpacking`) in the following example:
 51 | 
 52 | <div align="center">
 53 |     <img src="pack.png" alt="packing and unpacking integer values" width="500px"/>
 54 | <div align="center">
 55 | </div>
 56 |     <span class="caption">Packing and unpacking integer values</span>
 57 | </div>
 58 | 
 59 | ## Bit-packing in Cairo
 60 | 
 61 | The storage of a Starknet smart contract is a map with 2<sup>251</sup> slots, where each slot is a `felt252` which is initialized to 0.
 62 | 
 63 | As we saw earlier, to reduce gas costs due to storage updates, we have to use as few bits as possible, so we have to organize stored variables by packing them.
 64 | 
 65 | For example, consider the following `Sizes` struct with 3 fields of different types: one `u8`, one `u32` and one `u64`. The total size is 8 + 32 + 64 = 104 bits. This is less than a slot size (i.e 251 bits) so we can pack them together to be stored into a single slot.
 66 | 
 67 | Note that, as it also fits in a `u128`, it's a good practice to use the smallest type to pack all your variables, so here a `u128` should be used.
 68 | 
 69 | ```cairo,noplayground
 70 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_01_storage_packing/src/lib.cairo:struct}}
 71 | ```
 72 | 
 73 | To pack these 3 variables into a `u128` we have to successively shift them to the left, and finally sum them.
 74 | 
 75 | <div align="center">
 76 |     <img src="sizes-packing.png" alt="Sizes packing" width="800px"/>
 77 | <div align="center">
 78 | </div>
 79 |     <span class="caption">Sizes packing</span>
 80 | </div>
 81 | 
 82 | To unpack these 3 variables from a `u128` we have to successively shift them to the right and use a mask to isolate them.
 83 | 
 84 | <div align="center">
 85 |     <img src="sizes-unpacking.png" alt="Sizes unpacking" width="800px"/>
 86 | <div align="center">
 87 | </div>
 88 |     <span class="caption">Sizes unpacking</span>
 89 | </div>
 90 | 
 91 | ## The `StorePacking` Trait
 92 | 
 93 | Cairo provides the `StorePacking` trait to enable packing struct fields into fewer storage slots. `StorePacking<T, PackedT>` is a generic trait taking the type you want to pack (`T`) and the destination type (`PackedT`) as parameters. It provides two functions to implement: `pack` and `unpack`.
 94 | 
 95 | Here is the implementation of the example of the previous chapter:
 96 | 
 97 | ```cairo,noplayground
 98 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_01_storage_packing/src/lib.cairo:here}}
 99 | ```
100 | 
101 | <div align="center">
102 |     <span class="caption">Optimizing storage by implementing the `StorePacking` trait.</span>
103 | </div>
104 | 
105 | In this code snippet, you see that:
106 | 
107 | - `TWO_POW_8` and `TWO_POW_40` are used to shift left in the `pack` function and shift right in the `unpack`function,
108 | - `MASK_8` and `MASK_32` are used to isolate a variable in the `unpack` function,
109 | - all the variables from the storage are converted to `u128` to be able to use bitwise operators.
110 | 
111 | This technique can be used for any group of fields that fit within the bit size of the packed storage type. For example, if you have a struct with multiple fields whose bit sizes add up to 256 bits, you can pack them into a single `u256` variable. If the bit sizes add up to 512 bits, you can pack them into a single `u512` variable, and so on. You can define your own structs and logic to pack and unpack them.
112 | 
113 | The rest of the work is done magically by the compiler - if a type implements the `StorePacking` trait, then the compiler will know it can use the `StoreUsingPacking` implementation of the `Store` trait in order to pack before writing and unpack after reading from storage.
114 | One important detail, however, is that the type that `StorePacking::pack` spits out also has to implement `Store` for `StoreUsingPacking` to work. Most of the time, we will want to pack into a felt252 or u256 - but if you want to pack into a type of your own, make sure that this one implements the `Store` trait.
115 | 


--------------------------------------------------------------------------------
/src/ch16-02-00-composability-and-components.md:
--------------------------------------------------------------------------------
  1 | # Components: Lego-Like Building Blocks for Smart Contracts
  2 | 
  3 | Developing contracts sharing a common logic and storage can be painful and
  4 | bug-prone, as this logic can hardly be reused and needs to be reimplemented in
  5 | each contract. But what if there was a way to snap in just the extra
  6 | functionality you need inside your contract, separating the core logic of your
  7 | contract from the rest?
  8 | 
  9 | Components provide exactly that. They are modular add-ons encapsulating reusable
 10 | logic, storage, and events that can be incorporated into multiple contracts.
 11 | They can be used to extend a contract's functionality, without having to
 12 | reimplement the same logic over and over again.
 13 | 
 14 | Think of components as Lego blocks. They allow you to enrich your contracts by
 15 | plugging in a module that you or someone else wrote. This module can be a simple
 16 | one, like an ownership component, or more complex like a full-fledged ERC20
 17 | token.
 18 | 
 19 | A component is a separate module that can contain storage, events, and
 20 | functions. Unlike a contract, a component cannot be declared or deployed. Its
 21 | logic will eventually be part of the contracts bytecode it has been embedded
 22 | in.
 23 | 
 24 | ## What's in a Component?
 25 | 
 26 | A component is very similar to a contract. It can contain:
 27 | 
 28 | - Storage variables
 29 | - Events
 30 | - External and internal functions
 31 | 
 32 | Unlike a contract, a component cannot be deployed on its own. The component's
 33 | code becomes part of the contract it's embedded to.
 34 | 
 35 | ## Creating Components
 36 | 
 37 | To create a component, first define it in its own module decorated with a
 38 | `#[starknet::component]` attribute. Within this module, you can declare a `
 39 | Storage` struct and `Event` enum, as usually done in [contracts][contract anatomy].
 40 | 
 41 | The next step is to define the component interface, containing the signatures of
 42 | the functions that will allow external access to the component's logic. You can
 43 | define the interface of the component by declaring a trait with the
 44 | `#[starknet::interface]` attribute, just as you would with contracts. This
 45 | interface will be used to enable external access to the component's functions
 46 | using the [dispatcher][contract dispatcher] pattern.
 47 | 
 48 | The actual implementation of the component's external logic is done in an `impl`
 49 | block marked as `#[embeddable_as(name)]`. Usually, this `impl` block will be an
 50 | implementation of the trait defining the interface of the component.
 51 | 
 52 | > Note: `name` is the name that well be using in the contract to refer to the
 53 | > component. It is different than the name of your impl.
 54 | 
 55 | You can also define internal functions that will not be accessible externally,
 56 | by simply omitting the `#[embeddable_as(name)]` attribute above the internal
 57 | `impl` block. You will be able to use these internal functions inside the
 58 | contract you embed the component in, but not interact with it from outside, as
 59 | they're not a part of the abi of the contract.
 60 | 
 61 | Functions within these `impl` block expect arguments like `ref self:
 62 | ComponentState<TContractState>` (for state-modifying functions) or `self:
 63 | @ComponentState<TContractState>` (for view functions). This makes the impl
 64 | generic over `TContractState`, allowing us to use this component in any
 65 | contract.
 66 | 
 67 | [contract anatomy]: ./ch13-02-anatomy-of-a-simple-contract.md
 68 | [contract dispatcher]: ./ch15-02-interacting-with-another-contract.md
 69 | 
 70 | ### Example: an Ownable Component
 71 | 
 72 | >  The example shown below has not been audited and is not intended for
 73 | > production use. The authors are not responsible for any damages caused by the
 74 | > use of this code.
 75 | 
 76 | The interface of the Ownable component, defining the methods available
 77 | externally to manage ownership of a contract, would look like this:
 78 | 
 79 | ```cairo,noplayground
 80 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:interface}}
 81 | ```
 82 | 
 83 | The component itself is defined as:
 84 | 
 85 | ```cairo,noplayground
 86 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:component}}
 87 | ```
 88 | 
 89 | This syntax is actually quite similar to the syntax used for contracts. The only
 90 | differences relate to the `#[embeddable_as]` attribute above the impl and the
 91 | genericity of the impl block that we will dissect in details.
 92 | 
 93 | As you can see, our component has two `impl` blocks: one corresponding to the
 94 | implementation of the interface trait, and one containing methods that should
 95 | not be exposed externally and are only meant for internal use. Exposing the
 96 | `assert_only_owner` as part of the interface wouldn't make sense, as it's only
 97 | meant to be used internally by a contract embedding the component.
 98 | 
 99 | ## A Closer Look at the `impl` Block
100 | 
101 | ```cairo,noplayground
102 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:impl_signature}}
103 | ```
104 | 
105 | The `#[embeddable_as]` attribute is used to mark the impl as embeddable inside a
106 | contract. It allows us to specify the name of the impl that will be used in the
107 | contract to refer to this component. In this case, the component will be
108 | referred to as `Ownable` in contracts embedding it.
109 | 
110 | The implementation itself is generic over `ComponentState<TContractState>`, with
111 | the added restriction that `TContractState` must implement the `HasComponent<T>`
112 | trait. This allows us to use the component in any contract, as long as the
113 | contract implements the `HasComponent` trait. Understanding this mechanism in
114 | details is not required to use components, but if you're curious about the inner
115 | workings, you can read more in the ["Components Under the Hood"][components inner working] section.
116 | 
117 | One of the major differences from a regular smart contract is that access to
118 | storage and events is done via the generic `ComponentState<TContractState>` type
119 | and not `ContractState`. Note that while the type is different, accessing
120 | storage or emitting events is done similarly via `self.storage_var_name.read()`
121 | or `self.emit(...).`
122 | 
123 | > Note: To avoid the confusion between the embeddable name and the impl name, we
124 | > recommend keeping the suffix `Impl` in the impl name.
125 | 
126 | [components inner working]: ./ch16-02-01-under-the-hood.md
127 | 
128 | ## Migrating a Contract to a Component
129 | 
130 | Since both contracts and components share a lot of similarities, it's actually
131 | very easy to migrate from a contract to a component. The only changes required
132 | are:
133 | 
134 | - Adding the `#[starknet::component]` attribute to the module.
135 | - Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will be
136 |   embedded in another contract.
137 | - Adding generic parameters to the `impl` block:
138 |   - Adding `TContractState` as a generic parameter.
139 |   - Adding `+HasComponent<TContractState>` as an impl restriction.
140 | - Changing the type of the `self` argument in the functions inside the `impl`
141 |   block to `ComponentState<TContractState>` instead of `ContractState`.
142 | 
143 | For traits that do not have an explicit definition and are generated using
144 | `#[generate_trait]`, the logic is the same - but the trait is generic over
145 | `TContractState` instead of `ComponentState<TContractState>`, as demonstrated in
146 | the example with the `InternalTrait`.
147 | 
148 | ## Using Components Inside a Contract
149 | 
150 | The major strength of components is how it allows reusing already built
151 | primitives inside your contracts with a restricted amount of boilerplate. To
152 | integrate a component into your contract, you need to:
153 | 
154 | 1. Declare it with the `component!()` macro, specifying
155 | 
156 |    1. The path to the component `path::to::component`.
157 |    2. The name of the variable in your contract's storage referring to this
158 |       component's storage (e.g. `ownable`).
159 |    3. The name of the variant in your contract's event enum referring to this
160 |       component's events (e.g. `OwnableEvent`).
161 | 
162 | 2. Add the path to the component's storage and events to the contract's
163 |    `Storage` and `Event`. They must match the names provided in step 1 (e.g.
164 |    `ownable: ownable_component::Storage` and `OwnableEvent:
165 | ownable_component::Event`).
166 | 
167 |    The storage variable **MUST** be annotated with the `#[substorage(v0)]`
168 |    attribute.
169 | 
170 | 3. Embed the component's logic defined inside your contract, by instantiating
171 |    the component's generic impl with a concrete `ContractState` using an impl
172 |    alias. This alias must be annotated with `#[abi(embed_v0)]` to externally
173 |    expose the component's functions.
174 | 
175 |    As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`.
176 |    Indeed, we don't want to expose externally the functions defined in this
177 |    impl. However, we might still want to access them internally.
178 | 
179 | For example, to embed the `Ownable` component defined above, we would do the
180 | following:
181 | 
182 | ```cairo,noplayground
183 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/contract.cairo:all}}
184 | ```
185 | 
186 | The component's logic is now seamlessly part of the contract! We can interact
187 | with the components functions externally by calling them using the
188 | `IOwnableDispatcher` instantiated with the contract's address.
189 | 
190 | ```cairo
191 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:interface}}
192 | ```
193 | 
194 | ## Stacking Components for Maximum Composability
195 | 
196 | The composability of components really shines when combining multiple of them
197 | together. Each adds its features onto the contract. You can rely on
198 | [Openzeppelin's][OpenZeppelin Cairo Contracts] implementation
199 | of components to quickly plug-in all the common functionalities you need a contract
200 | to have.
201 | 
202 | Developers can focus on their core contract logic while relying on battle-tested
203 | and audited components for everything else.
204 | 
205 | Components can even [depend][component dependencies] on other components by restricting the
206 | `TContractstate` they're generic on to implement the trait of another component.
207 | Before we dive into this mechanism, let's first look at [how components work under the hood][components inner working].
208 | 
209 | [OpenZeppelin Cairo Contracts]: https://github.com/OpenZeppelin/cairo-contracts
210 | [component dependencies]: ./ch16-02-02-component-dependencies.md
211 | [components inner working]: ./ch16-02-01-under-the-hood.md
212 | 


--------------------------------------------------------------------------------
/src/ch16-02-01-under-the-hood.md:
--------------------------------------------------------------------------------
  1 | # Components: Under the Hood
  2 | 
  3 | Components provide powerful modularity to Starknet contracts. But how does this
  4 | magic actually happen behind the scenes?
  5 | 
  6 | This chapter will dive deep into the compiler internals to explain the
  7 | mechanisms that enable component composability.
  8 | 
  9 | ## A Primer on Embeddable Impls
 10 | 
 11 | Before digging into components, we need to understand _embeddable impls_.
 12 | 
 13 | An impl of a Starknet interface trait (marked with `#[starknet::interface]`) can
 14 | be made embeddable. Embeddable impls can be injected into any contract, adding
 15 | new entry points and modifying the ABI of the contract.
 16 | 
 17 | Let's look at an example to see this in action:
 18 | 
 19 | ```cairo,noplayground
 20 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/no_listing_01_embeddable/src/lib.cairo}}
 21 | ```
 22 | 
 23 | By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI.
 24 | 
 25 | Now that were more familiar with the embedding mechanism, we can now see how
 26 | components build on this.
 27 | 
 28 | ## Inside Components: Generic Impls
 29 | 
 30 | Recall the impl block syntax used in components:
 31 | 
 32 | ```cairo,noplayground
 33 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:impl_signature}}
 34 | ```
 35 | 
 36 | The key points:
 37 | 
 38 | - `OwnableImpl` requires the implementation of the
 39 |   `HasComponent<TContractState>` trait by the underlying contract, which is
 40 |   automatically generated with the `component!()` macro when using a component
 41 |   inside a contract.
 42 | 
 43 |   The compiler will generate an impl that wraps any function in `OwnableImpl`,
 44 |   replacing the `self: ComponentState<TContractState>` argument with `self:
 45 | TContractState`, where access to the component state is made via the
 46 |   `get_component` function in the `HasComponent<TContractState>` trait.
 47 | 
 48 |   For each component, the compiler generates a `HasComponent` trait. This trait
 49 |   defines the interface to bridge between the actual `TContractState` of a
 50 |   generic contract, and `ComponentState<TContractState>`.
 51 | 
 52 |   ```cairo,noplayground
 53 |   // generated per component
 54 |   trait HasComponent<TContractState> {
 55 |       fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
 56 |       fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
 57 |       fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
 58 |       fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
 59 |       fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
 60 |   }
 61 |   ```
 62 | 
 63 |   In our context `ComponentState<TContractState>` is a type specific to the
 64 |   ownable component, i.e. it has members based on the storage variables defined
 65 |   in `ownable_component::Storage`. Moving from the generic `TContractState` to
 66 |   `ComponentState<TContractState>` will allow us to embed `Ownable` in any
 67 |   contract that wants to use it. The opposite direction
 68 |   (`ComponentState<TContractState>` to `ContractState`) is useful for
 69 |   dependencies (see the `Upgradeable` component depending on an `IOwnable`
 70 |   implementation example in the [Components dependencies ](./ch16-02-02-component-dependencies.md) section).
 71 | 
 72 |   To put it briefly, one should think of an implementation of the above
 73 |   `HasComponent<T>` as saying: **Contract whose state T has the upgradeable
 74 |   component.**
 75 | 
 76 | - `Ownable` is annotated with the `embeddable_as(<name>)` attribute:
 77 | 
 78 |   `embeddable_as` is similar to `embeddable`; it only applies to impls of
 79 |   `starknet::interface` traits and allows embedding this impl in a contract
 80 |   module. That said, `embeddable_as(<name>)` has another role in the context of
 81 |   components. Eventually, when embedding `OwnableImpl` in some contract, we
 82 |   expect to get an impl with the following functions:
 83 | 
 84 |   ```cairo,noplayground
 85 |   {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:trait_def}}
 86 |   ```
 87 | 
 88 |   Note that while starting with a function receiving the generic type
 89 |   `ComponentState<TContractState>`, we want to end up with a function receiving
 90 |   `ContractState`. This is where `embeddable_as(<name>)` comes in. To see the
 91 |   full picture, we need to see what is the impl generated by the compiler due to
 92 |   the `embeddable_as(Ownable)` annotation:
 93 | 
 94 | ```cairo,noplayground
 95 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/no_listing_02_embeddable_as_output/src/lib.cairo}}
 96 | ```
 97 | 
 98 | Note that thanks to having an impl of `HasComponent<TContractState>`, the
 99 | compiler was able to wrap our functions in a new impl that doesnt directly
100 | know about the `ComponentState` type. `Ownable`, whose name we chose when
101 | writing `embeddable_as(Ownable)`, is the impl that we will embed in a contract
102 | that wants ownership.
103 | 
104 | ## Contract Integration
105 | 
106 | We've seen how generic impls enable component reusability. Next let's see how a
107 | contract integrates a component.
108 | 
109 | The contract uses an **impl alias** to instantiate the component's generic impl
110 | with the concrete `ContractState` of the contract.
111 | 
112 | ```cairo,noplayground
113 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/contract.cairo:embedded_impl}}
114 | ```
115 | 
116 | The above lines use the Cairo impl embedding mechanism alongside the impl alias
117 | syntax. Were instantiating the generic `OwnableImpl<TContractState>` with the
118 | concrete type `ContractState`. Recall that `OwnableImpl<TContractState>` has the
119 | `HasComponent<TContractState>` generic impl parameter. An implementation of this
120 | trait is generated by the `component!` macro.
121 | 
122 | Note that only the using contract
123 | could have implemented this trait since only it knows about both the contract
124 | state and the component state.
125 | 
126 | This glues everything together to inject the component logic into the contract.
127 | 
128 | ## Key Takeaways
129 | 
130 | - Embeddable impls allow injecting components logic into contracts by adding
131 |   entry points and modifying the contract ABI.
132 | - The compiler automatically generates a `HasComponent` trait implementation
133 |   when a component is used in a contract. This creates a bridge between the
134 |   contract's state and the component's state, enabling interaction between the
135 |   two.
136 | - Components encapsulate reusable logic in a generic, contract-agnostic way.
137 |   Contracts integrate components through impl aliases and access them via the
138 |   generated `HasComponent` trait.
139 | - Components build on embeddable impls by defining generic component logic that
140 |   can be integrated into any contract wanting to use that component. Impl
141 |   aliases instantiate these generic impls with the contract's concrete storage
142 |   types.
143 | 


--------------------------------------------------------------------------------
/src/ch16-02-02-component-dependencies.md:
--------------------------------------------------------------------------------
 1 | # Component Dependencies
 2 | 
 3 | Working with components becomes more complex when we try to use one component inside another. As mentioned earlier, a component can only be embedded within a contract, meaning that it's not possible to embed a component within another component. However, this doesn't mean that we can't use one component inside another. In this section, we will see how to use a component as a dependency of another component.
 4 | 
 5 | Consider a component called `OwnableCounter` whose purpose is to create a counter that can only be incremented by its owner. This component can be embedded in any contract, so that any contract that uses it will have a counter that can only be incremented by its owner.
 6 | 
 7 | The first way to implement this is to create a single component that contains both counter and ownership features from within a single component. However, this approach is not recommended: our goal is to minimize the amount of code duplication and take advantage of component reusability. Instead, we can create a new component that _depends_ on the `Ownable` component for the ownership features, and internally defines the logic for the counter.
 8 | 
 9 | Listing {{#ref ownable_component}} shows the complete implementation, which we'll break down right after:
10 | 
11 | ```cairo,noplayground
12 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:full}}
13 | ```
14 | 
15 | {{#label ownable_component}}
16 | <span class="caption">Listing {{#ref ownable_component}}: An OwnableCounter Component</span>
17 | 
18 | ## Specificities
19 | 
20 | ### Specifying Dependencies on Another Component
21 | 
22 | ```cairo,noplayground
23 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:component_signature}}
24 | ```
25 | 
26 | In [chapter 8][cairo traits], we introduced trait bounds, which are used to specify that a generic type must implement a certain trait. In the same way, we can specify that a component depends on another component by restricting the `impl` block to be available only for contracts that contain the required component.
27 | In our case, this is done by adding a restriction `impl Owner: ownable_component::HasComponent<TContractState>`, which indicates that this `impl` block is only available for contracts that contain an implementation of the `ownable_component::HasComponent` trait. This essentially means that the `TContractState' type has access to the ownable component. See [Components under the hood][component impl] for more information.
28 | 
29 | Although most of the trait bounds were defined using [anonymous parameters][anonymous generic impl operator], the dependency on the `Ownable` component is defined using a named parameter (here, `Owner`). We will need to use this explicit name when accessing the `Ownable`component within the`impl` block.
30 | 
31 | While this mechanism is verbose and may not be easy to approach at first, it is a powerful leverage of the trait system in Cairo. The inner workings of this mechanism are abstracted away from the user, and all you need to know is that when you embed a component in a contract, all other components in the same contract can access it.
32 | 
33 | [cairo traits]: ./ch08-02-traits-in-cairo.md
34 | [component impl]: ch16-02-01-under-the-hood.md#inside-components-generic-impls
35 | 
36 | [anonymous generic impl operator]: ./ch08-01-generic-data-types md#anonymous-generic-implementation-parameter--operator
37 | 
38 | ### Using the Dependency
39 | 
40 | Now that we have made our `impl` depend on the `Ownable` component, we can access its functions, storage, and events within the implementation block. To bring the `Ownable` component into scope, we have two choices, depending on whether we intend to mutate the state of the `Ownable` component or not.
41 | If we want to access the state of the `Ownable` component without mutating it, we use the `get_dep_component!` macro. If we want to mutate the state of the `Ownable` component (for example, change the current owner), we use the `get_dep_component_mut!` macro.
42 | Both macros take two arguments: the first is `self`, either as a snapshot or by reference depending on mutability, representing the state of the component using the dependency, and the second is the component to access.
43 | 
44 | ```cairo,noplayground
45 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:increment}}
46 | ```
47 | 
48 | In this function, we want to make sure that only the owner can call the `increment` function. We need to use
49 | the `assert_only_owner` function from the `Ownable` component. We'll use the `get_dep_component!` macro which will return a snapshot of the requested component state, and call `assert_only_owner` on it, as a method of that component.
50 | 
51 | For the `transfer_ownership` function, we want to mutate that state to change the current owner. We need to use the `get_dep_component_mut!` macro, which will return the requested component state as a mutable reference, and call `transfer_ownership` on it.
52 | 
53 | ```cairo,noplayground
54 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:transfer_ownership}}
55 | ```
56 | 
57 | It works exactly the same as `get_dep_component!` except that we need to pass the state as a `ref` so we can
58 | mutate it to transfer the ownership.
59 | 


--------------------------------------------------------------------------------
/src/ch16-02-03-testing-components.md:
--------------------------------------------------------------------------------
 1 | # Testing Components
 2 | 
 3 | Testing components is a bit different than testing contracts.
 4 | Contracts need to be tested against a specific state, which can be achieved by either deploying the contract in a test, or by simply getting the `ContractState` object and modifying it in the context of your tests.
 5 | 
 6 | Components are a generic construct, meant to be integrated in contracts, that can't be deployed on their own and don't have a `ContractState` object that we could use. So how do we test them?
 7 | 
 8 | Let's consider that we want to test a very simple component called "Counter", that will allow each contract to have a counter that can be incremented. The component is defined in Listing {{#ref test_component}}:
 9 | 
10 | ```cairo, noplayground
11 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/counter.cairo:component}}
12 | ```
13 | 
14 | {{#label test_component}}
15 | <span class="caption">Listing {{#ref test_component}}: A simple Counter component</span>
16 | 
17 | ## Testing the Component by Deploying a Mock Contract
18 | 
19 | The easiest way to test a component is to integrate it within a mock contract. This mock contract is only used for testing purposes, and only integrates the component you want to test. This allows you to test the component in the context of a contract, and to use a Dispatcher to call the component's entry points.
20 | 
21 | We can define such a mock contract as follows:
22 | 
23 | ```cairo, noplayground
24 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/lib.cairo:mock_contract}}
25 | ```
26 | 
27 | This contract is entirely dedicated to testing the `Counter` component. It embeds the component with the `component!` macro, exposes the component's entry points by annotating the impl aliases with `#[abi(embed_v0)]`.
28 | 
29 | We also need to define an interface that will be required to interact externally with this mock contract.
30 | 
31 | ```cairo, noplayground
32 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/counter.cairo:interface}}
33 | ```
34 | 
35 | We can now write tests for the component by deploying this mock contract and calling its entry points, as we would with a typical contract.
36 | 
37 | ```cairo, noplayground
38 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_deployed.cairo}}
39 | ```
40 | 
41 | ## Testing Components Without Deploying a Contract
42 | 
43 | In [Components under the hood][components inner working], we saw that components leveraged genericity to define storage and logic that could be embedded in multiple contracts. If a contract embeds a component, a `HasComponent` trait is created in this contract, and the component methods are made available.
44 | 
45 | This informs us that if we can provide a concrete `TContractState` that implements the `HasComponent` trait to the `ComponentState` struct, should be able to directly invoke the methods of the component using this concrete `ComponentState` object, without having to deploy a mock.
46 | 
47 | Let's see how we can do that by using type aliases. We still need to define a mock contract - let's use the same as above - but this time, we won't need to deploy it.
48 | 
49 | First, we need to define a concrete implementation of the generic `ComponentState` type using a type alias. We will use the `MockContract::ContractState` type to do so.
50 | 
51 | ```cairo, noplayground
52 | {{#rustdoc_include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_direct.cairo:type_alias}}
53 | ```
54 | 
55 | We defined the `TestingState` type as an alias of the `CounterComponent::ComponentState<MockContract::ContractState>` type. By passing the `MockContract::ContractState` type as a concrete type for `ComponentState`, we aliased a concrete implementation of the `ComponentState` struct to `TestingState`.
56 | 
57 | Because `MockContract` embeds `CounterComponent`, the methods of `CounterComponent` defined in the `CounterImpl` block can now be used on a `TestingState` object.
58 | 
59 | Now that we have made these methods available, we need to instantiate an object of type `TestingState`, that we will use to test the component. We can do so by calling the `component_state_for_testing` function, which automatically infers that it should return an object of type `TestingState`.
60 | 
61 | We can even implement this as part of the `Default` trait, which allows us to return an empty `TestingState` with the `Default::default()` syntax.
62 | 
63 | Let's summarize what we've done so far:
64 | 
65 | - We defined a mock contract that embeds the component we want to test.
66 | - We defined a concrete implementation of `ComponentState<TContractState>` using a type alias with `MockContract::ContractState`, that we named `TestingState`.
67 | - We defined a function that uses `component_state_for_testing` to return a `TestingState` object.
68 | 
69 | We can now write tests for the component by calling its functions directly, without having to deploy a mock contract. This approach is more lightweight than the previous one, and it allows testing internal functions of the component that are not exposed to the outside world trivially.
70 | 
71 | ```cairo, noplayground
72 | {{#rustdoc_include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_direct.cairo:test}}
73 | ```
74 | 
75 | [components inner working]: ./ch16-02-01-under-the-hood.md
76 | 


--------------------------------------------------------------------------------
/src/ch16-03-upgradeability.md:
--------------------------------------------------------------------------------
 1 | # Upgradeable Contracts
 2 | 
 3 | Starknet separates contracts into classes and instances, making it simple to upgrade a contract's logic without affecting its state.
 4 | 
 5 | A contract class is the definition of the semantics of a contract. It includes the entire logic of a contract: the name of the entry points, the addresses of the storage variables, the events that can be emitted, etc. Each class is uniquely identified by its class hash. A class does not have its own storage: it's only a definition of logic.
 6 | 
 7 | Classes are typically identified by a [class hash][class hash doc]. When declaring a class, the network registers it and assigns a unique hash used to identify the class and deploy contract instances from it.
 8 | 
 9 | A contract instance is a deployed contract corresponding to a class, with its own storage.
10 | 
11 | Starknet natively supports upgradeable contracts through the `replace_class_syscall` [system call][syscalls doc], enabling simple contract upgrades without affecting the contract's state.
12 | 
13 | [class hash doc]: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash
14 | [syscalls doc]: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/
15 | 
16 | ## Upgrading Contracts
17 | 
18 | To upgrade a contract, expose an entry point that executes `replace_class_syscall` with the new class hash as an argument:
19 | 
20 | ```cairo,noplayground
21 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_06_upgrade_with_syscall/src/lib.cairo}}
22 | ```
23 | 
24 | {{#label replace-class}}
25 | <span class="caption">Listing {{#ref replace-class}}: Exposing `replace_class_syscall` to update the contract's class</span>
26 | 
27 | > Note: Thoroughly review changes and potential impacts before upgrading, as it's a delicate procedure with security implications. Don't allow arbitrary addresses to upgrade your contract.
28 | 
29 | ## Upgradeable Component
30 | 
31 | OpenZeppelin Contracts for Cairo provides the `Upgradeable` component that can be embedded into your contract to make it upgradeable. This component is a simple way to add upgradeability to your contract while relying on an audited library. It can be combined with the `Ownable` component to restrict the upgradeability to a single address, so that the contract owner has the exclusive right to upgrade the contract.
32 | 
33 | ```cairo,noplayground
34 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_07_oz_upgrade/src/lib.cairo}}
35 | ```
36 | 
37 | {{#label upgradeable-contract}}
38 | <span class="caption">Listing {{#ref upgradeable-contract}} Integrating OpenZeppelin's Upgradeable component in a contract</span>
39 | 
40 | For more information, please refer to the [OpenZeppelin docs API reference][oz upgradeability api].
41 | 
42 | [oz upgradeability api]: https://docs.openzeppelin.com/contracts-cairo/0.19.0/api/upgrades
43 | 


--------------------------------------------------------------------------------
/src/ch16-04-L1-L2-messaging.md:
--------------------------------------------------------------------------------
  1 | # L1-L2 Messaging
  2 | 
  3 | A crucial feature of a Layer 2 is its ability to interact with Layer 1.
  4 | 
  5 | Starknet has its own `L1-L2` messaging system, which is different from its consensus mechanism and the submission of state updates on L1. Messaging is a way for smart-contracts on L1 to interact with smart-contracts on L2 (or the other way around), allowing us to do "cross-chain" transactions. For example, we can do some computations on one chain and use the result of this computation on the other chain.
  6 | 
  7 | Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to bridge tokens from Ethereum to Starknet. You will simply have to deposit your tokens into the L1 bridge contract, which will automatically trigger the minting of the same token on L2. Another good use case for `L1-L2` messaging would be [DeFi pooling][defi pooling doc].
  8 | 
  9 | On Starknet, it's important to note that the messaging system is **asynchronous** and **asymmetric**.
 10 | 
 11 | - **Asynchronous**: this means that in your contract code (being Solidity or Cairo), you can't await the result of the message being sent on the other chain within your contract code execution.
 12 | - **Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is fully automated by the Starknet sequencer, which means that the message is being automatically delivered to the target contract on L2. However, when sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the message is sent to L1 by the Starknet sequencer. You must then consume the message manually via a transaction on L1.
 13 | 
 14 | Let's dive into the details.
 15 | 
 16 | [defi pooling doc]: https://starkware.co/resource/defi-pooling/
 17 | 
 18 | ## The StarknetMessaging Contract
 19 | 
 20 | The crucial component of the `L1-L2` Messaging system is the [`StarknetCore`][starknetcore etherscan] contract. It is a set of Solidity contracts deployed on Ethereum that allows Starknet to function properly. One of the contracts of `StarknetCore` is called `StarknetMessaging` and it is the contract responsible for passing messages between Starknet and Ethereum. `StarknetMessaging` follows an [interface][IStarknetMessaging] with functions allowing to send messages to L2, receiving messages on L1 from L2 and canceling messages.
 21 | 
 22 | ```js
 23 | interface IStarknetMessaging is IStarknetMessagingEvents {
 24 | 
 25 |     function sendMessageToL2(
 26 |         uint256 toAddress,
 27 |         uint256 selector,
 28 |         uint256[] calldata payload
 29 |     ) external returns (bytes32);
 30 | 
 31 |     function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)
 32 |         external
 33 |         returns (bytes32);
 34 | 
 35 |     function startL1ToL2MessageCancellation(
 36 |         uint256 toAddress,
 37 |         uint256 selector,
 38 |         uint256[] calldata payload,
 39 |         uint256 nonce
 40 |     ) external;
 41 | 
 42 |     function cancelL1ToL2Message(
 43 |         uint256 toAddress,
 44 |         uint256 selector,
 45 |         uint256[] calldata payload,
 46 |         uint256 nonce
 47 |     ) external;
 48 | }
 49 | ```
 50 | 
 51 | <span class="caption"> Starknet messaging contract interface</span>
 52 | 
 53 | In the case of `L1->L2` messages, the Starknet sequencer is constantly listening to the logs emitted by the `StarknetMessaging` contract on Ethereum.
 54 | Once a message is detected in a log, the sequencer prepares and executes an `L1HandlerTransaction` to call the function on the target L2 contract. This takes up to 1-2 minutes to be done (few seconds for ethereum block to be mined, and then the sequencer must build and execute the transaction).
 55 | 
 56 | `L2->L1` messages are prepared by contract's execution on L2 and are part of the block produced. When the sequencer produces a block, it sends the hash of each message prepared by the contract's execution
 57 | to the `StarknetCore` contract on L1, where they can then be consumed once the block they belong to is proven and verified on Ethereum (which for now is around 3-4 hours).
 58 | 
 59 | [starknetcore etherscan]: https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4
 60 | [IStarknetMessaging]: https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6
 61 | 
 62 | ## Sending Messages from Ethereum to Starknet
 63 | 
 64 | If you want to send messages from Ethereum to Starknet, your Solidity contracts must call the `sendMessageToL2` function of the `StarknetMessaging` contract. To receive these messages on Starknet, you will need to annotate functions that can be called from L1 with the `#[l1_handler]` attribute.
 65 | 
 66 | Let's take a simple contract taken from [this tutorial][messaging contract] where we want to send a message to Starknet.
 67 | The `_snMessaging` is a state variable already initialized with the address of the `StarknetMessaging` contract. You can check all Starknet contract and sequencer addresses [here][starknet addresses].
 68 | 
 69 | ```js
 70 | // Sends a message on Starknet with a single felt.
 71 | function sendMessageFelt(
 72 |     uint256 contractAddress,
 73 |     uint256 selector,
 74 |     uint256 myFelt
 75 | )
 76 |     external
 77 |     payable
 78 | {
 79 |     // We "serialize" here the felt into a payload, which is an array of uint256.
 80 |     uint256[] memory payload = new uint256[](1);
 81 |     payload[0] = myFelt;
 82 | 
 83 |     // msg.value must always be >= 20_000 wei.
 84 |     _snMessaging.sendMessageToL2{value: msg.value}(
 85 |         contractAddress,
 86 |         selector,
 87 |         payload
 88 |     );
 89 | }
 90 | ```
 91 | 
 92 | The function sends a message with a single felt value to the `StarknetMessaging` contract.
 93 | Be aware that your Cairo contract will only understand `felt252` data type, so if you want to send more complex data, you must ensure that the data serialization into the `uint256` array follows the Cairo serialization scheme.
 94 | 
 95 | It's important to note that we have `{value: msg.value}`. In fact, the minimum value we have to send here is `20k wei`, due to the fact that the `StarknetMessaging` contract will register
 96 | the hash of our message in the storage of Ethereum.
 97 | 
 98 | In addition to those `20k wei`, since the `L1HandlerTransaction` executed by the sequencer is not tied to any account (the message originates from L1), you must also ensure
 99 | that you pay enough fees on L1 for your message to be deserialized and processed on L2.
100 | 
101 | The fees of the `L1HandlerTransaction` are computed in a regular manner as it would be done for an `Invoke` transaction. For this, you can profile
102 | the gas consumption using `starkli` or `snforge` to estimate the cost of your message execution.
103 | 
104 | The signature of the `sendMessageToL2` is:
105 | 
106 | ```js
107 | function sendMessageToL2(
108 |         uint256 toAddress,
109 |         uint256 selector,
110 |         uint256[] calldata payload
111 |     ) external override returns (bytes32);
112 | ```
113 | 
114 | The parameters are as follows:
115 | 
116 | - `toAddress`: The contract address on L2 that will be called.
117 | - `selector`: The selector of the function of this contract at `toAddress`. This selector (function) must have the `#[l1_handler]` attribute to be callable.
118 | - `payload`: The payload is always an array of `felt252` (which are represented by `uint256` in Solidity). For this reason we've inserted the input `myFelt` into the array.
119 |   This is why we need to insert the input data into an array.
120 | 
121 | On the Starknet side, to receive this message, we have:
122 | 
123 | ```cairo,noplayground
124 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/no_listing_03_L1_L2_messaging/src/lib.cairo:felt_msg_handler}}
125 | ```
126 | 
127 | We need to add the `#[l1_handler]` attribute to our function. L1 handlers are special functions that can only be executed by an `L1HandlerTransaction`. There is nothing particular to do to receive transactions from L1, as the message is relayed by the sequencer automatically. In your `#[l1_handler]` functions, it is important to verify the sender of the L1 message to ensure that our contract can only receive messages from a trusted L1 contract.
128 | 
129 | [messaging contract]: https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol
130 | [starknet addresses]: https://docs.starknet.io/documentation/tools/important_addresses/
131 | 
132 | ## Sending Messages from Starknet to Ethereum
133 | 
134 | When sending messages from Starknet to Ethereum, you will have to use the `send_message_to_l1` syscall in your Cairo contracts. This syscall allows you to send messages to the `StarknetMessaging` contract on L1. Unlike `L1->L2` messages, `L2->L1` messages must be consumed manually, which means that you will need your Solidity contract to explicitly call the `consumeMessageFromL2` function of the `StarknetMessaging` contract in order to consume the message.
135 | 
136 | To send a message from L2 to L1, what we would do on Starknet is:
137 | 
138 | ```cairo,noplayground
139 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/no_listing_03_L1_L2_messaging/src/lib.cairo:felt_msg_send}}
140 | ```
141 | 
142 | We simply build the payload and pass it, along with the L1 contract address, to the syscall function.
143 | 
144 | On L1, the important part is to build the same payload sent by the L2. Then in your Solidity contract, you can call `consumeMessageFromL2` by passing the L2 contract address and the payload. Please be aware that the L2 contract address expected by the `consumeMessageFromL2` is the address of the contract that sends the message on the L2 by calling `send_message_to_l1_syscall`.
145 | 
146 | ```js
147 | function consumeMessageFelt(
148 |     uint256 fromAddress,
149 |     uint256[] calldata payload
150 | )
151 |     external
152 | {
153 |     let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, payload);
154 | 
155 |     // You can use the message hash if you want here.
156 | 
157 |     // We expect the payload to contain only a felt252 value (which is a uint256 in Solidity).
158 |     require(payload.length == 1, "Invalid payload");
159 | 
160 |     uint256 my_felt = payload[0];
161 | 
162 |     // From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.
163 |     require(my_felt > 0, "Invalid value");
164 | }
165 | ```
166 | 
167 | As you can see, in this context we don't have to verify which contract from L2 is sending the message (as we do on the L2 to verify which contract from L1 is sending the message). But we are actually using the `consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs (the contract address on L2 and the payload) to ensure we are only consuming valid messages.
168 | 
169 | > **Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract is expected to be called from a Solidity contract, and not directly on the `StarknetCore` contract. The reason for that is because the `StarknetCore` contract is using `msg.sender` to actually compute the hash of the message. And this `msg.sender` must correspond to the `to_address` field that is given to the function `send_message_to_l1_syscall` that is called on Starknet.
170 | 
171 | ## Cairo Serde
172 | 
173 | Before sending messages between L1 and L2, you must remember that Starknet contracts, written in Cairo, can only understand serialized data. And serialized data is always an array of `felt252`.
174 | In Solidity we have `uint256` type, and `felt252` is approximately 4 bits smaller than `uint256`. So we have to pay attention to the values contained in the payload of the messages we are sending.
175 | If, on L1, we build a message with values above the maximum `felt252`, the message will be stuck and never consumed on L2.
176 | 
177 | So for instance, an actual `uint256` value in Cairo is represented by a struct like:
178 | 
179 | ```cairo,does_not_compile
180 | struct u256 {
181 |     low: u128,
182 |     high: u128,
183 | }
184 | ```
185 | 
186 | which will be serialized as **TWO** felts, one for `low`, and one for `high`. This means that to send only one `u256` to Cairo, you'll need to send a payload from L1 with **TWO** values.
187 | 
188 | ```js
189 | uint256[] memory payload = new uint256[](2);
190 | // Let's send the value 1 as a u256 in cairo: low = 1, high = 0.
191 | payload[0] = 1;
192 | payload[1] = 0;
193 | ```
194 | 
195 | If you want to learn more about the messaging mechanism, you can visit the [Starknet documentation][starknet messaging doc].
196 | 
197 | You can also find a [detailed guide here][glihm messaging guide] to test the messaging system locally.
198 | 
199 | [starknet messaging doc]: https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/
200 | [glihm messaging guide]: https://github.com/glihm/starknet-messaging-dev
201 | 


--------------------------------------------------------------------------------
/src/ch16-05-01-price-feeds.md:
--------------------------------------------------------------------------------
 1 | # Price Feeds
 2 | 
 3 | Price feeds enabled by an oracle serve as a bridge between real-world data feed and the blockchain. They provide real time pricing data that is aggregated from multiple trusted external sources ( e.g. crypto exchanges, financial data providers, etc. ) to the blockchain network.
 4 | 
 5 | For the example in this book section, we will use Pragma Oracle to read the price feed for `ETH/USD` asset pair and also showcase a mini application that utilizes this feed.
 6 | 
 7 | [Pragma Oracle](https://www.pragma.build/) is a leading zero knowledge oracle that provides access to off-chain data on Starknet blockchain in a verifiable way.
 8 | 
 9 | ## Setting Up Your Contract for Price Feeds
10 | 
11 | ### Add Pragma as a Project Dependency
12 | 
13 | To get started with integrating Pragma on your Cairo smart contract for price feed data, edit your project's `Scarb.toml` file to include the path to use Pragma.
14 | 
15 | ```toml
16 | [dependencies]
17 | pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib" }
18 | ```
19 | 
20 | ### Creating a Price Feed Contract
21 | 
22 | After adding the required dependencies for your project, you'll need to define a contract interface that includes the required pragma price feed entry point.
23 | 
24 | 
25 | ```cairo,noplayground
26 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:price_interface}}
27 | ```
28 | 
29 | Of the two public functions exposed in the `IPriceFeedExample`, the one necessary to interact with the pragma price feed oracle is the `get_asset_price` function, a view function that takes in the `asset_id` argument and returns a `u128` value.
30 | 
31 | ### Import Pragma Dependencies
32 | 
33 | ```cairo,noplayground
34 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:pragma_lib}}
35 | ```
36 | 
37 | The snippet above shows the necessary imports you need to add to your contract module in order to interact with the Pragma oracle.
38 | 
39 | ### Required Price Feed Function Impl in Contract
40 | 
41 | ```cairo,noplayground
42 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:price_feed_impl}}
43 | ```
44 | 
45 | The `get_asset_price` function is responsible for retrieving the price of the asset specified by the `asset_id` argument from Pragma Oracle. The `get_data_median` method is called from the `IPragmaDispatcher` instance by passing the `DataType::SpotEntry(asset_id)` as an argument and its output is assigned to a variable named `output` of type `PragmaPricesResponse`. Finally, the function returns the price of the requested asset as a `u128`.
46 | 
47 | ## Example Application Using Pragma Price Feed
48 | 
49 | ```cairo,noplayground
50 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:here}}
51 | ```
52 | 
53 | > **Note**: Pragma returns the value of different token pairs using the decimal factor of 6 or 8. You can convert the value to the required decimal factor by dividing the value by \\( {10^{n}} \\), where `n` is the decimal factor.
54 | 
55 | The code above is an example implementation of an applications consuming a price feed from the Pragma oracle. The contract imports necessary modules and interfaces, including the `IPragmaABIDispatcher` for interacting with the Pragma oracle contract and the `ERC20ABIDispatcher` for interacting with the ETH ERC20 token contract.
56 | 
57 | The contract has a `const` that stores the token pair ID of `ETH/USD`, and a `Storage` struct that holds two fields `pragma_contract` and `product_price_in_usd`. The constructor function initializes the `pragma_contract` address and sets the `product_price_in_usd` to 100.
58 | 
59 | The `buy_item` function is the main entry point for a user to purchase an item. It retrieves the caller's address. It calls the `get_asset_price` function to get the current price of ETH in USD using the `ETH_USD` asset ID. It calculates the amount of ETH needed to buy the product based on the product price in USD at the corresponding ETH price. It then checks if the caller has enough ETH by calling the `balance_of` method on the ERC20 ETH contract. If the caller has enough ETH, it calls the `transfer_from` method of the `eth_dispatcher` instance to transfer the required amount of ETH from the caller to another contract address.
60 | 
61 | The `get_asset_price` function is the entry point to interact with the Pragma oracle and has been explained in the section above.
62 | 
63 | You can get a detailed guide on consuming data using Pragma price feeds on their [documentation](https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data).
64 | 


--------------------------------------------------------------------------------
/src/ch16-05-02-randomness.md:
--------------------------------------------------------------------------------
 1 | # Randomness
 2 | 
 3 | Since all blockchains are fundamentally deterministic and most are public ledgers, generating truly unpredictatable randomness on-chain presents a challenge. This randomness is crucial for fair outcomes in gaming, lotteries, and unique generation of NFTs. To address this, verifiable random functions (VRFs) provided by oracles offer a solution. VRFs guarantee that the randomness can't be predicted or tampered with, ensuring trust and transparency in these applications.
 4 | 
 5 | ## Overview on VRFs
 6 | 
 7 | VRFs use a secret key and a nonce (a unique input) to generate an output that appears random. While technically 'pseudo-random', it's practically impossible for another party to predict the outcome without knowing the secret key.
 8 | 
 9 | VRFs produce not only the random number but also a proof that anyone can use to independently verify that the result was generated correctly according to the function's parameters.
10 | 
11 | ## Generating Randomness with Pragma
12 | 
13 | [Pragma](https://www.pragma.build/), an oracle on Starknet provides a solution for generating random numbers using VRFs.
14 | Let's dive into how to use Pragma VRF to generate a random number in a simple dice game contract.
15 | 
16 | ### Add Pragma as a Dependency
17 | 
18 | Edit your cairo project's `Scarb.toml` file to include the path to use Pragma.
19 | 
20 | ```toml
21 | [dependencies]
22 | pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib" }
23 | ```
24 | 
25 | ### Define the Contract Interface
26 | 
27 | ```cairo,noplayground
28 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_06_dice_game_vrf/src/lib.cairo:interfaces}}
29 | ```
30 | 
31 | {{#label pragma_vrf_interface}}
32 | <span class="caption">Listing {{#ref pragma_vrf_interface}} shows a contract interfaces for Pragma VRF and a simple dice game.</span>
33 | 
34 | ### Description of Key IPragmaVRF Entrypoints and Their Inputs
35 | 
36 | The function `request_randomness_from_pragma` initiates a request for verifiable randomness from the Pragma oracle. It does this by emitting an event that triggers the following actions off-chain:
37 | 
38 | 1. **Randomness generation**: The oracle generates random values and a corresponding proof.
39 | 2. **On-chain submission**: The oracle submits the generated randomness and proof back to the blockchain via the `receive_random_words` callback function.
40 | 
41 | #### `request_randomness_from_pragma` Inputs
42 | 
43 | 1. `seed`: A value used to initialize the randomness generation process. This should be unique to ensure unpredictable results.
44 | 2. `callback_address`: The contract address where the `receive_random_words` function will be called to deliver the generated randomness. It is typically the address of your deployed contract implementing Pragma VRF.
45 | 3. `callback_fee_limit`: The maximum amount of gas you're willing to spend on executing the `receive_random_words` callback function.
46 | 4. `publish_delay`: The minimum delay (in blocks) between requesting randomness and the oracle fulfilling the request.
47 | 5. `num_words`: The number of random values (each represented as a `felt252`) you want to receive in a single callback.
48 | 6. `calldata`: Additional data you want to pass to the `receive_random_words` callback function.
49 | 
50 | #### `receive_randomn_words` Inputs
51 | 
52 | 1. `requester_address`: The contract address that initiated the randomness request.
53 | 2. `request_id`: A unique identifier assigned to the randomness request.
54 | 3. `random_words`: An array (span) of the generated random values (represented as `felt252`).
55 | 4. `calldata`: Additional data passed along with the initial randomness request.
56 | 
57 | ## Dice Game Contract
58 | 
59 | This dice game contract allows players to guess a number between 1 & 6 during an active game window. The contract owner then has the ability to toggle the game window to disable new guesses from players. To determine the winning number, the contract owner calls the `request_randomness_from_pragma` function to request a random number from the Pragma VRF oracle. Once the random number is received through the `receive_random_words` callback function, it is stored in the `last_random_number` storage variable. Each player has to call `process_game_winners` function to determine if they have won or lost. The `last_random_number` generated is then reduced to a number between 1 & 6, and compared to the guesses of the players stored in the `user_guesses` mapping, which leads to the emission of an event `GameWinner` or `GameLost`.
60 | 
61 | ```cairo,noplayground
62 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_06_dice_game_vrf/src/lib.cairo:dice_game}}
63 | ```
64 | 
65 | {{#label dice_game_vrf}}
66 | <span class="caption">Listing {{#ref dice_game_vrf}}: Simple Dice Game Contract using Pragma VRF.</span>
67 | 
68 | #### NB: Fund Your Contract After Deployment to Utilize Pragma VRF
69 | 
70 | After deploying your contract that includes Pragma VRF functionalities, ensure it holds sufficient ETH to cover the expenses related to requesting random values. Pragma VRF requires payment for both generating the random numbers and executing the callback function defined in your contract.
71 | 
72 | For more information, please refer to the [Pragma][pragma] docs.
73 | 
74 | [pragma]: https://docs.pragma.build/Resources/Starknet/randomness/randomness
75 | 


--------------------------------------------------------------------------------
/src/ch16-05-oracle-interactions.md:
--------------------------------------------------------------------------------
1 | # Oracle Interactions
2 | 
3 | This section focuses on the concept of bringing off-chain data to the Starknet blockchain using oracles. Oracles are third-party services that serve as intermediaries, securely transmitting external data, such as asset prices, weather information, or other real-world data, to blockchains and smart contracts. It also provides practical examples and code snippets demonstrating how developers can interact with a specific oracle named Pragma on Starknet network, covering topics like querying and handling price data, and verifiable random function (VRF) to generate random numbers.
4 | 


--------------------------------------------------------------------------------
/src/ch16-06-00-other-examples.md:
--------------------------------------------------------------------------------
1 | # Other Examples
2 | 
3 | This section contains additional examples of Starknet smart contracts, utilizing various features of the Cairo programming language. Your contributions are welcome and encouraged, as we aim to gather as many diverse examples as possible.
4 | 


--------------------------------------------------------------------------------
/src/ch16-06-01-deploying-and-interacting-with-a-voting-contract.md:
--------------------------------------------------------------------------------
  1 | # Deploying and Interacting with a Voting contract
  2 | 
  3 | The **`Vote`** contract in Starknet begins by registering voters through the contract's constructor. Three voters are initialized at this stage, and their addresses are passed to an internal function **`_register_voters`**. This function adds the voters to the contract's state, marking them as registered and eligible to vote.
  4 | 
  5 | Within the contract, the constants **`YES`** and **`NO`** are defined to represent the voting options (1 and 0, respectively). These constants facilitate the voting process by standardizing the input values.
  6 | 
  7 | Once registered, a voter is able to cast a vote using the **`vote`** function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, the state of the contract is updated, recording the vote and marking the voter as having voted. This ensures that the voter is not able to cast a vote again within the same proposal. The casting of a vote triggers the **`VoteCast`** event, logging the action.
  8 | 
  9 | The contract also monitors unauthorized voting attempts. If an unauthorized action is detected, such as a non-registered user attempting to vote or a user trying to vote again, the **`UnauthorizedAttempt`** event is emitted.
 10 | 
 11 | Together, these functions, states, constants, and events create a structured voting system, managing the lifecycle of a vote from registration to casting, event logging, and result retrieval within the Starknet environment. Constants like **`YES`** and **`NO`** help streamline the voting process, while events play a vital role in ensuring transparency and traceability.
 12 | 
 13 | Listing {{#ref voting_contract}} shows the `Vote` contract in detail:
 14 | 
 15 | ```cairo,noplayground
 16 | {{#include ../listings/ch16-building-advanced-starknet-smart-contracts/listing_05_vote_contract/src/lib.cairo}}
 17 | ```
 18 | 
 19 | {{#label voting_contract}}
 20 | <span class="caption">Listing {{#ref voting_contract}}: A voting smart contract</span>
 21 | 
 22 | ## Deploying, Calling and Invoking the Voting Contract
 23 | 
 24 | Part of the Starknet experience is deploying and interacting with smart contracts.
 25 | 
 26 | Once the contract is deployed, we can interact with it by calling and invoking its functions:
 27 | 
 28 | - Calling contracts: Interacting with external functions that only read from the state. These functions do not alter the state of the network, so they don't require fees or signing.
 29 | - Invoking contracts: Interacting with external functions that can write to the state. These functions do alter the state of the network and require fees and signing.
 30 | 
 31 | We will setup a local development node using `katana` to deploy the voting contract. Then, we'll interact with the contract by calling and invoking its functions. You can also use the Goerli Testnet instead of `katana`. However, we recommend using `katana` for local development and testing. You can find the complete tutorial for `katana` in the ["Katana: A Local Node"][katana chapter] chapter of the Starknet Book.
 32 | 
 33 | [katana chapter]: https://book.starknet.io/ch02-04-katana.html
 34 | 
 35 | ### The `katana` Local Starknet Node
 36 | 
 37 | `katana` is designed to support local development by the [Dojo team][dojo katana]. It will allow you to do everything you need to do with Starknet, but locally. It is a great tool for development and testing.
 38 | 
 39 | To install `katana` from the source code, please refer to the ["Basic Installation"][katana installation] chapter of the Starknet Book.
 40 | 
 41 | > Note: Please verify that the version of `katana` match the specified version provided below.
 42 | >
 43 | > ```bash
 44 | > $ katana --version
 45 | > katana 0.6.0
 46 | > ```
 47 | >
 48 | > To upgrade `katana` version, refer to the ["Basic Installation"][katana installation] chapter of the Starknet Book.
 49 | 
 50 | Once you have `katana` installed, you can start the local Starknet node with:
 51 | 
 52 | ```bash
 53 | katana --accounts 3 --seed 0 --gas-price 250
 54 | ```
 55 | 
 56 | This command will start a local Starknet node with 3 deployed accounts. We will use these accounts to deploy and interact with the voting contract:
 57 | 
 58 | ```bash
 59 | ...
 60 | PREFUNDED ACCOUNTS
 61 | ==================
 62 | 
 63 | | Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0
 64 | | Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600
 65 | | Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e
 66 | 
 67 | | Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c
 68 | | Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b
 69 | | Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d
 70 | 
 71 | | Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5
 72 | | Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c
 73 | | Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc
 74 | ...
 75 | ```
 76 | 
 77 | Before we can interact with the voting contract, we need to prepare the voter and admin accounts on Starknet. Each voter account must be registered and sufficiently funded for voting. For a more detailed understanding of how accounts operate with Account Abstraction, refer to the ["Account Abstraction"][aa chapter] chapter of the Starknet Book.
 78 | 
 79 | [dojo katana]: https://github.com/dojoengine/dojo/blob/main/crates/katana
 80 | [katana installation]: https://book.starknet.io/ch02-01-basic-installation.html#katana-node-installation
 81 | [aa chapter]: https://book.starknet.io/ch04-00-account-abstraction.html
 82 | 
 83 | ### Smart Wallets for Voting
 84 | 
 85 | Aside from Scarb you will need to have Starkli installed. Starkli is a command line tool that allows you to interact with Starknet. You can find the installation instructions in the ["Basic Installation"][starkli installation] chapter of the Starknet Book.
 86 | 
 87 | > Note: Please verify that the version of `starkli` match the specified version provided below.
 88 | >
 89 | > ```bash
 90 | > $ starkli --version
 91 | > 0.2.9 (0535f44)
 92 | > ```
 93 | >
 94 | > To upgrade `starkli` to `0.2.9`, use the `starkliup -v 0.2.9` command, or simply `starkliup` which installed the latest stable version.
 95 | 
 96 | For each smart wallet we'll use, we must create a Signer within the encrypted keystore and an Account Descriptor. This process is also detailed in the ["Testnet Deployment"][signer creation] chapter of the Starknet Book.
 97 | 
 98 | We can create Signers and Account Descriptors for the accounts we want to use for voting. Let's create a smart wallet for voting in our smart contract.
 99 | 
100 | Firstly, we create a signer from a private key:
101 | 
102 | ```bash
103 | starkli signer keystore from-key ~/.starkli-wallets/deployer/account0_keystore.json
104 | ```
105 | 
106 | Then, we create the Account Descriptor by fetching the katana account we want to use:
107 | 
108 | ```bash
109 | starkli account fetch <KATANA ACCOUNT ADDRESS> --rpc http://0.0.0.0:5050 --output ~/.starkli-wallets/deployer/account0_account.json
110 | ```
111 | 
112 | This command will create a new `account0_account.json` file containing the following details:
113 | 
114 | ```bash
115 | {
116 |   "version": 1,
117 |   "variant": {
118 |         "type": "open_zeppelin",
119 |         "version": 1,
120 |         "public_key": "<SMART_WALLET_PUBLIC_KEY>"
121 |   },
122 |     "deployment": {
123 |         "status": "deployed",
124 |         "class_hash": "<SMART_WALLET_CLASS_HASH>",
125 |         "address": "<SMART_WALLET_ADDRESS>"
126 |   }
127 | }
128 | ```
129 | 
130 | You can retrieve the smart wallet class hash (it will be the same for all your smart wallets) with the following command. Notice the use of the `--rpc` flag and the RPC endpoint provided by `katana`:
131 | 
132 | ```
133 | starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050
134 | ```
135 | 
136 | For the public key, you can use the `starkli signer keystore inspect` command with the directory of the keystore json file:
137 | 
138 | ```bash
139 | starkli signer keystore inspect ~/.starkli-wallets/deployer/account0_keystore.json
140 | ```
141 | 
142 | This process is identical for `account_1` and `account_2` in case you want to have a second and a third voter.
143 | 
144 | [starkli installation]: https://book.starknet.io/ch02-01-basic-installation.html#starkli-installation)
145 | [signer creation]: https://book.starknet.io/ch02-05-testnet-deployment.html?highlight=signer#creating-a-signer
146 | 
147 | ### Contract Deployment
148 | 
149 | Before deploying, we need to declare the contract. We can do this with the `starkli declare` command:
150 | 
151 | ```bash
152 | starkli declare target/dev/starknetbook_chapter_2_Vote.sierra.json --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json
153 | ```
154 | 
155 | If the compiler version you're using is older than the one used by Starkli and you encounter a `compiler-version` error while using the command above, you can specify a compiler version to use in the command by adding the `--compiler-version x.y.z` flag.
156 | 
157 | If you're still encountering issues with the compiler version, try upgrading Starkli using the command: `starkliup` to make sure you're using the latest version of starkli.
158 | 
159 | The class hash of the contract is: `0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You can declare this contract on Sepolia testnet and see that the class hash will correspond.
160 | 
161 | The `--rpc` flag specifies the RPC endpoint to use (the one provided by `katana`). The `--account` flag specifies the account to use for signing the transaction. The account we use here is the one we created in the previous step. The `--keystore` flag specifies the keystore file to use for signing the transaction.
162 | 
163 | Since we are using a local node, the transaction will achieve finality immediately. If you are using the Goerli Testnet, you will need to wait for the transaction to be final, which usually takes a few seconds.
164 | 
165 | The following command deploys the voting contract and registers voter_0, voter_1, and voter_2 as eligible voters. These are the constructor arguments, so add a voter account that you can later vote with.
166 | 
167 | ```bash
168 | starkli deploy <class_hash_of_the_contract_to_be_deployed> <voter_0_address> <voter_1_address> <voter_2_address> --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json
169 | ```
170 | 
171 | An example command:
172 | 
173 | ```bash
174 | starkli deploy 0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c 0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json
175 | ```
176 | 
177 | In this case, the contract has been deployed at an specific address: `0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This address will be different for you. We will use this address to interact with the contract.
178 | 
179 | ### Voter Eligibility Verification
180 | 
181 | In our voting contract, we have two functions to validate voter eligibility, `voter_can_vote` and `is_voter_registered`. These are external read functions, which mean they don't alter the state of the contract but only read the current state.
182 | 
183 | The `is_voter_registered` function checks whether a particular address is registered as an eligible voter in the contract. The `voter_can_vote` function, on the other hand, checks whether the voter at a specific address is currently eligible to vote, i.e., they are registered and haven't voted already.
184 | 
185 | You can call these functions using the `starkli call` command. Note that the `call` command is used for read functions, while the `invoke` command is used for functions that can also write to storage. The `call` command does not require signing, while the `invoke` command does.
186 | 
187 | ```bash+
188 | starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050
189 | ```
190 | 
191 | First we added the address of the contract, then the function we want to call, and finally the input for the function. In this case, we are checking whether the voter at the address `0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can vote.
192 | 
193 | Since we provided a registered voter address as an input, the result is 1 (boolean true), indicating the voter is eligible to vote.
194 | 
195 | Next, let's call the `is_voter_registered` function using an unregistered account address to observe the output:
196 | 
197 | ```bash
198 | starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050
199 | ```
200 | 
201 | With an unregistered account address, the terminal output is 0 (i.e., false), confirming that the account is not eligible to vote.
202 | 
203 | ### Casting a Vote
204 | 
205 | Now that we have established how to verify voter eligibility, we can vote! To vote, we interact with the `vote` function, which is flagged as external, necessitating the use of the `starknet invoke` command.
206 | 
207 | The `invoke` command syntax resembles the `call` command, but for voting, we submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the `vote` function, we are charged a fee, and the transaction must be signed by the voter; we are writing to the contract's storage.
208 | 
209 | ```bash
210 | //Voting Yes
211 | starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json
212 | 
213 | //Voting No
214 | starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json
215 | ```
216 | 
217 | You will be prompted to enter the password for the signer. Once you enter the password, the transaction will be signed and submitted to the Starknet network. You will receive the transaction hash as output. With the starkli transaction command, you can get more details about the transaction:
218 | 
219 | ```bash
220 | starkli transaction <TRANSACTION_HASH> --rpc http://0.0.0.0:5050
221 | ```
222 | 
223 | This returns:
224 | 
225 | ```bash
226 | {
227 |   "transaction_hash": "0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd",
228 |   "max_fee": "0x430e81",
229 |   "version": "0x1",
230 |   "signature": [
231 |     "0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57",
232 |     "0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51"
233 |   ],
234 |   "nonce": "0x3",
235 |   "type": "INVOKE",
236 |   "sender_address": "0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0",
237 |   "calldata": [
238 |     "0x1",
239 |     "0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349",
240 |     "0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41",
241 |     "0x0",
242 |     "0x1",
243 |     "0x1",
244 |     "0x1"
245 |   ]
246 | }
247 | ```
248 | 
249 | If you try to vote twice with the same signer you will get an error:
250 | 
251 | ```bash
252 | Error: code=ContractError, message="Contract error"
253 | ```
254 | 
255 | The error is not very informative, but you can get more details when looking at the output in the terminal where you started `katana` (our local Starknet node):
256 | 
257 | ```bash
258 | ...
259 | Transaction execution error: "Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):
260 |     Error at pc=0:81:
261 |     Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \"USER_ALREADY_VOTED\".
262 |     ...
263 | ```
264 | 
265 | The key for the error is `USER_ALREADY_VOTED`.
266 | 
267 | ```bash
268 | assert!(can_vote, "USER_ALREADY_VOTED");
269 | ```
270 | 
271 | We can repeat the process to create Signers and Account Descriptors for the accounts we want to use for voting. Remember that each Signer must be created from a private key, and each Account Descriptor must be created from a public key, a smart wallet address, and the smart wallet class hash (which is the same for each voter).
272 | 
273 | ```bash
274 | starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account1_account.json --keystore ~/.starkli-wallets/deployer/account1_keystore.json
275 | 
276 | starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account2_account.json --keystore ~/.starkli-wallets/deployer/account2_keystore.json
277 | ```
278 | 
279 | ### Visualizing Vote Outcomes
280 | 
281 | To examine the voting results, we invoke the `get_vote_status` function, another view function, through the `starknet call` command.
282 | 
283 | ```bash
284 | starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 get_vote_status --rpc http://0.0.0.0:5050
285 | ```
286 | 
287 | The output reveals the tally of "Yes" and "No" votes along with their relative percentages.
288 | 


--------------------------------------------------------------------------------
/src/ch17-00-starknet-smart-contracts-security.md:
--------------------------------------------------------------------------------
1 | # Starknet Smart Contracts Security
2 | 


--------------------------------------------------------------------------------
/src/ch17-01-general-recommendations.md:
--------------------------------------------------------------------------------
 1 | # General Recommendations
 2 | 
 3 | When developing software, ensuring it functions as intended is usually straightforward. However, preventing unintended usage and vulnerabilities can be more challenging.
 4 | 
 5 | In smart contract development, security is very important. A single error can result in the loss of valuable assets or the improper functioning of certain features.
 6 | 
 7 | Smart contracts are executed in a public environment where anyone can examine the code and interact with it. Any errors or vulnerabilities in the code can be exploited by malicious actors.
 8 | 
 9 | This chapter presents general recommendations for writing secure smart contracts. By incorporating these concepts during development, you can create robust and reliable smart contracts. This reduces the chance of unexpected behavior or vulnerabilities.
10 | 
11 | ## Disclaimer
12 | 
13 | This chapter does not provide an exhaustive list of all possible security issues, and it does not guarantee that your contracts will be completely secure.
14 | 
15 | If you are developing smart contracts for production use, it is highly recommended to conduct external audits performed by security experts.
16 | 
17 | ## Mindset
18 | 
19 | Cairo is a highly safe language inspired by Rust. It is designed in a way that forces you to cover all possible cases. Security issues on Starknet mostly arise from the way smart contract flows are designed, not much from the language itself.
20 | 
21 | Adopting a security mindset is the initial step in writing secure smart contracts. Try to always consider all possible scenarios when writing code.
22 | 
23 | ### Viewing Smart Contracts as Finite State Machines
24 | 
25 | Transactions in smart contracts are atomic, meaning they either succeed or fail without making any changes.
26 | 
27 | Think of smart contracts as state machines: they have a set of initial states defined by the constructor constraints, and external functions represent a set of possible state transitions. A transaction is nothing more than a state transition.
28 | 
29 | The `assert!` or `panic!` macros can be used to validate conditions before performing specific actions. You can learn more about these on the [Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-panic.md) page.
30 | 
31 | These validations can include:
32 | 
33 | - Inputs provided by the caller
34 | - Execution requirements
35 | - Invariants (conditions that must always be true)
36 | - Return values from other function calls
37 | 
38 | For example, you could use the `assert!` macro to validate that a user has enough funds to perform a withdraw transaction. If the condition is not met, the transaction will fail and the state of the contract will not change.
39 | 
40 | ```cairo,noplayground
41 | {{#include ../listings/ch17-starknet-smart-contracts-security/no_listing_01_assert_balance/src/lib.cairo:withdraw}}
42 | ```
43 | 
44 | Using these functions to check conditions adds constraints that help clearly define the boundaries of possible state transitions for each function in your smart contract. These checks ensure that the behavior of the contract stays within the expected limits.
45 | 
46 | ## Recommendations
47 | 
48 | ### Checks Effects Interactions Pattern
49 | 
50 | The Checks Effects Interactions pattern is a common design pattern used to prevent reentrancy attacks on Ethereum. While reentrancy is harder to achieve in Starknet, it is still recommended to use this pattern in your smart contracts.
51 | 
52 | <!-- TODO add reference to the reentrancy CairoByExample page -->
53 | 
54 | The pattern consists of following a specific order of operations in your functions:
55 | 
56 | 1. **Checks**: Validate all conditions and inputs before performing any state changes.
57 | 2. **Effects**: Perform all state changes.
58 | 3. **Interactions**: All external calls to other contracts should be made at the end of the function.
59 | 
60 | ### Access Control
61 | 
62 | Access control is the process of restricting access to certain features or resources. It is a common security mechanism used to prevent unauthorized access to sensitive information or actions. In smart contracts, some functions may often be restricted to specific users or roles.
63 | 
64 | You can implement the access control pattern to easily manage permissions. This pattern consists of defining a set of roles and assigning them to specific users. Each function can then be restricted to specific roles.
65 | 
66 | ```cairo,noplayground
67 | {{#include ../listings/ch17-starknet-smart-contracts-security/no_listing_02_simple_access_control/src/lib.cairo}}
68 | ```
69 | 


--------------------------------------------------------------------------------
/src/ch17-02-testing-smart-contracts.md:
--------------------------------------------------------------------------------
  1 | # Testing Smart Contracts
  2 | 
  3 | Testing smart contracts is a critical part of the development process. It is important to ensure that smart contracts behave as expected and that they are secure.
  4 | 
  5 | In a previous section of the Cairo Book, we learned how to write and structure our tests for Cairo programs. We demonstrated how these tests could be run using the `scarb` command-line tool.
  6 | While this approach is useful for testing standalone Cairo programs and functions, it lacks functionality for testing smart contracts that require control over the contract state and execution context. Therefore, in this section, we will introduce how to use Starknet Foundry, a smart contract development toolchain for Starknet, to test your Cairo contracts.
  7 | 
  8 | Throughout this chapter, we will be using as an example the `PizzaFactory` contract in Listing {{#ref pizza-factory}} to demonstrate how to write tests with Starknet Foundry.
  9 | 
 10 | ```cairo,noplayground
 11 | {{#rustdoc_include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/pizza.cairo}}
 12 | ```
 13 | 
 14 | {{#label pizza-factory}}
 15 | <span class="caption">Listing {{#ref pizza-factory}}: A pizza factory that needs to be tested</span>
 16 | 
 17 | ## Configuring your Scarb project with Starknet Foundry
 18 | 
 19 | The settings of your Scarb project can be configured in the `Scarb.toml` file. To use Starknet Foundry as your testing tool, you will need to add it as a dev dependency in your `Scarb.toml` file. At the time of writing, the latest version of Starknet Foundry is `v0.22.0` - but you should use the latest version.
 20 | 
 21 | ```toml,noplayground
 22 | [dev-dependencies]
 23 | snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }
 24 | 
 25 | [scripts]
 26 | test = "snforge test"
 27 | ```
 28 | 
 29 | The `scarb test` command is configured to execute `scarb cairo-test` by default. In our settings, we have configured it to execute `snforge test` instead. This will allow us to run our tests using Starknet Foundry when we run the `scarb test` command.
 30 | 
 31 | Once your project is configured, you will need to install Starknet Foundry by following the installation guide from the [Starknet Foundry Documentation](https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html). As usual, we recommend to use `asdf` to manage versions of your development tools.
 32 | 
 33 | ## Testing Smart Contracts with Starknet Foundry
 34 | 
 35 | The usual command to run your tests using Starknet Foundry is `snforge test`. However, when we configured our projects, we defined that the `scarb test` command will run the `snforge test` command. Therefore, during the rest of this chapter, consider that the `scarb test` command will be using `snforge test` under the hood.
 36 | 
 37 | The usual testing flow of a contract is as follows:
 38 | 
 39 | 1. Declare the class of the contract to test, identified by its name
 40 | 2. Serialize the constructor calldata into an array
 41 | 3. Deploy the contract and retrieve its address
 42 | 4. Interact with the contract's entrypoint to test various scenarios
 43 | 
 44 | ### Deploying the Contract to Test
 45 | 
 46 | In Listing {{#ref contract-deployment}}, we wrote a function that deploys the `PizzaFactory` contract and sets up the dispatcher for interactions.
 47 | 
 48 | ```cairo,noplayground
 49 | {{#rustdoc_include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:deployment}}
 50 | ```
 51 | 
 52 | {{#label contract-deployment}}
 53 | <span class="caption">Listing {{#ref contract-deployment}} Deploying the contract to test</span>
 54 | 
 55 | ### Testing our Contract
 56 | 
 57 | Determining the behavior that your contract should respect is the first step in writing tests. In the `PizzaFactory` contract, we determined that the contract should have the following behavior:
 58 | 
 59 | - Upon deployment, the contract owner should be set to the address provided in the constructor, and the factory should have 10 units of pepperoni and pineapple, and no pizzas created.
 60 | - If someone tries to make a pizza and they are not the owner, the operation should fail. Otherwise, the pizza count should be incremented, and an event should be emitted.
 61 | - If someone tries to take ownership of the contract and they are not the owner, the operation should fail. Otherwise, the owner should be updated.
 62 | 
 63 | #### Accessing Storage Variables with `load`
 64 | 
 65 | ```cairo,noplayground
 66 | {{#rustdoc_include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:test_constructor}}
 67 | ```
 68 | 
 69 | {{#label test-constructor}}
 70 | <span class="caption">Listing {{#ref test-constructor}}: Testing the initial state by loading storage variables </span>
 71 | 
 72 | Once our contract is deployed, we want to assert that the initial values are set as expected. If our contract has an entrypoint that returns the value of a storage variable, we can call this entrypoint. Otherwise, we can use the `load` function from `snforge` to load the value of a storage variable inside our contract, even if not exposed by an entrypoint.
 73 | 
 74 | #### Mocking the Caller Address with `start_cheat_caller_address`
 75 | 
 76 | The security of our factory relies on the owner being the only one able to make pizzas and transfer ownership. To test this, we can use the `start_cheat_caller_address` function to mock the caller address and assert that the contract behaves as expected.
 77 | 
 78 | ```cairo,noplayground
 79 | {{#rustdoc_include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:test_owner}}
 80 | ```
 81 | 
 82 | {{#label test-owner}}
 83 | <span class="caption">Listing {{#ref test-owner}}: Testing ownership of the contract by mocking the caller address </span>
 84 | 
 85 | Using `start_cheat_caller_address`, we call the `change_owner` function first as the owner, and then as a different address. We assert that the operation fails when the caller is not the owner, and that the owner is updated when the caller is the owner.
 86 | 
 87 | #### Capturing Events with `spy_events`
 88 | 
 89 | When a pizza is created, the contract emits an event. To test this, we can use the `spy_events` function to capture the emitted events and assert that the event was emitted with the expected parameters. Naturally, we can also assert that the pizza count was incremented, and that only the owner can make a pizza.
 90 | 
 91 | ```cairo,noplayground
 92 | {{#rustdoc_include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:test_make_pizza}}
 93 | ```
 94 | 
 95 | {{#label capture-pizza-emission-event}}
 96 | <span class="caption">Listing {{#ref capture-pizza-emission-event}}: Testing the events emitted when a pizza is created</span>
 97 | 
 98 | #### Accessing Internal Functions with `contract_state_for_testing`
 99 | 
100 | All the tests we have seen so far have been using a workflow that involves deploying the contract and interacting with the contract's entrypoints. However, sometimes we may want to test the internals of the contract directly, without deploying the contract. How could this be done, if we were reasoning in purely Cairo terms?
101 | 
102 | Recall the struct `ContractState`, which is used as a parameter to all the entrypoints of a contract. To make it short, this struct contains zero-sized fields, corresponding to the storage variables of the contract. The only purpose of these fields is to allow the Cairo compiler to generate the correct code for accessing the storage variables. If we could create an instance of this struct, we could access these storage variables directly, without deploying the contract...
103 | 
104 | ...and this is exactly what the `contract_state_for_testing` function does! It creates an instance of the `ContractState` struct, allowing us to call any function that takes as parameter a `ContractState` struct, without deploying the contract. To interact with the storage variables properly, we need to manually import the traits that define access to the storage variables.
105 | 
106 | ```cairo,noplayground
107 | {{#rustdoc_include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:import_internal}}
108 | ```
109 | 
110 | {{#label test-internal}}
111 | <span class="caption">Listing {{#ref test-internal}}: Unit testing our contract without deployment</span>
112 | 
113 | These imports give us access to our internal functions (notably, `set_owner`), as well as the
114 | read/write access to the `owner` storage variable. Once we have these, we can interact with the
115 | contract directly, changing the address of the owner by calling the `set_owner` method, accessible
116 | through `InternalTrait`, and reading the `owner` storage variable.
117 | 
118 | > Note: Both approaches cannot be used at the same time. If you decide to deploy the contract, you interact with it using the dispatcher. If you decide to test the internal functions, you interact with the `ContractState` object directly.
119 | 
120 | ```bash,noplayground
121 | {{#include ../listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/output.txt}}
122 | ```
123 | 
124 | The output of the tests shows that all the tests passed successfully, along with an estimation of the gas consumed by each test.
125 | 
126 | ## Summary
127 | 
128 | In this chapter, we learned how to test smart contracts using Starknet Foundry. We demonstrated how to deploy a contract and interact with it using the dispatcher. We also showed how to test the contract's behavior by mocking the caller address and capturing events. Finally, we demonstrated how to test the internal functions of the contract directly, without deploying the contract.
129 | 
130 | To learn more about Starknet Foundry, refer to the [Starknet Foundry documentation](https://foundry-rs.github.io/starknet-foundry/index.html).
131 | 


--------------------------------------------------------------------------------
/src/ch17-03-static-analysis-tools.md:
--------------------------------------------------------------------------------
 1 | # Static Analysis Tools
 2 | 
 3 | Static analysis refers to the process of examining code without its execution, focusing on its structure, syntax, and properties. It involves analyzing the source code to identify potential issues, vulnerabilities, or violations of specified rules.
 4 | 
 5 | By defining rules, such as coding conventions or security guidelines, developers can utilize static analysis tools to automatically check the code against these standards.
 6 | 
 7 | Reference:
 8 | 
 9 | - [Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)
10 | - [Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)
11 | 


--------------------------------------------------------------------------------
/src/ch200-introduction.md:
--------------------------------------------------------------------------------
 1 | # Introduction
 2 | 
 3 | Ever wondered how your Cairo programs were executed?
 4 | 
 5 | First, they are compiled by the Cairo Compiler, then executed
 6 | by the Cairo Virtual Machine, or _Cairo VM_ for short,
 7 | which generates a trace of execution, used by the Prover
 8 | to generate a STARK proof of that execution. This proof can later
 9 | be verified by a Verifier.
10 | 
11 | The following chapters will go deep inside the inner workings of the Cairo VM.
12 | We'll cover its architecture, its memory model, and its execution model.
13 | Next, we'll explore builtins and hints, their purpose, and how they work.
14 | Finally, we'll look at the runner, which orchestrates the execution of a Cairo program.
15 | 
16 | But first, what do we mean by "virtual machine"?
17 | 
18 | ## Virtual Machine
19 | 
20 | Virtual Machines (VMs) are software emulations of physical computers.
21 | They provide a complete programming environment through an API which
22 | includes everything required for the correct execution of programs above it.
23 | 
24 | Every virtual machine API includes an instruction set architecture (ISA)
25 | in which to express programs. It could be the same instruction set as some
26 | physical machine (e.g. RISC-V), or a dedicated one implemented in the VM
27 | (e.g. Cairo assembly, CASM).
28 | 
29 | Those that emulate an OS are called _System Virtual Machines_, such as Xen and VMWare.
30 | We're not interested in them here.
31 | 
32 | The other ones we're interested in are _Process Virtual Machines_.
33 | They provide the environment needed by a single user-level process.
34 | 
35 | The most well-known process VM might be the Java Virtual Machine (JVM).
36 | 
37 | - Given a Java program `prgm.java`, it is compiled into a class `prgm.class`,
38 |   containing _Java bytecode_ (JVM instructions and metadata).
39 | - The JVM verifies that the bytecode is safe to run.
40 | - The bytecode is either interpreted (slow) or compiled to machine code just in time (JIT, fast).
41 | - If using JIT, the bytecode is translated to machine code while executing the program.
42 | - Java programs could also be directly compiled to a specific CPU architecture (read machine code) through a process called _ahead-of-time compilation_ (AOT).
43 | 
44 | The Cairo VM is also a process VM, similar to the JVM, with one significant difference:
45 | Java and its JVM are designed for (platform-independent) general-purpose computing,
46 | while Cairo and its Cairo VM are specifically designed for (platform-independent)
47 | _provable_ general-purpose computing.
48 | 
49 | - A Cairo program `prgm.cairo` is compiled into compilation artifacts `prgm.json`,
50 |   containing _Cairo bytecode_ (encoded CASM, the Cairo instruction set, and extra data).
51 | - As seen in the [introduction](ch00-00-introduction.md), Cairo Zero directly compiles to CASM
52 |   while Cairo first compiles to _Sierra_ and then to a safe subset of CASM.
53 | - The Cairo VM _interprets_ the provided CASM and generates a trace of the program execution.
54 | - The obtained trace data can be fed to the Cairo Prover in order to generate a STARK proof,
55 |   allowing to prove the correct execution of the program. Creating this _validity proof_ is the
56 |   main purpose of Cairo.
57 | 
58 | Here is a high-level flow diagram showing how a Java program and a Cairo one are executed
59 | with their respective compiler and VM. The proof generation of a Cairo program is included.
60 | 
61 | <div align="center">
62 |   <img src="java-cairo-execution-flow.png" alt="Java and Cairo execution flow" width="800px"/>
63 | </div>
64 | <div align="center">
65 |   <span class="caption">Java and Cairo program high-level execution flow diagram</span>
66 | </div>
67 | 
68 | An ongoing project, [Cairo Native][cairo-native] works on providing
69 | Sierra to machine code compilation, including JIT and AOT, for executing Cairo programs.
70 | 
71 | Even though the high-level flow of both VMs is similar, their actual architectures
72 | are extremely different: the instruction set, the memory model, Cairo's non-determinism
73 | and the output.
74 | 
75 | [cairo-native]: https://github.com/lambdaclass/cairo_native
76 | 
77 | ## References
78 | 
79 | Michael L. Scott, in Programming Language Pragmatics, 2015
80 | 


--------------------------------------------------------------------------------
/src/ch201-architecture.md:
--------------------------------------------------------------------------------
  1 | # Architecture
  2 | 
  3 | Cairo is a STARK-friendly Von Neumann architecture capable of generating validity proofs
  4 | for arbitrary computations. Being STARK-friendly means that Cairo's design is optimized for the STARK
  5 | proof system, while remaining compatible with other proof system backends.
  6 | It implements a Turing-complete process virtual machine.
  7 | 
  8 | Cairo consists of three main components:
  9 | 
 10 | 1. The Cairo compiler
 11 | 2. The Cairo Virtual Machine (CairoVM)
 12 | 3. The Cairo prover and verifier
 13 | 
 14 | The Cairo compiler transforms Cairo source code into Cairo bytecode (encoded instructions and metadata).
 15 | The compiler's output is commonly referred to as the _compilation artifacts_.
 16 | 
 17 | The CairoVM implements the theoretical _Cairo machine_,
 18 | processing the compilation artifacts and executing the instructions
 19 | to produce two key outputs required for proof generation and verification:
 20 | the _AIR (Arithmetic Intermediate Representation) private input_ (witness) and _AIR public input_:
 21 | 
 22 | - The AIR private input comprises the _execution trace_ (or simply "trace") and the _memory_.
 23 | - The AIR public input includes the _initial and final states_ (first and last entries of the trace),
 24 |   the _public memory_ (a subset of the memory), and configuration data
 25 |   (e.g., layout) of the execution.
 26 | 
 27 | The prover takes the AIR's private and public inputs to generate a proof
 28 | of the corresponding program execution.
 29 | The verifier can then verify the proof's correctness asynchronously,
 30 | given the proof and the AIR public input.
 31 | 
 32 | What are AIRs, though?
 33 | 
 34 | ## Arithmetic Intermediate Representation - AIR
 35 | 
 36 | AIR stands for _Arithmetic Intermediate Representation_, which is an arithmetization
 37 | technique. Arithmetization is the foundation of every proof system: STARK uses AIRs,
 38 | while other proof systems might rely on different techniques (e.g., R1CS, PLONKish arithmetization).
 39 | It allows converting a computational statement into a set of polynomial equations.
 40 | These polynomial equations then represent the constraints of your system:
 41 | if they all hold while following the proof system protocol, then the proof is valid;
 42 | otherwise, it's invalid.
 43 | 
 44 | At its core, Cairo is a set of AIRs that represent a Turing-complete machine for the Cairo ISA: the _Cairo machine_.
 45 | This enables proving any statement (i.e., arbitrary code) through the Cairo machine.
 46 | 
 47 | The Cairo machine abstracts away the need to write AIRs for the program you would like to prove,
 48 | and Cairo, as a language, provides a human-readable interface to use the Cairo machine.
 49 | 
 50 | Each component of the Cairo machine has its corresponding AIR: the CPU, the Memory, the Builtins...
 51 | 
 52 | Good AIRs are critical to the performance of proof generation and verification.
 53 | While there can be many ways to express a computational statement into polynomials,
 54 | not all are equally efficient. Writing optimal AIRs is a strong factor of performance.
 55 | 
 56 | We won't go any further on AIRs here, but it's good to know that the CairoVM's purpose
 57 | is to provide the required inputs to the Cairo prover for it to generate proof of the given Cairo program.
 58 | In a nutshell, the Cairo prover and verifier job is to verify that the constraints
 59 | defined by the Cairo AIR holds for the CairoVM outputs.
 60 | 
 61 | ## Cairo Machine
 62 | 
 63 | The Cairo machine is the theoretical model that defines the Von Neumann architecture to
 64 | prove arbitrary computation.
 65 | 
 66 | The machine is defined by two core models:
 67 | 
 68 | - CPU, or Execution model - The Instruction Set Architecture (ISA)
 69 | - Memory model - Non-deterministic Read-only Memory
 70 | 
 71 | The Execution model specifies the ISA through three key components:
 72 | 
 73 | - The instruction set
 74 | - The registers (`pc`, `ap`, `fp`)
 75 | - The state transition algorithm
 76 | 
 77 | Unlike general-purpose ISAs such as RISC-V, Cairo implements its own ISA specifically optimized
 78 | for proof generation and verificationa custom zero-knowledge ISA (ZK-ISA).
 79 | The Memory model defines how the CPU interacts with the memory.
 80 | Following Von Neumann architecture principles, a single memory stores both program and instruction data.
 81 | 
 82 | The Cairo machine exists in two versions:
 83 | 
 84 | 1. The _deterministic machine_ (used by the prover)
 85 | 2. The _non-deterministic machine_ (used by the verifier)
 86 | 
 87 | Why are there two versions of the Cairo machine, one for the prover and one for the verifier?
 88 | 
 89 | ### Deterministic and Non-deterministic Cairo Machine
 90 | 
 91 | The deterministic machine takes a trace (a sequence of states) and the whole memory
 92 | (a memory function), and verifies that the transition between two consecutive states is valid.
 93 | It returns `accept` if all state transitions are valid and `reject` otherwise.
 94 | This machine does not perform any computation, it only asserts the validity of a trace
 95 | and its memory.
 96 | 
 97 | The non-deterministic machine relies on the deterministic one: it only takes the initial
 98 | state, the final state, and a partial memory function (i.e. the public memory)
 99 | and returns `accept` if there exists a sequence of states (a trace)
100 | with the same initial and final states and a memory function that extends the partial memory
101 | (a whole memory that includes the public-memory) which is accepted by the deterministic machine.
102 | 
103 | The deterministic machine allows the prover to generate a proof, while the non-deterministic
104 | machine allows the verifier to verify the proof succinctly in a zero-knowledge way
105 | (some data can be kept private from the verifier).
106 | 
107 | The CairoVM is the implementation of this theoretical machine,
108 | including some functionalities to benefit from its design (_builtins_ & _hints_).
109 | Among the various implementations of the CairoVM, what we call the _Cairo Runner_ is the
110 | entrypoint for running a Cairo program and generating the AIR inputs needed for proof.
111 | 
112 | When a Cairo program is executed by the CairoVM, we could view the memory model as a Write-Once one.
113 | 
114 | #### Recap - Differences between the two Cairo machines
115 | 
116 | We could recap in a table the key differences between the deterministic Cairo machine,
117 | and the non-deterministic one.
118 | 
119 | |        | Deterministic Cairo Machine | Non-Deterministic Cairo Machine |
120 | | ------ | --------------------------- | ------------------------------- |
121 | | Usage  | Prover                      | Verifier                        |
122 | | Hints  | Executed                    | Not aware of them               |
123 | | Memory | Complete memory             | Public memory only              |
124 | | Trace  | Full execution trace        | Initial & Final states only     |
125 | 
126 | ## Cairo Virtual Machine Architecture Diagram
127 | 
128 | The following diagram represent the architecture of the CairoVM,
129 | to generate the AIR inputs for the proof system.
130 | 
131 | <div align="center">
132 |   <img src="cairo-vm-architecture.png" alt="CairoVM architecture" width="800px"/>
133 | </div>
134 | 


--------------------------------------------------------------------------------
/src/ch204-00-builtins.md:
--------------------------------------------------------------------------------
 1 | # Builtins
 2 | 
 3 | The Cairo whitepaper defines builtins as "predefined optimized low-level execution units".
 4 | 
 5 | In other words, builtins are logic blocks embedded in the Cairo architecture
 6 | to significantly enhance performance compared to defining the same logic using
 7 | Cairo's instruction set.
 8 | 
 9 | Builtins can be compared to Ethereum precompiles, primitive operations implemented
10 | in the client's implementation language rather than using EVM opcodes.
11 | 
12 | The Cairo architecture does not specify a specific set of builtins,
13 | they can be added or removed depending on our needs, which is why
14 | different layouts exist. Builtins are adding constraints to the CPU AIR,
15 | which will increase the verification time.
16 | 
17 | In this chapter, we'll see how builtins work, the builtins that exist
18 | and their purposes.
19 | 


--------------------------------------------------------------------------------
/src/ch204-01-how-builtins-work.md:
--------------------------------------------------------------------------------
 1 | # How Builtins Work
 2 | 
 3 | A builtin enforces some constraints on the Cairo memory
 4 | to perform specific tasks, such as computing a hash.
 5 | 
 6 | Each builtin works on a dedicated memory segment,
 7 | which represents in the end a fixed address range.
 8 | This communication method is called _memory-mapped I/O_:
 9 | specific ranges of memory addresses dedicated to builtins.
10 | 
11 | For a Cairo program to interact with a builtin, it simply
12 | needs to read or write to the corresponding memory cells.
13 | 
14 | There are two main types of builtin constraints that we'll
15 | refer as _validation property_ and _deduction property_.
16 | The builtins with a deduction property are usually split
17 | in block of cells where some cells are constrained by
18 | a validation property
19 | 
20 | If the defined property doesn't hold, then the Cairo VM
21 | will panic.
22 | 
23 | ## Validation Property
24 | 
25 | A validation property defines constraints a value must
26 | hold for it to be written to a builtin memory cell.
27 | 
28 | For example, the _Range Check_ builtin only accepts felts and verify
29 | that such a felt is within the range `[0, 2**128)`.
30 | A program can write a value to the Range Check builtin
31 | only if those two constraints hold. Those two constraints
32 | represent the validation property of the Range Check builtin.
33 | 
34 | <div align="center">
35 |   <img src="range-check-validation-property.png" alt="Diagram snapshot Cairo memory using the Range Check builtin" width="800px"/>
36 | </div>
37 | <div align="center">
38 |   <span class="caption">Diagram of the Cairo VM memory using the Range Check builtin</span>
39 | </div>
40 | 
41 | ## Deduction Property
42 | 
43 | A deduction property defines constraints on a block
44 | of cells, when reading or writing to a cell.
45 | 
46 | A block of cells has two categories of cells:
47 | 
48 | - _Input cells_ - cells the program can write to,
49 |   their constraints are similar to a validation property.
50 | - _Output cells_ - cells the program must read,
51 |   and their value is computed based on the deduction
52 |   property and the input cells value.
53 | 
54 | A program that only writes to the input cells, without
55 | ever reading the output cell, is valid as long as the constraints
56 | on those cells hold. Though, it is useless.
57 | 
58 | For example, the _Pedersen_ builtin works with triplets of cells:
59 | 
60 | - Two input cells to store two felts, `a` and `b`.
61 | - One output cell which will store `Pedersen(a, b)`.
62 | 
63 | To compute the Pedersen hash of `a` and `b`, the program must:
64 | 
65 | - Write `a` to the first cell
66 | - Write `b` to the second cell
67 | - Read the third cell, which will compute and write `Pedersen(a, b) to it.
68 | 
69 | In the following diagram, the Pedersen builtin is used,
70 | highlighting its deduction property: the output cell `2:2`
71 | being read when writing its value to the cell `1:5`.
72 | 
73 | <div align="center">
74 |   <img src="pedersen-deduction-property.png" alt="Diagram of Cairo VM memory Pedersen builtins" width="800px"/>
75 | </div>
76 | <div align="center">
77 |   <span class="caption">Diagram of the Cairo VM memory using the Pedersen builtin</span>
78 | </div>
79 | 


--------------------------------------------------------------------------------
/src/ch204-02-00-output.md:
--------------------------------------------------------------------------------
1 | # Output Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-01-pedersen.md:
--------------------------------------------------------------------------------
 1 | # Pedersen Builtin
 2 | 
 3 | The _Pedersen_ builtin is dedicated to computing the pedersen hash
 4 | of two felts. Its use in Cairo is explained on section 11.4 [Working with Hashes](ch11-04-hash.md).
 5 | 
 6 | ## Cells organization
 7 | 
 8 | The Pedersen builtin has its own segment during a Cairo VM run.
 9 | It follows a deduction property, organized by _triplets of cells_,
10 | two input and one output.
11 | 
12 | - The input cells must store felts, relocatable are forbidden.
13 |   It makes sense as you cannot compute the hash of a pointer
14 |   (unless you allow dereferencing pointers from the builtin...)
15 | - The output cell is deduced from the input cells.
16 |   Once an instruction tries reading the cell, the Pedersen hash
17 |   of the two related input cells is computed and written to
18 |   the cell.
19 | 
20 | Let's take a look at two snapshots of a Pedersen segment,
21 | during the execution of a dummy program by the Cairo VM.
22 | 
23 | In the first snapshot, the first triplet has its three cells
24 | storing felts and the second one only has its two input cells
25 | storing felts.
26 | 
27 | It means that the Pedersen hash of 15 and 35 has been computed,
28 | because the cell `3:2` has been read.
29 | The cell `3:5` is still empty while its two input cells are filled
30 | with 93 and 5. It means that even if the input cells have been written to,
31 | the output cell `3:5` has not been read yet, so
32 | the Pedersen hash of 93 and 5 has not been computed yet.
33 | 
34 | <div align="center">
35 |   <img src="pedersen-builtin-valid.png" alt="valid pedersen builtin segment" width="300px"/>
36 | </div>
37 | <div align="center">
38 |   <span class="caption">Snapshot 1 - Pedersen builtin segment with valid inputs</span>
39 | </div>
40 | 
41 | On the second snapshot, both triplets of cells would throw
42 | an error if their output cell was read.
43 | 
44 | Why is there an error when trying to read `3:2`?
45 | 
46 | This is because one of the input cells is empty.
47 | It's hard to compute a hash of something missing.
48 | 
49 | Why is there an error when trying to read `3:5`?
50 | 
51 | If you look closely to the related input cells `3:3` and `3:4`,
52 | you'll notice that the value asserted in `3:4` is a _relocatable_,
53 | a pointer to the cell `1:7`. Recall that the Pedersen builtin
54 | cannot hash a relocatable value, hence the error.
55 | 
56 | The error arises when the output cell is read. In the second case,
57 | it could have been caught earlier if the input cells were validated
58 | as being felts only.
59 | 
60 | <div align="center">
61 |   <img src="pedersen-builtin-error.png" alt="Invalid pedersen builtin segment" width="300px"/>
62 | </div>
63 | <div align="center">
64 |   <span class="caption">Snapshot 2 - Pedersen builtin segment with invalid inputs</span>
65 | </div>
66 | 
67 | ## Implementation References
68 | 
69 | These implementation references of the Pedersen builtin might not be exhaustive.
70 | 
71 | - [TypeScript Pedersen Builtin](https://github.com/kkrt-labs/cairo-vm-ts/blob/58fd07d81cff4a4bb45c30ab99976ba66f0576ad/src/builtins/pedersen.ts#L4)
72 | - [Python Pedersen Builtin](https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/hash/hash_builtin_runner.py)
73 | - [Rust Pedersen Builtin](https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/hash.rs)
74 | - [Go Pedersen Builtin](https://github.com/NethermindEth/cairo-vm-go/blob/dc02d614497f5e59818313e02d2d2f321941cbfa/pkg/vm/builtins/pedersen.go)
75 | - [Zig Pedersen Builtin](https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/hash.zig)
76 | 
77 | ## Resources on Pedersen Hash
78 | 
79 | If you're interested about the Pedersen hash and its use,
80 | take a look at those references:
81 | 
82 | - StarkNet, [Hash Functions - Pedersen Hash](https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#pedersen-hash)
83 | - nccgroup, [Breaking Pedersen Hashes in Practice](https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/), 2023, March 22
84 | - Ryan S., [Pedersen Hash Function Overview](https://rya-sge.github.io/access-denied/2024/05/07/pedersen-hash-function/), 2024, May 07
85 | 


--------------------------------------------------------------------------------
/src/ch204-02-02-range-check.md:
--------------------------------------------------------------------------------
1 | # Range Check Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-03-ecdsa.md:
--------------------------------------------------------------------------------
1 | # ECDSA Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-04-bitwise.md:
--------------------------------------------------------------------------------
1 | # Bitwise Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-05-ec-op.md:
--------------------------------------------------------------------------------
1 | # EC OP Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-06-keccak.md:
--------------------------------------------------------------------------------
1 | # Keccak Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-07-poseidon.md:
--------------------------------------------------------------------------------
1 | # Poseidon Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-08-range-check-96.md:
--------------------------------------------------------------------------------
1 | # Range Check96 Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-09-add-mod.md:
--------------------------------------------------------------------------------
1 | # Add Mod Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-10-mul-mod.md:
--------------------------------------------------------------------------------
1 | # Mul Mod Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-11-segment-arena.md:
--------------------------------------------------------------------------------
1 | # Segment Arena Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-12-gas.md:
--------------------------------------------------------------------------------
1 | # Gas Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-13-system.md:
--------------------------------------------------------------------------------
1 | # System Builtin
2 | 


--------------------------------------------------------------------------------
/src/ch204-02-builtins-list.md:
--------------------------------------------------------------------------------
 1 | # Builtins List
 2 | 
 3 | The following table lists the different builtins implemented
 4 | in the Cairo VM and gives a brief description of their purpose.
 5 | For each builtin, a specific section details how it works,
 6 | its cells organization if any, and references their actual
 7 | implementation in different implementations of the Cairo VM.
 8 | 
 9 | Additional resources related to the operation performed
10 | by the builtin are provided if relevant.
11 | 
12 | | Builtin                  | Description                                                                                                                            |
13 | | ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
14 | | [Output][output]         | Stores all the public memory needed to generate a STARK proof (input & output values, builtin pointers...)                             |
15 | | [Pedersen][pedersen]     | Computes the Pedersen hash `h` of two felts `a` and `b`. `h = Pedersen(a, b)`                                                          |
16 | | [Range Check][rc]        | Verify that a felt `x` is within the bounds `[0, 2**128)`.                                                                             |
17 | | [ECDSA][ecdsa]           | Verify that the ECDSA signature of a given public key `pub` on a message `m` equals `sig`, previously stored. Only used by Cairo Zero. |
18 | | [Bitwise][bitwise]       | Computes the bitwise AND, XOR and OR of two felts `a` and `b`. `a & b`, `a ^ b` and `a \| b`.                                          |
19 | | [EC OP][ec_op]           | Performs Elliptic Curve OPerations - For two points on the STARK curve `P`, `Q` and a scalar `m`, computes `R = P + mQ`.               |
20 | | [Keccak][keccak]         | Computes the new state `s'` after applying the 24 rounds of the keccak-f1600 block permutation on a given state `s`.                   |
21 | | [Poseidon][poseidon]     | Computes the new state `s'` after applying the 91 rounds of the hades block permutation on a given state `s`.                          |
22 | | [Range Check96][rc96]    | Verify that a felt `x` is within the bounds `[0, 2**96)`.                                                                              |
23 | | [AddMod][add_mod]        | Arithmetic Circuit Support - Computes the modular addition `c` of two felts `a`, `b` by batches. `c  a + b mod(p)`                    |
24 | | [MulMod][mul_mod]        | Arithmetic Circuit Support - Computes the modular multiplication `c` of two felts `a`, `b` by batches. `c  a * b mod(p)`              |
25 | | [Segment Arena][seg_are] | Manages the Cairo dictionaries Not used in Cairo Zero.                                                                                 |
26 | | [Gas][gas]               | Manages the available gas during the run. Used by Starknet to handle its gas usage and avoid DoS.                                      |
27 | | [System][system]         | Manages the Starknet syscalls & cheatcodes.                                                                                            |
28 | 
29 | [output]: ch204-02-00-output.md
30 | [pedersen]: ch204-02-01-pedersen.md
31 | [rc]: ch204-02-02-range-check.md
32 | [ecdsa]: ch204-02-03-ecdsa.md
33 | [bitwise]: ch204-02-04-bitwise.md
34 | [ec_op]: ch204-02-05-ec-op.md
35 | [keccak]: ch204-02-06-keccak.md
36 | [poseidon]: ch204-02-07-poseidon.md
37 | [rc96]: ch204-02-08-range-check-96.md
38 | [add_mod]: ch204-02-09-add-mod.md
39 | [mul_mod]: ch204-02-10-mul-mod.md
40 | [seg_are]: ch204-02-11-segment-arena.md
41 | [gas]: ch204-02-12-gas.md
42 | [system]: ch204-02-13-system.md
43 | 


--------------------------------------------------------------------------------
/src/combine.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/combine.png


--------------------------------------------------------------------------------
/src/icons/Cairo_logo_500x500.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/icons/Cairo_logo_500x500.png


--------------------------------------------------------------------------------
/src/integer_in_bits.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/integer_in_bits.png


--------------------------------------------------------------------------------
/src/java-cairo-execution-flow.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/java-cairo-execution-flow.png


--------------------------------------------------------------------------------
/src/mappings.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/mappings.png


--------------------------------------------------------------------------------
/src/mask.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/mask.png


--------------------------------------------------------------------------------
/src/mermaid-storage-model.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/mermaid-storage-model.png


--------------------------------------------------------------------------------
/src/mermaid-storage-model.txt:
--------------------------------------------------------------------------------
 1 | sequenceDiagram
 2 |     participant User
 3 |     participant Compiler
 4 |     participant StorageBase
 5 |     participant StoragePath
 6 |     participant StoragePointer
 7 |     participant ContractStorage
 8 | 
 9 |     User->>Compiler: self.owner.name.read()
10 |     Compiler->>StorageBase: Get base address for 'owner'
11 |     StorageBase->>StoragePointer: Create pointer for 'name'
12 |     StoragePointer->>ContractStorage: Read value
13 |     ContractStorage-->>User: Return value
14 | 
15 |     User->>Compiler: self.user_values.entry(addr).read()
16 |     Compiler->>StorageBase: Get base address for 'user_values'
17 |     StorageBase->>StoragePath: Create initial path
18 |     StoragePath->>StoragePath: Hash with 'addr'
19 |     StoragePath->>StoragePointer: Convert to pointer
20 |     StoragePointer->>ContractStorage: Read value
21 |     ContractStorage-->>User: Return value
22 | 
23 |     User->>Compiler: self.user_values.entry(addr).write(value)
24 |     Compiler->>StorageBase: Get base address for 'user_values'
25 |     StorageBase->>StoragePath: Create initial path
26 |     StoragePath->>StoragePath: Hash with 'addr'
27 |     StoragePath->>StoragePointer: Convert to pointer
28 |     StoragePointer->>ContractStorage: Write value
29 |     ContractStorage-->>User: Confirm write
30 | 


--------------------------------------------------------------------------------
/src/pack.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/pack.png


--------------------------------------------------------------------------------
/src/packing.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/packing.png


--------------------------------------------------------------------------------
/src/pedersen-builtin-error.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/pedersen-builtin-error.png


--------------------------------------------------------------------------------
/src/pedersen-builtin-valid.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/pedersen-builtin-valid.png


--------------------------------------------------------------------------------
/src/pedersen-deduction-property.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/pedersen-deduction-property.png


--------------------------------------------------------------------------------
/src/pprof-steps.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/pprof-steps.png


--------------------------------------------------------------------------------
/src/range-check-validation-property.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/range-check-validation-property.png


--------------------------------------------------------------------------------
/src/shift.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/shift.png


--------------------------------------------------------------------------------
/src/sizes-packing.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/sizes-packing.png


--------------------------------------------------------------------------------
/src/sizes-unpacking.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/sizes-unpacking.png


--------------------------------------------------------------------------------
/src/title-page.md:
--------------------------------------------------------------------------------
 1 | # The Cairo Book
 2 | 
 3 | _By the Cairo Community and its [contributors](https://github.com/cairo-book/cairo-book.github.io). Special thanks to [StarkWare](https://starkware.co/) through [OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager.online/) for supporting the creation of this book._
 4 | 
 5 | This version of the text assumes youre using [Cairo](https://github.com/starkware-libs/cairo) [version 2.9.1](https://github.com/starkware-libs/cairo/releases) and [Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/index.html) [version 0.33.0](https://github.com/foundry-rs/starknet-foundry/releases). See the [Installation](ch01-01-installation.md) section of Chapter {{#chap getting-started}} to install or update Cairo and Starknet Foundry.
 6 | 
 7 | While reading this book, if you want to experiment with Cairo code and see how it compiles into Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use the [cairovm.codes](https://cairovm.codes/) playground.
 8 | 
 9 | This book is open source. Find a typo or want to contribute? Check out the book's [GitHub repository](https://github.com/cairo-book/cairo-book).
10 | 


--------------------------------------------------------------------------------
/src/unpacking.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/cairo-book/cairo-book/5a72ab0b7cb600c287f1dd0723a0600261c37fef/src/unpacking.png